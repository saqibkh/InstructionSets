{
  "instructions": [
    {
      "mnemonic": "xvi4ger8",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Integer 4-bit GER (Rank-8 Update)",
      "summary": "Performs 4-bit integer matrix multiply accumulate (AI Quantization).",
      "syntax": "xvi4ger8 AT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | AT | XA | XB | 34",
        "hex_opcode": "0xF0000022",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "AT",
            "clean": "AT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "34",
            "clean": "34"
          }
        ]
      },
      "operands": [
        {
          "name": "AT",
          "desc": "Accumulator"
        },
        {
          "name": "XA",
          "desc": "Src A (4-bit)"
        },
        {
          "name": "XB",
          "desc": "Src B (4-bit)"
        }
      ],
      "extension": "Matrix Math (MMA)",
      "slug": "xvi4ger8",
      "rel_url": "powerisa/xvi4ger8/",
      "linked_summary": "Performs 4-<a href=\"../../armv8-a/bit/\">bit</a> integer matrix multiply accumulate (AI Quantization).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvi4ger8pp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Integer 4-bit GER (Rank-8 Update) Plus/Plus",
      "summary": "Unsigned 4-bit integer matrix multiply accumulate.",
      "syntax": "xvi4ger8pp AT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | AT | XA | XB | 35",
        "hex_opcode": "0xF0000023",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "AT",
            "clean": "AT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "35",
            "clean": "35"
          }
        ]
      },
      "operands": [
        {
          "name": "AT",
          "desc": "Accumulator"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "Matrix Math (MMA)",
      "slug": "xvi4ger8pp",
      "rel_url": "powerisa/xvi4ger8pp/",
      "linked_summary": "Unsigned 4-<a href=\"../../armv8-a/bit/\">bit</a> integer matrix multiply accumulate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmxvi4ger8",
      "architecture": "PowerISA",
      "full_name": "Prefixed Masked VSX Vector Integer 4-bit GER",
      "summary": "Masked 4-bit integer matrix multiply.",
      "syntax": "pmxvi4ger8 AT, XA, XB, XMSK, YMSK",
      "encoding": {
        "format": "MMIRR-form",
        "binary_pattern": "000001 | 11 | ...",
        "hex_opcode": "0x06000000...",
        "visual_parts": [
          {
            "raw": "000001",
            "clean": "000001"
          },
          {
            "raw": "11",
            "clean": "11"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "AT",
          "desc": "Accumulator"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        },
        {
          "name": "XMSK",
          "desc": "Mask A"
        },
        {
          "name": "YMSK",
          "desc": "Mask B"
        }
      ],
      "extension": "Prefixed (MMA)",
      "slug": "pmxvi4ger8",
      "rel_url": "powerisa/pmxvi4ger8/",
      "linked_summary": "Masked 4-<a href=\"../../armv8-a/bit/\">bit</a> integer matrix multiply.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmxvi4ger8pp",
      "architecture": "PowerISA",
      "full_name": "Prefixed Masked VSX Vector Integer 4-bit GER Plus/Plus",
      "summary": "Masked unsigned 4-bit integer matrix multiply.",
      "syntax": "pmxvi4ger8pp AT, XA, XB, XMSK, YMSK",
      "encoding": {
        "format": "MMIRR-form",
        "binary_pattern": "000001 | 11 | ...",
        "hex_opcode": "0x06000000...",
        "visual_parts": [
          {
            "raw": "000001",
            "clean": "000001"
          },
          {
            "raw": "11",
            "clean": "11"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "AT",
          "desc": "Accumulator"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        },
        {
          "name": "XMSK",
          "desc": "Mask A"
        },
        {
          "name": "YMSK",
          "desc": "Mask B"
        }
      ],
      "extension": "Prefixed (MMA)",
      "slug": "pmxvi4ger8pp",
      "rel_url": "powerisa/pmxvi4ger8pp/",
      "linked_summary": "Masked unsigned 4-<a href=\"../../armv8-a/bit/\">bit</a> integer matrix multiply.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dst",
      "architecture": "PowerISA",
      "full_name": "Data Stream Touch",
      "summary": "Initiates a hardware data stream prefetch (AltiVec Legacy).",
      "syntax": "dst RA, RB, STRM",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | STRM | RA | RB | 342 | /",
        "hex_opcode": "0x7C0002A6",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "STRM",
            "clean": "STRM"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "342",
            "clean": "342"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        },
        {
          "name": "STRM",
          "desc": "Stream ID"
        }
      ],
      "extension": "Base (Legacy Stream)",
      "slug": "dst",
      "rel_url": "powerisa/dst/",
      "linked_summary": "Initiates a hardware data stream prefetch (AltiVec Legacy).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dstt",
      "architecture": "PowerISA",
      "full_name": "Data Stream Touch Transient",
      "summary": "Initiates a transient (non-temporal) data stream prefetch.",
      "syntax": "dstt RA, RB, STRM",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | STRM | RA | RB | 342 | /",
        "hex_opcode": "0x7C0002A6",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "STRM",
            "clean": "STRM"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "342",
            "clean": "342"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        },
        {
          "name": "STRM",
          "desc": "Stream ID"
        }
      ],
      "extension": "Base (Legacy Stream)",
      "slug": "dstt",
      "rel_url": "powerisa/dstt/",
      "linked_summary": "Initiates a transient (non-temporal) data stream prefetch.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dstst",
      "architecture": "PowerISA",
      "full_name": "Data Stream Touch for Store",
      "summary": "Initiates a prefetch for writing.",
      "syntax": "dstst RA, RB, STRM",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | STRM | RA | RB | 374 | /",
        "hex_opcode": "0x7C0002E6",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "STRM",
            "clean": "STRM"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "374",
            "clean": "374"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        },
        {
          "name": "STRM",
          "desc": "Stream ID"
        }
      ],
      "extension": "Base (Legacy Stream)",
      "slug": "dstst",
      "rel_url": "powerisa/dstst/",
      "linked_summary": "Initiates a prefetch for writing.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dststt",
      "architecture": "PowerISA",
      "full_name": "Data Stream Touch for Store Transient",
      "summary": "Initiates a transient prefetch for writing.",
      "syntax": "dststt RA, RB, STRM",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | STRM | RA | RB | 374 | /",
        "hex_opcode": "0x7C0002E6",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "STRM",
            "clean": "STRM"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "374",
            "clean": "374"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        },
        {
          "name": "STRM",
          "desc": "Stream ID"
        }
      ],
      "extension": "Base (Legacy Stream)",
      "slug": "dststt",
      "rel_url": "powerisa/dststt/",
      "linked_summary": "Initiates a transient prefetch for writing.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dss",
      "architecture": "PowerISA",
      "full_name": "Data Stream Stop",
      "summary": "Stops a data stream prefetch operation.",
      "syntax": "dss STRM",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | STRM | 0 | 0 | 822 | /",
        "hex_opcode": "0x7C000666",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "STRM",
            "clean": "STRM"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "822",
            "clean": "822"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "STRM",
          "desc": "Stream ID"
        }
      ],
      "extension": "Base (Legacy Stream)",
      "slug": "dss",
      "rel_url": "powerisa/dss/",
      "linked_summary": "Stops a data stream prefetch operation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dssall",
      "architecture": "PowerISA",
      "full_name": "Data Stream Stop All",
      "summary": "Stops all active data stream prefetch operations.",
      "syntax": "dssall",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | 0 | 0 | 0 | 822 | /",
        "hex_opcode": "0x7C000666",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "822",
            "clean": "822"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [],
      "extension": "Base (Legacy Stream)",
      "slug": "dssall",
      "rel_url": "powerisa/dssall/",
      "linked_summary": "Stops all active data stream prefetch operations.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dcba",
      "architecture": "PowerISA",
      "full_name": "Data Cache Block Allocate",
      "summary": "Allocates a cache block without loading from memory (optimization for overwrite).",
      "syntax": "dcba RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | RA | RB | 758 | /",
        "hex_opcode": "0x7C0005E6",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "758",
            "clean": "758"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base (Cache)",
      "slug": "dcba",
      "rel_url": "powerisa/dcba/",
      "linked_summary": "Allocates a cache block without loading from memory (optimization for overwrite).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dcbi",
      "architecture": "PowerISA",
      "full_name": "Data Cache Block Invalidate",
      "summary": "Invalidates a cache block (Privileged).",
      "syntax": "dcbi RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | RA | RB | 470 | /",
        "hex_opcode": "0x7C0003AE",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "470",
            "clean": "470"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Privileged",
      "slug": "dcbi",
      "rel_url": "powerisa/dcbi/",
      "linked_summary": "Invalidates a cache block (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "eciwx",
      "architecture": "PowerISA",
      "full_name": "External Control In Word Indexed",
      "summary": "Loads a word from an external device using the EAR register.",
      "syntax": "eciwx RT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | RA | RB | 310 | /",
        "hex_opcode": "0x7C00026C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "310",
            "clean": "310"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base (External)",
      "slug": "eciwx",
      "rel_url": "powerisa/eciwx/",
      "linked_summary": "Loads a word from an external device using the EAR register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ecowx",
      "architecture": "PowerISA",
      "full_name": "External Control Out Word Indexed",
      "summary": "Stores a word to an external device using the EAR register.",
      "syntax": "ecowx RS, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 438 | /",
        "hex_opcode": "0x7C00036C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "438",
            "clean": "438"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base (External)",
      "slug": "ecowx",
      "rel_url": "powerisa/ecowx/",
      "linked_summary": "Stores a word to an external device using the EAR register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mcrfs",
      "architecture": "PowerISA",
      "full_name": "Move to Condition Register from FPSCR",
      "summary": "Copies FPSCR exception bits to the Condition Register.",
      "syntax": "mcrfs BF, BFA",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | BF | / | BFA | / | 64 | /",
        "hex_opcode": "0xFC000040",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "BFA",
            "clean": "BFA"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "64",
            "clean": "64"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "Target CR"
        },
        {
          "name": "BFA",
          "desc": "Src FPSCR"
        }
      ],
      "extension": "Float",
      "slug": "mcrfs",
      "rel_url": "powerisa/mcrfs/",
      "linked_summary": "Copies FPSCR exception bits to the Condition Register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mfmsr",
      "architecture": "PowerISA",
      "full_name": "Move From Machine State Register",
      "summary": "Reads the MSR (Privileged).",
      "syntax": "mfmsr RT",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | / | / | 83 | /",
        "hex_opcode": "0x7C0000A6",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "83",
            "clean": "83"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        }
      ],
      "extension": "Privileged",
      "slug": "mfmsr",
      "rel_url": "powerisa/mfmsr/",
      "linked_summary": "Reads the MSR (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mtmsr",
      "architecture": "PowerISA",
      "full_name": "Move To Machine State Register",
      "summary": "Writes the MSR (Privileged).",
      "syntax": "mtmsr RS, L",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | / | L | 146 | /",
        "hex_opcode": "0x7C000124",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "L",
            "clean": "L"
          },
          {
            "raw": "146",
            "clean": "146"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "L",
          "desc": "Load (32/64)"
        }
      ],
      "extension": "Privileged",
      "slug": "mtmsr",
      "rel_url": "powerisa/mtmsr/",
      "linked_summary": "Writes the MSR (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mtmsrd",
      "architecture": "PowerISA",
      "full_name": "Move To Machine State Register Doubleword",
      "summary": "Writes the 64-bit MSR.",
      "syntax": "mtmsrd RS, L",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | / | L | 178 | /",
        "hex_opcode": "0x7C000164",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "L",
            "clean": "L"
          },
          {
            "raw": "178",
            "clean": "178"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "L",
          "desc": "Load"
        }
      ],
      "extension": "Privileged",
      "slug": "mtmsrd",
      "rel_url": "powerisa/mtmsrd/",
      "linked_summary": "Writes the 64-<a href=\"../../armv8-a/bit/\">bit</a> MSR.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tlbia",
      "architecture": "PowerISA",
      "full_name": "TLB Invalidate All",
      "summary": "Invalidates the entire Translation Lookaside Buffer.",
      "syntax": "tlbia",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | / | / | 370 | /",
        "hex_opcode": "0x7C0002E4",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "370",
            "clean": "370"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [],
      "extension": "Privileged (Legacy)",
      "slug": "tlbia",
      "rel_url": "powerisa/tlbia/",
      "linked_summary": "Invalidates the entire Translation Lookaside Buffer.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tlbsync",
      "architecture": "PowerISA",
      "full_name": "TLB Synchronize",
      "summary": "Ensures global TLB invalidation completion.",
      "syntax": "tlbsync",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | / | / | 566 | /",
        "hex_opcode": "0x7C00046C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "566",
            "clean": "566"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [],
      "extension": "Privileged",
      "slug": "tlbsync",
      "rel_url": "powerisa/tlbsync/",
      "linked_summary": "Ensures global TLB invalidation completion.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dcbtst",
      "architecture": "PowerISA",
      "full_name": "Data Cache Block Touch for Store",
      "summary": "Prefetches a cache block for writing (RFO).",
      "syntax": "dcbtst CT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | CT | RA | RB | 246 | /",
        "hex_opcode": "0x7C0001EC",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "CT",
            "clean": "CT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "246",
            "clean": "246"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "CT",
          "desc": "Hint"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base",
      "slug": "dcbtst",
      "rel_url": "powerisa/dcbtst/",
      "linked_summary": "Prefetches a cache block for writing (RFO).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "icbt",
      "architecture": "PowerISA",
      "full_name": "Instruction Cache Block Touch",
      "summary": "Prefetches an instruction cache block.",
      "syntax": "icbt CT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | CT | RA | RB | 22 | /",
        "hex_opcode": "0x7C00002C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "CT",
            "clean": "CT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "22",
            "clean": "22"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "CT",
          "desc": "Hint"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base",
      "slug": "icbt",
      "rel_url": "powerisa/icbt/",
      "linked_summary": "Prefetches an instruction cache block.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mfpvr",
      "architecture": "PowerISA",
      "full_name": "Move From Processor Version Register",
      "summary": "Reads the PVR (Processor ID).",
      "syntax": "mfpvr RT",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "mfspr RT, 287",
        "hex_opcode": "See mfspr",
        "visual_parts": [
          {
            "raw": "mfspr RT, 287",
            "clean": "mfspr RT, 287"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        }
      ],
      "extension": "Privileged",
      "slug": "mfpvr",
      "rel_url": "powerisa/mfpvr/",
      "linked_summary": "Reads the PVR (Processor ID).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mftb",
      "architecture": "PowerISA",
      "full_name": "Move From Timebase",
      "summary": "Reads the Timebase register.",
      "syntax": "mftb RT",
      "encoding": {
        "format": "XFX-form",
        "binary_pattern": "31 | RT | 268 | 371 | /",
        "hex_opcode": "0x7C0002E6",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "268",
            "clean": "268"
          },
          {
            "raw": "371",
            "clean": "371"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        }
      ],
      "extension": "Base",
      "slug": "mftb",
      "rel_url": "powerisa/mftb/",
      "linked_summary": "Reads the Timebase register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mftbu",
      "architecture": "PowerISA",
      "full_name": "Move From Timebase Upper",
      "summary": "Reads the upper 32 bits of the Timebase (32-bit implementations).",
      "syntax": "mftbu RT",
      "encoding": {
        "format": "XFX-form",
        "binary_pattern": "31 | RT | 269 | 371 | /",
        "hex_opcode": "0x7C0002E7",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "269",
            "clean": "269"
          },
          {
            "raw": "371",
            "clean": "371"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        }
      ],
      "extension": "Base (32-bit)",
      "slug": "mftbu",
      "rel_url": "powerisa/mftbu/",
      "linked_summary": "Reads the upper 32 bits of the Timebase (32-<a href=\"../../armv8-a/bit/\">bit</a> implementations).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lbz",
      "architecture": "PowerISA",
      "full_name": "Load Byte and Zero",
      "summary": "Loads a byte from memory into the low 8 bits of a register and clears the upper 56 bits.",
      "syntax": "lbz RT, D(RA)",
      "encoding": {
        "format": "D-form",
        "binary_pattern": "34 | RT | RA | D",
        "hex_opcode": "0x88000000",
        "visual_parts": [
          {
            "raw": "34",
            "clean": "34"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D",
            "clean": "D"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register"
        },
        {
          "name": "D",
          "desc": "Displacement (16-bit Signed)"
        },
        {
          "name": "RA",
          "desc": "Base Register"
        }
      ],
      "pseudocode": "RT <- (0x00...00) || MEM(EA, 1)",
      "example": "lbz r3, 0(r4)",
      "example_note": "Load byte from address in r4.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RT &lt;- (0x00...00) || MEM(EA, 1)</code></pre>",
      "slug": "lbz",
      "rel_url": "powerisa/lbz/",
      "linked_summary": "Loads a byte from memory into the low 8 bits of a register <a href=\"../../armv8-a/and_6/\">and</a> clears the upper 56 bits.",
      "linked_pseudocode": "RT <- (0x00...00) || MEM(EA, 1)"
    },
    {
      "mnemonic": "lhz",
      "architecture": "PowerISA",
      "full_name": "Load Halfword and Zero",
      "summary": "Loads a halfword (16 bits) from memory and clears the upper 48 bits.",
      "syntax": "lhz RT, D(RA)",
      "encoding": {
        "format": "D-form",
        "binary_pattern": "40 | RT | RA | D",
        "hex_opcode": "0xA0000000",
        "visual_parts": [
          {
            "raw": "40",
            "clean": "40"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D",
            "clean": "D"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register"
        },
        {
          "name": "D",
          "desc": "Displacement"
        },
        {
          "name": "RA",
          "desc": "Base Register"
        }
      ],
      "pseudocode": "RT <- (0x00...00) || MEM(EA, 2)",
      "example": "lhz r3, 0(r4)",
      "example_note": "Load unsigned 16-bit value.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RT &lt;- (0x00...00) || MEM(EA, 2)</code></pre>",
      "slug": "lhz",
      "rel_url": "powerisa/lhz/",
      "linked_summary": "Loads a halfword (16 bits) from memory <a href=\"../../armv8-a/and_6/\">and</a> clears the upper 48 bits.",
      "linked_pseudocode": "RT <- (0x00...00) || MEM(EA, 2)"
    },
    {
      "mnemonic": "lha",
      "architecture": "PowerISA",
      "full_name": "Load Halfword Algebraic",
      "summary": "Loads a halfword (16 bits) from memory and sign-extends it to 64 bits.",
      "syntax": "lha RT, D(RA)",
      "encoding": {
        "format": "D-form",
        "binary_pattern": "42 | RT | RA | D",
        "hex_opcode": "0xA8000000",
        "visual_parts": [
          {
            "raw": "42",
            "clean": "42"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D",
            "clean": "D"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register"
        },
        {
          "name": "D",
          "desc": "Displacement"
        },
        {
          "name": "RA",
          "desc": "Base Register"
        }
      ],
      "pseudocode": "RT <- EXTS(MEM(EA, 2))",
      "example": "lha r3, 0(r4)",
      "example_note": "Load signed 16-bit value.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RT &lt;- EXTS(MEM(EA, 2))</code></pre>",
      "slug": "lha",
      "rel_url": "powerisa/lha/",
      "linked_summary": "Loads a halfword (16 bits) from memory <a href=\"../../armv8-a/and_6/\">and</a> sign-extends <a href=\"../../armv8-a/it/\">it</a> to 64 bits.",
      "linked_pseudocode": "RT <- EXTS(MEM(EA, 2))"
    },
    {
      "mnemonic": "lwz",
      "architecture": "PowerISA",
      "full_name": "Load Word and Zero",
      "summary": "Loads a word (32 bits) from memory and clears the upper 32 bits.",
      "syntax": "lwz RT, D(RA)",
      "encoding": {
        "format": "D-form",
        "binary_pattern": "32 | RT | RA | D",
        "hex_opcode": "0x80000000",
        "visual_parts": [
          {
            "raw": "32",
            "clean": "32"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D",
            "clean": "D"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register"
        },
        {
          "name": "D",
          "desc": "Displacement"
        },
        {
          "name": "RA",
          "desc": "Base Register"
        }
      ],
      "pseudocode": "RT <- (0x00...00) || MEM(EA, 4)",
      "example": "lwz r3, 8(r4)",
      "example_note": "Load 32-bit int from r4+8.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RT &lt;- (0x00...00) || MEM(EA, 4)</code></pre>",
      "slug": "lwz",
      "rel_url": "powerisa/lwz/",
      "linked_summary": "Loads a word (32 bits) from memory <a href=\"../../armv8-a/and_6/\">and</a> clears the upper 32 bits.",
      "linked_pseudocode": "RT <- (0x00...00) || MEM(EA, 4)"
    },
    {
      "mnemonic": "lwa",
      "architecture": "PowerISA",
      "full_name": "Load Word Algebraic",
      "summary": "Loads a word (32 bits) from memory and sign-extends it to 64 bits.",
      "syntax": "lwa RT, DS(RA)",
      "encoding": {
        "format": "DS-form",
        "binary_pattern": "58 | RT | RA | DS | 2",
        "hex_opcode": "0xE8000002",
        "visual_parts": [
          {
            "raw": "58",
            "clean": "58"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "DS",
            "clean": "DS"
          },
          {
            "raw": "2",
            "clean": "2"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register"
        },
        {
          "name": "DS",
          "desc": "Displacement (Aligned)"
        },
        {
          "name": "RA",
          "desc": "Base Register"
        }
      ],
      "pseudocode": "RT <- EXTS(MEM(EA, 4))",
      "example": "lwa r3, 8(r4)",
      "example_note": "Load signed 32-bit int.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RT &lt;- EXTS(MEM(EA, 4))</code></pre>",
      "slug": "lwa",
      "rel_url": "powerisa/lwa/",
      "linked_summary": "Loads a word (32 bits) from memory <a href=\"../../armv8-a/and_6/\">and</a> sign-extends <a href=\"../../armv8-a/it/\">it</a> to 64 bits.",
      "linked_pseudocode": "RT <- EXTS(MEM(EA, 4))"
    },
    {
      "mnemonic": "ld",
      "architecture": "PowerISA",
      "full_name": "Load Doubleword",
      "summary": "Loads a doubleword (64 bits) from memory.",
      "syntax": "ld RT, DS(RA)",
      "encoding": {
        "format": "DS-form",
        "binary_pattern": "58 | RT | RA | DS | 0",
        "hex_opcode": "0xE8000000",
        "visual_parts": [
          {
            "raw": "58",
            "clean": "58"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "DS",
            "clean": "DS"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register"
        },
        {
          "name": "DS",
          "desc": "Displacement (14-bit Signed, Multiple of 4)"
        },
        {
          "name": "RA",
          "desc": "Base Register"
        }
      ],
      "pseudocode": "RT <- MEM(EA, 8)",
      "example": "ld r3, 16(r4)",
      "example_note": "Load 64-bit value.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RT &lt;- MEM(EA, 8)</code></pre>",
      "slug": "ld",
      "rel_url": "powerisa/ld/",
      "linked_summary": "Loads a doubleword (64 bits) from memory.",
      "linked_pseudocode": "RT <- MEM(EA, 8)"
    },
    {
      "mnemonic": "lwarx",
      "architecture": "PowerISA",
      "full_name": "Load Word and Reserve Indexed",
      "summary": "Loads a word and creates a reservation for use with 'stwcx.'. Critical for implementing atomic primitives (mutexes).",
      "syntax": "lwarx RT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | RA | RB | 20 | /",
        "hex_opcode": "0x7C000028",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "20",
            "clean": "20"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register"
        },
        {
          "name": "RA",
          "desc": "Base Register"
        },
        {
          "name": "RB",
          "desc": "Index Register"
        }
      ],
      "pseudocode": "RESERVE <- 1; RESERVE_ADDR <- EA; RT <- MEM(EA, 4)",
      "example": "lwarx r3, 0, r4",
      "example_note": "Start atomic read-modify-write.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RESERVE &lt;- 1; RESERVE_ADDR &lt;- EA; RT &lt;- MEM(EA, 4)</code></pre>",
      "slug": "lwarx",
      "rel_url": "powerisa/lwarx/",
      "linked_summary": "Loads a word <a href=\"../../armv8-a/and_6/\">and</a> creates a reservation for use with 'stwcx.'. Critical for implementing atomic primitives (mutexes).",
      "linked_pseudocode": "RESERVE <- 1; RESERVE_ADDR <- EA; RT <- MEM(EA, 4)"
    },
    {
      "mnemonic": "ldarx",
      "architecture": "PowerISA",
      "full_name": "Load Doubleword and Reserve Indexed",
      "summary": "Loads a doubleword and creates a reservation. 64-bit version of lwarx.",
      "syntax": "ldarx RT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | RA | RB | 84 | /",
        "hex_opcode": "0x7C0000A8",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "84",
            "clean": "84"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register"
        },
        {
          "name": "RA",
          "desc": "Base Register"
        },
        {
          "name": "RB",
          "desc": "Index Register"
        }
      ],
      "pseudocode": "RESERVE <- 1; RESERVE_ADDR <- EA; RT <- MEM(EA, 8)",
      "example": "ldarx r3, 0, r4",
      "example_note": "Atomic 64-bit load.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RESERVE &lt;- 1; RESERVE_ADDR &lt;- EA; RT &lt;- MEM(EA, 8)</code></pre>",
      "slug": "ldarx",
      "rel_url": "powerisa/ldarx/",
      "linked_summary": "Loads a doubleword <a href=\"../../armv8-a/and_6/\">and</a> creates a reservation. 64-<a href=\"../../armv8-a/bit/\">bit</a> version of <a href=\"../../powerisa/lwarx/\">lwarx</a>.",
      "linked_pseudocode": "RESERVE <- 1; RESERVE_ADDR <- EA; RT <- MEM(EA, 8)"
    },
    {
      "mnemonic": "mtspr",
      "architecture": "PowerISA",
      "full_name": "Move To Special Purpose Register",
      "summary": "Copies a value from a general-purpose register to a system SPR (e.g., CTR, LR, XER).",
      "syntax": "mtspr SPR, RS",
      "encoding": {
        "format": "XFX-form",
        "binary_pattern": "31 | RS | SPR | 467 | /",
        "hex_opcode": "0x7C0003A6",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "SPR",
            "clean": "SPR"
          },
          {
            "raw": "467",
            "clean": "467"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "SPR",
          "desc": "Special Purpose Register ID (Reordered bits)"
        },
        {
          "name": "RS",
          "desc": "Source Register"
        }
      ],
      "pseudocode": "SPR[SPR_NUM] <- (RS)",
      "example": "mtspr 9, r3",
      "example_note": "Move r3 to Count Register (CTR).",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">SPR[SPR_NUM] &lt;- (RS)</code></pre>",
      "slug": "mtspr",
      "rel_url": "powerisa/mtspr/",
      "linked_summary": "Copies a value from a general-purpose register to a system SPR (e.g., CTR, LR, XER).",
      "linked_pseudocode": "SPR[SPR_NUM] <- (RS)"
    },
    {
      "mnemonic": "mfspr",
      "architecture": "PowerISA",
      "full_name": "Move From Special Purpose Register",
      "summary": "Copies a value from a system SPR to a general-purpose register.",
      "syntax": "mfspr RT, SPR",
      "encoding": {
        "format": "XFX-form",
        "binary_pattern": "31 | RT | SPR | 339 | /",
        "hex_opcode": "0x7C0002A6",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "SPR",
            "clean": "SPR"
          },
          {
            "raw": "339",
            "clean": "339"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register"
        },
        {
          "name": "SPR",
          "desc": "Special Purpose Register ID"
        }
      ],
      "pseudocode": "RT <- SPR[SPR_NUM]",
      "example": "mfspr r3, 8",
      "example_note": "Move Link Register (LR) to r3.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RT &lt;- SPR[SPR_NUM]</code></pre>",
      "slug": "mfspr",
      "rel_url": "powerisa/mfspr/",
      "linked_summary": "Copies a value from a system SPR to a general-purpose register.",
      "linked_pseudocode": "RT <- SPR[SPR_NUM]"
    },
    {
      "mnemonic": "mullw",
      "architecture": "PowerISA",
      "full_name": "Multiply Low Word",
      "summary": "Multiplies two 32-bit integers and stores the lower 32 bits of the 64-bit result.",
      "syntax": "mullw RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "31 | RT | RA | RB | OE | 235 | Rc",
        "hex_opcode": "0x7C0001D6",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "OE",
            "clean": "OE"
          },
          {
            "raw": "235",
            "clean": "235"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src 1"
        },
        {
          "name": "RB",
          "desc": "Src 2"
        }
      ],
      "pseudocode": "RT <- (RA)[32:63] * (RB)[32:63]",
      "example": "mullw r3, r4, r5",
      "example_note": "32-bit multiply.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RT &lt;- (RA)[32:63] * (RB)[32:63]</code></pre>",
      "slug": "mullw",
      "rel_url": "powerisa/mullw/",
      "linked_summary": "Multiplies two 32-<a href=\"../../armv8-a/bit/\">bit</a> integers <a href=\"../../armv8-a/and_6/\">and</a> stores the lower 32 bits of the 64-<a href=\"../../armv8-a/bit/\">bit</a> result.",
      "linked_pseudocode": "RT <- (RA)[32:63] * (RB)[32:63]"
    },
    {
      "mnemonic": "mulld",
      "architecture": "PowerISA",
      "full_name": "Multiply Low Doubleword",
      "summary": "Multiplies two 64-bit integers and stores the lower 64 bits of the 128-bit result.",
      "syntax": "mulld RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "31 | RT | RA | RB | OE | 233 | Rc",
        "hex_opcode": "0x7C0001D2",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "OE",
            "clean": "OE"
          },
          {
            "raw": "233",
            "clean": "233"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src 1"
        },
        {
          "name": "RB",
          "desc": "Src 2"
        }
      ],
      "pseudocode": "RT <- (RA) * (RB)",
      "example": "mulld r3, r4, r5",
      "example_note": "64-bit multiply.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RT &lt;- (RA) * (RB)</code></pre>",
      "slug": "mulld",
      "rel_url": "powerisa/mulld/",
      "linked_summary": "Multiplies two 64-<a href=\"../../armv8-a/bit/\">bit</a> integers <a href=\"../../armv8-a/and_6/\">and</a> stores the lower 64 bits of the 128-<a href=\"../../armv8-a/bit/\">bit</a> result.",
      "linked_pseudocode": "RT <- (RA) * (RB)"
    },
    {
      "mnemonic": "mr",
      "architecture": "PowerISA",
      "full_name": "Move Register (Pseudo)",
      "summary": "Copies the contents of one register to another. (Encoded as OR RA, RS, RS).",
      "syntax": "mr RA, RS",
      "encoding": {
        "format": "Pseudo",
        "binary_pattern": "or RA, RS, RS",
        "hex_opcode": "See OR",
        "visual_parts": [
          {
            "raw": "or RA, RS, RS",
            "clean": "or RA, RS, RS"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Source"
        }
      ],
      "pseudocode": "RA <- (RS)",
      "example": "mr r3, r4",
      "example_note": "Copy r4 to r3.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RA &lt;- (RS)</code></pre>",
      "slug": "mr",
      "rel_url": "powerisa/mr/",
      "linked_summary": "Copies the contents of one register to another. (Encoded as <a href=\"../../risc-v/or/\">OR</a> RA, RS, RS).",
      "linked_pseudocode": "RA <- (RS)"
    },
    {
      "mnemonic": "sc",
      "architecture": "PowerISA",
      "full_name": "System Call",
      "summary": "Invokes the operating system (Supervisor Call).",
      "syntax": "sc LEV",
      "encoding": {
        "format": "SC-form",
        "binary_pattern": "17 | / | / | / | LEV | / | 1",
        "hex_opcode": "0x44000002",
        "visual_parts": [
          {
            "raw": "17",
            "clean": "17"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "LEV",
            "clean": "LEV"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "1",
            "clean": "1"
          }
        ]
      },
      "operands": [
        {
          "name": "LEV",
          "desc": "Level (0=OS, 1=Hypervisor)"
        }
      ],
      "extension": "Base",
      "slug": "sc",
      "rel_url": "powerisa/sc/",
      "linked_summary": "Invokes the operating system (Supervisor Call).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "nop",
      "architecture": "PowerISA",
      "full_name": "No Operation",
      "summary": "Does nothing. (Alias for 'ori 0, 0, 0').",
      "syntax": "nop",
      "encoding": {
        "format": "D-form",
        "binary_pattern": "24 | 0 | 0 | 0",
        "hex_opcode": "0x60000000",
        "visual_parts": [
          {
            "raw": "24",
            "clean": "24"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [],
      "extension": "Base (Alias)",
      "slug": "nop",
      "rel_url": "powerisa/nop/",
      "linked_summary": "Does nothing. (Alias for '<a href=\"../../powerisa/ori/\">ori</a> 0, 0, 0').",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mr",
      "architecture": "PowerISA",
      "full_name": "Move Register",
      "summary": "Copies contents of RS to RA. (Alias for 'or RA, RS, RS').",
      "syntax": "mr RA, RS",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RS | 444 | /",
        "hex_opcode": "0x7C000378",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "444",
            "clean": "444"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Source"
        }
      ],
      "extension": "Base (Alias)",
      "slug": "mr_1",
      "rel_url": "powerisa/mr_1/",
      "linked_summary": "Copies contents of RS to RA. (Alias for '<a href=\"../../powerisa/or/\">or</a> RA, RS, RS').",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "li",
      "architecture": "PowerISA",
      "full_name": "Load Immediate",
      "summary": "Loads a 16-bit signed immediate into a register. (Alias for 'addi RT, 0, SIM').",
      "syntax": "li RT, SIM",
      "encoding": {
        "format": "D-form",
        "binary_pattern": "14 | RT | 0 | SIM",
        "hex_opcode": "0x38000000",
        "visual_parts": [
          {
            "raw": "14",
            "clean": "14"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "SIM",
            "clean": "SIM"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "SIM",
          "desc": "Immediate"
        }
      ],
      "extension": "Base (Alias)",
      "slug": "li",
      "rel_url": "powerisa/li/",
      "linked_summary": "Loads a 16-<a href=\"../../armv8-a/bit/\">bit</a> signed immediate into a register. (Alias for '<a href=\"../../powerisa/addi/\">addi</a> RT, 0, SIM').",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lis",
      "architecture": "PowerISA",
      "full_name": "Load Immediate Shifted",
      "summary": "Loads a 16-bit immediate into the upper half of a 32-bit word. (Alias for 'addis RT, 0, SIM').",
      "syntax": "lis RT, SIM",
      "encoding": {
        "format": "D-form",
        "binary_pattern": "15 | RT | 0 | SIM",
        "hex_opcode": "0x3C000000",
        "visual_parts": [
          {
            "raw": "15",
            "clean": "15"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "SIM",
            "clean": "SIM"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "SIM",
          "desc": "Immediate"
        }
      ],
      "extension": "Base (Alias)",
      "slug": "lis",
      "rel_url": "powerisa/lis/",
      "linked_summary": "Loads a 16-<a href=\"../../armv8-a/bit/\">bit</a> immediate into the upper half of a 32-<a href=\"../../armv8-a/bit/\">bit</a> word. (Alias for '<a href=\"../../powerisa/addis/\">addis</a> RT, 0, SIM').",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "not",
      "architecture": "PowerISA",
      "full_name": "Complement Register",
      "summary": "Ones' complement (Bitwise NOT). (Alias for 'nor RA, RS, RS').",
      "syntax": "not RA, RS",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RS | 124 | /",
        "hex_opcode": "0x7C0000F8",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "124",
            "clean": "124"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Source"
        }
      ],
      "extension": "Base (Alias)",
      "slug": "not",
      "rel_url": "powerisa/not/",
      "linked_summary": "Ones' complement (Bitwise <a href=\"../../risc-v/not/\">NOT</a>). (Alias for '<a href=\"../../powerisa/nor/\">nor</a> RA, RS, RS').",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mtctr",
      "architecture": "PowerISA",
      "full_name": "Move To Count Register",
      "summary": "Moves GPR to CTR. (Alias for 'mtspr 9, RS').",
      "syntax": "mtctr RS",
      "encoding": {
        "format": "XFX-form",
        "binary_pattern": "31 | RS | 9 | 467 | /",
        "hex_opcode": "0x7C0903A6",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "9",
            "clean": "9"
          },
          {
            "raw": "467",
            "clean": "467"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        }
      ],
      "extension": "Base (Alias)",
      "slug": "mtctr",
      "rel_url": "powerisa/mtctr/",
      "linked_summary": "Moves GPR to CTR. (Alias for '<a href=\"../../powerisa/mtspr/\">mtspr</a> 9, RS').",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mfctr",
      "architecture": "PowerISA",
      "full_name": "Move From Count Register",
      "summary": "Moves CTR to GPR. (Alias for 'mfspr RT, 9').",
      "syntax": "mfctr RT",
      "encoding": {
        "format": "XFX-form",
        "binary_pattern": "31 | RT | 9 | 339 | /",
        "hex_opcode": "0x7C0902A6",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "9",
            "clean": "9"
          },
          {
            "raw": "339",
            "clean": "339"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        }
      ],
      "extension": "Base (Alias)",
      "slug": "mfctr",
      "rel_url": "powerisa/mfctr/",
      "linked_summary": "Moves CTR to GPR. (Alias for '<a href=\"../../powerisa/mfspr/\">mfspr</a> RT, 9').",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mtlr",
      "architecture": "PowerISA",
      "full_name": "Move To Link Register",
      "summary": "Moves GPR to LR. (Alias for 'mtspr 8, RS').",
      "syntax": "mtlr RS",
      "encoding": {
        "format": "XFX-form",
        "binary_pattern": "31 | RS | 8 | 467 | /",
        "hex_opcode": "0x7C0803A6",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "8",
            "clean": "8"
          },
          {
            "raw": "467",
            "clean": "467"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        }
      ],
      "extension": "Base (Alias)",
      "slug": "mtlr",
      "rel_url": "powerisa/mtlr/",
      "linked_summary": "Moves GPR to LR. (Alias for '<a href=\"../../powerisa/mtspr/\">mtspr</a> 8, RS').",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mflr",
      "architecture": "PowerISA",
      "full_name": "Move From Link Register",
      "summary": "Moves LR to GPR. (Alias for 'mfspr RT, 8').",
      "syntax": "mflr RT",
      "encoding": {
        "format": "XFX-form",
        "binary_pattern": "31 | RT | 8 | 339 | /",
        "hex_opcode": "0x7C0802A6",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "8",
            "clean": "8"
          },
          {
            "raw": "339",
            "clean": "339"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        }
      ],
      "extension": "Base (Alias)",
      "slug": "mflr",
      "rel_url": "powerisa/mflr/",
      "linked_summary": "Moves LR to GPR. (Alias for '<a href=\"../../powerisa/mfspr/\">mfspr</a> RT, 8').",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rlwinm",
      "architecture": "PowerISA",
      "full_name": "Rotate Left Word Immediate Then AND with Mask",
      "summary": "Rotates a word left, then ANDs with a mask. Used for extracting bitfields.",
      "syntax": "rlwinm RA, RS, SH, MB, ME",
      "encoding": {
        "format": "M-form",
        "binary_pattern": "21 | RS | RA | SH | MB | ME",
        "hex_opcode": "0x54000000",
        "visual_parts": [
          {
            "raw": "21",
            "clean": "21"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "SH",
            "clean": "SH"
          },
          {
            "raw": "MB",
            "clean": "MB"
          },
          {
            "raw": "ME",
            "clean": "ME"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "SH",
          "desc": "Shift"
        },
        {
          "name": "MB",
          "desc": "Mask Begin"
        },
        {
          "name": "ME",
          "desc": "Mask End"
        }
      ],
      "extension": "Base",
      "slug": "rlwinm",
      "rel_url": "powerisa/rlwinm/",
      "linked_summary": "Rotates a word left, then ANDs with a mask. Used for extracting bitfields.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rlwimi",
      "architecture": "PowerISA",
      "full_name": "Rotate Left Word Immediate Then Mask Insert",
      "summary": "Rotates a word left, then inserts bits into the target under a mask. Used for inserting bitfields.",
      "syntax": "rlwimi RA, RS, SH, MB, ME",
      "encoding": {
        "format": "M-form",
        "binary_pattern": "20 | RS | RA | SH | MB | ME",
        "hex_opcode": "0x50000000",
        "visual_parts": [
          {
            "raw": "20",
            "clean": "20"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "SH",
            "clean": "SH"
          },
          {
            "raw": "MB",
            "clean": "MB"
          },
          {
            "raw": "ME",
            "clean": "ME"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target/Dest"
        },
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "SH",
          "desc": "Shift"
        },
        {
          "name": "MB",
          "desc": "Mask Begin"
        },
        {
          "name": "ME",
          "desc": "Mask End"
        }
      ],
      "extension": "Base",
      "slug": "rlwimi",
      "rel_url": "powerisa/rlwimi/",
      "linked_summary": "Rotates a word left, then inserts bits into the target under a mask. Used for inserting bitfields.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rlwnm",
      "architecture": "PowerISA",
      "full_name": "Rotate Left Word Then AND with Mask",
      "summary": "Rotates a word left by amount in RB, then ANDs with a mask.",
      "syntax": "rlwnm RA, RS, RB, MB, ME",
      "encoding": {
        "format": "M-form",
        "binary_pattern": "23 | RS | RA | RB | MB | ME",
        "hex_opcode": "0x5C000000",
        "visual_parts": [
          {
            "raw": "23",
            "clean": "23"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "MB",
            "clean": "MB"
          },
          {
            "raw": "ME",
            "clean": "ME"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "RB",
          "desc": "Shift Reg"
        },
        {
          "name": "MB",
          "desc": "Mask Begin"
        },
        {
          "name": "ME",
          "desc": "Mask End"
        }
      ],
      "extension": "Base",
      "slug": "rlwnm",
      "rel_url": "powerisa/rlwnm/",
      "linked_summary": "Rotates a word left by amount <a href=\"../../x86/in/\">in</a> RB, then ANDs with a mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rldic",
      "architecture": "PowerISA",
      "full_name": "Rotate Left Doubleword Immediate Clear",
      "summary": "Rotates a 64-bit value left, then clears bits based on a mask.",
      "syntax": "rldic RA, RS, SH, MB",
      "encoding": {
        "format": "MD-form",
        "binary_pattern": "30 | RS | RA | SH | MB | 2 | SH",
        "hex_opcode": "0x78000004",
        "visual_parts": [
          {
            "raw": "30",
            "clean": "30"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "SH",
            "clean": "SH"
          },
          {
            "raw": "MB",
            "clean": "MB"
          },
          {
            "raw": "2",
            "clean": "2"
          },
          {
            "raw": "SH",
            "clean": "SH"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "SH",
          "desc": "Shift"
        },
        {
          "name": "MB",
          "desc": "Mask Begin"
        }
      ],
      "extension": "Base (64-bit)",
      "slug": "rldic",
      "rel_url": "powerisa/rldic/",
      "linked_summary": "Rotates a 64-<a href=\"../../armv8-a/bit/\">bit</a> value left, then clears bits based on a mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rldicl",
      "architecture": "PowerISA",
      "full_name": "Rotate Left Doubleword Immediate Clear Left",
      "summary": "Rotates left and clears upper bits (Extract/Shift Right logic).",
      "syntax": "rldicl RA, RS, SH, MB",
      "encoding": {
        "format": "MD-form",
        "binary_pattern": "30 | RS | RA | SH | MB | 0 | SH",
        "hex_opcode": "0x78000000",
        "visual_parts": [
          {
            "raw": "30",
            "clean": "30"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "SH",
            "clean": "SH"
          },
          {
            "raw": "MB",
            "clean": "MB"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "SH",
            "clean": "SH"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "SH",
          "desc": "Shift"
        },
        {
          "name": "MB",
          "desc": "Mask Begin"
        }
      ],
      "extension": "Base (64-bit)",
      "slug": "rldicl",
      "rel_url": "powerisa/rldicl/",
      "linked_summary": "Rotates left <a href=\"../../armv8-a/and_6/\">and</a> clears upper bits (Extract/Shift Right logic).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rldicr",
      "architecture": "PowerISA",
      "full_name": "Rotate Left Doubleword Immediate Clear Right",
      "summary": "Rotates left and clears lower bits (Shift Left logic).",
      "syntax": "rldicr RA, RS, SH, ME",
      "encoding": {
        "format": "MD-form",
        "binary_pattern": "30 | RS | RA | SH | ME | 1 | SH",
        "hex_opcode": "0x78000002",
        "visual_parts": [
          {
            "raw": "30",
            "clean": "30"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "SH",
            "clean": "SH"
          },
          {
            "raw": "ME",
            "clean": "ME"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "SH",
            "clean": "SH"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "SH",
          "desc": "Shift"
        },
        {
          "name": "ME",
          "desc": "Mask End"
        }
      ],
      "extension": "Base (64-bit)",
      "slug": "rldicr",
      "rel_url": "powerisa/rldicr/",
      "linked_summary": "Rotates left <a href=\"../../armv8-a/and_6/\">and</a> clears lower bits (Shift Left logic).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rldimi",
      "architecture": "PowerISA",
      "full_name": "Rotate Left Doubleword Immediate Mask Insert",
      "summary": "Rotates 64-bit value and inserts into target under mask.",
      "syntax": "rldimi RA, RS, SH, MB",
      "encoding": {
        "format": "MD-form",
        "binary_pattern": "30 | RS | RA | SH | MB | 3 | SH",
        "hex_opcode": "0x78000006",
        "visual_parts": [
          {
            "raw": "30",
            "clean": "30"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "SH",
            "clean": "SH"
          },
          {
            "raw": "MB",
            "clean": "MB"
          },
          {
            "raw": "3",
            "clean": "3"
          },
          {
            "raw": "SH",
            "clean": "SH"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "SH",
          "desc": "Shift"
        },
        {
          "name": "MB",
          "desc": "Mask Begin"
        }
      ],
      "extension": "Base (64-bit)",
      "slug": "rldimi",
      "rel_url": "powerisa/rldimi/",
      "linked_summary": "Rotates 64-<a href=\"../../armv8-a/bit/\">bit</a> value <a href=\"../../armv8-a/and_6/\">and</a> inserts into target under mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sld",
      "architecture": "PowerISA",
      "full_name": "Shift Left Doubleword",
      "summary": "Shifts a 64-bit value left by amount in RB.",
      "syntax": "sld RA, RS, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 27",
        "hex_opcode": "0x7C000036",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "27",
            "clean": "27"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "RB",
          "desc": "Shift Reg"
        }
      ],
      "extension": "Base (64-bit)",
      "slug": "sld",
      "rel_url": "powerisa/sld/",
      "linked_summary": "Shifts a 64-<a href=\"../../armv8-a/bit/\">bit</a> value left by amount <a href=\"../../x86/in/\">in</a> RB.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "srd",
      "architecture": "PowerISA",
      "full_name": "Shift Right Doubleword",
      "summary": "Logical right shift of 64-bit value.",
      "syntax": "srd RA, RS, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 539",
        "hex_opcode": "0x7C000436",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "539",
            "clean": "539"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "RB",
          "desc": "Shift Reg"
        }
      ],
      "extension": "Base (64-bit)",
      "slug": "srd",
      "rel_url": "powerisa/srd/",
      "linked_summary": "Logical right shift of 64-<a href=\"../../armv8-a/bit/\">bit</a> value.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "srad",
      "architecture": "PowerISA",
      "full_name": "Shift Right Algebraic Doubleword",
      "summary": "Arithmetic right shift of 64-bit value (preserves sign).",
      "syntax": "srad RA, RS, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 794",
        "hex_opcode": "0x7C000634",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "794",
            "clean": "794"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "RB",
          "desc": "Shift Reg"
        }
      ],
      "extension": "Base (64-bit)",
      "slug": "srad",
      "rel_url": "powerisa/srad/",
      "linked_summary": "Arithmetic right shift of 64-<a href=\"../../armv8-a/bit/\">bit</a> value (preserves sign).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sradi",
      "architecture": "PowerISA",
      "full_name": "Shift Right Algebraic Doubleword Immediate",
      "summary": "Arithmetic right shift by immediate.",
      "syntax": "sradi RA, RS, SH",
      "encoding": {
        "format": "XS-form",
        "binary_pattern": "31 | RS | RA | SH | 413 | SH",
        "hex_opcode": "0x7C000674",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "SH",
            "clean": "SH"
          },
          {
            "raw": "413",
            "clean": "413"
          },
          {
            "raw": "SH",
            "clean": "SH"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "SH",
          "desc": "Shift"
        }
      ],
      "extension": "Base (64-bit)",
      "slug": "sradi",
      "rel_url": "powerisa/sradi/",
      "linked_summary": "Arithmetic right shift by immediate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lhbrx",
      "architecture": "PowerISA",
      "full_name": "Load Halfword Byte-Reverse Indexed",
      "summary": "Loads a halfword and swaps bytes (Little-Endian load).",
      "syntax": "lhbrx RT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | RA | RB | 790 | /",
        "hex_opcode": "0x7C00062C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "790",
            "clean": "790"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base",
      "slug": "lhbrx",
      "rel_url": "powerisa/lhbrx/",
      "linked_summary": "Loads a halfword <a href=\"../../armv8-a/and_6/\">and</a> swaps bytes (Little-Endian load).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lwbrx",
      "architecture": "PowerISA",
      "full_name": "Load Word Byte-Reverse Indexed",
      "summary": "Loads a word and swaps bytes.",
      "syntax": "lwbrx RT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | RA | RB | 534 | /",
        "hex_opcode": "0x7C00042C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "534",
            "clean": "534"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base",
      "slug": "lwbrx",
      "rel_url": "powerisa/lwbrx/",
      "linked_summary": "Loads a word <a href=\"../../armv8-a/and_6/\">and</a> swaps bytes.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sthbrx",
      "architecture": "PowerISA",
      "full_name": "Store Halfword Byte-Reverse Indexed",
      "summary": "Swaps bytes and stores a halfword.",
      "syntax": "sthbrx RS, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 918 | /",
        "hex_opcode": "0x7C00072C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "918",
            "clean": "918"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base",
      "slug": "sthbrx",
      "rel_url": "powerisa/sthbrx/",
      "linked_summary": "Swaps bytes <a href=\"../../armv8-a/and_6/\">and</a> stores a halfword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stwbrx",
      "architecture": "PowerISA",
      "full_name": "Store Word Byte-Reverse Indexed",
      "summary": "Swaps bytes and stores a word.",
      "syntax": "stwbrx RS, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 662 | /",
        "hex_opcode": "0x7C00052C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "662",
            "clean": "662"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base",
      "slug": "stwbrx",
      "rel_url": "powerisa/stwbrx/",
      "linked_summary": "Swaps bytes <a href=\"../../armv8-a/and_6/\">and</a> stores a word.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ldbrx",
      "architecture": "PowerISA",
      "full_name": "Load Doubleword Byte-Reverse Indexed",
      "summary": "Loads 64 bits and swaps bytes.",
      "syntax": "ldbrx RT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | RA | RB | 532 | /",
        "hex_opcode": "0x7C000428",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "532",
            "clean": "532"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base (64-bit)",
      "slug": "ldbrx",
      "rel_url": "powerisa/ldbrx/",
      "linked_summary": "Loads 64 bits <a href=\"../../armv8-a/and_6/\">and</a> swaps bytes.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stdbrx",
      "architecture": "PowerISA",
      "full_name": "Store Doubleword Byte-Reverse Indexed",
      "summary": "Swaps bytes and stores 64 bits.",
      "syntax": "stdbrx RS, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 660 | /",
        "hex_opcode": "0x7C000528",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "660",
            "clean": "660"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base (64-bit)",
      "slug": "stdbrx",
      "rel_url": "powerisa/stdbrx/",
      "linked_summary": "Swaps bytes <a href=\"../../armv8-a/and_6/\">and</a> stores 64 bits.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stwcx.",
      "architecture": "PowerISA",
      "full_name": "Store Word Conditional Indexed",
      "summary": "Atomic Store Word (checks reservation).",
      "syntax": "stwcx. RS, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 150 | 1",
        "hex_opcode": "0x7C00012D",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "150",
            "clean": "150"
          },
          {
            "raw": "1",
            "clean": "1"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base (Atomics)",
      "slug": "stwcx_",
      "rel_url": "powerisa/stwcx_/",
      "linked_summary": "Atomic Store Word (checks reservation).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stdcx.",
      "architecture": "PowerISA",
      "full_name": "Store Doubleword Conditional Indexed",
      "summary": "Atomic Store Doubleword.",
      "syntax": "stdcx. RS, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 214 | 1",
        "hex_opcode": "0x7C0001AD",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "214",
            "clean": "214"
          },
          {
            "raw": "1",
            "clean": "1"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base (Atomics)",
      "slug": "stdcx_",
      "rel_url": "powerisa/stdcx_/",
      "linked_summary": "Atomic Store Doubleword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tw",
      "architecture": "PowerISA",
      "full_name": "Trap Word",
      "summary": "Traps if condition (comparison of words) is met.",
      "syntax": "tw TO, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | TO | RA | RB | 4",
        "hex_opcode": "0x7C000008",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "TO",
            "clean": "TO"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "4",
            "clean": "4"
          }
        ]
      },
      "operands": [
        {
          "name": "TO",
          "desc": "Options"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Base",
      "slug": "tw",
      "rel_url": "powerisa/tw/",
      "linked_summary": "Traps if condition (comparison of words) is met.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "twi",
      "architecture": "PowerISA",
      "full_name": "Trap Word Immediate",
      "summary": "Traps if condition (comparison with immediate) is met.",
      "syntax": "twi TO, RA, SIM",
      "encoding": {
        "format": "D-form",
        "binary_pattern": "3 | TO | RA | SIM",
        "hex_opcode": "0x0C000000",
        "visual_parts": [
          {
            "raw": "3",
            "clean": "3"
          },
          {
            "raw": "TO",
            "clean": "TO"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "SIM",
            "clean": "SIM"
          }
        ]
      },
      "operands": [
        {
          "name": "TO",
          "desc": "Options"
        },
        {
          "name": "RA",
          "desc": "Src"
        },
        {
          "name": "SIM",
          "desc": "Imm"
        }
      ],
      "extension": "Base",
      "slug": "twi",
      "rel_url": "powerisa/twi/",
      "linked_summary": "Traps if condition (comparison with immediate) is met.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "td",
      "architecture": "PowerISA",
      "full_name": "Trap Doubleword",
      "summary": "Traps if condition (comparison of doublewords) is met.",
      "syntax": "td TO, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | TO | RA | RB | 68",
        "hex_opcode": "0x7C000088",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "TO",
            "clean": "TO"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "68",
            "clean": "68"
          }
        ]
      },
      "operands": [
        {
          "name": "TO",
          "desc": "Options"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Base (64-bit)",
      "slug": "td",
      "rel_url": "powerisa/td/",
      "linked_summary": "Traps if condition (comparison of doublewords) is met.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tdi",
      "architecture": "PowerISA",
      "full_name": "Trap Doubleword Immediate",
      "summary": "Traps if condition (comparison with immediate) is met.",
      "syntax": "tdi TO, RA, SIM",
      "encoding": {
        "format": "D-form",
        "binary_pattern": "2 | TO | RA | SIM",
        "hex_opcode": "0x08000000",
        "visual_parts": [
          {
            "raw": "2",
            "clean": "2"
          },
          {
            "raw": "TO",
            "clean": "TO"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "SIM",
            "clean": "SIM"
          }
        ]
      },
      "operands": [
        {
          "name": "TO",
          "desc": "Options"
        },
        {
          "name": "RA",
          "desc": "Src"
        },
        {
          "name": "SIM",
          "desc": "Imm"
        }
      ],
      "extension": "Base (64-bit)",
      "slug": "tdi",
      "rel_url": "powerisa/tdi/",
      "linked_summary": "Traps if condition (comparison with immediate) is met.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "extsb",
      "architecture": "PowerISA",
      "full_name": "Extend Sign Byte",
      "summary": "Sign extends the low byte of a register to the full width.",
      "syntax": "extsb RA, RS",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | 954 | /",
        "hex_opcode": "0x7C000774",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "954",
            "clean": "954"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Source"
        }
      ],
      "extension": "Base",
      "slug": "extsb",
      "rel_url": "powerisa/extsb/",
      "linked_summary": "Sign extends the low byte of a register to the full width.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "extsh",
      "architecture": "PowerISA",
      "full_name": "Extend Sign Halfword",
      "summary": "Sign extends the low halfword.",
      "syntax": "extsh RA, RS",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | 922 | /",
        "hex_opcode": "0x7C000734",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "922",
            "clean": "922"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Source"
        }
      ],
      "extension": "Base",
      "slug": "extsh",
      "rel_url": "powerisa/extsh/",
      "linked_summary": "Sign extends the low halfword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "extsw",
      "architecture": "PowerISA",
      "full_name": "Extend Sign Word",
      "summary": "Sign extends the low word (32-bit) to 64 bits.",
      "syntax": "extsw RA, RS",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | 986 | /",
        "hex_opcode": "0x7C0007B4",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "986",
            "clean": "986"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Source"
        }
      ],
      "extension": "Base (64-bit)",
      "slug": "extsw",
      "rel_url": "powerisa/extsw/",
      "linked_summary": "Sign extends the low word (32-<a href=\"../../armv8-a/bit/\">bit</a>) to 64 bits.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "eqv",
      "architecture": "PowerISA",
      "full_name": "Equivalent",
      "summary": "Bitwise Equivalence (XNOR). RA = ~(RS ^ RB).",
      "syntax": "eqv RA, RS, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 284 | /",
        "hex_opcode": "0x7C000238",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "284",
            "clean": "284"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Base",
      "slug": "eqv",
      "rel_url": "powerisa/eqv/",
      "linked_summary": "Bitwise Equivalence (<a href=\"../../risc-v/xnor/\">XNOR</a>). RA = ~(RS ^ RB).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "nand",
      "architecture": "PowerISA",
      "full_name": "NAND",
      "summary": "Bitwise NAND. RA = ~(RS & RB).",
      "syntax": "nand RA, RS, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 476 | /",
        "hex_opcode": "0x7C0003B8",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "476",
            "clean": "476"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Base",
      "slug": "nand",
      "rel_url": "powerisa/nand/",
      "linked_summary": "Bitwise NAND. RA = ~(RS & RB).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "nor",
      "architecture": "PowerISA",
      "full_name": "NOR",
      "summary": "Bitwise NOR. RA = ~(RS | RB).",
      "syntax": "nor RA, RS, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 124 | /",
        "hex_opcode": "0x7C0000F8",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "124",
            "clean": "124"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Base",
      "slug": "nor",
      "rel_url": "powerisa/nor/",
      "linked_summary": "Bitwise NOR. RA = ~(RS | RB).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "orc",
      "architecture": "PowerISA",
      "full_name": "OR with Complement",
      "summary": "Bitwise OR with complement. RA = RS | ~RB.",
      "syntax": "orc RA, RS, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 412 | /",
        "hex_opcode": "0x7C000338",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "412",
            "clean": "412"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Base",
      "slug": "orc",
      "rel_url": "powerisa/orc/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/or/\">OR</a> with complement. RA = RS | ~RB.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evaddw",
      "architecture": "PowerISA",
      "full_name": "Vector Add Word",
      "summary": "Adds two 64-bit vectors of two 32-bit words.",
      "syntax": "evaddw RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 512",
        "hex_opcode": "0x10000200",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "512",
            "clean": "512"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evaddw",
      "rel_url": "powerisa/evaddw/",
      "linked_summary": "Adds two 64-<a href=\"../../armv8-a/bit/\">bit</a> vectors of two 32-<a href=\"../../armv8-a/bit/\">bit</a> words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evsubw",
      "architecture": "PowerISA",
      "full_name": "Vector Subtract Word",
      "summary": "Subtracts two 64-bit vectors of two 32-bit words.",
      "syntax": "evsubw RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 514",
        "hex_opcode": "0x10000202",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "514",
            "clean": "514"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evsubw",
      "rel_url": "powerisa/evsubw/",
      "linked_summary": "Subtracts two 64-<a href=\"../../armv8-a/bit/\">bit</a> vectors of two 32-<a href=\"../../armv8-a/bit/\">bit</a> words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evabs",
      "architecture": "PowerISA",
      "full_name": "Vector Absolute Value",
      "summary": "Computes absolute value of words in a 64-bit vector.",
      "syntax": "evabs RT, RA",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | 0 | 520",
        "hex_opcode": "0x10000208",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "520",
            "clean": "520"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evabs",
      "rel_url": "powerisa/evabs/",
      "linked_summary": "Computes absolute value of words <a href=\"../../x86/in/\">in</a> a 64-<a href=\"../../armv8-a/bit/\">bit</a> vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evneg",
      "architecture": "PowerISA",
      "full_name": "Vector Negate",
      "summary": "Negates words in a 64-bit vector.",
      "syntax": "evneg RT, RA",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | 0 | 521",
        "hex_opcode": "0x10000209",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "521",
            "clean": "521"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evneg",
      "rel_url": "powerisa/evneg/",
      "linked_summary": "Negates words <a href=\"../../x86/in/\">in</a> a 64-<a href=\"../../armv8-a/bit/\">bit</a> vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evextsb",
      "architecture": "PowerISA",
      "full_name": "Vector Extend Sign Byte",
      "summary": "Sign extends the low byte of each word to 32 bits.",
      "syntax": "evextsb RT, RA",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | 0 | 522",
        "hex_opcode": "0x1000020A",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "522",
            "clean": "522"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evextsb",
      "rel_url": "powerisa/evextsb/",
      "linked_summary": "Sign extends the low byte of each word to 32 bits.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evextsh",
      "architecture": "PowerISA",
      "full_name": "Vector Extend Sign Halfword",
      "summary": "Sign extends the low halfword of each word to 32 bits.",
      "syntax": "evextsh RT, RA",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | 0 | 523",
        "hex_opcode": "0x1000020B",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "523",
            "clean": "523"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evextsh",
      "rel_url": "powerisa/evextsh/",
      "linked_summary": "Sign extends the low halfword of each word to 32 bits.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evrndw",
      "architecture": "PowerISA",
      "full_name": "Vector Round Word",
      "summary": "Rounds words in the vector.",
      "syntax": "evrndw RT, RA",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | 0 | 524",
        "hex_opcode": "0x1000020C",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "524",
            "clean": "524"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evrndw",
      "rel_url": "powerisa/evrndw/",
      "linked_summary": "Rounds words <a href=\"../../x86/in/\">in</a> the vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evcntlzw",
      "architecture": "PowerISA",
      "full_name": "Vector Count Leading Zeros Word",
      "summary": "Counts leading zeros in each word.",
      "syntax": "evcntlzw RT, RA",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | 0 | 525",
        "hex_opcode": "0x1000020D",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "525",
            "clean": "525"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evcntlzw",
      "rel_url": "powerisa/evcntlzw/",
      "linked_summary": "Counts leading zeros <a href=\"../../x86/in/\">in</a> each word.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evcntlsw",
      "architecture": "PowerISA",
      "full_name": "Vector Count Leading Signs Word",
      "summary": "Counts leading sign bits in each word.",
      "syntax": "evcntlsw RT, RA",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | 0 | 526",
        "hex_opcode": "0x1000020E",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "526",
            "clean": "526"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evcntlsw",
      "rel_url": "powerisa/evcntlsw/",
      "linked_summary": "Counts leading sign bits <a href=\"../../x86/in/\">in</a> each word.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evand",
      "architecture": "PowerISA",
      "full_name": "Vector AND",
      "summary": "Bitwise AND of two 64-bit vectors.",
      "syntax": "evand RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 529",
        "hex_opcode": "0x10000211",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "529",
            "clean": "529"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evand",
      "rel_url": "powerisa/evand/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/and/\">AND</a> of two 64-<a href=\"../../armv8-a/bit/\">bit</a> vectors.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evor",
      "architecture": "PowerISA",
      "full_name": "Vector OR",
      "summary": "Bitwise OR of two 64-bit vectors.",
      "syntax": "evor RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 531",
        "hex_opcode": "0x10000213",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "531",
            "clean": "531"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evor",
      "rel_url": "powerisa/evor/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/or/\">OR</a> of two 64-<a href=\"../../armv8-a/bit/\">bit</a> vectors.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evxor",
      "architecture": "PowerISA",
      "full_name": "Vector XOR",
      "summary": "Bitwise XOR of two 64-bit vectors.",
      "syntax": "evxor RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 534",
        "hex_opcode": "0x10000216",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "534",
            "clean": "534"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evxor",
      "rel_url": "powerisa/evxor/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/xor/\">XOR</a> of two 64-<a href=\"../../armv8-a/bit/\">bit</a> vectors.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evnand",
      "architecture": "PowerISA",
      "full_name": "Vector NAND",
      "summary": "Bitwise NAND of two 64-bit vectors.",
      "syntax": "evnand RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 542",
        "hex_opcode": "0x1000021E",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "542",
            "clean": "542"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evnand",
      "rel_url": "powerisa/evnand/",
      "linked_summary": "Bitwise NAND of two 64-<a href=\"../../armv8-a/bit/\">bit</a> vectors.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evnor",
      "architecture": "PowerISA",
      "full_name": "Vector NOR",
      "summary": "Bitwise NOR of two 64-bit vectors.",
      "syntax": "evnor RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 536",
        "hex_opcode": "0x10000218",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "536",
            "clean": "536"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evnor",
      "rel_url": "powerisa/evnor/",
      "linked_summary": "Bitwise NOR of two 64-<a href=\"../../armv8-a/bit/\">bit</a> vectors.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "eveqv",
      "architecture": "PowerISA",
      "full_name": "Vector Equivalent",
      "summary": "Bitwise Equivalence (XNOR).",
      "syntax": "eveqv RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 537",
        "hex_opcode": "0x10000219",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "537",
            "clean": "537"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "eveqv",
      "rel_url": "powerisa/eveqv/",
      "linked_summary": "Bitwise Equivalence (<a href=\"../../risc-v/xnor/\">XNOR</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evandc",
      "architecture": "PowerISA",
      "full_name": "Vector AND with Complement",
      "summary": "RT = RA & ~RB.",
      "syntax": "evandc RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 530",
        "hex_opcode": "0x10000212",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "530",
            "clean": "530"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evandc",
      "rel_url": "powerisa/evandc/",
      "linked_summary": "RT = RA & ~RB.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evorc",
      "architecture": "PowerISA",
      "full_name": "Vector OR with Complement",
      "summary": "RT = RA | ~RB.",
      "syntax": "evorc RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 533",
        "hex_opcode": "0x10000215",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "533",
            "clean": "533"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evorc",
      "rel_url": "powerisa/evorc/",
      "linked_summary": "RT = RA | ~RB.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evrlw",
      "architecture": "PowerISA",
      "full_name": "Vector Rotate Left Word",
      "summary": "Rotates words in RA left by amount in RB.",
      "syntax": "evrlw RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 552",
        "hex_opcode": "0x10000228",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "552",
            "clean": "552"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Data"
        },
        {
          "name": "RB",
          "desc": "Shift"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evrlw",
      "rel_url": "powerisa/evrlw/",
      "linked_summary": "Rotates words <a href=\"../../x86/in/\">in</a> RA left by amount <a href=\"../../x86/in/\">in</a> RB.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evslw",
      "architecture": "PowerISA",
      "full_name": "Vector Shift Left Word",
      "summary": "Shifts words in RA left by amount in RB.",
      "syntax": "evslw RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 544",
        "hex_opcode": "0x10000220",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "544",
            "clean": "544"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Data"
        },
        {
          "name": "RB",
          "desc": "Shift"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evslw",
      "rel_url": "powerisa/evslw/",
      "linked_summary": "Shifts words <a href=\"../../x86/in/\">in</a> RA left by amount <a href=\"../../x86/in/\">in</a> RB.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evsrws",
      "architecture": "PowerISA",
      "full_name": "Vector Shift Right Word Signed",
      "summary": "Arithmetic right shift of words.",
      "syntax": "evsrws RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 545",
        "hex_opcode": "0x10000221",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "545",
            "clean": "545"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Data"
        },
        {
          "name": "RB",
          "desc": "Shift"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evsrws",
      "rel_url": "powerisa/evsrws/",
      "linked_summary": "Arithmetic right shift of words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evsrwu",
      "architecture": "PowerISA",
      "full_name": "Vector Shift Right Word Unsigned",
      "summary": "Logical right shift of words.",
      "syntax": "evsrwu RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 546",
        "hex_opcode": "0x10000222",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "546",
            "clean": "546"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Data"
        },
        {
          "name": "RB",
          "desc": "Shift"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evsrwu",
      "rel_url": "powerisa/evsrwu/",
      "linked_summary": "Logical right shift of words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evrlwi",
      "architecture": "PowerISA",
      "full_name": "Vector Rotate Left Word Immediate",
      "summary": "Rotates words left by immediate value.",
      "syntax": "evrlwi RT, RA, UIM",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | UIM | 554",
        "hex_opcode": "0x1000022A",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          },
          {
            "raw": "554",
            "clean": "554"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Data"
        },
        {
          "name": "UIM",
          "desc": "Shift"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evrlwi",
      "rel_url": "powerisa/evrlwi/",
      "linked_summary": "Rotates words left by immediate value.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evslwi",
      "architecture": "PowerISA",
      "full_name": "Vector Shift Left Word Immediate",
      "summary": "Shifts words left by immediate value.",
      "syntax": "evslwi RT, RA, UIM",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | UIM | 548",
        "hex_opcode": "0x10000224",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          },
          {
            "raw": "548",
            "clean": "548"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Data"
        },
        {
          "name": "UIM",
          "desc": "Shift"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evslwi",
      "rel_url": "powerisa/evslwi/",
      "linked_summary": "Shifts words left by immediate value.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evsrwis",
      "architecture": "PowerISA",
      "full_name": "Vector Shift Right Word Immediate Signed",
      "summary": "Arithmetic right shift by immediate.",
      "syntax": "evsrwis RT, RA, UIM",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | UIM | 549",
        "hex_opcode": "0x10000225",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          },
          {
            "raw": "549",
            "clean": "549"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Data"
        },
        {
          "name": "UIM",
          "desc": "Shift"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evsrwis",
      "rel_url": "powerisa/evsrwis/",
      "linked_summary": "Arithmetic right shift by immediate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evsrwiu",
      "architecture": "PowerISA",
      "full_name": "Vector Shift Right Word Immediate Unsigned",
      "summary": "Logical right shift by immediate.",
      "syntax": "evsrwiu RT, RA, UIM",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | UIM | 550",
        "hex_opcode": "0x10000226",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          },
          {
            "raw": "550",
            "clean": "550"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Data"
        },
        {
          "name": "UIM",
          "desc": "Shift"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evsrwiu",
      "rel_url": "powerisa/evsrwiu/",
      "linked_summary": "Logical right shift by immediate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evsplati",
      "architecture": "PowerISA",
      "full_name": "Vector Splat Immediate",
      "summary": "Splats a signed 5-bit immediate into both words.",
      "syntax": "evsplati RT, SIM",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | SIM | 0 | 553",
        "hex_opcode": "0x10000229",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "SIM",
            "clean": "SIM"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "553",
            "clean": "553"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "SIM",
          "desc": "Imm"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evsplati",
      "rel_url": "powerisa/evsplati/",
      "linked_summary": "Splats a signed 5-<a href=\"../../armv8-a/bit/\">bit</a> immediate into both words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evsplatfi",
      "architecture": "PowerISA",
      "full_name": "Vector Splat Float Immediate",
      "summary": "Splats a 5-bit immediate (scaled) into both words.",
      "syntax": "evsplatfi RT, SIM",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | SIM | 0 | 555",
        "hex_opcode": "0x1000022B",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "SIM",
            "clean": "SIM"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "555",
            "clean": "555"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "SIM",
          "desc": "Imm"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evsplatfi",
      "rel_url": "powerisa/evsplatfi/",
      "linked_summary": "Splats a 5-<a href=\"../../armv8-a/bit/\">bit</a> immediate (scaled) into both words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evldd",
      "architecture": "PowerISA",
      "full_name": "Vector Load Doubleword into Doubleword",
      "summary": "Loads 64 bits from memory into a vector GPR.",
      "syntax": "evldd RT, D(RA)",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | D | 769",
        "hex_opcode": "0x10000301",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D",
            "clean": "D"
          },
          {
            "raw": "769",
            "clean": "769"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evldd",
      "rel_url": "powerisa/evldd/",
      "linked_summary": "Loads 64 bits from memory into a vector GPR.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evldw",
      "architecture": "PowerISA",
      "full_name": "Vector Load Doubleword into Word",
      "summary": "Loads two words from memory (aligned) into a vector.",
      "syntax": "evldw RT, D(RA)",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | D | 771",
        "hex_opcode": "0x10000303",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D",
            "clean": "D"
          },
          {
            "raw": "771",
            "clean": "771"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evldw",
      "rel_url": "powerisa/evldw/",
      "linked_summary": "Loads two words from memory (aligned) into a vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evldh",
      "architecture": "PowerISA",
      "full_name": "Vector Load Doubleword into Halfword",
      "summary": "Loads 4 halfwords from memory into a vector.",
      "syntax": "evldh RT, D(RA)",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | D | 773",
        "hex_opcode": "0x10000305",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D",
            "clean": "D"
          },
          {
            "raw": "773",
            "clean": "773"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evldh",
      "rel_url": "powerisa/evldh/",
      "linked_summary": "Loads 4 halfwords from memory into a vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evlhhesplat",
      "architecture": "PowerISA",
      "full_name": "Vector Load Halfword into Halfword Even and Splat",
      "summary": "Loads a halfword and duplicates it into the even halfwords of the target.",
      "syntax": "evlhhesplat RT, D(RA)",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | D | 777",
        "hex_opcode": "0x10000309",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D",
            "clean": "D"
          },
          {
            "raw": "777",
            "clean": "777"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evlhhesplat",
      "rel_url": "powerisa/evlhhesplat/",
      "linked_summary": "Loads a halfword <a href=\"../../armv8-a/and_6/\">and</a> duplicates <a href=\"../../armv8-a/it/\">it</a> into the even halfwords of the target.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evlhhousplat",
      "architecture": "PowerISA",
      "full_name": "Vector Load Halfword into Halfword Odd Unsigned and Splat",
      "summary": "Loads a halfword and duplicates it into the odd halfwords (zero extended).",
      "syntax": "evlhhousplat RT, D(RA)",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | D | 781",
        "hex_opcode": "0x1000030D",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D",
            "clean": "D"
          },
          {
            "raw": "781",
            "clean": "781"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evlhhousplat",
      "rel_url": "powerisa/evlhhousplat/",
      "linked_summary": "Loads a halfword <a href=\"../../armv8-a/and_6/\">and</a> duplicates <a href=\"../../armv8-a/it/\">it</a> into the odd halfwords (<a href=\"../../armv9-a/zero_2/\">zero</a> extended).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evlhhossplat",
      "architecture": "PowerISA",
      "full_name": "Vector Load Halfword into Halfword Odd Signed and Splat",
      "summary": "Loads a halfword and duplicates it into the odd halfwords (sign extended).",
      "syntax": "evlhhossplat RT, D(RA)",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | D | 783",
        "hex_opcode": "0x1000030F",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D",
            "clean": "D"
          },
          {
            "raw": "783",
            "clean": "783"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evlhhossplat",
      "rel_url": "powerisa/evlhhossplat/",
      "linked_summary": "Loads a halfword <a href=\"../../armv8-a/and_6/\">and</a> duplicates <a href=\"../../armv8-a/it/\">it</a> into the odd halfwords (sign extended).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evlwhe",
      "architecture": "PowerISA",
      "full_name": "Vector Load Word into Halfword Even",
      "summary": "Loads two words and places them in the even halfword positions.",
      "syntax": "evlwhe RT, D(RA)",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | D | 785",
        "hex_opcode": "0x10000311",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D",
            "clean": "D"
          },
          {
            "raw": "785",
            "clean": "785"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evlwhe",
      "rel_url": "powerisa/evlwhe/",
      "linked_summary": "Loads two words <a href=\"../../armv8-a/and_6/\">and</a> places them <a href=\"../../x86/in/\">in</a> the even halfword positions.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evlwhou",
      "architecture": "PowerISA",
      "full_name": "Vector Load Word into Halfword Odd Unsigned",
      "summary": "Loads words into odd positions (zero extended).",
      "syntax": "evlwhou RT, D(RA)",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | D | 789",
        "hex_opcode": "0x10000315",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D",
            "clean": "D"
          },
          {
            "raw": "789",
            "clean": "789"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evlwhou",
      "rel_url": "powerisa/evlwhou/",
      "linked_summary": "Loads words into odd positions (<a href=\"../../armv9-a/zero_2/\">zero</a> extended).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evlwhos",
      "architecture": "PowerISA",
      "full_name": "Vector Load Word into Halfword Odd Signed",
      "summary": "Loads words into odd positions (sign extended).",
      "syntax": "evlwhos RT, D(RA)",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | D | 791",
        "hex_opcode": "0x10000317",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D",
            "clean": "D"
          },
          {
            "raw": "791",
            "clean": "791"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evlwhos",
      "rel_url": "powerisa/evlwhos/",
      "linked_summary": "Loads words into odd positions (sign extended).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evstdd",
      "architecture": "PowerISA",
      "full_name": "Vector Store Doubleword of Doubleword",
      "summary": "Stores 64-bit vector to memory.",
      "syntax": "evstdd RS, D(RA)",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RS | RA | D | 801",
        "hex_opcode": "0x10000321",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D",
            "clean": "D"
          },
          {
            "raw": "801",
            "clean": "801"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evstdd",
      "rel_url": "powerisa/evstdd/",
      "linked_summary": "Stores 64-<a href=\"../../armv8-a/bit/\">bit</a> vector to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evstdw",
      "architecture": "PowerISA",
      "full_name": "Vector Store Doubleword of Word",
      "summary": "Stores two words from vector to memory.",
      "syntax": "evstdw RS, D(RA)",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RS | RA | D | 803",
        "hex_opcode": "0x10000323",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D",
            "clean": "D"
          },
          {
            "raw": "803",
            "clean": "803"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evstdw",
      "rel_url": "powerisa/evstdw/",
      "linked_summary": "Stores two words from vector to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evstdh",
      "architecture": "PowerISA",
      "full_name": "Vector Store Doubleword of Halfword",
      "summary": "Stores 4 halfwords from vector to memory.",
      "syntax": "evstdh RS, D(RA)",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RS | RA | D | 805",
        "hex_opcode": "0x10000325",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D",
            "clean": "D"
          },
          {
            "raw": "805",
            "clean": "805"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evstdh",
      "rel_url": "powerisa/evstdh/",
      "linked_summary": "Stores 4 halfwords from vector to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evstwhe",
      "architecture": "PowerISA",
      "full_name": "Vector Store Word of Halfword Even",
      "summary": "Stores even halfwords to memory.",
      "syntax": "evstwhe RS, D(RA)",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RS | RA | D | 809",
        "hex_opcode": "0x10000329",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D",
            "clean": "D"
          },
          {
            "raw": "809",
            "clean": "809"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evstwhe",
      "rel_url": "powerisa/evstwhe/",
      "linked_summary": "Stores even halfwords to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evstwho",
      "architecture": "PowerISA",
      "full_name": "Vector Store Word of Halfword Odd",
      "summary": "Stores odd halfwords to memory.",
      "syntax": "evstwho RS, D(RA)",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RS | RA | D | 813",
        "hex_opcode": "0x1000032D",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D",
            "clean": "D"
          },
          {
            "raw": "813",
            "clean": "813"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evstwho",
      "rel_url": "powerisa/evstwho/",
      "linked_summary": "Stores odd halfwords to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evstwwe",
      "architecture": "PowerISA",
      "full_name": "Vector Store Word of Word Even",
      "summary": "Stores the even word (upper 32-bits) to memory.",
      "syntax": "evstwwe RS, D(RA)",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RS | RA | D | 817",
        "hex_opcode": "0x10000331",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D",
            "clean": "D"
          },
          {
            "raw": "817",
            "clean": "817"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evstwwe",
      "rel_url": "powerisa/evstwwe/",
      "linked_summary": "Stores the even word (upper 32-bits) to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evstwwo",
      "architecture": "PowerISA",
      "full_name": "Vector Store Word of Word Odd",
      "summary": "Stores the odd word (lower 32-bits) to memory.",
      "syntax": "evstwwo RS, D(RA)",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RS | RA | D | 821",
        "hex_opcode": "0x10000335",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D",
            "clean": "D"
          },
          {
            "raw": "821",
            "clean": "821"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evstwwo",
      "rel_url": "powerisa/evstwwo/",
      "linked_summary": "Stores the odd word (lower 32-bits) to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evmhegsmfaa",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Halfword Even Guarded Signed Modulo Fractional Accumulate",
      "summary": "Fractional multiply accumulate (DSP).",
      "syntax": "evmhegsmfaa RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1323",
        "hex_opcode": "0x1000052B",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1323",
            "clean": "1323"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evmhegsmfaa",
      "rel_url": "powerisa/evmhegsmfaa/",
      "linked_summary": "Fractional multiply accumulate (DSP).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evmhegsmfan",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Halfword Even Guarded Signed Modulo Fractional Accumulate Negative",
      "summary": "Fractional multiply negative accumulate.",
      "syntax": "evmhegsmfan RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1451",
        "hex_opcode": "0x100005AB",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1451",
            "clean": "1451"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evmhegsmfan",
      "rel_url": "powerisa/evmhegsmfan/",
      "linked_summary": "Fractional multiply negative accumulate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evmhegum",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Halfword Even Guarded Unsigned Modulo",
      "summary": "Unsigned multiply.",
      "syntax": "evmhegum RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1290",
        "hex_opcode": "0x1000050A",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1290",
            "clean": "1290"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evmhegum",
      "rel_url": "powerisa/evmhegum/",
      "linked_summary": "Unsigned multiply.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evmhesmia",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Halfword Even Signed Modulo Integer Accumulate",
      "summary": "Integer multiply accumulate.",
      "syntax": "evmhesmia RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1333",
        "hex_opcode": "0x10000535",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1333",
            "clean": "1333"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evmhesmia",
      "rel_url": "powerisa/evmhesmia/",
      "linked_summary": "Integer multiply accumulate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evmhesmian",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Halfword Even Signed Modulo Integer Accumulate Negative",
      "summary": "Integer multiply negative accumulate.",
      "syntax": "evmhesmian RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1461",
        "hex_opcode": "0x100005B5",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1461",
            "clean": "1461"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evmhesmian",
      "rel_url": "powerisa/evmhesmian/",
      "linked_summary": "Integer multiply negative accumulate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evmheumia",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Halfword Even Unsigned Modulo Integer Accumulate",
      "summary": "Unsigned multiply accumulate.",
      "syntax": "evmheumia RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1332",
        "hex_opcode": "0x10000534",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1332",
            "clean": "1332"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evmheumia",
      "rel_url": "powerisa/evmheumia/",
      "linked_summary": "Unsigned multiply accumulate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evmheumian",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Halfword Even Unsigned Modulo Integer Accumulate Negative",
      "summary": "Unsigned multiply negative accumulate.",
      "syntax": "evmheumian RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1460",
        "hex_opcode": "0x100005B4",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1460",
            "clean": "1460"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evmheumian",
      "rel_url": "powerisa/evmheumian/",
      "linked_summary": "Unsigned multiply negative accumulate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evmhossf",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Halfword Odd Signed Saturate Fractional",
      "summary": "Saturating fractional multiply.",
      "syntax": "evmhossf RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1287",
        "hex_opcode": "0x10000507",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1287",
            "clean": "1287"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evmhossf",
      "rel_url": "powerisa/evmhossf/",
      "linked_summary": "Saturating fractional multiply.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evmhossfa",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Halfword Odd Signed Saturate Fractional Accumulate",
      "summary": "Saturating fractional multiply accumulate.",
      "syntax": "evmhossfa RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1319",
        "hex_opcode": "0x10000527",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1319",
            "clean": "1319"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evmhossfa",
      "rel_url": "powerisa/evmhossfa/",
      "linked_summary": "Saturating fractional multiply accumulate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evmhosm",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Halfword Odd Signed Modulo",
      "summary": "Signed modulo multiply.",
      "syntax": "evmhosm RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1295",
        "hex_opcode": "0x1000050F",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1295",
            "clean": "1295"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evmhosm",
      "rel_url": "powerisa/evmhosm/",
      "linked_summary": "Signed modulo multiply.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evmhosmi",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Halfword Odd Signed Modulo Integer",
      "summary": "Signed integer modulo multiply.",
      "syntax": "evmhosmi RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1303",
        "hex_opcode": "0x10000517",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1303",
            "clean": "1303"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evmhosmi",
      "rel_url": "powerisa/evmhosmi/",
      "linked_summary": "Signed integer modulo multiply.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evmhoumi",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Halfword Odd Unsigned Modulo Integer",
      "summary": "Unsigned integer modulo multiply.",
      "syntax": "evmhoumi RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1302",
        "hex_opcode": "0x10000516",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1302",
            "clean": "1302"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evmhoumi",
      "rel_url": "powerisa/evmhoumi/",
      "linked_summary": "Unsigned integer modulo multiply.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evmwhsm",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Word High Signed Modulo",
      "summary": "Multiplies high 16-bits of words.",
      "syntax": "evmwhsm RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1311",
        "hex_opcode": "0x1000051F",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1311",
            "clean": "1311"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evmwhsm",
      "rel_url": "powerisa/evmwhsm/",
      "linked_summary": "Multiplies high 16-bits of words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evmwhsmi",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Word High Signed Modulo Integer",
      "summary": "Multiplies high 16-bits of words (integer).",
      "syntax": "evmwhsmi RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1319",
        "hex_opcode": "0x10000527",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1319",
            "clean": "1319"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evmwhsmi",
      "rel_url": "powerisa/evmwhsmi/",
      "linked_summary": "Multiplies high 16-bits of words (integer).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evmwhssf",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Word High Signed Saturate Fractional",
      "summary": "Fractional multiply of high words.",
      "syntax": "evmwhssf RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1303",
        "hex_opcode": "0x10000517",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1303",
            "clean": "1303"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evmwhssf",
      "rel_url": "powerisa/evmwhssf/",
      "linked_summary": "Fractional multiply of high words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evmwhssfa",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Word High Signed Saturate Fractional Accumulate",
      "summary": "Fractional multiply accumulate of high words.",
      "syntax": "evmwhssfa RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1335",
        "hex_opcode": "0x10000537",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1335",
            "clean": "1335"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evmwhssfa",
      "rel_url": "powerisa/evmwhssfa/",
      "linked_summary": "Fractional multiply accumulate of high words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evmwlumi",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Word Low Unsigned Modulo Integer",
      "summary": "Multiplies low 16-bits of words.",
      "syntax": "evmwlumi RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1312",
        "hex_opcode": "0x10000520",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1312",
            "clean": "1312"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evmwlumi",
      "rel_url": "powerisa/evmwlumi/",
      "linked_summary": "Multiplies low 16-bits of words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evmwlumia",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Word Low Unsigned Modulo Integer Accumulate",
      "summary": "Multiply accumulate low words.",
      "syntax": "evmwlumia RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1344",
        "hex_opcode": "0x10000540",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1344",
            "clean": "1344"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evmwlumia",
      "rel_url": "powerisa/evmwlumia/",
      "linked_summary": "Multiply accumulate low words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evmwlumiaa",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Word Low Unsigned Modulo Integer Accumulate Accumulate",
      "summary": "Multiply and double accumulate low words.",
      "syntax": "evmwlumiaa RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1346",
        "hex_opcode": "0x10000542",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1346",
            "clean": "1346"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evmwlumiaa",
      "rel_url": "powerisa/evmwlumiaa/",
      "linked_summary": "Multiply <a href=\"../../armv8-a/and_6/\">and</a> double accumulate low words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evmwlusiaaw",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Word Low Unsigned Signed Integer Accumulate Accumulate Word",
      "summary": "Complex mixed-sign accumulation.",
      "syntax": "evmwlusiaaw RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1347",
        "hex_opcode": "0x10000543",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1347",
            "clean": "1347"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evmwlusiaaw",
      "rel_url": "powerisa/evmwlusiaaw/",
      "linked_summary": "Complex mixed-sign accumulation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evmwsmia",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Word Signed Modulo Integer Accumulate",
      "summary": "Signed integer multiply accumulate.",
      "syntax": "evmwsmia RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1349",
        "hex_opcode": "0x10000545",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1349",
            "clean": "1349"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evmwsmia",
      "rel_url": "powerisa/evmwsmia/",
      "linked_summary": "Signed integer multiply accumulate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evmwsmiaa",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Word Signed Modulo Integer Accumulate Accumulate",
      "summary": "Signed integer multiply double accumulate.",
      "syntax": "evmwsmiaa RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1351",
        "hex_opcode": "0x10000547",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1351",
            "clean": "1351"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evmwsmiaa",
      "rel_url": "powerisa/evmwsmiaa/",
      "linked_summary": "Signed integer multiply double accumulate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evmwsmiaaw",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Word Signed Modulo Integer Accumulate Accumulate Word",
      "summary": "Signed integer multiply accumulate word.",
      "syntax": "evmwsmiaaw RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1353",
        "hex_opcode": "0x10000549",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1353",
            "clean": "1353"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evmwsmiaaw",
      "rel_url": "powerisa/evmwsmiaaw/",
      "linked_summary": "Signed integer multiply accumulate word.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evmwssfaa",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Word Signed Saturate Fractional Accumulate Accumulate",
      "summary": "Saturating fractional multiply double accumulate.",
      "syntax": "evmwssfaa RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1355",
        "hex_opcode": "0x1000054B",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1355",
            "clean": "1355"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evmwssfaa",
      "rel_url": "powerisa/evmwssfaa/",
      "linked_summary": "Saturating fractional multiply double accumulate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evmwssfaaw",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Word Signed Saturate Fractional Accumulate Accumulate Word",
      "summary": "Saturating fractional multiply accumulate word.",
      "syntax": "evmwssfaaw RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1357",
        "hex_opcode": "0x1000054D",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1357",
            "clean": "1357"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evmwssfaaw",
      "rel_url": "powerisa/evmwssfaaw/",
      "linked_summary": "Saturating fractional multiply accumulate word.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evmwumia",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Word Unsigned Modulo Integer Accumulate",
      "summary": "Unsigned multiply accumulate.",
      "syntax": "evmwumia RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1348",
        "hex_opcode": "0x10000544",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1348",
            "clean": "1348"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evmwumia",
      "rel_url": "powerisa/evmwumia/",
      "linked_summary": "Unsigned multiply accumulate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evmwumiaa",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Word Unsigned Modulo Integer Accumulate Accumulate",
      "summary": "Unsigned multiply double accumulate.",
      "syntax": "evmwumiaa RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1350",
        "hex_opcode": "0x10000546",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1350",
            "clean": "1350"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evmwumiaa",
      "rel_url": "powerisa/evmwumiaa/",
      "linked_summary": "Unsigned multiply double accumulate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evmwumiaaw",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Word Unsigned Modulo Integer Accumulate Accumulate Word",
      "summary": "Unsigned multiply accumulate word.",
      "syntax": "evmwumiaaw RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1352",
        "hex_opcode": "0x10000548",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1352",
            "clean": "1352"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evmwumiaaw",
      "rel_url": "powerisa/evmwumiaaw/",
      "linked_summary": "Unsigned multiply accumulate word.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evsubfsmiaaw",
      "architecture": "PowerISA",
      "full_name": "Vector Subtract Signed Modulo Integer Accumulate Accumulate Word",
      "summary": "Complex subtraction accumulate.",
      "syntax": "evsubfsmiaaw RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1225",
        "hex_opcode": "0x100004C9",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1225",
            "clean": "1225"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evsubfsmiaaw",
      "rel_url": "powerisa/evsubfsmiaaw/",
      "linked_summary": "Complex subtraction accumulate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evsubfssiaaw",
      "architecture": "PowerISA",
      "full_name": "Vector Subtract Signed Saturate Integer Accumulate Accumulate Word",
      "summary": "Complex subtraction saturate accumulate.",
      "syntax": "evsubfssiaaw RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 1227",
        "hex_opcode": "0x100004CB",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1227",
            "clean": "1227"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evsubfssiaaw",
      "rel_url": "powerisa/evsubfssiaaw/",
      "linked_summary": "Complex subtraction saturate accumulate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evsubfw",
      "architecture": "PowerISA",
      "full_name": "Vector Subtract From Word",
      "summary": "Subtracts words (Alternate syntax for evsubw).",
      "syntax": "evsubfw RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 514",
        "hex_opcode": "0x10000202",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "514",
            "clean": "514"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evsubfw",
      "rel_url": "powerisa/evsubfw/",
      "linked_summary": "Subtracts words (Alternate syntax for <a href=\"../../powerisa/evsubw/\">evsubw</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evsubifw",
      "architecture": "PowerISA",
      "full_name": "Vector Subtract Immediate From Word",
      "summary": "Subtracts immediate from word.",
      "syntax": "evsubifw RT, UIM, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | UIM | RB | 515",
        "hex_opcode": "0x10000203",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "515",
            "clean": "515"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "UIM",
          "desc": "Imm"
        },
        {
          "name": "RB",
          "desc": "Src"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evsubifw",
      "rel_url": "powerisa/evsubifw/",
      "linked_summary": "Subtracts immediate from word.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efsadd",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Single Add",
      "summary": "Single precision add (SPE Float).",
      "syntax": "efsadd RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 704",
        "hex_opcode": "0x100002C0",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "704",
            "clean": "704"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efsadd",
      "rel_url": "powerisa/efsadd/",
      "linked_summary": "Single precision <a href=\"../../armv8-a/add_8/\">add</a> (SPE Float).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efssub",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Single Subtract",
      "summary": "Single precision subtract (SPE Float).",
      "syntax": "efssub RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 705",
        "hex_opcode": "0x100002C1",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "705",
            "clean": "705"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efssub",
      "rel_url": "powerisa/efssub/",
      "linked_summary": "Single precision subtract (SPE Float).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efsmul",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Single Multiply",
      "summary": "Single precision multiply (SPE Float).",
      "syntax": "efsmul RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 708",
        "hex_opcode": "0x100002C4",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "708",
            "clean": "708"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efsmul",
      "rel_url": "powerisa/efsmul/",
      "linked_summary": "Single precision multiply (SPE Float).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efsdiv",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Single Divide",
      "summary": "Single precision divide (SPE Float).",
      "syntax": "efsdiv RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 709",
        "hex_opcode": "0x100002C5",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "709",
            "clean": "709"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efsdiv",
      "rel_url": "powerisa/efsdiv/",
      "linked_summary": "Single precision divide (SPE Float).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efdadd",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Double Add",
      "summary": "Double precision add (SPE Float).",
      "syntax": "efdadd RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 736",
        "hex_opcode": "0x100002E0",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "736",
            "clean": "736"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efdadd",
      "rel_url": "powerisa/efdadd/",
      "linked_summary": "Double precision <a href=\"../../armv8-a/add_8/\">add</a> (SPE Float).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efdsub",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Double Subtract",
      "summary": "Double precision subtract (SPE Float).",
      "syntax": "efdsub RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 737",
        "hex_opcode": "0x100002E1",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "737",
            "clean": "737"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efdsub",
      "rel_url": "powerisa/efdsub/",
      "linked_summary": "Double precision subtract (SPE Float).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efdmul",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Double Multiply",
      "summary": "Double precision multiply (SPE Float).",
      "syntax": "efdmul RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 740",
        "hex_opcode": "0x100002E4",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "740",
            "clean": "740"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efdmul",
      "rel_url": "powerisa/efdmul/",
      "linked_summary": "Double precision multiply (SPE Float).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efddiv",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Double Divide",
      "summary": "Double precision divide (SPE Float).",
      "syntax": "efddiv RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 741",
        "hex_opcode": "0x100002E5",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "741",
            "clean": "741"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efddiv",
      "rel_url": "powerisa/efddiv/",
      "linked_summary": "Double precision divide (SPE Float).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efsabs",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Single Absolute Value",
      "summary": "Single precision absolute value.",
      "syntax": "efsabs RT, RA",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | 0 | 712",
        "hex_opcode": "0x100002C8",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "712",
            "clean": "712"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efsabs",
      "rel_url": "powerisa/efsabs/",
      "linked_summary": "Single precision absolute value.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efdabs",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Double Absolute Value",
      "summary": "Double precision absolute value.",
      "syntax": "efdabs RT, RA",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | 0 | 744",
        "hex_opcode": "0x100002E8",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "744",
            "clean": "744"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efdabs",
      "rel_url": "powerisa/efdabs/",
      "linked_summary": "Double precision absolute value.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efsneg",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Single Negate",
      "summary": "Single precision negate.",
      "syntax": "efsneg RT, RA",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | 0 | 713",
        "hex_opcode": "0x100002C9",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "713",
            "clean": "713"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efsneg",
      "rel_url": "powerisa/efsneg/",
      "linked_summary": "Single precision negate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efdneg",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Double Negate",
      "summary": "Double precision negate.",
      "syntax": "efdneg RT, RA",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | 0 | 745",
        "hex_opcode": "0x100002E9",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "745",
            "clean": "745"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efdneg",
      "rel_url": "powerisa/efdneg/",
      "linked_summary": "Double precision negate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efscfsi",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Single Convert From Signed Integer",
      "summary": "Converts vector of signed integers to floats.",
      "syntax": "efscfsi RT, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | 0 | RB | 657",
        "hex_opcode": "0x10000291",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "657",
            "clean": "657"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RB",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (SPE Vector)",
      "slug": "efscfsi",
      "rel_url": "powerisa/efscfsi/",
      "linked_summary": "Converts vector of signed integers to floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efsctsi",
      "architecture": "PowerISA",
      "full_name": "Vector Float Single Convert To Signed Integer",
      "summary": "Converts vector of floats to signed integers.",
      "syntax": "evfsctsi RT, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | 0 | RB | 661",
        "hex_opcode": "0x10000295",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "661",
            "clean": "661"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RB",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (SPE Vector)",
      "slug": "efsctsi",
      "rel_url": "powerisa/efsctsi/",
      "linked_summary": "Converts vector of floats to signed integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "macchw",
      "architecture": "PowerISA",
      "full_name": "Multiply Accumulate Cross Halfword",
      "summary": "Multiply bottom half of RA by top half of RB, add to RT.",
      "syntax": "macchw RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "4 | RT | RA | RB | 172 | 0",
        "hex_opcode": "0x100000AC",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "172",
            "clean": "172"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc/Dest"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (Legacy 4xx)",
      "slug": "macchw",
      "rel_url": "powerisa/macchw/",
      "linked_summary": "Multiply bottom half of RA by top half of RB, <a href=\"../../armv8-a/add_8/\">add</a> to RT.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "macchws",
      "architecture": "PowerISA",
      "full_name": "Multiply Accumulate Cross Halfword Signed",
      "summary": "Signed Multiply Accumulate Cross Halfword with Saturation.",
      "syntax": "macchws RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "4 | RT | RA | RB | 236 | 0",
        "hex_opcode": "0x100000EC",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "236",
            "clean": "236"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc/Dest"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (Legacy 4xx)",
      "slug": "macchws",
      "rel_url": "powerisa/macchws/",
      "linked_summary": "Signed Multiply Accumulate Cross Halfword with Saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "macchwu",
      "architecture": "PowerISA",
      "full_name": "Multiply Accumulate Cross Halfword Unsigned",
      "summary": "Unsigned Multiply Accumulate Cross Halfword.",
      "syntax": "macchwu RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "4 | RT | RA | RB | 12 | 0",
        "hex_opcode": "0x1000000C",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "12",
            "clean": "12"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc/Dest"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (Legacy 4xx)",
      "slug": "macchwu",
      "rel_url": "powerisa/macchwu/",
      "linked_summary": "Unsigned Multiply Accumulate Cross Halfword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "macchwsu",
      "architecture": "PowerISA",
      "full_name": "Multiply Accumulate Cross Halfword Signed Unsigned",
      "summary": "Mixed Sign Multiply Accumulate Cross Halfword with Saturation.",
      "syntax": "macchwsu RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "4 | RT | RA | RB | 204 | 0",
        "hex_opcode": "0x100000CC",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "204",
            "clean": "204"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc/Dest"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (Legacy 4xx)",
      "slug": "macchwsu",
      "rel_url": "powerisa/macchwsu/",
      "linked_summary": "Mixed Sign Multiply Accumulate Cross Halfword with Saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "machhw",
      "architecture": "PowerISA",
      "full_name": "Multiply Accumulate High Halfword",
      "summary": "Multiply top half of RA by top half of RB, add to RT.",
      "syntax": "machhw RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "4 | RT | RA | RB | 44 | 0",
        "hex_opcode": "0x1000002C",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "44",
            "clean": "44"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc/Dest"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (Legacy 4xx)",
      "slug": "machhw",
      "rel_url": "powerisa/machhw/",
      "linked_summary": "Multiply top half of RA by top half of RB, <a href=\"../../armv8-a/add_8/\">add</a> to RT.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "machhws",
      "architecture": "PowerISA",
      "full_name": "Multiply Accumulate High Halfword Signed",
      "summary": "Signed Multiply Accumulate High Halfword with Saturation.",
      "syntax": "machhws RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "4 | RT | RA | RB | 108 | 0",
        "hex_opcode": "0x1000006C",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "108",
            "clean": "108"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc/Dest"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (Legacy 4xx)",
      "slug": "machhws",
      "rel_url": "powerisa/machhws/",
      "linked_summary": "Signed Multiply Accumulate High Halfword with Saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "machhwu",
      "architecture": "PowerISA",
      "full_name": "Multiply Accumulate High Halfword Unsigned",
      "summary": "Unsigned Multiply Accumulate High Halfword.",
      "syntax": "machhwu RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "4 | RT | RA | RB | 12 | 0",
        "hex_opcode": "0x1000000C",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "12",
            "clean": "12"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc/Dest"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (Legacy 4xx)",
      "slug": "machhwu",
      "rel_url": "powerisa/machhwu/",
      "linked_summary": "Unsigned Multiply Accumulate High Halfword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "machhwsu",
      "architecture": "PowerISA",
      "full_name": "Multiply Accumulate High Halfword Signed Unsigned",
      "summary": "Mixed Sign Multiply Accumulate High Halfword with Saturation.",
      "syntax": "machhwsu RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "4 | RT | RA | RB | 76 | 0",
        "hex_opcode": "0x1000004C",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "76",
            "clean": "76"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc/Dest"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (Legacy 4xx)",
      "slug": "machhwsu",
      "rel_url": "powerisa/machhwsu/",
      "linked_summary": "Mixed Sign Multiply Accumulate High Halfword with Saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "maclhw",
      "architecture": "PowerISA",
      "full_name": "Multiply Accumulate Low Halfword",
      "summary": "Multiply bottom half of RA by bottom half of RB, add to RT.",
      "syntax": "maclhw RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "4 | RT | RA | RB | 428 | 0",
        "hex_opcode": "0x100001AC",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "428",
            "clean": "428"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc/Dest"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (Legacy 4xx)",
      "slug": "maclhw",
      "rel_url": "powerisa/maclhw/",
      "linked_summary": "Multiply bottom half of RA by bottom half of RB, <a href=\"../../armv8-a/add_8/\">add</a> to RT.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "maclhws",
      "architecture": "PowerISA",
      "full_name": "Multiply Accumulate Low Halfword Signed",
      "summary": "Signed Multiply Accumulate Low Halfword with Saturation.",
      "syntax": "maclhws RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "4 | RT | RA | RB | 492 | 0",
        "hex_opcode": "0x100001EC",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "492",
            "clean": "492"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc/Dest"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (Legacy 4xx)",
      "slug": "maclhws",
      "rel_url": "powerisa/maclhws/",
      "linked_summary": "Signed Multiply Accumulate Low Halfword with Saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "maclhwu",
      "architecture": "PowerISA",
      "full_name": "Multiply Accumulate Low Halfword Unsigned",
      "summary": "Unsigned Multiply Accumulate Low Halfword.",
      "syntax": "maclhwu RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "4 | RT | RA | RB | 396 | 0",
        "hex_opcode": "0x1000018C",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "396",
            "clean": "396"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc/Dest"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (Legacy 4xx)",
      "slug": "maclhwu",
      "rel_url": "powerisa/maclhwu/",
      "linked_summary": "Unsigned Multiply Accumulate Low Halfword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "maclhwsu",
      "architecture": "PowerISA",
      "full_name": "Multiply Accumulate Low Halfword Signed Unsigned",
      "summary": "Mixed Sign Multiply Accumulate Low Halfword with Saturation.",
      "syntax": "maclhwsu RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "4 | RT | RA | RB | 460 | 0",
        "hex_opcode": "0x100001CC",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "460",
            "clean": "460"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc/Dest"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (Legacy 4xx)",
      "slug": "maclhwsu",
      "rel_url": "powerisa/maclhwsu/",
      "linked_summary": "Mixed Sign Multiply Accumulate Low Halfword with Saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mulchw",
      "architecture": "PowerISA",
      "full_name": "Multiply Cross Halfword",
      "summary": "Multiply bottom half of RA by top half of RB.",
      "syntax": "mulchw RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "4 | RT | RA | RB | 168 | 0",
        "hex_opcode": "0x100000A8",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "168",
            "clean": "168"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (Legacy 4xx)",
      "slug": "mulchw",
      "rel_url": "powerisa/mulchw/",
      "linked_summary": "Multiply bottom half of RA by top half of RB.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mulchwu",
      "architecture": "PowerISA",
      "full_name": "Multiply Cross Halfword Unsigned",
      "summary": "Unsigned Multiply Cross Halfword.",
      "syntax": "mulchwu RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "4 | RT | RA | RB | 136 | 0",
        "hex_opcode": "0x10000088",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "136",
            "clean": "136"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (Legacy 4xx)",
      "slug": "mulchwu",
      "rel_url": "powerisa/mulchwu/",
      "linked_summary": "Unsigned Multiply Cross Halfword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mulhhw",
      "architecture": "PowerISA",
      "full_name": "Multiply High Halfword",
      "summary": "Multiply top half of RA by top half of RB.",
      "syntax": "mulhhw RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "4 | RT | RA | RB | 40 | 0",
        "hex_opcode": "0x10000028",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "40",
            "clean": "40"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (Legacy 4xx)",
      "slug": "mulhhw",
      "rel_url": "powerisa/mulhhw/",
      "linked_summary": "Multiply top half of RA by top half of RB.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mulhhwu",
      "architecture": "PowerISA",
      "full_name": "Multiply High Halfword Unsigned",
      "summary": "Unsigned Multiply High Halfword.",
      "syntax": "mulhhwu RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "4 | RT | RA | RB | 8 | 0",
        "hex_opcode": "0x10000008",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "8",
            "clean": "8"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (Legacy 4xx)",
      "slug": "mulhhwu",
      "rel_url": "powerisa/mulhhwu/",
      "linked_summary": "Unsigned Multiply High Halfword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mullhw",
      "architecture": "PowerISA",
      "full_name": "Multiply Low Halfword",
      "summary": "Multiply bottom half of RA by bottom half of RB.",
      "syntax": "mullhw RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "4 | RT | RA | RB | 424 | 0",
        "hex_opcode": "0x100001A8",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "424",
            "clean": "424"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (Legacy 4xx)",
      "slug": "mullhw",
      "rel_url": "powerisa/mullhw/",
      "linked_summary": "Multiply bottom half of RA by bottom half of RB.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mullhwu",
      "architecture": "PowerISA",
      "full_name": "Multiply Low Halfword Unsigned",
      "summary": "Unsigned Multiply Low Halfword.",
      "syntax": "mullhwu RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "4 | RT | RA | RB | 392 | 0",
        "hex_opcode": "0x10000188",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "392",
            "clean": "392"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (Legacy 4xx)",
      "slug": "mullhwu",
      "rel_url": "powerisa/mullhwu/",
      "linked_summary": "Unsigned Multiply Low Halfword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "nmacchw",
      "architecture": "PowerISA",
      "full_name": "Negative Multiply Accumulate Cross Halfword",
      "summary": "Negate product of cross halfwords and add to accumulator.",
      "syntax": "nmacchw RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "4 | RT | RA | RB | 174 | 0",
        "hex_opcode": "0x100000AE",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "174",
            "clean": "174"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc/Dest"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (Legacy 4xx)",
      "slug": "nmacchw",
      "rel_url": "powerisa/nmacchw/",
      "linked_summary": "Negate product of cross halfwords <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../armv8-a/add_8/\">add</a> to accumulator.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "nmacchws",
      "architecture": "PowerISA",
      "full_name": "Negative Multiply Accumulate Cross Halfword Signed",
      "summary": "Negate product of cross halfwords and add to accumulator (Signed Saturation).",
      "syntax": "nmacchws RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "4 | RT | RA | RB | 238 | 0",
        "hex_opcode": "0x100000EE",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "238",
            "clean": "238"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc/Dest"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (Legacy 4xx)",
      "slug": "nmacchws",
      "rel_url": "powerisa/nmacchws/",
      "linked_summary": "Negate product of cross halfwords <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../armv8-a/add_8/\">add</a> to accumulator (Signed Saturation).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "nmachhw",
      "architecture": "PowerISA",
      "full_name": "Negative Multiply Accumulate High Halfword",
      "summary": "Negate product of high halfwords and add to accumulator.",
      "syntax": "nmachhw RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "4 | RT | RA | RB | 46 | 0",
        "hex_opcode": "0x1000002E",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "46",
            "clean": "46"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc/Dest"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (Legacy 4xx)",
      "slug": "nmachhw",
      "rel_url": "powerisa/nmachhw/",
      "linked_summary": "Negate product of high halfwords <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../armv8-a/add_8/\">add</a> to accumulator.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "nmachhws",
      "architecture": "PowerISA",
      "full_name": "Negative Multiply Accumulate High Halfword Signed",
      "summary": "Negate product of high halfwords and add to accumulator (Signed Saturation).",
      "syntax": "nmachhws RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "4 | RT | RA | RB | 110 | 0",
        "hex_opcode": "0x1000006E",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "110",
            "clean": "110"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc/Dest"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (Legacy 4xx)",
      "slug": "nmachhws",
      "rel_url": "powerisa/nmachhws/",
      "linked_summary": "Negate product of high halfwords <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../armv8-a/add_8/\">add</a> to accumulator (Signed Saturation).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "nmaclhw",
      "architecture": "PowerISA",
      "full_name": "Negative Multiply Accumulate Low Halfword",
      "summary": "Negate product of low halfwords and add to accumulator.",
      "syntax": "nmaclhw RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "4 | RT | RA | RB | 430 | 0",
        "hex_opcode": "0x100001AE",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "430",
            "clean": "430"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc/Dest"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (Legacy 4xx)",
      "slug": "nmaclhw",
      "rel_url": "powerisa/nmaclhw/",
      "linked_summary": "Negate product of low halfwords <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../armv8-a/add_8/\">add</a> to accumulator.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "nmaclhws",
      "architecture": "PowerISA",
      "full_name": "Negative Multiply Accumulate Low Halfword Signed",
      "summary": "Negate product of low halfwords and add to accumulator (Signed Saturation).",
      "syntax": "nmaclhws RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "4 | RT | RA | RB | 494 | 0",
        "hex_opcode": "0x100001EE",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "494",
            "clean": "494"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Acc/Dest"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (Legacy 4xx)",
      "slug": "nmaclhws",
      "rel_url": "powerisa/nmaclhws/",
      "linked_summary": "Negate product of low halfwords <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../armv8-a/add_8/\">add</a> to accumulator (Signed Saturation).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dccci",
      "architecture": "PowerISA",
      "full_name": "Data Cache Congruence Class Invalidate",
      "summary": "Invalidates a congruence class in the data cache (Embedded).",
      "syntax": "dccci RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | RA | RB | 454 | /",
        "hex_opcode": "0x7C00038E",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "454",
            "clean": "454"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Embedded (Cache)",
      "slug": "dccci",
      "rel_url": "powerisa/dccci/",
      "linked_summary": "Invalidates a congruence class <a href=\"../../x86/in/\">in</a> the data cache (Embedded).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dcread",
      "architecture": "PowerISA",
      "full_name": "Data Cache Read",
      "summary": "Reads a data cache tag or data (Debug).",
      "syntax": "dcread RT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | RA | RB | 486 | /",
        "hex_opcode": "0x7C0003CE",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "486",
            "clean": "486"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Embedded (Cache)",
      "slug": "dcread",
      "rel_url": "powerisa/dcread/",
      "linked_summary": "Reads a data cache tag <a href=\"../../powerisa/or/\">or</a> data (Debug).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "iccci",
      "architecture": "PowerISA",
      "full_name": "Instruction Cache Congruence Class Invalidate",
      "summary": "Invalidates a congruence class in the instruction cache (Embedded).",
      "syntax": "iccci RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | RA | RB | 966 | /",
        "hex_opcode": "0x7C00078E",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "966",
            "clean": "966"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Embedded (Cache)",
      "slug": "iccci",
      "rel_url": "powerisa/iccci/",
      "linked_summary": "Invalidates a congruence class <a href=\"../../x86/in/\">in</a> the instruction cache (Embedded).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "icread",
      "architecture": "PowerISA",
      "full_name": "Instruction Cache Read",
      "summary": "Reads an instruction cache tag or data (Debug).",
      "syntax": "icread RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | RA | RB | 998 | /",
        "hex_opcode": "0x7C0007CE",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "998",
            "clean": "998"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Embedded (Cache)",
      "slug": "icread",
      "rel_url": "powerisa/icread/",
      "linked_summary": "Reads an instruction cache tag <a href=\"../../powerisa/or/\">or</a> data (Debug).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tlbre",
      "architecture": "PowerISA",
      "full_name": "TLB Read Entry",
      "summary": "Reads a TLB entry into MAS registers.",
      "syntax": "tlbre",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | / | / | 946 | /",
        "hex_opcode": "0x7C000762",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "946",
            "clean": "946"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [],
      "extension": "Embedded (TLB)",
      "slug": "tlbre",
      "rel_url": "powerisa/tlbre/",
      "linked_summary": "Reads a TLB entry into MAS registers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tlbwe",
      "architecture": "PowerISA",
      "full_name": "TLB Write Entry",
      "summary": "Writes a TLB entry from MAS registers.",
      "syntax": "tlbwe",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | / | / | 978 | /",
        "hex_opcode": "0x7C0007A2",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "978",
            "clean": "978"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [],
      "extension": "Embedded (TLB)",
      "slug": "tlbwe",
      "rel_url": "powerisa/tlbwe/",
      "linked_summary": "Writes a TLB entry from MAS registers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tlbsx",
      "architecture": "PowerISA",
      "full_name": "TLB Search Indexed",
      "summary": "Searches the TLB for an address.",
      "syntax": "tlbsx RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | RA | RB | 914 | /",
        "hex_opcode": "0x7C000722",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "914",
            "clean": "914"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Embedded (TLB)",
      "slug": "tlbsx",
      "rel_url": "powerisa/tlbsx/",
      "linked_summary": "Searches the TLB for an address.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tlbivax",
      "architecture": "PowerISA",
      "full_name": "TLB Invalidate Virtual Address Indexed",
      "summary": "Invalidates a TLB entry by virtual address.",
      "syntax": "tlbivax RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | RA | RB | 786 | /",
        "hex_opcode": "0x7C000622",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "786",
            "clean": "786"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Embedded (TLB)",
      "slug": "tlbivax",
      "rel_url": "powerisa/tlbivax/",
      "linked_summary": "Invalidates a TLB entry by virtual address.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "wrtee",
      "architecture": "PowerISA",
      "full_name": "Write MSR External Enable",
      "summary": "Updates the EE bit of the MSR from a GPR.",
      "syntax": "wrtee RS",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | / | / | 131 | /",
        "hex_opcode": "0x7C000106",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "131",
            "clean": "131"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (Control)",
      "slug": "wrtee",
      "rel_url": "powerisa/wrtee/",
      "linked_summary": "Updates the EE <a href=\"../../armv8-a/bit/\">bit</a> of the MSR from a GPR.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "wrteei",
      "architecture": "PowerISA",
      "full_name": "Write MSR External Enable Immediate",
      "summary": "Updates the EE bit of the MSR from an immediate.",
      "syntax": "wrteei E",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | / | E | 163 | /",
        "hex_opcode": "0x7C000146",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "E",
            "clean": "E"
          },
          {
            "raw": "163",
            "clean": "163"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "E",
          "desc": "Enable (0/1)"
        }
      ],
      "extension": "Embedded (Control)",
      "slug": "wrteei",
      "rel_url": "powerisa/wrteei/",
      "linked_summary": "Updates the EE <a href=\"../../armv8-a/bit/\">bit</a> of the MSR from an immediate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mfdcr",
      "architecture": "PowerISA",
      "full_name": "Move From Device Control Register",
      "summary": "Reads an on-chip peripheral register (DCR).",
      "syntax": "mfdcr RT, DCRN",
      "encoding": {
        "format": "XFX-form",
        "binary_pattern": "31 | RT | DCRN | 323",
        "hex_opcode": "0x7C000286",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "DCRN",
            "clean": "DCRN"
          },
          {
            "raw": "323",
            "clean": "323"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "DCRN",
          "desc": "DCR Number"
        }
      ],
      "extension": "Embedded (Device)",
      "slug": "mfdcr",
      "rel_url": "powerisa/mfdcr/",
      "linked_summary": "Reads an on-chip peripheral register (DCR).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mtdcr",
      "architecture": "PowerISA",
      "full_name": "Move To Device Control Register",
      "summary": "Writes an on-chip peripheral register (DCR).",
      "syntax": "mtdcr DCRN, RS",
      "encoding": {
        "format": "XFX-form",
        "binary_pattern": "31 | RS | DCRN | 451",
        "hex_opcode": "0x7C000386",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "DCRN",
            "clean": "DCRN"
          },
          {
            "raw": "451",
            "clean": "451"
          }
        ]
      },
      "operands": [
        {
          "name": "DCRN",
          "desc": "DCR Number"
        },
        {
          "name": "RS",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (Device)",
      "slug": "mtdcr",
      "rel_url": "powerisa/mtdcr/",
      "linked_summary": "Writes an on-chip peripheral register (DCR).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efscmpeq",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Single Compare Equal",
      "summary": "Single precision compare equal.",
      "syntax": "efscmpeq BF, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | BF | RA | RB | 716",
        "hex_opcode": "0x100002CC",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "716",
            "clean": "716"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efscmpeq",
      "rel_url": "powerisa/efscmpeq/",
      "linked_summary": "Single precision compare equal.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efdcmpeq",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Double Compare Equal",
      "summary": "Double precision compare equal.",
      "syntax": "efdcmpeq BF, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | BF | RA | RB | 748",
        "hex_opcode": "0x100002EC",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "748",
            "clean": "748"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efdcmpeq",
      "rel_url": "powerisa/efdcmpeq/",
      "linked_summary": "Double precision compare equal.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efscmpgt",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Single Compare Greater Than",
      "summary": "Single precision compare greater than.",
      "syntax": "efscmpgt BF, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | BF | RA | RB | 717",
        "hex_opcode": "0x100002CD",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "717",
            "clean": "717"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efscmpgt",
      "rel_url": "powerisa/efscmpgt/",
      "linked_summary": "Single precision compare greater than.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efdcmpgt",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Double Compare Greater Than",
      "summary": "Double precision compare greater than.",
      "syntax": "efdcmpgt BF, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | BF | RA | RB | 749",
        "hex_opcode": "0x100002ED",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "749",
            "clean": "749"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efdcmpgt",
      "rel_url": "powerisa/efdcmpgt/",
      "linked_summary": "Double precision compare greater than.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efscmplt",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Single Compare Less Than",
      "summary": "Single precision compare less than.",
      "syntax": "efscmplt BF, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | BF | RA | RB | 718",
        "hex_opcode": "0x100002CE",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "718",
            "clean": "718"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efscmplt",
      "rel_url": "powerisa/efscmplt/",
      "linked_summary": "Single precision compare less than.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efdcmplt",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Double Compare Less Than",
      "summary": "Double precision compare less than.",
      "syntax": "efdcmplt BF, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | BF | RA | RB | 750",
        "hex_opcode": "0x100002EE",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "750",
            "clean": "750"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efdcmplt",
      "rel_url": "powerisa/efdcmplt/",
      "linked_summary": "Double precision compare less than.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "darn",
      "architecture": "PowerISA",
      "full_name": "Deliver A Random Number",
      "summary": "Returns a random number from the hardware RNG. (L=3: Raw, L=1: Conditioned, L=0: 32-bit).",
      "syntax": "darn RT, L",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | / | L | 755 | /",
        "hex_opcode": "0x7C0005E6",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "L",
            "clean": "L"
          },
          {
            "raw": "755",
            "clean": "755"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "L",
          "desc": "Mode"
        }
      ],
      "extension": "Base",
      "slug": "darn",
      "rel_url": "powerisa/darn/",
      "linked_summary": "Returns a random number from the hardware RNG. (L=3: Raw, L=1: Conditioned, L=0: 32-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mffs",
      "architecture": "PowerISA",
      "full_name": "Move From FPSCR",
      "summary": "Copies the Floating-Point Status and Control Register to a float register.",
      "syntax": "mffs FRT",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | FRT | 0 | 0 | 583 | /",
        "hex_opcode": "0xFC00048E",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "583",
            "clean": "583"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        }
      ],
      "extension": "Float",
      "slug": "mffs",
      "rel_url": "powerisa/mffs/",
      "linked_summary": "Copies the Floating-Point Status <a href=\"../../armv8-a/and_6/\">and</a> Control Register to a float register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mtfsf",
      "architecture": "PowerISA",
      "full_name": "Move To FPSCR Fields",
      "summary": "Writes fields of the FPSCR from a float register.",
      "syntax": "mtfsf FLM, FRB, W, L",
      "encoding": {
        "format": "XFL-form",
        "binary_pattern": "63 | L | FLM | W | FRB | 711 | /",
        "hex_opcode": "0xFC00058E",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "L",
            "clean": "L"
          },
          {
            "raw": "FLM",
            "clean": "FLM"
          },
          {
            "raw": "W",
            "clean": "W"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "711",
            "clean": "711"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FLM",
          "desc": "Field Mask"
        },
        {
          "name": "FRB",
          "desc": "Source"
        }
      ],
      "extension": "Float",
      "slug": "mtfsf",
      "rel_url": "powerisa/mtfsf/",
      "linked_summary": "Writes fields of the FPSCR from a float register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mtfsfi",
      "architecture": "PowerISA",
      "full_name": "Move To FPSCR Field Immediate",
      "summary": "Writes a 4-bit immediate to a specific FPSCR field.",
      "syntax": "mtfsfi BF, U",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | BF | / | U | 134 | /",
        "hex_opcode": "0xFC00010E",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "U",
            "clean": "U"
          },
          {
            "raw": "134",
            "clean": "134"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "Field Index"
        },
        {
          "name": "U",
          "desc": "Immediate"
        }
      ],
      "extension": "Float",
      "slug": "mtfsfi",
      "rel_url": "powerisa/mtfsfi/",
      "linked_summary": "Writes a 4-<a href=\"../../armv8-a/bit/\">bit</a> immediate to a specific FPSCR field.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mtfsb0",
      "architecture": "PowerISA",
      "full_name": "Move To FPSCR Bit 0",
      "summary": "Clears a specific bit in the FPSCR.",
      "syntax": "mtfsb0 BT",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | BT | / | / | 70 | /",
        "hex_opcode": "0xFC00008C",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "BT",
            "clean": "BT"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "70",
            "clean": "70"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "BT",
          "desc": "Bit Index"
        }
      ],
      "extension": "Float",
      "slug": "mtfsb0",
      "rel_url": "powerisa/mtfsb0/",
      "linked_summary": "Clears a specific <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> the FPSCR.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mtfsb1",
      "architecture": "PowerISA",
      "full_name": "Move To FPSCR Bit 1",
      "summary": "Sets a specific bit in the FPSCR.",
      "syntax": "mtfsb1 BT",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | BT | / | / | 38 | /",
        "hex_opcode": "0xFC00004C",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "BT",
            "clean": "BT"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "38",
            "clean": "38"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "BT",
          "desc": "Bit Index"
        }
      ],
      "extension": "Float",
      "slug": "mtfsb1",
      "rel_url": "powerisa/mtfsb1/",
      "linked_summary": "Sets a specific <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> the FPSCR.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "hrfid",
      "architecture": "PowerISA",
      "full_name": "Hypervisor Return From Interrupt Doubleword",
      "summary": "Returns from a hypervisor interrupt.",
      "syntax": "hrfid",
      "encoding": {
        "format": "XL-form",
        "binary_pattern": "19 | / | / | / | 274 | /",
        "hex_opcode": "0x4C000224",
        "visual_parts": [
          {
            "raw": "19",
            "clean": "19"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "274",
            "clean": "274"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [],
      "extension": "Privileged",
      "slug": "hrfid",
      "rel_url": "powerisa/hrfid/",
      "linked_summary": "Returns from a hypervisor interrupt.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "copy",
      "architecture": "PowerISA",
      "full_name": "Copy",
      "summary": "Initiates a hardware copy (accelerator) operation.",
      "syntax": "copy RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | RA | RB | 706 | /",
        "hex_opcode": "0x7C000584",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "706",
            "clean": "706"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Dest/Control"
        },
        {
          "name": "RB",
          "desc": "Source"
        }
      ],
      "extension": "Privileged",
      "slug": "copy",
      "rel_url": "powerisa/copy/",
      "linked_summary": "Initiates a hardware <a href=\"../../powerisa/copy/\">copy</a> (accelerator) operation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "paste",
      "architecture": "PowerISA",
      "full_name": "Paste",
      "summary": "Completes a hardware copy (paste) operation.",
      "syntax": "paste RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | RA | RB | 770 | /",
        "hex_opcode": "0x7C000604",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "770",
            "clean": "770"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Dest"
        },
        {
          "name": "RB",
          "desc": "Control"
        }
      ],
      "extension": "Privileged",
      "slug": "paste",
      "rel_url": "powerisa/paste/",
      "linked_summary": "Completes a hardware <a href=\"../../powerisa/copy/\">copy</a> (<a href=\"../../powerisa/paste/\">paste</a>) operation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vclzb",
      "architecture": "PowerISA",
      "full_name": "Vector Count Leading Zeros Byte",
      "summary": "Counts leading zeros in each byte.",
      "syntax": "vclzb vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1794",
        "hex_opcode": "0x10000702",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1794",
            "clean": "1794"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VMX",
      "slug": "vclzb",
      "rel_url": "powerisa/vclzb/",
      "linked_summary": "Counts leading zeros <a href=\"../../x86/in/\">in</a> each byte.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vclzh",
      "architecture": "PowerISA",
      "full_name": "Vector Count Leading Zeros Halfword",
      "summary": "Counts leading zeros in each halfword.",
      "syntax": "vclzh vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1858",
        "hex_opcode": "0x10000742",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1858",
            "clean": "1858"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VMX",
      "slug": "vclzh",
      "rel_url": "powerisa/vclzh/",
      "linked_summary": "Counts leading zeros <a href=\"../../x86/in/\">in</a> each halfword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vclzw",
      "architecture": "PowerISA",
      "full_name": "Vector Count Leading Zeros Word",
      "summary": "Counts leading zeros in each word.",
      "syntax": "vclzw vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1922",
        "hex_opcode": "0x10000782",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1922",
            "clean": "1922"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VMX",
      "slug": "vclzw",
      "rel_url": "powerisa/vclzw/",
      "linked_summary": "Counts leading zeros <a href=\"../../x86/in/\">in</a> each word.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vclzd",
      "architecture": "PowerISA",
      "full_name": "Vector Count Leading Zeros Doubleword",
      "summary": "Counts leading zeros in each doubleword.",
      "syntax": "vclzd vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1986",
        "hex_opcode": "0x100007C2",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1986",
            "clean": "1986"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VMX",
      "slug": "vclzd",
      "rel_url": "powerisa/vclzd/",
      "linked_summary": "Counts leading zeros <a href=\"../../x86/in/\">in</a> each doubleword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vctzb",
      "architecture": "PowerISA",
      "full_name": "Vector Count Trailing Zeros Byte",
      "summary": "Counts trailing zeros in each byte.",
      "syntax": "vctzb vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1794",
        "hex_opcode": "0x10000702",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1794",
            "clean": "1794"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VMX",
      "slug": "vctzb",
      "rel_url": "powerisa/vctzb/",
      "linked_summary": "Counts trailing zeros <a href=\"../../x86/in/\">in</a> each byte.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vctzh",
      "architecture": "PowerISA",
      "full_name": "Vector Count Trailing Zeros Halfword",
      "summary": "Counts trailing zeros in each halfword.",
      "syntax": "vctzh vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1858",
        "hex_opcode": "0x10000742",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1858",
            "clean": "1858"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VMX",
      "slug": "vctzh",
      "rel_url": "powerisa/vctzh/",
      "linked_summary": "Counts trailing zeros <a href=\"../../x86/in/\">in</a> each halfword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vctzw",
      "architecture": "PowerISA",
      "full_name": "Vector Count Trailing Zeros Word",
      "summary": "Counts trailing zeros in each word.",
      "syntax": "vctzw vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1922",
        "hex_opcode": "0x10000782",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1922",
            "clean": "1922"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VMX",
      "slug": "vctzw",
      "rel_url": "powerisa/vctzw/",
      "linked_summary": "Counts trailing zeros <a href=\"../../x86/in/\">in</a> each word.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vctzd",
      "architecture": "PowerISA",
      "full_name": "Vector Count Trailing Zeros Doubleword",
      "summary": "Counts trailing zeros in each doubleword.",
      "syntax": "vctzd vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1986",
        "hex_opcode": "0x100007C2",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1986",
            "clean": "1986"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VMX",
      "slug": "vctzd",
      "rel_url": "powerisa/vctzd/",
      "linked_summary": "Counts trailing zeros <a href=\"../../x86/in/\">in</a> each doubleword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpopcntb",
      "architecture": "PowerISA",
      "full_name": "Vector Population Count Byte",
      "summary": "Counts set bits in each byte.",
      "syntax": "vpopcntb vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1795",
        "hex_opcode": "0x10000703",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1795",
            "clean": "1795"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VMX",
      "slug": "vpopcntb",
      "rel_url": "powerisa/vpopcntb/",
      "linked_summary": "Counts set bits <a href=\"../../x86/in/\">in</a> each byte.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpopcnth",
      "architecture": "PowerISA",
      "full_name": "Vector Population Count Halfword",
      "summary": "Counts set bits in each halfword.",
      "syntax": "vpopcnth vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1859",
        "hex_opcode": "0x10000743",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1859",
            "clean": "1859"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VMX",
      "slug": "vpopcnth",
      "rel_url": "powerisa/vpopcnth/",
      "linked_summary": "Counts set bits <a href=\"../../x86/in/\">in</a> each halfword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpopcntw",
      "architecture": "PowerISA",
      "full_name": "Vector Population Count Word",
      "summary": "Counts set bits in each word.",
      "syntax": "vpopcntw vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1923",
        "hex_opcode": "0x10000783",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1923",
            "clean": "1923"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VMX",
      "slug": "vpopcntw",
      "rel_url": "powerisa/vpopcntw/",
      "linked_summary": "Counts set bits <a href=\"../../x86/in/\">in</a> each word.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpopcntd",
      "architecture": "PowerISA",
      "full_name": "Vector Population Count Doubleword",
      "summary": "Counts set bits in each doubleword.",
      "syntax": "vpopcntd vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1987",
        "hex_opcode": "0x100007C3",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1987",
            "clean": "1987"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VMX",
      "slug": "vpopcntd",
      "rel_url": "powerisa/vpopcntd/",
      "linked_summary": "Counts set bits <a href=\"../../x86/in/\">in</a> each doubleword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vextractub",
      "architecture": "PowerISA",
      "full_name": "Vector Extract Unsigned Byte",
      "summary": "Extracts a specific byte from a vector into a GPR.",
      "syntax": "vextractub RA, vB, UIM",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | RA | UIM | vB | 525",
        "hex_opcode": "0x1000020D",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "525",
            "clean": "525"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target GPR"
        },
        {
          "name": "vB",
          "desc": "Source Vector"
        },
        {
          "name": "UIM",
          "desc": "Index"
        }
      ],
      "extension": "VMX",
      "slug": "vextractub",
      "rel_url": "powerisa/vextractub/",
      "linked_summary": "Extracts a specific byte from a vector into a GPR.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vextractuh",
      "architecture": "PowerISA",
      "full_name": "Vector Extract Unsigned Halfword",
      "summary": "Extracts a halfword from a vector into a GPR.",
      "syntax": "vextractuh RA, vB, UIM",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | RA | UIM | vB | 589",
        "hex_opcode": "0x1000024D",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "589",
            "clean": "589"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target GPR"
        },
        {
          "name": "vB",
          "desc": "Source Vector"
        },
        {
          "name": "UIM",
          "desc": "Index"
        }
      ],
      "extension": "VMX",
      "slug": "vextractuh",
      "rel_url": "powerisa/vextractuh/",
      "linked_summary": "Extracts a halfword from a vector into a GPR.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vextractuw",
      "architecture": "PowerISA",
      "full_name": "Vector Extract Unsigned Word",
      "summary": "Extracts a word from a vector into a GPR.",
      "syntax": "vextractuw RA, vB, UIM",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | RA | UIM | vB | 653",
        "hex_opcode": "0x1000028D",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "653",
            "clean": "653"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target GPR"
        },
        {
          "name": "vB",
          "desc": "Source Vector"
        },
        {
          "name": "UIM",
          "desc": "Index"
        }
      ],
      "extension": "VMX",
      "slug": "vextractuw",
      "rel_url": "powerisa/vextractuw/",
      "linked_summary": "Extracts a word from a vector into a GPR.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vextractd",
      "architecture": "PowerISA",
      "full_name": "Vector Extract Doubleword",
      "summary": "Extracts a doubleword from a vector into a GPR.",
      "syntax": "vextractd RA, vB, UIM",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | RA | UIM | vB | 717",
        "hex_opcode": "0x100002CD",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "717",
            "clean": "717"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target GPR"
        },
        {
          "name": "vB",
          "desc": "Source Vector"
        },
        {
          "name": "UIM",
          "desc": "Index"
        }
      ],
      "extension": "VMX",
      "slug": "vextractd",
      "rel_url": "powerisa/vextractd/",
      "linked_summary": "Extracts a doubleword from a vector into a GPR.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vinsertb",
      "architecture": "PowerISA",
      "full_name": "Vector Insert Byte",
      "summary": "Inserts a byte from a GPR into a vector.",
      "syntax": "vinsertb vD, vB, UIM",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | UIM | vB | 781",
        "hex_opcode": "0x1000030D",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "781",
            "clean": "781"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target Vector"
        },
        {
          "name": "vB",
          "desc": "Source GPR"
        },
        {
          "name": "UIM",
          "desc": "Index"
        }
      ],
      "extension": "VMX",
      "slug": "vinsertb",
      "rel_url": "powerisa/vinsertb/",
      "linked_summary": "Inserts a byte from a GPR into a vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vinserth",
      "architecture": "PowerISA",
      "full_name": "Vector Insert Halfword",
      "summary": "Inserts a halfword from a GPR into a vector.",
      "syntax": "vinserth vD, vB, UIM",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | UIM | vB | 845",
        "hex_opcode": "0x1000034D",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "845",
            "clean": "845"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target Vector"
        },
        {
          "name": "vB",
          "desc": "Source GPR"
        },
        {
          "name": "UIM",
          "desc": "Index"
        }
      ],
      "extension": "VMX",
      "slug": "vinserth",
      "rel_url": "powerisa/vinserth/",
      "linked_summary": "Inserts a halfword from a GPR into a vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vinsertw",
      "architecture": "PowerISA",
      "full_name": "Vector Insert Word",
      "summary": "Inserts a word from a GPR into a vector.",
      "syntax": "vinsertw vD, vB, UIM",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | UIM | vB | 909",
        "hex_opcode": "0x1000038D",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "909",
            "clean": "909"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target Vector"
        },
        {
          "name": "vB",
          "desc": "Source GPR"
        },
        {
          "name": "UIM",
          "desc": "Index"
        }
      ],
      "extension": "VMX",
      "slug": "vinsertw",
      "rel_url": "powerisa/vinsertw/",
      "linked_summary": "Inserts a word from a GPR into a vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vinsertd",
      "architecture": "PowerISA",
      "full_name": "Vector Insert Doubleword",
      "summary": "Inserts a doubleword from a GPR into a vector.",
      "syntax": "vinsertd vD, vB, UIM",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | UIM | vB | 973",
        "hex_opcode": "0x100003CD",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "973",
            "clean": "973"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target Vector"
        },
        {
          "name": "vB",
          "desc": "Source GPR"
        },
        {
          "name": "UIM",
          "desc": "Index"
        }
      ],
      "extension": "VMX",
      "slug": "vinsertd",
      "rel_url": "powerisa/vinsertd/",
      "linked_summary": "Inserts a doubleword from a GPR into a vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vaddcuw",
      "architecture": "PowerISA",
      "full_name": "Vector Add Carryout Unsigned Word",
      "summary": "Calculates carry-out for word addition.",
      "syntax": "vaddcuw vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 384",
        "hex_opcode": "0x10000180",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "384",
            "clean": "384"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX",
      "slug": "vaddcuw",
      "rel_url": "powerisa/vaddcuw/",
      "linked_summary": "Calculates carry-<a href=\"../../x86/out/\">out</a> for word addition.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vaddcuq",
      "architecture": "PowerISA",
      "full_name": "Vector Add Carryout Unsigned Quadword",
      "summary": "Calculates carry-out for quadword addition.",
      "syntax": "vaddcuq vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1280",
        "hex_opcode": "0x10000500",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1280",
            "clean": "1280"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX",
      "slug": "vaddcuq",
      "rel_url": "powerisa/vaddcuq/",
      "linked_summary": "Calculates carry-<a href=\"../../x86/out/\">out</a> for quadword addition.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsubcuw",
      "architecture": "PowerISA",
      "full_name": "Vector Subtract Carryout Unsigned Word",
      "summary": "Calculates carry-out for word subtraction.",
      "syntax": "vsubcuw vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1408",
        "hex_opcode": "0x10000580",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1408",
            "clean": "1408"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX",
      "slug": "vsubcuw",
      "rel_url": "powerisa/vsubcuw/",
      "linked_summary": "Calculates carry-<a href=\"../../x86/out/\">out</a> for word subtraction.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsubcuq",
      "architecture": "PowerISA",
      "full_name": "Vector Subtract Carryout Unsigned Quadword",
      "summary": "Calculates carry-out for quadword subtraction.",
      "syntax": "vsubcuq vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1280",
        "hex_opcode": "0x10000500",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1280",
            "clean": "1280"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX",
      "slug": "vsubcuq",
      "rel_url": "powerisa/vsubcuq/",
      "linked_summary": "Calculates carry-<a href=\"../../x86/out/\">out</a> for quadword subtraction.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vprtybw",
      "architecture": "PowerISA",
      "full_name": "Vector Parity Byte Word",
      "summary": "Computes parity of bytes within words.",
      "syntax": "vprtybw vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1540",
        "hex_opcode": "0x10000604",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1540",
            "clean": "1540"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VMX",
      "slug": "vprtybw",
      "rel_url": "powerisa/vprtybw/",
      "linked_summary": "Computes parity of bytes within words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vprtybd",
      "architecture": "PowerISA",
      "full_name": "Vector Parity Byte Doubleword",
      "summary": "Computes parity of bytes within doublewords.",
      "syntax": "vprtybd vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1604",
        "hex_opcode": "0x10000644",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1604",
            "clean": "1604"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VMX",
      "slug": "vprtybd",
      "rel_url": "powerisa/vprtybd/",
      "linked_summary": "Computes parity of bytes within doublewords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vprtybq",
      "architecture": "PowerISA",
      "full_name": "Vector Parity Byte Quadword",
      "summary": "Computes parity of bytes within quadword.",
      "syntax": "vprtybq vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1668",
        "hex_opcode": "0x10000684",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1668",
            "clean": "1668"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VMX",
      "slug": "vprtybq",
      "rel_url": "powerisa/vprtybq/",
      "linked_summary": "Computes parity of bytes within quadword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vbcdadd",
      "architecture": "PowerISA",
      "full_name": "Vector BCD Add",
      "summary": "Adds two BCD (Binary Coded Decimal) vectors.",
      "syntax": "vbcdadd vD, vA, vB, PS",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1",
        "hex_opcode": "0x10000001",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1",
            "clean": "1"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        },
        {
          "name": "PS",
          "desc": "Sign"
        }
      ],
      "extension": "Vector Crypto",
      "slug": "vbcdadd",
      "rel_url": "powerisa/vbcdadd/",
      "linked_summary": "Adds two BCD (Binary Coded Decimal) vectors.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vbcdsub",
      "architecture": "PowerISA",
      "full_name": "Vector BCD Subtract",
      "summary": "Subtracts two BCD vectors.",
      "syntax": "vbcdsub vD, vA, vB, PS",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 65",
        "hex_opcode": "0x10000041",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "65",
            "clean": "65"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        },
        {
          "name": "PS",
          "desc": "Sign"
        }
      ],
      "extension": "Vector Crypto",
      "slug": "vbcdsub",
      "rel_url": "powerisa/vbcdsub/",
      "linked_summary": "Subtracts two BCD vectors.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dtstsfi",
      "architecture": "PowerISA",
      "full_name": "Decimal Test Significance Immediate",
      "summary": "Tests DFP significance (number of digits).",
      "syntax": "dtstsfi BF, U, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "59 | BF | / | U | FRB | 675",
        "hex_opcode": "0xEC000543",
        "visual_parts": [
          {
            "raw": "59",
            "clean": "59"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "U",
            "clean": "U"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "675",
            "clean": "675"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "U",
          "desc": "Imm"
        },
        {
          "name": "FRB",
          "desc": "Source"
        }
      ],
      "extension": "Decimal Float",
      "slug": "dtstsfi",
      "rel_url": "powerisa/dtstsfi/",
      "linked_summary": "Tests DFP significance (number of digits).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dtstsfiq",
      "architecture": "PowerISA",
      "full_name": "Decimal Test Significance Immediate Quad",
      "summary": "Tests DFP Quad significance.",
      "syntax": "dtstsfiq BF, U, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | BF | / | U | FRB | 675",
        "hex_opcode": "0xFC000543",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "U",
            "clean": "U"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "675",
            "clean": "675"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "U",
          "desc": "Imm"
        },
        {
          "name": "FRB",
          "desc": "Source"
        }
      ],
      "extension": "Decimal Float",
      "slug": "dtstsfiq",
      "rel_url": "powerisa/dtstsfiq/",
      "linked_summary": "Tests DFP Quad significance.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmpeqb",
      "architecture": "PowerISA",
      "full_name": "Compare Equal Byte",
      "summary": "Compares bytes in two GPRs for equality (Scalar).",
      "syntax": "cmpeqb RA, RS, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 224 | /",
        "hex_opcode": "0x7C0000E0",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "224",
            "clean": "224"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target GPR"
        },
        {
          "name": "RS",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Base",
      "slug": "cmpeqb",
      "rel_url": "powerisa/cmpeqb/",
      "linked_summary": "Compares bytes <a href=\"../../x86/in/\">in</a> two GPRs for equality (Scalar).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmpb",
      "architecture": "PowerISA",
      "full_name": "Compare Bytes",
      "summary": "Compares bytes in two GPRs, result is byte mask.",
      "syntax": "cmpb RA, RS, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 508 | /",
        "hex_opcode": "0x7C0003F8",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "508",
            "clean": "508"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target GPR"
        },
        {
          "name": "RS",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Base",
      "slug": "cmpb",
      "rel_url": "powerisa/cmpb/",
      "linked_summary": "Compares bytes <a href=\"../../x86/in/\">in</a> two GPRs, result is byte mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "prtyw",
      "architecture": "PowerISA",
      "full_name": "Parity Word",
      "summary": "Calculates parity of a word (Scalar).",
      "syntax": "prtyw RA, RS",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | / | 154 | /",
        "hex_opcode": "0x7C000128",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "154",
            "clean": "154"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Source"
        }
      ],
      "extension": "Base",
      "slug": "prtyw",
      "rel_url": "powerisa/prtyw/",
      "linked_summary": "Calculates parity of a word (Scalar).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "prtyd",
      "architecture": "PowerISA",
      "full_name": "Parity Doubleword",
      "summary": "Calculates parity of a doubleword (Scalar).",
      "syntax": "prtyd RA, RS",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | / | 186 | /",
        "hex_opcode": "0x7C000174",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "186",
            "clean": "186"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Source"
        }
      ],
      "extension": "Base",
      "slug": "prtyd",
      "rel_url": "powerisa/prtyd/",
      "linked_summary": "Calculates parity of a doubleword (Scalar).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "modsw",
      "architecture": "PowerISA",
      "full_name": "Modulo Signed Word",
      "summary": "Calculates remainder of signed word division.",
      "syntax": "modsw RT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | RA | RB | 779 | /",
        "hex_opcode": "0x7C000616",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "779",
            "clean": "779"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Dividend"
        },
        {
          "name": "RB",
          "desc": "Divisor"
        }
      ],
      "extension": "Base",
      "slug": "modsw",
      "rel_url": "powerisa/modsw/",
      "linked_summary": "Calculates remainder of signed word division.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "moduw",
      "architecture": "PowerISA",
      "full_name": "Modulo Unsigned Word",
      "summary": "Calculates remainder of unsigned word division.",
      "syntax": "moduw RT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | RA | RB | 267 | /",
        "hex_opcode": "0x7C000216",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "267",
            "clean": "267"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Dividend"
        },
        {
          "name": "RB",
          "desc": "Divisor"
        }
      ],
      "extension": "Base",
      "slug": "moduw",
      "rel_url": "powerisa/moduw/",
      "linked_summary": "Calculates remainder of unsigned word division.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "modsd",
      "architecture": "PowerISA",
      "full_name": "Modulo Signed Doubleword",
      "summary": "Calculates remainder of signed doubleword division.",
      "syntax": "modsd RT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | RA | RB | 777 | /",
        "hex_opcode": "0x7C000612",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "777",
            "clean": "777"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Dividend"
        },
        {
          "name": "RB",
          "desc": "Divisor"
        }
      ],
      "extension": "Base",
      "slug": "modsd",
      "rel_url": "powerisa/modsd/",
      "linked_summary": "Calculates remainder of signed doubleword division.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "modud",
      "architecture": "PowerISA",
      "full_name": "Modulo Unsigned Doubleword",
      "summary": "Calculates remainder of unsigned doubleword division.",
      "syntax": "modud RT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | RA | RB | 265 | /",
        "hex_opcode": "0x7C000212",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "265",
            "clean": "265"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Dividend"
        },
        {
          "name": "RB",
          "desc": "Divisor"
        }
      ],
      "extension": "Base",
      "slug": "modud",
      "rel_url": "powerisa/modud/",
      "linked_summary": "Calculates remainder of unsigned doubleword division.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ftdiv",
      "architecture": "PowerISA",
      "full_name": "Float Test for Divide",
      "summary": "Tests for conditions that would cause a divide exception.",
      "syntax": "ftdiv BF, FRA, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | BF | / | FRA | FRB | 128 | /",
        "hex_opcode": "0xFC000100",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "FRA",
            "clean": "FRA"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "128",
            "clean": "128"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "FRA",
          "desc": "A"
        },
        {
          "name": "FRB",
          "desc": "B"
        }
      ],
      "extension": "Float",
      "slug": "ftdiv",
      "rel_url": "powerisa/ftdiv/",
      "linked_summary": "Tests for conditions that would cause a divide exception.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ftsqrt",
      "architecture": "PowerISA",
      "full_name": "Float Test for Square Root",
      "summary": "Tests for conditions that would cause a sqrt exception.",
      "syntax": "ftsqrt BF, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | BF | / | 0 | FRB | 160 | /",
        "hex_opcode": "0xFC000140",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "160",
            "clean": "160"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "FRB",
          "desc": "Source"
        }
      ],
      "extension": "Float",
      "slug": "ftsqrt",
      "rel_url": "powerisa/ftsqrt/",
      "linked_summary": "Tests for conditions that would cause a sqrt exception.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fre",
      "architecture": "PowerISA",
      "full_name": "Floating Reciprocal Estimate",
      "summary": "Estimates 1/x (Double Precision).",
      "syntax": "fre FRT, FRB",
      "encoding": {
        "format": "A-form",
        "binary_pattern": "63 | FRT | 0 | 0 | FRB | 24 | /",
        "hex_opcode": "0xFC000030",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "24",
            "clean": "24"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRB",
          "desc": "Source"
        }
      ],
      "extension": "Float",
      "slug": "fre",
      "rel_url": "powerisa/fre/",
      "linked_summary": "Estimates 1/x (Double Precision).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fres",
      "architecture": "PowerISA",
      "full_name": "Floating Reciprocal Estimate Single",
      "summary": "Estimates 1/x (Single Precision).",
      "syntax": "fres FRT, FRB",
      "encoding": {
        "format": "A-form",
        "binary_pattern": "59 | FRT | 0 | 0 | FRB | 24 | /",
        "hex_opcode": "0xEC000030",
        "visual_parts": [
          {
            "raw": "59",
            "clean": "59"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "24",
            "clean": "24"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRB",
          "desc": "Source"
        }
      ],
      "extension": "Float",
      "slug": "fres",
      "rel_url": "powerisa/fres/",
      "linked_summary": "Estimates 1/x (Single Precision).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "frsqrte",
      "architecture": "PowerISA",
      "full_name": "Floating Reciprocal Square Root Estimate",
      "summary": "Estimates 1/sqrt(x) (Double Precision).",
      "syntax": "frsqrte FRT, FRB",
      "encoding": {
        "format": "A-form",
        "binary_pattern": "63 | FRT | 0 | 0 | FRB | 26 | /",
        "hex_opcode": "0xFC000034",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "26",
            "clean": "26"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRB",
          "desc": "Source"
        }
      ],
      "extension": "Float",
      "slug": "frsqrte",
      "rel_url": "powerisa/frsqrte/",
      "linked_summary": "Estimates 1/sqrt(x) (Double Precision).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "frsqrtes",
      "architecture": "PowerISA",
      "full_name": "Floating Reciprocal Square Root Estimate Single",
      "summary": "Estimates 1/sqrt(x) (Single Precision).",
      "syntax": "frsqrtes FRT, FRB",
      "encoding": {
        "format": "A-form",
        "binary_pattern": "59 | FRT | 0 | 0 | FRB | 26 | /",
        "hex_opcode": "0xEC000034",
        "visual_parts": [
          {
            "raw": "59",
            "clean": "59"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "26",
            "clean": "26"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRB",
          "desc": "Source"
        }
      ],
      "extension": "Float",
      "slug": "frsqrtes",
      "rel_url": "powerisa/frsqrtes/",
      "linked_summary": "Estimates 1/sqrt(x) (Single Precision).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rfebb",
      "architecture": "PowerISA",
      "full_name": "Return From Event-Based Branch",
      "summary": "Returns from an event handler (EBB).",
      "syntax": "rfebb S",
      "encoding": {
        "format": "XL-form",
        "binary_pattern": "19 | / | / | S | 146 | /",
        "hex_opcode": "0x4C000124",
        "visual_parts": [
          {
            "raw": "19",
            "clean": "19"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "S",
            "clean": "S"
          },
          {
            "raw": "146",
            "clean": "146"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "S",
          "desc": "State"
        }
      ],
      "extension": "Base",
      "slug": "rfebb",
      "rel_url": "powerisa/rfebb/",
      "linked_summary": "Returns from an event handler (EBB).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "setb",
      "architecture": "PowerISA",
      "full_name": "Set Boolean",
      "summary": "Sets RT to -1, 0, or 1 based on CR field.",
      "syntax": "setb RT, BFA",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | BFA | / | 128 | /",
        "hex_opcode": "0x7C000100",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "BFA",
            "clean": "BFA"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "128",
            "clean": "128"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "BFA",
          "desc": "CR Field"
        }
      ],
      "extension": "Base",
      "slug": "setb",
      "rel_url": "powerisa/setb/",
      "linked_summary": "Sets RT to -1, 0, <a href=\"../../powerisa/or/\">or</a> 1 based on CR field.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "divde",
      "architecture": "PowerISA",
      "full_name": "Divide Doubleword Extended",
      "summary": "64-bit extended division.",
      "syntax": "divde RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "31 | RT | RA | RB | OE | 425 | Rc",
        "hex_opcode": "0x7C000352",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "OE",
            "clean": "OE"
          },
          {
            "raw": "425",
            "clean": "425"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Dividend"
        },
        {
          "name": "RB",
          "desc": "Divisor"
        }
      ],
      "extension": "Base",
      "slug": "divde",
      "rel_url": "powerisa/divde/",
      "linked_summary": "64-<a href=\"../../armv8-a/bit/\">bit</a> extended division.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "divdeu",
      "architecture": "PowerISA",
      "full_name": "Divide Doubleword Extended Unsigned",
      "summary": "64-bit extended unsigned division.",
      "syntax": "divdeu RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "31 | RT | RA | RB | OE | 393 | Rc",
        "hex_opcode": "0x7C000312",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "OE",
            "clean": "OE"
          },
          {
            "raw": "393",
            "clean": "393"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Dividend"
        },
        {
          "name": "RB",
          "desc": "Divisor"
        }
      ],
      "extension": "Base",
      "slug": "divdeu",
      "rel_url": "powerisa/divdeu/",
      "linked_summary": "64-<a href=\"../../armv8-a/bit/\">bit</a> extended unsigned division.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "divwe",
      "architecture": "PowerISA",
      "full_name": "Divide Word Extended",
      "summary": "32-bit extended division.",
      "syntax": "divwe RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "31 | RT | RA | RB | OE | 427 | Rc",
        "hex_opcode": "0x7C000356",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "OE",
            "clean": "OE"
          },
          {
            "raw": "427",
            "clean": "427"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Dividend"
        },
        {
          "name": "RB",
          "desc": "Divisor"
        }
      ],
      "extension": "Base",
      "slug": "divwe",
      "rel_url": "powerisa/divwe/",
      "linked_summary": "32-<a href=\"../../armv8-a/bit/\">bit</a> extended division.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "divweu",
      "architecture": "PowerISA",
      "full_name": "Divide Word Extended Unsigned",
      "summary": "32-bit extended unsigned division.",
      "syntax": "divweu RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "31 | RT | RA | RB | OE | 395 | Rc",
        "hex_opcode": "0x7C000316",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "OE",
            "clean": "OE"
          },
          {
            "raw": "395",
            "clean": "395"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Dividend"
        },
        {
          "name": "RB",
          "desc": "Divisor"
        }
      ],
      "extension": "Base",
      "slug": "divweu",
      "rel_url": "powerisa/divweu/",
      "linked_summary": "32-<a href=\"../../armv8-a/bit/\">bit</a> extended unsigned division.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vand",
      "architecture": "PowerISA",
      "full_name": "Vector AND",
      "summary": "Bitwise AND of two 128-bit vectors.",
      "syntax": "vand vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1028",
        "hex_opcode": "0x10000404",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1028",
            "clean": "1028"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vand",
      "rel_url": "powerisa/vand/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/and/\">AND</a> of two 128-<a href=\"../../armv8-a/bit/\">bit</a> vectors.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vor",
      "architecture": "PowerISA",
      "full_name": "Vector OR",
      "summary": "Bitwise OR of two 128-bit vectors.",
      "syntax": "vor vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1156",
        "hex_opcode": "0x10000484",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1156",
            "clean": "1156"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vor",
      "rel_url": "powerisa/vor/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/or/\">OR</a> of two 128-<a href=\"../../armv8-a/bit/\">bit</a> vectors.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vxor",
      "architecture": "PowerISA",
      "full_name": "Vector XOR",
      "summary": "Bitwise XOR of two 128-bit vectors.",
      "syntax": "vxor vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1220",
        "hex_opcode": "0x100004C4",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1220",
            "clean": "1220"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vxor",
      "rel_url": "powerisa/vxor/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/xor/\">XOR</a> of two 128-<a href=\"../../armv8-a/bit/\">bit</a> vectors.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vnor",
      "architecture": "PowerISA",
      "full_name": "Vector NOR",
      "summary": "Bitwise NOR of two 128-bit vectors. (NOT (A OR B)).",
      "syntax": "vnor vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1284",
        "hex_opcode": "0x10000504",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1284",
            "clean": "1284"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vnor",
      "rel_url": "powerisa/vnor/",
      "linked_summary": "Bitwise NOR of two 128-<a href=\"../../armv8-a/bit/\">bit</a> vectors. (<a href=\"../../risc-v/not/\">NOT</a> (A <a href=\"../../risc-v/or/\">OR</a> B)).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vandc",
      "architecture": "PowerISA",
      "full_name": "Vector AND with Complement",
      "summary": "Bitwise AND of vA with the ones' complement of vB (vA & ~vB).",
      "syntax": "vandc vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1092",
        "hex_opcode": "0x10000444",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1092",
            "clean": "1092"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vandc",
      "rel_url": "powerisa/vandc/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/and/\">AND</a> of vA with the ones' complement of vB (vA & ~vB).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcmpequb",
      "architecture": "PowerISA",
      "full_name": "Vector Compare Equal Byte",
      "summary": "Compares 16 bytes. Result is 0xFF (True) or 0x00 (False) per byte.",
      "syntax": "vcmpequb vD, vA, vB",
      "encoding": {
        "format": "VC-form",
        "binary_pattern": "4 | vD | vA | vB | 6",
        "hex_opcode": "0x10000006",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "6",
            "clean": "6"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vcmpequb",
      "rel_url": "powerisa/vcmpequb/",
      "linked_summary": "Compares 16 bytes. Result is 0xFF (True) <a href=\"../../powerisa/or/\">or</a> 0x00 (False) per byte.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcmpequh",
      "architecture": "PowerISA",
      "full_name": "Vector Compare Equal Halfword",
      "summary": "Compares 8 halfwords for equality.",
      "syntax": "vcmpequh vD, vA, vB",
      "encoding": {
        "format": "VC-form",
        "binary_pattern": "4 | vD | vA | vB | 70",
        "hex_opcode": "0x10000046",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "70",
            "clean": "70"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vcmpequh",
      "rel_url": "powerisa/vcmpequh/",
      "linked_summary": "Compares 8 halfwords for equality.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcmpequd",
      "architecture": "PowerISA",
      "full_name": "Vector Compare Equal Doubleword",
      "summary": "Compares 2 doublewords for equality.",
      "syntax": "vcmpequd vD, vA, vB",
      "encoding": {
        "format": "VC-form",
        "binary_pattern": "4 | vD | vA | vB | 199",
        "hex_opcode": "0x100000C7",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "199",
            "clean": "199"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vcmpequd",
      "rel_url": "powerisa/vcmpequd/",
      "linked_summary": "Compares 2 doublewords for equality.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcmpgtub",
      "architecture": "PowerISA",
      "full_name": "Vector Compare Greater Than Unsigned Byte",
      "summary": "Unsigned > comparison for 16 bytes.",
      "syntax": "vcmpgtub vD, vA, vB",
      "encoding": {
        "format": "VC-form",
        "binary_pattern": "4 | vD | vA | vB | 518",
        "hex_opcode": "0x10000206",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "518",
            "clean": "518"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vcmpgtub",
      "rel_url": "powerisa/vcmpgtub/",
      "linked_summary": "Unsigned > comparison for 16 bytes.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcmpgtsb",
      "architecture": "PowerISA",
      "full_name": "Vector Compare Greater Than Signed Byte",
      "summary": "Signed > comparison for 16 bytes.",
      "syntax": "vcmpgtsb vD, vA, vB",
      "encoding": {
        "format": "VC-form",
        "binary_pattern": "4 | vD | vA | vB | 774",
        "hex_opcode": "0x10000306",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "774",
            "clean": "774"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vcmpgtsb",
      "rel_url": "powerisa/vcmpgtsb/",
      "linked_summary": "Signed > comparison for 16 bytes.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcmpgtuh",
      "architecture": "PowerISA",
      "full_name": "Vector Compare Greater Than Unsigned Halfword",
      "summary": "Unsigned > comparison for 8 halfwords.",
      "syntax": "vcmpgtuh vD, vA, vB",
      "encoding": {
        "format": "VC-form",
        "binary_pattern": "4 | vD | vA | vB | 582",
        "hex_opcode": "0x10000246",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "582",
            "clean": "582"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vcmpgtuh",
      "rel_url": "powerisa/vcmpgtuh/",
      "linked_summary": "Unsigned > comparison for 8 halfwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcmpgtsh",
      "architecture": "PowerISA",
      "full_name": "Vector Compare Greater Than Signed Halfword",
      "summary": "Signed > comparison for 8 halfwords.",
      "syntax": "vcmpgtsh vD, vA, vB",
      "encoding": {
        "format": "VC-form",
        "binary_pattern": "4 | vD | vA | vB | 838",
        "hex_opcode": "0x10000346",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "838",
            "clean": "838"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vcmpgtsh",
      "rel_url": "powerisa/vcmpgtsh/",
      "linked_summary": "Signed > comparison for 8 halfwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcmpgtuw",
      "architecture": "PowerISA",
      "full_name": "Vector Compare Greater Than Unsigned Word",
      "summary": "Unsigned > comparison for 4 words.",
      "syntax": "vcmpgtuw vD, vA, vB",
      "encoding": {
        "format": "VC-form",
        "binary_pattern": "4 | vD | vA | vB | 646",
        "hex_opcode": "0x10000286",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "646",
            "clean": "646"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vcmpgtuw",
      "rel_url": "powerisa/vcmpgtuw/",
      "linked_summary": "Unsigned > comparison for 4 words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcmpgtsw",
      "architecture": "PowerISA",
      "full_name": "Vector Compare Greater Than Signed Word",
      "summary": "Signed > comparison for 4 words.",
      "syntax": "vcmpgtsw vD, vA, vB",
      "encoding": {
        "format": "VC-form",
        "binary_pattern": "4 | vD | vA | vB | 902",
        "hex_opcode": "0x10000386",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "902",
            "clean": "902"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vcmpgtsw",
      "rel_url": "powerisa/vcmpgtsw/",
      "linked_summary": "Signed > comparison for 4 words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcmpgtud",
      "architecture": "PowerISA",
      "full_name": "Vector Compare Greater Than Unsigned Doubleword",
      "summary": "Unsigned > comparison for 2 doublewords.",
      "syntax": "vcmpgtud vD, vA, vB",
      "encoding": {
        "format": "VC-form",
        "binary_pattern": "4 | vD | vA | vB | 711",
        "hex_opcode": "0x100002C7",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "711",
            "clean": "711"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vcmpgtud",
      "rel_url": "powerisa/vcmpgtud/",
      "linked_summary": "Unsigned > comparison for 2 doublewords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcmpgtsd",
      "architecture": "PowerISA",
      "full_name": "Vector Compare Greater Than Signed Doubleword",
      "summary": "Signed > comparison for 2 doublewords.",
      "syntax": "vcmpgtsd vD, vA, vB",
      "encoding": {
        "format": "VC-form",
        "binary_pattern": "4 | vD | vA | vB | 967",
        "hex_opcode": "0x100003C7",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "967",
            "clean": "967"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vcmpgtsd",
      "rel_url": "powerisa/vcmpgtsd/",
      "linked_summary": "Signed > comparison for 2 doublewords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vavgub",
      "architecture": "PowerISA",
      "full_name": "Vector Average Unsigned Byte",
      "summary": "Computes (a+b+1)/2 for bytes.",
      "syntax": "vavgub vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 1026",
        "hex_opcode": "0x10000402",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1026",
            "clean": "1026"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vavgub",
      "rel_url": "powerisa/vavgub/",
      "linked_summary": "Computes (a+<a href=\"../../armv8-a/b_1/\">b</a>+1)/2 for bytes.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vavgsb",
      "architecture": "PowerISA",
      "full_name": "Vector Average Signed Byte",
      "summary": "Computes (a+b+1)/2 for signed bytes.",
      "syntax": "vavgsb vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 1282",
        "hex_opcode": "0x10000502",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1282",
            "clean": "1282"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vavgsb",
      "rel_url": "powerisa/vavgsb/",
      "linked_summary": "Computes (a+<a href=\"../../armv8-a/b_1/\">b</a>+1)/2 for signed bytes.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vavguh",
      "architecture": "PowerISA",
      "full_name": "Vector Average Unsigned Halfword",
      "summary": "Computes (a+b+1)/2 for halfwords.",
      "syntax": "vavguh vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 1090",
        "hex_opcode": "0x10000442",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1090",
            "clean": "1090"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vavguh",
      "rel_url": "powerisa/vavguh/",
      "linked_summary": "Computes (a+<a href=\"../../armv8-a/b_1/\">b</a>+1)/2 for halfwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vavgsh",
      "architecture": "PowerISA",
      "full_name": "Vector Average Signed Halfword",
      "summary": "Computes (a+b+1)/2 for signed halfwords.",
      "syntax": "vavgsh vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 1346",
        "hex_opcode": "0x10000542",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1346",
            "clean": "1346"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vavgsh",
      "rel_url": "powerisa/vavgsh/",
      "linked_summary": "Computes (a+<a href=\"../../armv8-a/b_1/\">b</a>+1)/2 for signed halfwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vavguw",
      "architecture": "PowerISA",
      "full_name": "Vector Average Unsigned Word",
      "summary": "Computes (a+b+1)/2 for words.",
      "syntax": "vavguw vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 1154",
        "hex_opcode": "0x10000482",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1154",
            "clean": "1154"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vavguw",
      "rel_url": "powerisa/vavguw/",
      "linked_summary": "Computes (a+<a href=\"../../armv8-a/b_1/\">b</a>+1)/2 for words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vavgsw",
      "architecture": "PowerISA",
      "full_name": "Vector Average Signed Word",
      "summary": "Computes (a+b+1)/2 for signed words.",
      "syntax": "vavgsw vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 1410",
        "hex_opcode": "0x10000582",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1410",
            "clean": "1410"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vavgsw",
      "rel_url": "powerisa/vavgsw/",
      "linked_summary": "Computes (a+<a href=\"../../armv8-a/b_1/\">b</a>+1)/2 for signed words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vminub",
      "architecture": "PowerISA",
      "full_name": "Vector Minimum Unsigned Byte",
      "summary": "Selects minimum value per byte (unsigned).",
      "syntax": "vminub vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 1026",
        "hex_opcode": "0x10000402",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1026",
            "clean": "1026"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vminub",
      "rel_url": "powerisa/vminub/",
      "linked_summary": "Selects minimum value per byte (unsigned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vminsb",
      "architecture": "PowerISA",
      "full_name": "Vector Minimum Signed Byte",
      "summary": "Selects minimum value per byte (signed).",
      "syntax": "vminsb vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 1538",
        "hex_opcode": "0x10000602",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1538",
            "clean": "1538"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vminsb",
      "rel_url": "powerisa/vminsb/",
      "linked_summary": "Selects minimum value per byte (signed).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vminuh",
      "architecture": "PowerISA",
      "full_name": "Vector Minimum Unsigned Halfword",
      "summary": "Selects minimum value per halfword (unsigned).",
      "syntax": "vminuh vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 1090",
        "hex_opcode": "0x10000442",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1090",
            "clean": "1090"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vminuh",
      "rel_url": "powerisa/vminuh/",
      "linked_summary": "Selects minimum value per halfword (unsigned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vminsh",
      "architecture": "PowerISA",
      "full_name": "Vector Minimum Signed Halfword",
      "summary": "Selects minimum value per halfword (signed).",
      "syntax": "vminsh vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 1602",
        "hex_opcode": "0x10000642",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1602",
            "clean": "1602"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vminsh",
      "rel_url": "powerisa/vminsh/",
      "linked_summary": "Selects minimum value per halfword (signed).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vminuw",
      "architecture": "PowerISA",
      "full_name": "Vector Minimum Unsigned Word",
      "summary": "Selects minimum value per word (unsigned).",
      "syntax": "vminuw vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 1154",
        "hex_opcode": "0x10000482",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1154",
            "clean": "1154"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vminuw",
      "rel_url": "powerisa/vminuw/",
      "linked_summary": "Selects minimum value per word (unsigned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vminsw",
      "architecture": "PowerISA",
      "full_name": "Vector Minimum Signed Word",
      "summary": "Selects minimum value per word (signed).",
      "syntax": "vminsw vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 1666",
        "hex_opcode": "0x10000682",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1666",
            "clean": "1666"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vminsw",
      "rel_url": "powerisa/vminsw/",
      "linked_summary": "Selects minimum value per word (signed).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmaxub",
      "architecture": "PowerISA",
      "full_name": "Vector Maximum Unsigned Byte",
      "summary": "Selects maximum value per byte (unsigned).",
      "syntax": "vmaxub vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 4",
        "hex_opcode": "0x10000004",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "4",
            "clean": "4"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vmaxub",
      "rel_url": "powerisa/vmaxub/",
      "linked_summary": "Selects maximum value per byte (unsigned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmaxsb",
      "architecture": "PowerISA",
      "full_name": "Vector Maximum Signed Byte",
      "summary": "Selects maximum value per byte (signed).",
      "syntax": "vmaxsb vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 516",
        "hex_opcode": "0x10000204",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "516",
            "clean": "516"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vmaxsb",
      "rel_url": "powerisa/vmaxsb/",
      "linked_summary": "Selects maximum value per byte (signed).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmaxuh",
      "architecture": "PowerISA",
      "full_name": "Vector Maximum Unsigned Halfword",
      "summary": "Selects maximum value per halfword (unsigned).",
      "syntax": "vmaxuh vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 68",
        "hex_opcode": "0x10000044",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "68",
            "clean": "68"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vmaxuh",
      "rel_url": "powerisa/vmaxuh/",
      "linked_summary": "Selects maximum value per halfword (unsigned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmaxsh",
      "architecture": "PowerISA",
      "full_name": "Vector Maximum Signed Halfword",
      "summary": "Selects maximum value per halfword (signed).",
      "syntax": "vmaxsh vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 580",
        "hex_opcode": "0x10000244",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "580",
            "clean": "580"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vmaxsh",
      "rel_url": "powerisa/vmaxsh/",
      "linked_summary": "Selects maximum value per halfword (signed).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmaxuw",
      "architecture": "PowerISA",
      "full_name": "Vector Maximum Unsigned Word",
      "summary": "Selects maximum value per word (unsigned).",
      "syntax": "vmaxuw vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 132",
        "hex_opcode": "0x10000084",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "132",
            "clean": "132"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vmaxuw",
      "rel_url": "powerisa/vmaxuw/",
      "linked_summary": "Selects maximum value per word (unsigned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmaxsw",
      "architecture": "PowerISA",
      "full_name": "Vector Maximum Signed Word",
      "summary": "Selects maximum value per word (signed).",
      "syntax": "vmaxsw vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 644",
        "hex_opcode": "0x10000284",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "644",
            "clean": "644"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vmaxsw",
      "rel_url": "powerisa/vmaxsw/",
      "linked_summary": "Selects maximum value per word (signed).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmrghb",
      "architecture": "PowerISA",
      "full_name": "Vector Merge High Byte",
      "summary": "Interleaves high-order bytes from two vectors (Permutation).",
      "syntax": "vmrghb vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 12",
        "hex_opcode": "0x1000000C",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "12",
            "clean": "12"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vmrghb",
      "rel_url": "powerisa/vmrghb/",
      "linked_summary": "Interleaves high-order bytes from two vectors (Permutation).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmrghh",
      "architecture": "PowerISA",
      "full_name": "Vector Merge High Halfword",
      "summary": "Interleaves high-order halfwords.",
      "syntax": "vmrghh vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 76",
        "hex_opcode": "0x1000004C",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "76",
            "clean": "76"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vmrghh",
      "rel_url": "powerisa/vmrghh/",
      "linked_summary": "Interleaves high-order halfwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmrghw",
      "architecture": "PowerISA",
      "full_name": "Vector Merge High Word",
      "summary": "Interleaves high-order words.",
      "syntax": "vmrghw vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 140",
        "hex_opcode": "0x1000008C",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "140",
            "clean": "140"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vmrghw",
      "rel_url": "powerisa/vmrghw/",
      "linked_summary": "Interleaves high-order words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmrglb",
      "architecture": "PowerISA",
      "full_name": "Vector Merge Low Byte",
      "summary": "Interleaves low-order bytes.",
      "syntax": "vmrglb vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 268",
        "hex_opcode": "0x1000010C",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "268",
            "clean": "268"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vmrglb",
      "rel_url": "powerisa/vmrglb/",
      "linked_summary": "Interleaves low-order bytes.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmrglh",
      "architecture": "PowerISA",
      "full_name": "Vector Merge Low Halfword",
      "summary": "Interleaves low-order halfwords.",
      "syntax": "vmrglh vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 332",
        "hex_opcode": "0x1000014C",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "332",
            "clean": "332"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vmrglh",
      "rel_url": "powerisa/vmrglh/",
      "linked_summary": "Interleaves low-order halfwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmrglw",
      "architecture": "PowerISA",
      "full_name": "Vector Merge Low Word",
      "summary": "Interleaves low-order words.",
      "syntax": "vmrglw vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 396",
        "hex_opcode": "0x1000018C",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "396",
            "clean": "396"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vmrglw",
      "rel_url": "powerisa/vmrglw/",
      "linked_summary": "Interleaves low-order words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpkuhum",
      "architecture": "PowerISA",
      "full_name": "Vector Pack Unsigned Halfword Unsigned Modulo",
      "summary": "Truncates 8 halfwords to 16 bytes (modulo 256).",
      "syntax": "vpkuhum vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 14",
        "hex_opcode": "0x1000000E",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "14",
            "clean": "14"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vpkuhum",
      "rel_url": "powerisa/vpkuhum/",
      "linked_summary": "Truncates 8 halfwords to 16 bytes (modulo 256).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpkuwum",
      "architecture": "PowerISA",
      "full_name": "Vector Pack Unsigned Word Unsigned Modulo",
      "summary": "Truncates 4 words to 8 halfwords.",
      "syntax": "vpkuwum vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 78",
        "hex_opcode": "0x1000004E",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "78",
            "clean": "78"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vpkuwum",
      "rel_url": "powerisa/vpkuwum/",
      "linked_summary": "Truncates 4 words to 8 halfwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpkuhus",
      "architecture": "PowerISA",
      "full_name": "Vector Pack Unsigned Halfword Unsigned Saturate",
      "summary": "Saturates 8 halfwords to 16 unsigned bytes.",
      "syntax": "vpkuhus vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 142",
        "hex_opcode": "0x1000008E",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "142",
            "clean": "142"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vpkuhus",
      "rel_url": "powerisa/vpkuhus/",
      "linked_summary": "Saturates 8 halfwords to 16 unsigned bytes.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpkshss",
      "architecture": "PowerISA",
      "full_name": "Vector Pack Signed Halfword Signed Saturate",
      "summary": "Saturates 8 signed halfwords to 16 signed bytes.",
      "syntax": "vpkshss vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 462",
        "hex_opcode": "0x100001CE",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "462",
            "clean": "462"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vpkshss",
      "rel_url": "powerisa/vpkshss/",
      "linked_summary": "Saturates 8 signed halfwords to 16 signed bytes.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpkswss",
      "architecture": "PowerISA",
      "full_name": "Vector Pack Signed Word Signed Saturate",
      "summary": "Saturates 4 signed words to 8 signed halfwords.",
      "syntax": "vpkswss vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 526",
        "hex_opcode": "0x1000020E",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "526",
            "clean": "526"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vpkswss",
      "rel_url": "powerisa/vpkswss/",
      "linked_summary": "Saturates 4 signed words to 8 signed halfwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vupkhsb",
      "architecture": "PowerISA",
      "full_name": "Vector Unpack High Signed Byte",
      "summary": "Unpacks high 8 signed bytes to 8 signed halfwords.",
      "syntax": "vupkhsb vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 526",
        "hex_opcode": "0x1000020E",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "526",
            "clean": "526"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vupkhsb",
      "rel_url": "powerisa/vupkhsb/",
      "linked_summary": "Unpacks high 8 signed bytes to 8 signed halfwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vupkhsh",
      "architecture": "PowerISA",
      "full_name": "Vector Unpack High Signed Halfword",
      "summary": "Unpacks high 4 signed halfwords to 4 signed words.",
      "syntax": "vupkhsh vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 590",
        "hex_opcode": "0x1000024E",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "590",
            "clean": "590"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vupkhsh",
      "rel_url": "powerisa/vupkhsh/",
      "linked_summary": "Unpacks high 4 signed halfwords to 4 signed words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vupklsb",
      "architecture": "PowerISA",
      "full_name": "Vector Unpack Low Signed Byte",
      "summary": "Unpacks low 8 signed bytes to 8 signed halfwords.",
      "syntax": "vupklsb vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 654",
        "hex_opcode": "0x1000028E",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "654",
            "clean": "654"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vupklsb",
      "rel_url": "powerisa/vupklsb/",
      "linked_summary": "Unpacks low 8 signed bytes to 8 signed halfwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vupklsh",
      "architecture": "PowerISA",
      "full_name": "Vector Unpack Low Signed Halfword",
      "summary": "Unpacks low 4 signed halfwords to 4 signed words.",
      "syntax": "vupklsh vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 718",
        "hex_opcode": "0x100002CE",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "718",
            "clean": "718"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vupklsh",
      "rel_url": "powerisa/vupklsh/",
      "linked_summary": "Unpacks low 4 signed halfwords to 4 signed words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vaddubm",
      "architecture": "PowerISA",
      "full_name": "Vector Add Unsigned Byte Modulo",
      "summary": "Adds 16 bytes modulo 256.",
      "syntax": "vaddubm vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 0",
        "hex_opcode": "0x10000000",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vaddubm",
      "rel_url": "powerisa/vaddubm/",
      "linked_summary": "Adds 16 bytes modulo 256.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vadduhm",
      "architecture": "PowerISA",
      "full_name": "Vector Add Unsigned Halfword Modulo",
      "summary": "Adds 8 halfwords modulo 65536.",
      "syntax": "vadduhm vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 64",
        "hex_opcode": "0x10000040",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "64",
            "clean": "64"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vadduhm",
      "rel_url": "powerisa/vadduhm/",
      "linked_summary": "Adds 8 halfwords modulo 65536.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vadduwm",
      "architecture": "PowerISA",
      "full_name": "Vector Add Unsigned Word Modulo",
      "summary": "Adds 4 words modulo 2^32.",
      "syntax": "vadduwm vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 128",
        "hex_opcode": "0x10000080",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "128",
            "clean": "128"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vadduwm",
      "rel_url": "powerisa/vadduwm/",
      "linked_summary": "Adds 4 words modulo 2^32.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vaddudm",
      "architecture": "PowerISA",
      "full_name": "Vector Add Unsigned Doubleword Modulo",
      "summary": "Adds 2 doublewords modulo 2^64.",
      "syntax": "vaddudm vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 192",
        "hex_opcode": "0x100000C0",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "192",
            "clean": "192"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vaddudm",
      "rel_url": "powerisa/vaddudm/",
      "linked_summary": "Adds 2 doublewords modulo 2^64.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vaddubs",
      "architecture": "PowerISA",
      "full_name": "Vector Add Unsigned Byte Saturate",
      "summary": "Adds 16 unsigned bytes with saturation (0..255).",
      "syntax": "vaddubs vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 512",
        "hex_opcode": "0x10000200",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "512",
            "clean": "512"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vaddubs",
      "rel_url": "powerisa/vaddubs/",
      "linked_summary": "Adds 16 unsigned bytes with saturation (0..255).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vadduhs",
      "architecture": "PowerISA",
      "full_name": "Vector Add Unsigned Halfword Saturate",
      "summary": "Adds 8 unsigned halfwords with saturation.",
      "syntax": "vadduhs vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 576",
        "hex_opcode": "0x10000240",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "576",
            "clean": "576"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vadduhs",
      "rel_url": "powerisa/vadduhs/",
      "linked_summary": "Adds 8 unsigned halfwords with saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vadduws",
      "architecture": "PowerISA",
      "full_name": "Vector Add Unsigned Word Saturate",
      "summary": "Adds 4 unsigned words with saturation.",
      "syntax": "vadduws vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 640",
        "hex_opcode": "0x10000280",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "640",
            "clean": "640"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vadduws",
      "rel_url": "powerisa/vadduws/",
      "linked_summary": "Adds 4 unsigned words with saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vaddsbs",
      "architecture": "PowerISA",
      "full_name": "Vector Add Signed Byte Saturate",
      "summary": "Adds 16 signed bytes with saturation (-128..127).",
      "syntax": "vaddsbs vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 768",
        "hex_opcode": "0x10000300",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "768",
            "clean": "768"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vaddsbs",
      "rel_url": "powerisa/vaddsbs/",
      "linked_summary": "Adds 16 signed bytes with saturation (-128..127).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vaddshs",
      "architecture": "PowerISA",
      "full_name": "Vector Add Signed Halfword Saturate",
      "summary": "Adds 8 signed halfwords with saturation.",
      "syntax": "vaddshs vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 832",
        "hex_opcode": "0x10000340",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "832",
            "clean": "832"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vaddshs",
      "rel_url": "powerisa/vaddshs/",
      "linked_summary": "Adds 8 signed halfwords with saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vaddsws",
      "architecture": "PowerISA",
      "full_name": "Vector Add Signed Word Saturate",
      "summary": "Adds 4 signed words with saturation.",
      "syntax": "vaddsws vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 896",
        "hex_opcode": "0x10000380",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "896",
            "clean": "896"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vaddsws",
      "rel_url": "powerisa/vaddsws/",
      "linked_summary": "Adds 4 signed words with saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsububm",
      "architecture": "PowerISA",
      "full_name": "Vector Subtract Unsigned Byte Modulo",
      "summary": "Subtracts 16 bytes modulo 256.",
      "syntax": "vsububm vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1024",
        "hex_opcode": "0x10000400",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1024",
            "clean": "1024"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vsububm",
      "rel_url": "powerisa/vsububm/",
      "linked_summary": "Subtracts 16 bytes modulo 256.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsubuhm",
      "architecture": "PowerISA",
      "full_name": "Vector Subtract Unsigned Halfword Modulo",
      "summary": "Subtracts 8 halfwords modulo 65536.",
      "syntax": "vsubuhm vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1088",
        "hex_opcode": "0x10000440",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1088",
            "clean": "1088"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vsubuhm",
      "rel_url": "powerisa/vsubuhm/",
      "linked_summary": "Subtracts 8 halfwords modulo 65536.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsubudm",
      "architecture": "PowerISA",
      "full_name": "Vector Subtract Unsigned Doubleword Modulo",
      "summary": "Subtracts 2 doublewords modulo 2^64.",
      "syntax": "vsubudm vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1216",
        "hex_opcode": "0x100004C0",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1216",
            "clean": "1216"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vsubudm",
      "rel_url": "powerisa/vsubudm/",
      "linked_summary": "Subtracts 2 doublewords modulo 2^64.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsububs",
      "architecture": "PowerISA",
      "full_name": "Vector Subtract Unsigned Byte Saturate",
      "summary": "Subtracts 16 unsigned bytes with saturation.",
      "syntax": "vsububs vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1536",
        "hex_opcode": "0x10000600",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1536",
            "clean": "1536"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vsububs",
      "rel_url": "powerisa/vsububs/",
      "linked_summary": "Subtracts 16 unsigned bytes with saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsubuhs",
      "architecture": "PowerISA",
      "full_name": "Vector Subtract Unsigned Halfword Saturate",
      "summary": "Subtracts 8 unsigned halfwords with saturation.",
      "syntax": "vsubuhs vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1600",
        "hex_opcode": "0x10000640",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1600",
            "clean": "1600"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vsubuhs",
      "rel_url": "powerisa/vsubuhs/",
      "linked_summary": "Subtracts 8 unsigned halfwords with saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsubuws",
      "architecture": "PowerISA",
      "full_name": "Vector Subtract Unsigned Word Saturate",
      "summary": "Subtracts 4 unsigned words with saturation.",
      "syntax": "vsubuws vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1664",
        "hex_opcode": "0x10000680",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1664",
            "clean": "1664"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vsubuws",
      "rel_url": "powerisa/vsubuws/",
      "linked_summary": "Subtracts 4 unsigned words with saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsubsbs",
      "architecture": "PowerISA",
      "full_name": "Vector Subtract Signed Byte Saturate",
      "summary": "Subtracts 16 signed bytes with saturation.",
      "syntax": "vsubsbs vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1792",
        "hex_opcode": "0x10000700",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1792",
            "clean": "1792"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vsubsbs",
      "rel_url": "powerisa/vsubsbs/",
      "linked_summary": "Subtracts 16 signed bytes with saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsubshs",
      "architecture": "PowerISA",
      "full_name": "Vector Subtract Signed Halfword Saturate",
      "summary": "Subtracts 8 signed halfwords with saturation.",
      "syntax": "vsubshs vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1856",
        "hex_opcode": "0x10000740",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1856",
            "clean": "1856"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vsubshs",
      "rel_url": "powerisa/vsubshs/",
      "linked_summary": "Subtracts 8 signed halfwords with saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsubsws",
      "architecture": "PowerISA",
      "full_name": "Vector Subtract Signed Word Saturate",
      "summary": "Subtracts 4 signed words with saturation.",
      "syntax": "vsubsws vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1920",
        "hex_opcode": "0x10000780",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1920",
            "clean": "1920"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vsubsws",
      "rel_url": "powerisa/vsubsws/",
      "linked_summary": "Subtracts 4 signed words with saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsaddsp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Add Single-Precision",
      "summary": "Scalar float addition (32-bit).",
      "syntax": "xsaddsp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 0",
        "hex_opcode": "0xF0000000",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xsaddsp",
      "rel_url": "powerisa/xsaddsp/",
      "linked_summary": "Scalar float addition (32-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xssubsp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Subtract Single-Precision",
      "summary": "Scalar float subtraction (32-bit).",
      "syntax": "xssubsp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 8",
        "hex_opcode": "0xF0000008",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "8",
            "clean": "8"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xssubsp",
      "rel_url": "powerisa/xssubsp/",
      "linked_summary": "Scalar float subtraction (32-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsmulsp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Multiply Single-Precision",
      "summary": "Scalar float multiplication (32-bit).",
      "syntax": "xsmulsp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 16",
        "hex_opcode": "0xF0000010",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "16",
            "clean": "16"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xsmulsp",
      "rel_url": "powerisa/xsmulsp/",
      "linked_summary": "Scalar float multiplication (32-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsdivsp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Divide Single-Precision",
      "summary": "Scalar float division (32-bit).",
      "syntax": "xsdivsp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 24",
        "hex_opcode": "0xF0000018",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "24",
            "clean": "24"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xsdivsp",
      "rel_url": "powerisa/xsdivsp/",
      "linked_summary": "Scalar float division (32-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsmaxdp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Maximum Double-Precision",
      "summary": "Scalar maximum (64-bit float).",
      "syntax": "xsmaxdp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 160",
        "hex_opcode": "0xF00000A0",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "160",
            "clean": "160"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xsmaxdp",
      "rel_url": "powerisa/xsmaxdp/",
      "linked_summary": "Scalar maximum (64-<a href=\"../../armv8-a/bit/\">bit</a> float).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsmindp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Minimum Double-Precision",
      "summary": "Scalar minimum (64-bit float).",
      "syntax": "xsmindp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 168",
        "hex_opcode": "0xF00000A8",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "168",
            "clean": "168"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xsmindp",
      "rel_url": "powerisa/xsmindp/",
      "linked_summary": "Scalar minimum (64-<a href=\"../../armv8-a/bit/\">bit</a> float).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xssqrtdp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Square Root Double-Precision",
      "summary": "Scalar square root (64-bit float).",
      "syntax": "xssqrtdp XT, XB",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | 0 | XB | 75",
        "hex_opcode": "0xF000004B",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "75",
            "clean": "75"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        }
      ],
      "extension": "VSX",
      "slug": "xssqrtdp",
      "rel_url": "powerisa/xssqrtdp/",
      "linked_summary": "Scalar square root (64-<a href=\"../../armv8-a/bit/\">bit</a> float).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsabsdp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Absolute Value Double-Precision",
      "summary": "Scalar absolute value (64-bit float).",
      "syntax": "xsabsdp XT, XB",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | 0 | XB | 345",
        "hex_opcode": "0xF0000159",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "345",
            "clean": "345"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        }
      ],
      "extension": "VSX",
      "slug": "xsabsdp",
      "rel_url": "powerisa/xsabsdp/",
      "linked_summary": "Scalar absolute value (64-<a href=\"../../armv8-a/bit/\">bit</a> float).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsnegdp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Negate Double-Precision",
      "summary": "Scalar negation (64-bit float).",
      "syntax": "xsnegdp XT, XB",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | 0 | XB | 361",
        "hex_opcode": "0xF0000169",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "361",
            "clean": "361"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        }
      ],
      "extension": "VSX",
      "slug": "xsnegdp",
      "rel_url": "powerisa/xsnegdp/",
      "linked_summary": "Scalar negation (64-<a href=\"../../armv8-a/bit/\">bit</a> float).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xscmpodp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Compare Ordered Double-Precision",
      "summary": "Scalar compare (Exceptions on NaN).",
      "syntax": "xscmpodp BF, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | BF | / | XA | XB | 43",
        "hex_opcode": "0xF000002B",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "43",
            "clean": "43"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xscmpodp",
      "rel_url": "powerisa/xscmpodp/",
      "linked_summary": "Scalar compare (Exceptions on NaN).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xscmpudp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Compare Unordered Double-Precision",
      "summary": "Scalar compare (No exceptions on NaN).",
      "syntax": "xscmpudp BF, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | BF | / | XA | XB | 35",
        "hex_opcode": "0xF0000023",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "35",
            "clean": "35"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xscmpudp",
      "rel_url": "powerisa/xscmpudp/",
      "linked_summary": "Scalar compare (No exceptions on NaN).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsl",
      "architecture": "PowerISA",
      "full_name": "Vector Shift Left",
      "summary": "Shifts vector left by octet count in vB.",
      "syntax": "vsl vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 452",
        "hex_opcode": "0x100001C4",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "452",
            "clean": "452"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Data"
        },
        {
          "name": "vB",
          "desc": "Shift Count"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vsl",
      "rel_url": "powerisa/vsl/",
      "linked_summary": "Shifts vector left by octet count <a href=\"../../x86/in/\">in</a> vB.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsr",
      "architecture": "PowerISA",
      "full_name": "Vector Shift Right",
      "summary": "Shifts vector right by octet count in vB.",
      "syntax": "vsr vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 708",
        "hex_opcode": "0x100002C4",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "708",
            "clean": "708"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Data"
        },
        {
          "name": "vB",
          "desc": "Shift Count"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vsr",
      "rel_url": "powerisa/vsr/",
      "linked_summary": "Shifts vector right by octet count <a href=\"../../x86/in/\">in</a> vB.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vslo",
      "architecture": "PowerISA",
      "full_name": "Vector Shift Left by Octet",
      "summary": "Shifts vector left by byte count.",
      "syntax": "vslo vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1036",
        "hex_opcode": "0x1000040C",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1036",
            "clean": "1036"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Data"
        },
        {
          "name": "vB",
          "desc": "Shift Count"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vslo",
      "rel_url": "powerisa/vslo/",
      "linked_summary": "Shifts vector left by byte count.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsro",
      "architecture": "PowerISA",
      "full_name": "Vector Shift Right by Octet",
      "summary": "Shifts vector right by byte count.",
      "syntax": "vsro vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1100",
        "hex_opcode": "0x1000044C",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1100",
            "clean": "1100"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Data"
        },
        {
          "name": "vB",
          "desc": "Shift Count"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vsro",
      "rel_url": "powerisa/vsro/",
      "linked_summary": "Shifts vector right by byte count.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vrlb",
      "architecture": "PowerISA",
      "full_name": "Vector Rotate Left Byte",
      "summary": "Rotates each byte left.",
      "syntax": "vrlb vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 4",
        "hex_opcode": "0x10000004",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "4",
            "clean": "4"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Data"
        },
        {
          "name": "vB",
          "desc": "Rotate Count"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vrlb",
      "rel_url": "powerisa/vrlb/",
      "linked_summary": "Rotates each byte left.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vrlh",
      "architecture": "PowerISA",
      "full_name": "Vector Rotate Left Halfword",
      "summary": "Rotates each halfword left.",
      "syntax": "vrlh vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 68",
        "hex_opcode": "0x10000044",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "68",
            "clean": "68"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Data"
        },
        {
          "name": "vB",
          "desc": "Rotate Count"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vrlh",
      "rel_url": "powerisa/vrlh/",
      "linked_summary": "Rotates each halfword left.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vrlw",
      "architecture": "PowerISA",
      "full_name": "Vector Rotate Left Word",
      "summary": "Rotates each word left.",
      "syntax": "vrlw vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 132",
        "hex_opcode": "0x10000084",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "132",
            "clean": "132"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Data"
        },
        {
          "name": "vB",
          "desc": "Rotate Count"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vrlw",
      "rel_url": "powerisa/vrlw/",
      "linked_summary": "Rotates each word left.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vrld",
      "architecture": "PowerISA",
      "full_name": "Vector Rotate Left Doubleword",
      "summary": "Rotates each doubleword left.",
      "syntax": "vrld vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 196",
        "hex_opcode": "0x100000C4",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "196",
            "clean": "196"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Data"
        },
        {
          "name": "vB",
          "desc": "Rotate Count"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vrld",
      "rel_url": "powerisa/vrld/",
      "linked_summary": "Rotates each doubleword left.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "daddq",
      "architecture": "PowerISA",
      "full_name": "Decimal Add Quad-Precision",
      "summary": "Adds two 128-bit DFP numbers.",
      "syntax": "daddq vD, vA, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | vA | vB | 2 | /",
        "hex_opcode": "0xFC000002",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "2",
            "clean": "2"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "Decimal Float",
      "slug": "daddq",
      "rel_url": "powerisa/daddq/",
      "linked_summary": "Adds two 128-<a href=\"../../armv8-a/bit/\">bit</a> DFP numbers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dsubq",
      "architecture": "PowerISA",
      "full_name": "Decimal Subtract Quad-Precision",
      "summary": "Subtracts two 128-bit DFP numbers.",
      "syntax": "dsubq vD, vA, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | vA | vB | 514 | /",
        "hex_opcode": "0xFC000402",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "514",
            "clean": "514"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "Decimal Float",
      "slug": "dsubq",
      "rel_url": "powerisa/dsubq/",
      "linked_summary": "Subtracts two 128-<a href=\"../../armv8-a/bit/\">bit</a> DFP numbers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dmulq",
      "architecture": "PowerISA",
      "full_name": "Decimal Multiply Quad-Precision",
      "summary": "Multiplies two 128-bit DFP numbers.",
      "syntax": "dmulq vD, vA, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | vA | vB | 34 | /",
        "hex_opcode": "0xFC000042",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "34",
            "clean": "34"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "Decimal Float",
      "slug": "dmulq",
      "rel_url": "powerisa/dmulq/",
      "linked_summary": "Multiplies two 128-<a href=\"../../armv8-a/bit/\">bit</a> DFP numbers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ddivq",
      "architecture": "PowerISA",
      "full_name": "Decimal Divide Quad-Precision",
      "summary": "Divides two 128-bit DFP numbers.",
      "syntax": "ddivq vD, vA, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | vA | vB | 546 | /",
        "hex_opcode": "0xFC000442",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "546",
            "clean": "546"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "Decimal Float",
      "slug": "ddivq",
      "rel_url": "powerisa/ddivq/",
      "linked_summary": "Divides two 128-<a href=\"../../armv8-a/bit/\">bit</a> DFP numbers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dcmpuq",
      "architecture": "PowerISA",
      "full_name": "Decimal Compare Unordered Quad-Precision",
      "summary": "Compares two 128-bit DFP numbers (Non-signaling).",
      "syntax": "dcmpuq BF, vA, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | BF | / | vA | vB | 642 | /",
        "hex_opcode": "0xFC000502",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "642",
            "clean": "642"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "Decimal Float",
      "slug": "dcmpuq",
      "rel_url": "powerisa/dcmpuq/",
      "linked_summary": "Compares two 128-<a href=\"../../armv8-a/bit/\">bit</a> DFP numbers (Non-signaling).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dcmpoq",
      "architecture": "PowerISA",
      "full_name": "Decimal Compare Ordered Quad-Precision",
      "summary": "Compares two 128-bit DFP numbers (Signaling).",
      "syntax": "dcmpoq BF, vA, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | BF | / | vA | vB | 130 | /",
        "hex_opcode": "0xFC000102",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "130",
            "clean": "130"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "Decimal Float",
      "slug": "dcmpoq",
      "rel_url": "powerisa/dcmpoq/",
      "linked_summary": "Compares two 128-<a href=\"../../armv8-a/bit/\">bit</a> DFP numbers (Signaling).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dquaq",
      "architecture": "PowerISA",
      "full_name": "Decimal Quantize Quad-Precision",
      "summary": "Adjusts exponent of 128-bit DFP number.",
      "syntax": "dquaq vD, vA, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | vA | vB | 66 | /",
        "hex_opcode": "0xFC000082",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "66",
            "clean": "66"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Source"
        },
        {
          "name": "vB",
          "desc": "Reference"
        }
      ],
      "extension": "Decimal Float",
      "slug": "dquaq",
      "rel_url": "powerisa/dquaq/",
      "linked_summary": "Adjusts exponent of 128-<a href=\"../../armv8-a/bit/\">bit</a> DFP number.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "drrndq",
      "architecture": "PowerISA",
      "full_name": "Decimal Reround Quad-Precision",
      "summary": "Rerounds a 128-bit DFP number to fewer digits.",
      "syntax": "drrndq vD, vA, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | vA | vB | 98 | /",
        "hex_opcode": "0xFC0000C2",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "98",
            "clean": "98"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Source"
        },
        {
          "name": "vB",
          "desc": "Control"
        }
      ],
      "extension": "Decimal Float",
      "slug": "drrndq",
      "rel_url": "powerisa/drrndq/",
      "linked_summary": "Rerounds a 128-<a href=\"../../armv8-a/bit/\">bit</a> DFP number to fewer digits.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dcffixq",
      "architecture": "PowerISA",
      "full_name": "Decimal Convert From Fixed Quad-Precision",
      "summary": "Converts 64-bit integer to 128-bit DFP.",
      "syntax": "dcffixq vD, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | 0 | vB | 802 | /",
        "hex_opcode": "0xFC000642",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "802",
            "clean": "802"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Decimal Float",
      "slug": "dcffixq",
      "rel_url": "powerisa/dcffixq/",
      "linked_summary": "Converts 64-<a href=\"../../armv8-a/bit/\">bit</a> integer to 128-<a href=\"../../armv8-a/bit/\">bit</a> DFP.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dctfixq",
      "architecture": "PowerISA",
      "full_name": "Decimal Convert To Fixed Quad-Precision",
      "summary": "Converts 128-bit DFP to 64-bit integer.",
      "syntax": "dctfixq vD, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | 0 | vB | 290 | /",
        "hex_opcode": "0xFC000242",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "290",
            "clean": "290"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Decimal Float",
      "slug": "dctfixq",
      "rel_url": "powerisa/dctfixq/",
      "linked_summary": "Converts 128-<a href=\"../../armv8-a/bit/\">bit</a> DFP to 64-<a href=\"../../armv8-a/bit/\">bit</a> integer.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dxexq",
      "architecture": "PowerISA",
      "full_name": "Decimal Extract Exponent Quad-Precision",
      "summary": "Extracts exponent from 128-bit DFP.",
      "syntax": "dxexq vD, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | 0 | vB | 354 | /",
        "hex_opcode": "0xFC0002C2",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "354",
            "clean": "354"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Decimal Float",
      "slug": "dxexq",
      "rel_url": "powerisa/dxexq/",
      "linked_summary": "Extracts exponent from 128-<a href=\"../../armv8-a/bit/\">bit</a> DFP.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "diexq",
      "architecture": "PowerISA",
      "full_name": "Decimal Insert Exponent Quad-Precision",
      "summary": "Inserts exponent into 128-bit DFP.",
      "syntax": "diexq vD, vA, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | vA | vB | 866 | /",
        "hex_opcode": "0xFC0006C2",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "866",
            "clean": "866"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Coeff"
        },
        {
          "name": "vB",
          "desc": "Exp"
        }
      ],
      "extension": "Decimal Float",
      "slug": "diexq",
      "rel_url": "powerisa/diexq/",
      "linked_summary": "Inserts exponent into 128-<a href=\"../../armv8-a/bit/\">bit</a> DFP.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "denbcdq",
      "architecture": "PowerISA",
      "full_name": "Decimal Encode BCD Quad-Precision",
      "summary": "Encodes 128-bit DFP to BCD.",
      "syntax": "denbcdq vD, vB, S",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | S | vB | 834 | /",
        "hex_opcode": "0xFC000682",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "S",
            "clean": "S"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "834",
            "clean": "834"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        },
        {
          "name": "S",
          "desc": "Sign"
        }
      ],
      "extension": "Decimal Float",
      "slug": "denbcdq",
      "rel_url": "powerisa/denbcdq/",
      "linked_summary": "Encodes 128-<a href=\"../../armv8-a/bit/\">bit</a> DFP to BCD.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ddedpdq",
      "architecture": "PowerISA",
      "full_name": "Decimal Decode DPD Quad-Precision",
      "summary": "Decodes BCD to 128-bit DFP.",
      "syntax": "ddedpdq vD, vB, SP",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | SP | vB | 322 | /",
        "hex_opcode": "0xFC000282",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "SP",
            "clean": "SP"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "322",
            "clean": "322"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        },
        {
          "name": "SP",
          "desc": "Sign"
        }
      ],
      "extension": "Decimal Float",
      "slug": "ddedpdq",
      "rel_url": "powerisa/ddedpdq/",
      "linked_summary": "Decodes BCD to 128-<a href=\"../../armv8-a/bit/\">bit</a> DFP.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vspltb",
      "architecture": "PowerISA",
      "full_name": "Vector Splat Byte",
      "summary": "Duplicates a byte element across the vector.",
      "syntax": "vspltb vD, vB, UIM",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | UIM | vB | 524",
        "hex_opcode": "0x1000020C",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "524",
            "clean": "524"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        },
        {
          "name": "UIM",
          "desc": "Index"
        }
      ],
      "extension": "VMX",
      "slug": "vspltb",
      "rel_url": "powerisa/vspltb/",
      "linked_summary": "Duplicates a byte element across the vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsplth",
      "architecture": "PowerISA",
      "full_name": "Vector Splat Halfword",
      "summary": "Duplicates a halfword element across the vector.",
      "syntax": "vsplth vD, vB, UIM",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | UIM | vB | 588",
        "hex_opcode": "0x1000024C",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "588",
            "clean": "588"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        },
        {
          "name": "UIM",
          "desc": "Index"
        }
      ],
      "extension": "VMX",
      "slug": "vsplth",
      "rel_url": "powerisa/vsplth/",
      "linked_summary": "Duplicates a halfword element across the vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vspltisb",
      "architecture": "PowerISA",
      "full_name": "Vector Splat Immediate Signed Byte",
      "summary": "Fills vector with immediate 5-bit signed value (-16 to 15).",
      "syntax": "vspltisb vD, SIM",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | SIM | 00000 | 780",
        "hex_opcode": "0x1000030C",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "SIM",
            "clean": "SIM"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "780",
            "clean": "780"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "SIM",
          "desc": "Immediate"
        }
      ],
      "extension": "VMX",
      "slug": "vspltisb",
      "rel_url": "powerisa/vspltisb/",
      "linked_summary": "Fills vector with immediate 5-<a href=\"../../armv8-a/bit/\">bit</a> signed value (-16 to 15).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vspltish",
      "architecture": "PowerISA",
      "full_name": "Vector Splat Immediate Signed Halfword",
      "summary": "Fills vector with immediate 5-bit signed value.",
      "syntax": "vspltish vD, SIM",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | SIM | 00000 | 844",
        "hex_opcode": "0x1000034C",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "SIM",
            "clean": "SIM"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "844",
            "clean": "844"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "SIM",
          "desc": "Immediate"
        }
      ],
      "extension": "VMX",
      "slug": "vspltish",
      "rel_url": "powerisa/vspltish/",
      "linked_summary": "Fills vector with immediate 5-<a href=\"../../armv8-a/bit/\">bit</a> signed value.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vspltisw",
      "architecture": "PowerISA",
      "full_name": "Vector Splat Immediate Signed Word",
      "summary": "Fills vector with immediate 5-bit signed value.",
      "syntax": "vspltisw vD, SIM",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | SIM | 00000 | 908",
        "hex_opcode": "0x1000038C",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "SIM",
            "clean": "SIM"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "908",
            "clean": "908"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "SIM",
          "desc": "Immediate"
        }
      ],
      "extension": "VMX",
      "slug": "vspltisw",
      "rel_url": "powerisa/vspltisw/",
      "linked_summary": "Fills vector with immediate 5-<a href=\"../../armv8-a/bit/\">bit</a> signed value.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vslb",
      "architecture": "PowerISA",
      "full_name": "Vector Shift Left Byte",
      "summary": "Shifts each byte left.",
      "syntax": "vslb vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 260",
        "hex_opcode": "0x10000104",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "260",
            "clean": "260"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Data"
        },
        {
          "name": "vB",
          "desc": "Shift"
        }
      ],
      "extension": "VMX",
      "slug": "vslb",
      "rel_url": "powerisa/vslb/",
      "linked_summary": "Shifts each byte left.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vslh",
      "architecture": "PowerISA",
      "full_name": "Vector Shift Left Halfword",
      "summary": "Shifts each halfword left.",
      "syntax": "vslh vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 324",
        "hex_opcode": "0x10000144",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "324",
            "clean": "324"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Data"
        },
        {
          "name": "vB",
          "desc": "Shift"
        }
      ],
      "extension": "VMX",
      "slug": "vslh",
      "rel_url": "powerisa/vslh/",
      "linked_summary": "Shifts each halfword left.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsrb",
      "architecture": "PowerISA",
      "full_name": "Vector Shift Right Byte",
      "summary": "Shifts each byte right.",
      "syntax": "vsrb vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 516",
        "hex_opcode": "0x10000204",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "516",
            "clean": "516"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Data"
        },
        {
          "name": "vB",
          "desc": "Shift"
        }
      ],
      "extension": "VMX",
      "slug": "vsrb",
      "rel_url": "powerisa/vsrb/",
      "linked_summary": "Shifts each byte right.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsrh",
      "architecture": "PowerISA",
      "full_name": "Vector Shift Right Halfword",
      "summary": "Shifts each halfword right.",
      "syntax": "vsrh vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 580",
        "hex_opcode": "0x10000244",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "580",
            "clean": "580"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Data"
        },
        {
          "name": "vB",
          "desc": "Shift"
        }
      ],
      "extension": "VMX",
      "slug": "vsrh",
      "rel_url": "powerisa/vsrh/",
      "linked_summary": "Shifts each halfword right.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsrw",
      "architecture": "PowerISA",
      "full_name": "Vector Shift Right Word",
      "summary": "Shifts each word right.",
      "syntax": "vsrw vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 644",
        "hex_opcode": "0x10000284",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "644",
            "clean": "644"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Data"
        },
        {
          "name": "vB",
          "desc": "Shift"
        }
      ],
      "extension": "VMX",
      "slug": "vsrw",
      "rel_url": "powerisa/vsrw/",
      "linked_summary": "Shifts each word right.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsrab",
      "architecture": "PowerISA",
      "full_name": "Vector Shift Right Algebraic Byte",
      "summary": "Arithmetic right shift of bytes.",
      "syntax": "vsrab vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 772",
        "hex_opcode": "0x10000304",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "772",
            "clean": "772"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Data"
        },
        {
          "name": "vB",
          "desc": "Shift"
        }
      ],
      "extension": "VMX",
      "slug": "vsrab",
      "rel_url": "powerisa/vsrab/",
      "linked_summary": "Arithmetic right shift of bytes.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsrah",
      "architecture": "PowerISA",
      "full_name": "Vector Shift Right Algebraic Halfword",
      "summary": "Arithmetic right shift of halfwords.",
      "syntax": "vsrah vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 836",
        "hex_opcode": "0x10000344",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "836",
            "clean": "836"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Data"
        },
        {
          "name": "vB",
          "desc": "Shift"
        }
      ],
      "extension": "VMX",
      "slug": "vsrah",
      "rel_url": "powerisa/vsrah/",
      "linked_summary": "Arithmetic right shift of halfwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsraw",
      "architecture": "PowerISA",
      "full_name": "Vector Shift Right Algebraic Word",
      "summary": "Arithmetic right shift of words.",
      "syntax": "vsraw vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 900",
        "hex_opcode": "0x10000384",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "900",
            "clean": "900"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Data"
        },
        {
          "name": "vB",
          "desc": "Shift"
        }
      ],
      "extension": "VMX",
      "slug": "vsraw",
      "rel_url": "powerisa/vsraw/",
      "linked_summary": "Arithmetic right shift of words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmrgew",
      "architecture": "PowerISA",
      "full_name": "Vector Merge Even Word",
      "summary": "Merges even words from two vectors.",
      "syntax": "vmrgew vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1932",
        "hex_opcode": "0x1000078C",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1932",
            "clean": "1932"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX",
      "slug": "vmrgew",
      "rel_url": "powerisa/vmrgew/",
      "linked_summary": "Merges even words from two vectors.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmrgow",
      "architecture": "PowerISA",
      "full_name": "Vector Merge Odd Word",
      "summary": "Merges odd words from two vectors.",
      "syntax": "vmrgow vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1676",
        "hex_opcode": "0x1000068C",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1676",
            "clean": "1676"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX",
      "slug": "vmrgow",
      "rel_url": "powerisa/vmrgow/",
      "linked_summary": "Merges odd words from two vectors.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmulesb",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Even Signed Byte",
      "summary": "Multiplies even signed bytes to halfwords.",
      "syntax": "vmulesb vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 776",
        "hex_opcode": "0x10000308",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "776",
            "clean": "776"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX",
      "slug": "vmulesb",
      "rel_url": "powerisa/vmulesb/",
      "linked_summary": "Multiplies even signed bytes to halfwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmuleub",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Even Unsigned Byte",
      "summary": "Multiplies even unsigned bytes to halfwords.",
      "syntax": "vmuleub vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 520",
        "hex_opcode": "0x10000208",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "520",
            "clean": "520"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX",
      "slug": "vmuleub",
      "rel_url": "powerisa/vmuleub/",
      "linked_summary": "Multiplies even unsigned bytes to halfwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmulesh",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Even Signed Halfword",
      "summary": "Multiplies even signed halfwords to words.",
      "syntax": "vmulesh vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 840",
        "hex_opcode": "0x10000348",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "840",
            "clean": "840"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX",
      "slug": "vmulesh",
      "rel_url": "powerisa/vmulesh/",
      "linked_summary": "Multiplies even signed halfwords to words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmuleuh",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Even Unsigned Halfword",
      "summary": "Multiplies even unsigned halfwords to words.",
      "syntax": "vmuleuh vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 584",
        "hex_opcode": "0x10000248",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "584",
            "clean": "584"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX",
      "slug": "vmuleuh",
      "rel_url": "powerisa/vmuleuh/",
      "linked_summary": "Multiplies even unsigned halfwords to words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmulosb",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Odd Signed Byte",
      "summary": "Multiplies odd signed bytes to halfwords.",
      "syntax": "vmulosb vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 264",
        "hex_opcode": "0x10000108",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "264",
            "clean": "264"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX",
      "slug": "vmulosb",
      "rel_url": "powerisa/vmulosb/",
      "linked_summary": "Multiplies odd signed bytes to halfwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmuloub",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Odd Unsigned Byte",
      "summary": "Multiplies odd unsigned bytes to halfwords.",
      "syntax": "vmuloub vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 8",
        "hex_opcode": "0x10000008",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "8",
            "clean": "8"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX",
      "slug": "vmuloub",
      "rel_url": "powerisa/vmuloub/",
      "linked_summary": "Multiplies odd unsigned bytes to halfwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmulosh",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Odd Signed Halfword",
      "summary": "Multiplies odd signed halfwords to words.",
      "syntax": "vmulosh vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 328",
        "hex_opcode": "0x10000148",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "328",
            "clean": "328"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX",
      "slug": "vmulosh",
      "rel_url": "powerisa/vmulosh/",
      "linked_summary": "Multiplies odd signed halfwords to words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmulouh",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Odd Unsigned Halfword",
      "summary": "Multiplies odd unsigned halfwords to words.",
      "syntax": "vmulouh vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 72",
        "hex_opcode": "0x10000048",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "72",
            "clean": "72"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX",
      "slug": "vmulouh",
      "rel_url": "powerisa/vmulouh/",
      "linked_summary": "Multiplies odd unsigned halfwords to words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vabsdub",
      "architecture": "PowerISA",
      "full_name": "Vector Absolute Difference Unsigned Byte",
      "summary": "Computes |A - B| for bytes.",
      "syntax": "vabsdub vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 1027",
        "hex_opcode": "0x10000403",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1027",
            "clean": "1027"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX",
      "slug": "vabsdub",
      "rel_url": "powerisa/vabsdub/",
      "linked_summary": "Computes |A - B| for bytes.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vabsduh",
      "architecture": "PowerISA",
      "full_name": "Vector Absolute Difference Unsigned Halfword",
      "summary": "Computes |A - B| for halfwords.",
      "syntax": "vabsduh vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 1091",
        "hex_opcode": "0x10000443",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1091",
            "clean": "1091"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX",
      "slug": "vabsduh",
      "rel_url": "powerisa/vabsduh/",
      "linked_summary": "Computes |A - B| for halfwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vabsduw",
      "architecture": "PowerISA",
      "full_name": "Vector Absolute Difference Unsigned Word",
      "summary": "Computes |A - B| for words.",
      "syntax": "vabsduw vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 1155",
        "hex_opcode": "0x10000483",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1155",
            "clean": "1155"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX",
      "slug": "vabsduw",
      "rel_url": "powerisa/vabsduw/",
      "linked_summary": "Computes |A - B| for words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsmaxcqp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Maximum Type-C Quad-Precision",
      "summary": "Max of Quad float (IEEE 754-2008 specific rules).",
      "syntax": "xsmaxcqp vD, vA, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | vA | vB | 676 | /",
        "hex_opcode": "0xFC000544",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "676",
            "clean": "676"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX (Quad)",
      "slug": "xsmaxcqp",
      "rel_url": "powerisa/xsmaxcqp/",
      "linked_summary": "Max of Quad float (IEEE 754-2008 specific rules).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsmincqp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Minimum Type-C Quad-Precision",
      "summary": "Min of Quad float (IEEE 754-2008 specific rules).",
      "syntax": "xsmincqp vD, vA, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | vA | vB | 708 | /",
        "hex_opcode": "0xFC00058C",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "708",
            "clean": "708"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX (Quad)",
      "slug": "xsmincqp",
      "rel_url": "powerisa/xsmincqp/",
      "linked_summary": "Min of Quad float (IEEE 754-2008 specific rules).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xscpsgnqp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Copy Sign Quad-Precision",
      "summary": "Copies sign from B to A (128-bit).",
      "syntax": "xscpsgnqp vD, vA, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | vA | vB | 100 | /",
        "hex_opcode": "0xFC0000C4",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX (Quad)",
      "slug": "xscpsgnqp",
      "rel_url": "powerisa/xscpsgnqp/",
      "linked_summary": "Copies sign from B to A (128-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xststdcqp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Test Data Class Quad-Precision",
      "summary": "Tests class of Quad float (NaN/Inf/Zero).",
      "syntax": "xststdcqp BF, vB, DCM",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | BF | / | DCM | vB | 706 | /",
        "hex_opcode": "0xFC000582",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "DCM",
            "clean": "DCM"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "706",
            "clean": "706"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "vB",
          "desc": "Source"
        },
        {
          "name": "DCM",
          "desc": "Mask"
        }
      ],
      "extension": "VSX (Quad)",
      "slug": "xststdcqp",
      "rel_url": "powerisa/xststdcqp/",
      "linked_summary": "Tests class of Quad float (NaN/Inf/Zero).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xscmpexpqp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Compare Exponents Quad-Precision",
      "summary": "Compares exponents of two Quad floats.",
      "syntax": "xscmpexpqp BF, vA, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | BF | / | vA | vB | 228 | /",
        "hex_opcode": "0xFC0001C4",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "228",
            "clean": "228"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX (Quad)",
      "slug": "xscmpexpqp",
      "rel_url": "powerisa/xscmpexpqp/",
      "linked_summary": "Compares exponents of two Quad floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tcheck",
      "architecture": "PowerISA",
      "full_name": "Transaction Check",
      "summary": "Checks transaction status and updates CR.",
      "syntax": "tcheck BF",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | BF | / | / | 716 | /",
        "hex_opcode": "0x7C00059C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "716",
            "clean": "716"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        }
      ],
      "extension": "TM (Transactional Memory)",
      "slug": "tcheck",
      "rel_url": "powerisa/tcheck/",
      "linked_summary": "Checks transaction status <a href=\"../../armv8-a/and_6/\">and</a> updates CR.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tsuspend",
      "architecture": "PowerISA",
      "full_name": "Transaction Suspend",
      "summary": "Suspends the current transaction.",
      "syntax": "tsuspend.",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | 0 | 0 | 0 | 750 | 1",
        "hex_opcode": "0x7C0005DE",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "750",
            "clean": "750"
          },
          {
            "raw": "1",
            "clean": "1"
          }
        ]
      },
      "operands": [],
      "extension": "TM (Transactional Memory)",
      "slug": "tsuspend",
      "rel_url": "powerisa/tsuspend/",
      "linked_summary": "Suspends the current transaction.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tresume",
      "architecture": "PowerISA",
      "full_name": "Transaction Resume",
      "summary": "Resumes a suspended transaction.",
      "syntax": "tresume.",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | 1 | 0 | 0 | 750 | 1",
        "hex_opcode": "0x7C2005DE",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "750",
            "clean": "750"
          },
          {
            "raw": "1",
            "clean": "1"
          }
        ]
      },
      "operands": [],
      "extension": "TM (Transactional Memory)",
      "slug": "tresume",
      "rel_url": "powerisa/tresume/",
      "linked_summary": "Resumes a suspended transaction.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dcbtls",
      "architecture": "PowerISA",
      "full_name": "Data Cache Block Touch and Lock Set",
      "summary": "Locks a cache line in the L1 cache.",
      "syntax": "dcbtls CT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | CT | RA | RB | 166 | /",
        "hex_opcode": "0x7C00014C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "CT",
            "clean": "CT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "166",
            "clean": "166"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "CT",
          "desc": "Cache Target"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Privileged",
      "slug": "dcbtls",
      "rel_url": "powerisa/dcbtls/",
      "linked_summary": "Locks a cache line <a href=\"../../x86/in/\">in</a> the L1 cache.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "icbtls",
      "architecture": "PowerISA",
      "full_name": "Instruction Cache Block Touch and Lock Set",
      "summary": "Locks an instruction cache line.",
      "syntax": "icbtls CT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | CT | RA | RB | 486 | /",
        "hex_opcode": "0x7C0003CC",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "CT",
            "clean": "CT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "486",
            "clean": "486"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "CT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Privileged",
      "slug": "icbtls",
      "rel_url": "powerisa/icbtls/",
      "linked_summary": "Locks an instruction cache line.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "slbsync",
      "architecture": "PowerISA",
      "full_name": "SLB Synchronize",
      "summary": "Ensures SLB invalidations have propagated.",
      "syntax": "slbsync",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | / | / | 438 | /",
        "hex_opcode": "0x7C00036C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "438",
            "clean": "438"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [],
      "extension": "Privileged",
      "slug": "slbsync",
      "rel_url": "powerisa/slbsync/",
      "linked_summary": "Ensures SLB invalidations have propagated.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lbarx",
      "architecture": "PowerISA",
      "full_name": "Load Byte And Reserve Indexed",
      "summary": "Atomic Load Byte.",
      "syntax": "lbarx RT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | RA | RB | 52 | 0",
        "hex_opcode": "0x7C000034",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "52",
            "clean": "52"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base (Atomics)",
      "slug": "lbarx",
      "rel_url": "powerisa/lbarx/",
      "linked_summary": "Atomic Load Byte.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lharx",
      "architecture": "PowerISA",
      "full_name": "Load Halfword And Reserve Indexed",
      "summary": "Atomic Load Halfword.",
      "syntax": "lharx RT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | RA | RB | 116 | 0",
        "hex_opcode": "0x7C000074",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "116",
            "clean": "116"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base (Atomics)",
      "slug": "lharx",
      "rel_url": "powerisa/lharx/",
      "linked_summary": "Atomic Load Halfword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lqarx",
      "architecture": "PowerISA",
      "full_name": "Load Quadword And Reserve Indexed",
      "summary": "Atomic Load 128-bit Quadword.",
      "syntax": "lqarx RTp, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RTp | RA | RB | 276 | 0",
        "hex_opcode": "0x7C000228",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RTp",
            "clean": "RTp"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "276",
            "clean": "276"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RTp",
          "desc": "Target Pair"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base (Atomics)",
      "slug": "lqarx",
      "rel_url": "powerisa/lqarx/",
      "linked_summary": "Atomic Load 128-<a href=\"../../armv8-a/bit/\">bit</a> Quadword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stbcx.",
      "architecture": "PowerISA",
      "full_name": "Store Byte Conditional Indexed",
      "summary": "Atomic Store Byte.",
      "syntax": "stbcx. RS, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 694 | 1",
        "hex_opcode": "0x7C00056D",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "694",
            "clean": "694"
          },
          {
            "raw": "1",
            "clean": "1"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base (Atomics)",
      "slug": "stbcx_",
      "rel_url": "powerisa/stbcx_/",
      "linked_summary": "Atomic Store Byte.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sthcx.",
      "architecture": "PowerISA",
      "full_name": "Store Halfword Conditional Indexed",
      "summary": "Atomic Store Halfword.",
      "syntax": "sthcx. RS, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 726 | 1",
        "hex_opcode": "0x7C0005AD",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "726",
            "clean": "726"
          },
          {
            "raw": "1",
            "clean": "1"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base (Atomics)",
      "slug": "sthcx_",
      "rel_url": "powerisa/sthcx_/",
      "linked_summary": "Atomic Store Halfword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efststeq",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Single Test Equal",
      "summary": "Tests if two single-precision floats are equal, setting CR field.",
      "syntax": "efststeq BF, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | BF | RA | RB | 724",
        "hex_opcode": "0x100002D4",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "724",
            "clean": "724"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efststeq",
      "rel_url": "powerisa/efststeq/",
      "linked_summary": "Tests if two single-precision floats are equal, setting CR field.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efststgt",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Single Test Greater Than",
      "summary": "Tests if single-precision A > B.",
      "syntax": "efststgt BF, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | BF | RA | RB | 725",
        "hex_opcode": "0x100002D5",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "725",
            "clean": "725"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efststgt",
      "rel_url": "powerisa/efststgt/",
      "linked_summary": "Tests if single-precision A > B.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efststlt",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Single Test Less Than",
      "summary": "Tests if single-precision A < B.",
      "syntax": "efststlt BF, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | BF | RA | RB | 726",
        "hex_opcode": "0x100002D6",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "726",
            "clean": "726"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efststlt",
      "rel_url": "powerisa/efststlt/",
      "linked_summary": "Tests if single-precision A < B.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efdtsteq",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Double Test Equal",
      "summary": "Tests if two double-precision floats are equal.",
      "syntax": "efdtsteq BF, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | BF | RA | RB | 756",
        "hex_opcode": "0x100002F4",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "756",
            "clean": "756"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efdtsteq",
      "rel_url": "powerisa/efdtsteq/",
      "linked_summary": "Tests if two double-precision floats are equal.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efdtstgt",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Double Test Greater Than",
      "summary": "Tests if double-precision A > B.",
      "syntax": "efdtstgt BF, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | BF | RA | RB | 757",
        "hex_opcode": "0x100002F5",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "757",
            "clean": "757"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efdtstgt",
      "rel_url": "powerisa/efdtstgt/",
      "linked_summary": "Tests if double-precision A > B.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efdtstlt",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Double Test Less Than",
      "summary": "Tests if double-precision A < B.",
      "syntax": "efdtstlt BF, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | BF | RA | RB | 758",
        "hex_opcode": "0x100002F6",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "758",
            "clean": "758"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efdtstlt",
      "rel_url": "powerisa/efdtstlt/",
      "linked_summary": "Tests if double-precision A < B.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efscfd",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Single Convert From Double",
      "summary": "Converts double-precision to single-precision.",
      "syntax": "efscfd RT, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | 0 | RB | 719",
        "hex_opcode": "0x100002CF",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "719",
            "clean": "719"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RB",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efscfd",
      "rel_url": "powerisa/efscfd/",
      "linked_summary": "Converts double-precision to single-precision.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efdcfs",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Double Convert From Single",
      "summary": "Converts single-precision to double-precision.",
      "syntax": "efdcfs RT, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | 0 | RB | 751",
        "hex_opcode": "0x100002EF",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "751",
            "clean": "751"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RB",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efdcfs",
      "rel_url": "powerisa/efdcfs/",
      "linked_summary": "Converts single-precision to double-precision.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efscfsi",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Single Convert From Signed Integer",
      "summary": "Converts signed 32-bit integer to single-precision float.",
      "syntax": "efscfsi RT, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | 0 | RB | 721",
        "hex_opcode": "0x100002D1",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "721",
            "clean": "721"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RB",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efscfsi_1",
      "rel_url": "powerisa/efscfsi_1/",
      "linked_summary": "Converts signed 32-<a href=\"../../armv8-a/bit/\">bit</a> integer to single-precision float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efscfui",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Single Convert From Unsigned Integer",
      "summary": "Converts unsigned 32-bit integer to single-precision float.",
      "syntax": "efscfui RT, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | 0 | RB | 720",
        "hex_opcode": "0x100002D0",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "720",
            "clean": "720"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RB",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efscfui",
      "rel_url": "powerisa/efscfui/",
      "linked_summary": "Converts unsigned 32-<a href=\"../../armv8-a/bit/\">bit</a> integer to single-precision float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efsctsi",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Single Convert To Signed Integer",
      "summary": "Converts single-precision float to signed 32-bit integer.",
      "syntax": "efsctsi RT, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | 0 | RB | 725",
        "hex_opcode": "0x100002D5",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "725",
            "clean": "725"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RB",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efsctsi_1",
      "rel_url": "powerisa/efsctsi_1/",
      "linked_summary": "Converts single-precision float to signed 32-<a href=\"../../armv8-a/bit/\">bit</a> integer.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efsctui",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Single Convert To Unsigned Integer",
      "summary": "Converts single-precision float to unsigned 32-bit integer.",
      "syntax": "efsctui RT, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | 0 | RB | 724",
        "hex_opcode": "0x100002D4",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "724",
            "clean": "724"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RB",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efsctui",
      "rel_url": "powerisa/efsctui/",
      "linked_summary": "Converts single-precision float to unsigned 32-<a href=\"../../armv8-a/bit/\">bit</a> integer.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efsctsiz",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Single Convert To Signed Integer with Round toward Zero",
      "summary": "Converts float to integer (Truncate).",
      "syntax": "efsctsiz RT, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | 0 | RB | 727",
        "hex_opcode": "0x100002D7",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "727",
            "clean": "727"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RB",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efsctsiz",
      "rel_url": "powerisa/efsctsiz/",
      "linked_summary": "Converts float to integer (Truncate).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efsctuiz",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Single Convert To Unsigned Integer with Round toward Zero",
      "summary": "Converts float to unsigned integer (Truncate).",
      "syntax": "efsctuiz RT, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | 0 | RB | 726",
        "hex_opcode": "0x100002D6",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "726",
            "clean": "726"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RB",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efsctuiz",
      "rel_url": "powerisa/efsctuiz/",
      "linked_summary": "Converts float to unsigned integer (Truncate).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efscfsf",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Single Convert From Signed Fractional",
      "summary": "Converts 32-bit signed fractional to float.",
      "syntax": "efscfsf RT, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | 0 | RB | 723",
        "hex_opcode": "0x100002D3",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "723",
            "clean": "723"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RB",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efscfsf",
      "rel_url": "powerisa/efscfsf/",
      "linked_summary": "Converts 32-<a href=\"../../armv8-a/bit/\">bit</a> signed fractional to float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "efscfuf",
      "architecture": "PowerISA",
      "full_name": "Embedded Float Single Convert From Unsigned Fractional",
      "summary": "Converts 32-bit unsigned fractional to float.",
      "syntax": "efscfuf RT, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | 0 | RB | 722",
        "hex_opcode": "0x100002D2",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "722",
            "clean": "722"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RB",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (SPE Float)",
      "slug": "efscfuf",
      "rel_url": "powerisa/efscfuf/",
      "linked_summary": "Converts 32-<a href=\"../../armv8-a/bit/\">bit</a> unsigned fractional to float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evcmpeq",
      "architecture": "PowerISA",
      "full_name": "Vector Compare Equal",
      "summary": "Compares two vectors for equality, setting CR field.",
      "syntax": "evcmpeq BF, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | BF | RA | RB | 564",
        "hex_opcode": "0x10000234",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "564",
            "clean": "564"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evcmpeq",
      "rel_url": "powerisa/evcmpeq/",
      "linked_summary": "Compares two vectors for equality, setting CR field.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evcmpgtu",
      "architecture": "PowerISA",
      "full_name": "Vector Compare Greater Than Unsigned",
      "summary": "Compares vectors (unsigned A > B).",
      "syntax": "evcmpgtu BF, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | BF | RA | RB | 560",
        "hex_opcode": "0x10000230",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "560",
            "clean": "560"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evcmpgtu",
      "rel_url": "powerisa/evcmpgtu/",
      "linked_summary": "Compares vectors (unsigned A > B).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evcmpgts",
      "architecture": "PowerISA",
      "full_name": "Vector Compare Greater Than Signed",
      "summary": "Compares vectors (signed A > B).",
      "syntax": "evcmpgts BF, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | BF | RA | RB | 561",
        "hex_opcode": "0x10000231",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "561",
            "clean": "561"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evcmpgts",
      "rel_url": "powerisa/evcmpgts/",
      "linked_summary": "Compares vectors (signed A > B).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evcmpltu",
      "architecture": "PowerISA",
      "full_name": "Vector Compare Less Than Unsigned",
      "summary": "Compares vectors (unsigned A < B).",
      "syntax": "evcmpltu BF, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | BF | RA | RB | 562",
        "hex_opcode": "0x10000232",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "562",
            "clean": "562"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evcmpltu",
      "rel_url": "powerisa/evcmpltu/",
      "linked_summary": "Compares vectors (unsigned A < B).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evcmplts",
      "architecture": "PowerISA",
      "full_name": "Vector Compare Less Than Signed",
      "summary": "Compares vectors (signed A < B).",
      "syntax": "evcmplts BF, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | BF | RA | RB | 563",
        "hex_opcode": "0x10000233",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "563",
            "clean": "563"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evcmplts",
      "rel_url": "powerisa/evcmplts/",
      "linked_summary": "Compares vectors (signed A < B).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evsel",
      "architecture": "PowerISA",
      "full_name": "Vector Select",
      "summary": "Selects bits from RA or RB based on CR field.",
      "syntax": "evsel RT, RA, RB, CR",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 79",
        "hex_opcode": "0x1000004F",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "79",
            "clean": "79"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "True Src"
        },
        {
          "name": "RB",
          "desc": "False Src"
        },
        {
          "name": "CR",
          "desc": "Condition"
        }
      ],
      "extension": "Embedded (SPE)",
      "slug": "evsel",
      "rel_url": "powerisa/evsel/",
      "linked_summary": "Selects bits from RA <a href=\"../../powerisa/or/\">or</a> RB based on CR field.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evfsadd",
      "architecture": "PowerISA",
      "full_name": "Vector Float Single Add",
      "summary": "Adds two vectors of single-precision floats.",
      "syntax": "evfsadd RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 640",
        "hex_opcode": "0x10000280",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "640",
            "clean": "640"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE Vector)",
      "slug": "evfsadd",
      "rel_url": "powerisa/evfsadd/",
      "linked_summary": "Adds two vectors of single-precision floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evfssub",
      "architecture": "PowerISA",
      "full_name": "Vector Float Single Subtract",
      "summary": "Subtracts two vectors of single-precision floats.",
      "syntax": "evfssub RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 641",
        "hex_opcode": "0x10000281",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "641",
            "clean": "641"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE Vector)",
      "slug": "evfssub",
      "rel_url": "powerisa/evfssub/",
      "linked_summary": "Subtracts two vectors of single-precision floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evfsmul",
      "architecture": "PowerISA",
      "full_name": "Vector Float Single Multiply",
      "summary": "Multiplies two vectors of single-precision floats.",
      "syntax": "evfsmul RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 644",
        "hex_opcode": "0x10000284",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "644",
            "clean": "644"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE Vector)",
      "slug": "evfsmul",
      "rel_url": "powerisa/evfsmul/",
      "linked_summary": "Multiplies two vectors of single-precision floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evfsdiv",
      "architecture": "PowerISA",
      "full_name": "Vector Float Single Divide",
      "summary": "Divides two vectors of single-precision floats.",
      "syntax": "evfsdiv RT, RA, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | RB | 645",
        "hex_opcode": "0x10000285",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "645",
            "clean": "645"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Embedded (SPE Vector)",
      "slug": "evfsdiv",
      "rel_url": "powerisa/evfsdiv/",
      "linked_summary": "Divides two vectors of single-precision floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evfsabs",
      "architecture": "PowerISA",
      "full_name": "Vector Float Single Absolute Value",
      "summary": "Computes absolute value of floats in vector.",
      "syntax": "evfsabs RT, RA",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | 0 | 648",
        "hex_opcode": "0x10000288",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "648",
            "clean": "648"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (SPE Vector)",
      "slug": "evfsabs",
      "rel_url": "powerisa/evfsabs/",
      "linked_summary": "Computes absolute value of floats <a href=\"../../x86/in/\">in</a> vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evfsneg",
      "architecture": "PowerISA",
      "full_name": "Vector Float Single Negate",
      "summary": "Negates floats in vector.",
      "syntax": "evfsneg RT, RA",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | RA | 0 | 649",
        "hex_opcode": "0x10000289",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "649",
            "clean": "649"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (SPE Vector)",
      "slug": "evfsneg",
      "rel_url": "powerisa/evfsneg/",
      "linked_summary": "Negates floats <a href=\"../../x86/in/\">in</a> vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evfscfsi",
      "architecture": "PowerISA",
      "full_name": "Vector Float Single Convert From Signed Integer",
      "summary": "Converts vector of signed integers to floats.",
      "syntax": "evfscfsi RT, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | 0 | RB | 657",
        "hex_opcode": "0x10000291",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "657",
            "clean": "657"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RB",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (SPE Vector)",
      "slug": "evfscfsi",
      "rel_url": "powerisa/evfscfsi/",
      "linked_summary": "Converts vector of signed integers to floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "evfsctsi",
      "architecture": "PowerISA",
      "full_name": "Vector Float Single Convert To Signed Integer",
      "summary": "Converts vector of floats to signed integers.",
      "syntax": "evfsctsi RT, RB",
      "encoding": {
        "format": "SPE-form",
        "binary_pattern": "4 | RT | 0 | RB | 661",
        "hex_opcode": "0x10000295",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "661",
            "clean": "661"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RB",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (SPE Vector)",
      "slug": "evfsctsi",
      "rel_url": "powerisa/evfsctsi/",
      "linked_summary": "Converts vector of floats to signed integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "slw",
      "architecture": "PowerISA",
      "full_name": "Shift Left Word",
      "summary": "Shifts a 32-bit register left by the amount specified in RB.",
      "syntax": "slw RA, RS, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 24 | Rc",
        "hex_opcode": "0x7C000018",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "24",
            "clean": "24"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target Register"
        },
        {
          "name": "RS",
          "desc": "Source Register"
        },
        {
          "name": "RB",
          "desc": "Shift Amount Register"
        }
      ],
      "pseudocode": "n <- RB[58:63]; RA <- ROTL32(RS, n) & MASK(0, 31-n)",
      "example": "slw r3, r4, r5",
      "example_note": "r3 = r4 << r5 (32-bit).",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">n &lt;- RB[58:63]; RA &lt;- ROTL32(RS, n) &amp; MASK(0, 31-n)</code></pre>",
      "slug": "slw",
      "rel_url": "powerisa/slw/",
      "linked_summary": "Shifts a 32-<a href=\"../../armv8-a/bit/\">bit</a> register left by the amount specified <a href=\"../../x86/in/\">in</a> RB.",
      "linked_pseudocode": "n <- RB[58:63]; RA <- ROTL32(RS, n) & MASK(0, 31-n)"
    },
    {
      "mnemonic": "sld",
      "architecture": "PowerISA",
      "full_name": "Shift Left Doubleword",
      "summary": "Shifts a 64-bit register left by the amount specified in RB.",
      "syntax": "sld RA, RS, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 27 | Rc",
        "hex_opcode": "0x7C00001B",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "27",
            "clean": "27"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target Register"
        },
        {
          "name": "RS",
          "desc": "Source Register"
        },
        {
          "name": "RB",
          "desc": "Shift Amount Register"
        }
      ],
      "pseudocode": "n <- RB[57:63]; RA <- ROTL64(RS, n) & MASK(0, 63-n)",
      "example": "sld r3, r4, r5",
      "example_note": "r3 = r4 << r5 (64-bit).",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">n &lt;- RB[57:63]; RA &lt;- ROTL64(RS, n) &amp; MASK(0, 63-n)</code></pre>",
      "slug": "sld_1",
      "rel_url": "powerisa/sld_1/",
      "linked_summary": "Shifts a 64-<a href=\"../../armv8-a/bit/\">bit</a> register left by the amount specified <a href=\"../../x86/in/\">in</a> RB.",
      "linked_pseudocode": "n <- RB[57:63]; RA <- ROTL64(RS, n) & MASK(0, 63-n)"
    },
    {
      "mnemonic": "srw",
      "architecture": "PowerISA",
      "full_name": "Shift Right Word",
      "summary": "Performs a logical right shift (zeros shifted in) on a 32-bit word.",
      "syntax": "srw RA, RS, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 536 | Rc",
        "hex_opcode": "0x7C000438",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "536",
            "clean": "536"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target Register"
        },
        {
          "name": "RS",
          "desc": "Source Register"
        },
        {
          "name": "RB",
          "desc": "Shift Amount Register"
        }
      ],
      "pseudocode": "n <- RB[58:63]; RA <- ROTL32(RS, 64-n) & MASK(n, 31)",
      "example": "srw r3, r4, r5",
      "example_note": "r3 = r4 >> r5 (Unsigned 32-bit).",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">n &lt;- RB[58:63]; RA &lt;- ROTL32(RS, 64-n) &amp; MASK(n, 31)</code></pre>",
      "slug": "srw",
      "rel_url": "powerisa/srw/",
      "linked_summary": "Performs a logical right shift (zeros shifted <a href=\"../../x86/in/\">in</a>) on a 32-<a href=\"../../armv8-a/bit/\">bit</a> word.",
      "linked_pseudocode": "n <- RB[58:63]; RA <- ROTL32(RS, 64-n) & MASK(n, 31)"
    },
    {
      "mnemonic": "sraw",
      "architecture": "PowerISA",
      "full_name": "Shift Right Algebraic Word",
      "summary": "Performs an arithmetic right shift (sign bit replicated) on a 32-bit word. Updates Carry (CA) if bits are shifted out.",
      "syntax": "sraw RA, RS, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 792 | Rc",
        "hex_opcode": "0x7C000638",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "792",
            "clean": "792"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target Register"
        },
        {
          "name": "RS",
          "desc": "Source Register"
        },
        {
          "name": "RB",
          "desc": "Shift Amount Register"
        }
      ],
      "pseudocode": "n <- RB[58:63]; RA <- (RS) >>a n",
      "example": "sraw r3, r4, r5",
      "example_note": "r3 = r4 >> r5 (Signed 32-bit).",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">n &lt;- RB[58:63]; RA &lt;- (RS) &gt;&gt;a n</code></pre>",
      "slug": "sraw",
      "rel_url": "powerisa/sraw/",
      "linked_summary": "Performs an arithmetic right shift (sign <a href=\"../../armv8-a/bit/\">bit</a> replicated) on a 32-<a href=\"../../armv8-a/bit/\">bit</a> word. Updates Carry (CA) if bits are shifted <a href=\"../../x86/out/\">out</a>.",
      "linked_pseudocode": "n <- RB[58:63]; RA <- (RS) >>a n"
    },
    {
      "mnemonic": "srawi",
      "architecture": "PowerISA",
      "full_name": "Shift Right Algebraic Word Immediate",
      "summary": "Performs an arithmetic right shift on a 32-bit word by a constant amount.",
      "syntax": "srawi RA, RS, SH",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | SH | 824 | Rc",
        "hex_opcode": "0x7C000670",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "SH",
            "clean": "SH"
          },
          {
            "raw": "824",
            "clean": "824"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target Register"
        },
        {
          "name": "RS",
          "desc": "Source Register"
        },
        {
          "name": "SH",
          "desc": "Shift Amount (0-31)"
        }
      ],
      "pseudocode": "RA <- (RS) >>a SH",
      "example": "srawi r3, r4, 5",
      "example_note": "r3 = r4 >> 5 (Signed).",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RA &lt;- (RS) &gt;&gt;a SH</code></pre>",
      "slug": "srawi",
      "rel_url": "powerisa/srawi/",
      "linked_summary": "Performs an arithmetic right shift on a 32-<a href=\"../../armv8-a/bit/\">bit</a> word by a constant amount.",
      "linked_pseudocode": "RA <- (RS) >>a <a href=\"../../risc-v/sh/\">SH</a>"
    },
    {
      "mnemonic": "sradi",
      "architecture": "PowerISA",
      "full_name": "Shift Right Algebraic Doubleword Immediate",
      "summary": "Performs an arithmetic right shift on a 64-bit doubleword by a constant amount.",
      "syntax": "sradi RA, RS, SH",
      "encoding": {
        "format": "XS-form",
        "binary_pattern": "31 | RS | RA | SH | 413 | Rc",
        "hex_opcode": "0x7C00033C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "SH",
            "clean": "SH"
          },
          {
            "raw": "413",
            "clean": "413"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target Register"
        },
        {
          "name": "RS",
          "desc": "Source Register"
        },
        {
          "name": "SH",
          "desc": "Shift Amount (0-63, Split field)"
        }
      ],
      "pseudocode": "RA <- (RS) >>a SH",
      "example": "sradi r3, r4, 10",
      "example_note": "r3 = r4 >> 10 (Signed 64-bit).",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RA &lt;- (RS) &gt;&gt;a SH</code></pre>",
      "slug": "sradi_1",
      "rel_url": "powerisa/sradi_1/",
      "linked_summary": "Performs an arithmetic right shift on a 64-<a href=\"../../armv8-a/bit/\">bit</a> doubleword by a constant amount.",
      "linked_pseudocode": "RA <- (RS) >>a <a href=\"../../risc-v/sh/\">SH</a>"
    },
    {
      "mnemonic": "stb",
      "architecture": "PowerISA",
      "full_name": "Store Byte",
      "summary": "Stores the low 8 bits of a register to memory.",
      "syntax": "stb RS, D(RA)",
      "encoding": {
        "format": "D-form",
        "binary_pattern": "38 | RS | RA | D",
        "hex_opcode": "0x98000000",
        "visual_parts": [
          {
            "raw": "38",
            "clean": "38"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D",
            "clean": "D"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source Register"
        },
        {
          "name": "D",
          "desc": "Displacement"
        },
        {
          "name": "RA",
          "desc": "Base Register"
        }
      ],
      "pseudocode": "MEM(EA, 1) <- RS[56:63]",
      "example": "stb r3, 0(r4)",
      "example_note": "Store byte from r3 to address r4.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">MEM(EA, 1) &lt;- RS[56:63]</code></pre>",
      "slug": "stb",
      "rel_url": "powerisa/stb/",
      "linked_summary": "Stores the low 8 bits of a register to memory.",
      "linked_pseudocode": "MEM(EA, 1) <- RS[56:63]"
    },
    {
      "mnemonic": "sth",
      "architecture": "PowerISA",
      "full_name": "Store Halfword",
      "summary": "Stores the low 16 bits of a register to memory.",
      "syntax": "sth RS, D(RA)",
      "encoding": {
        "format": "D-form",
        "binary_pattern": "44 | RS | RA | D",
        "hex_opcode": "0xB0000000",
        "visual_parts": [
          {
            "raw": "44",
            "clean": "44"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D",
            "clean": "D"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source Register"
        },
        {
          "name": "D",
          "desc": "Displacement"
        },
        {
          "name": "RA",
          "desc": "Base Register"
        }
      ],
      "pseudocode": "MEM(EA, 2) <- RS[48:63]",
      "example": "sth r3, 0(r4)",
      "example_note": "Store 16-bit halfword.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">MEM(EA, 2) &lt;- RS[48:63]</code></pre>",
      "slug": "sth",
      "rel_url": "powerisa/sth/",
      "linked_summary": "Stores the low 16 bits of a register to memory.",
      "linked_pseudocode": "MEM(EA, 2) <- RS[48:63]"
    },
    {
      "mnemonic": "stw",
      "architecture": "PowerISA",
      "full_name": "Store Word",
      "summary": "Stores the low 32 bits of a register to memory.",
      "syntax": "stw RS, D(RA)",
      "encoding": {
        "format": "D-form",
        "binary_pattern": "36 | RS | RA | D",
        "hex_opcode": "0x90000000",
        "visual_parts": [
          {
            "raw": "36",
            "clean": "36"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D",
            "clean": "D"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source Register"
        },
        {
          "name": "D",
          "desc": "Displacement"
        },
        {
          "name": "RA",
          "desc": "Base Register"
        }
      ],
      "pseudocode": "MEM(EA, 4) <- RS[32:63]",
      "example": "stw r3, 0(r4)",
      "example_note": "Store 32-bit word.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">MEM(EA, 4) &lt;- RS[32:63]</code></pre>",
      "slug": "stw",
      "rel_url": "powerisa/stw/",
      "linked_summary": "Stores the low 32 bits of a register to memory.",
      "linked_pseudocode": "MEM(EA, 4) <- RS[32:63]"
    },
    {
      "mnemonic": "std",
      "architecture": "PowerISA",
      "full_name": "Store Doubleword",
      "summary": "Stores a 64-bit doubleword to memory.",
      "syntax": "std RS, DS(RA)",
      "encoding": {
        "format": "DS-form",
        "binary_pattern": "62 | RS | RA | DS | 00",
        "hex_opcode": "0xF8000000",
        "visual_parts": [
          {
            "raw": "62",
            "clean": "62"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "DS",
            "clean": "DS"
          },
          {
            "raw": "00",
            "clean": "00"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source Register"
        },
        {
          "name": "DS",
          "desc": "Displacement (Multiple of 4)"
        },
        {
          "name": "RA",
          "desc": "Base Register"
        }
      ],
      "pseudocode": "MEM(EA, 8) <- RS",
      "example": "std r3, 16(r4)",
      "example_note": "Store 64-bit value.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">MEM(EA, 8) &lt;- RS</code></pre>",
      "slug": "std",
      "rel_url": "powerisa/std/",
      "linked_summary": "Stores a 64-<a href=\"../../armv8-a/bit/\">bit</a> doubleword to memory.",
      "linked_pseudocode": "MEM(EA, 8) <- RS"
    },
    {
      "mnemonic": "trap",
      "architecture": "PowerISA",
      "full_name": "Trap (Pseudo)",
      "summary": "Unconditional trap. Forces an exception. (Encoded as tw 31, 0, 0).",
      "syntax": "trap",
      "encoding": {
        "format": "Pseudo",
        "binary_pattern": "tw 31, r0, r0",
        "hex_opcode": "0x7FE00008",
        "visual_parts": [
          {
            "raw": "tw 31, r0, r0",
            "clean": "tw 31, r0, r0"
          }
        ]
      },
      "operands": [],
      "pseudocode": "Trap()",
      "example": "trap",
      "example_note": "Crash/Breakpoint.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">Trap()</code></pre>",
      "slug": "trap",
      "rel_url": "powerisa/trap/",
      "linked_summary": "Unconditional <a href=\"../../powerisa/trap/\">trap</a>. Forces an exception. (Encoded as <a href=\"../../powerisa/tw/\">tw</a> 31, 0, 0).",
      "linked_pseudocode": "Trap()"
    },
    {
      "mnemonic": "xor",
      "architecture": "PowerISA",
      "full_name": "XOR",
      "summary": "Performs a bitwise Exclusive OR comparison.",
      "syntax": "xor RA, RS, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 316 | Rc",
        "hex_opcode": "0x7C000278",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "316",
            "clean": "316"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target Register"
        },
        {
          "name": "RS",
          "desc": "Source Register 1"
        },
        {
          "name": "RB",
          "desc": "Source Register 2"
        }
      ],
      "pseudocode": "RA <- RS XOR RB",
      "example": "xor r3, r4, r5",
      "example_note": "r3 = r4 ^ r5",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RA &lt;- RS XOR RB</code></pre>",
      "slug": "xor",
      "rel_url": "powerisa/xor/",
      "linked_summary": "Performs a bitwise Exclusive <a href=\"../../risc-v/or/\">OR</a> comparison.",
      "linked_pseudocode": "RA <- RS <a href=\"../../risc-v/xor/\">XOR</a> RB"
    },
    {
      "mnemonic": "xori",
      "architecture": "PowerISA",
      "full_name": "XOR Immediate",
      "summary": "Performs a bitwise XOR with a 16-bit unsigned immediate.",
      "syntax": "xori RA, RS, UI",
      "encoding": {
        "format": "D-form",
        "binary_pattern": "26 | RS | RA | UI",
        "hex_opcode": "0x68000000",
        "visual_parts": [
          {
            "raw": "26",
            "clean": "26"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "UI",
            "clean": "UI"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target Register"
        },
        {
          "name": "RS",
          "desc": "Source Register"
        },
        {
          "name": "UI",
          "desc": "Unsigned 16-bit Immediate"
        }
      ],
      "pseudocode": "RA <- RS XOR (0x0000 || UI)",
      "example": "xori r3, r4, 0x1",
      "example_note": "Toggle bit 0.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RA &lt;- RS XOR (0x0000 || UI)</code></pre>",
      "slug": "xori",
      "rel_url": "powerisa/xori/",
      "linked_summary": "Performs a bitwise <a href=\"../../risc-v/xor/\">XOR</a> with a 16-<a href=\"../../armv8-a/bit/\">bit</a> unsigned immediate.",
      "linked_pseudocode": "RA <- RS <a href=\"../../risc-v/xor/\">XOR</a> (0x0000 || UI)"
    },
    {
      "mnemonic": "xoris",
      "architecture": "PowerISA",
      "full_name": "XOR Immediate Shifted",
      "summary": "Performs a bitwise XOR with a 16-bit immediate shifted left by 16 bits.",
      "syntax": "xoris RA, RS, UI",
      "encoding": {
        "format": "D-form",
        "binary_pattern": "27 | RS | RA | UI",
        "hex_opcode": "0x6C000000",
        "visual_parts": [
          {
            "raw": "27",
            "clean": "27"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "UI",
            "clean": "UI"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target Register"
        },
        {
          "name": "RS",
          "desc": "Source Register"
        },
        {
          "name": "UI",
          "desc": "Unsigned 16-bit Immediate"
        }
      ],
      "pseudocode": "RA <- RS XOR (UI || 0x0000)",
      "example": "xoris r3, r4, 0xFFFF",
      "example_note": "Toggle upper 16 bits.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RA &lt;- RS XOR (UI || 0x0000)</code></pre>",
      "slug": "xoris",
      "rel_url": "powerisa/xoris/",
      "linked_summary": "Performs a bitwise <a href=\"../../risc-v/xor/\">XOR</a> with a 16-<a href=\"../../armv8-a/bit/\">bit</a> immediate shifted left by 16 bits.",
      "linked_pseudocode": "RA <- RS <a href=\"../../risc-v/xor/\">XOR</a> (UI || 0x0000)"
    },
    {
      "mnemonic": "xvsubdp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Subtract Double-Precision",
      "summary": "Subtracts two pairs of double-precision floats. (vD = vA - vB)",
      "syntax": "xvsubdp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 104",
        "hex_opcode": "0xF0000068",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "104",
            "clean": "104"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xvsubdp",
      "rel_url": "powerisa/xvsubdp/",
      "linked_summary": "Subtracts two pairs of double-precision floats. (vD = vA - vB)",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvmuldp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Multiply Double-Precision",
      "summary": "Multiplies two pairs of double-precision floats.",
      "syntax": "xvmuldp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 112",
        "hex_opcode": "0xF0000070",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "112",
            "clean": "112"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xvmuldp",
      "rel_url": "powerisa/xvmuldp/",
      "linked_summary": "Multiplies two pairs of double-precision floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvdivdp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Divide Double-Precision",
      "summary": "Divides two pairs of double-precision floats.",
      "syntax": "xvdivdp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 120",
        "hex_opcode": "0xF0000078",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "120",
            "clean": "120"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xvdivdp",
      "rel_url": "powerisa/xvdivdp/",
      "linked_summary": "Divides two pairs of double-precision floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvabsdp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Absolute Value Double-Precision",
      "summary": "Computes absolute value for two double-precision floats.",
      "syntax": "xvabsdp XT, XB",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | 0 | XB | 473",
        "hex_opcode": "0xF00001D9",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "473",
            "clean": "473"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        }
      ],
      "extension": "VSX",
      "slug": "xvabsdp",
      "rel_url": "powerisa/xvabsdp/",
      "linked_summary": "Computes absolute value for two double-precision floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvnegdp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Negate Double-Precision",
      "summary": "Negates two double-precision floats.",
      "syntax": "xvnegdp XT, XB",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | 0 | XB | 489",
        "hex_opcode": "0xF00001E9",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "489",
            "clean": "489"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        }
      ],
      "extension": "VSX",
      "slug": "xvnegdp",
      "rel_url": "powerisa/xvnegdp/",
      "linked_summary": "Negates two double-precision floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvsqrtdp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Square Root Double-Precision",
      "summary": "Computes square root for two double-precision floats.",
      "syntax": "xvsqrtdp XT, XB",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | 0 | XB | 203",
        "hex_opcode": "0xF00000CB",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "203",
            "clean": "203"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        }
      ],
      "extension": "VSX",
      "slug": "xvsqrtdp",
      "rel_url": "powerisa/xvsqrtdp/",
      "linked_summary": "Computes square root for two double-precision floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvmaxdp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Maximum Double-Precision",
      "summary": "Selects maximum value for two pairs of doubles.",
      "syntax": "xvmaxdp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 224",
        "hex_opcode": "0xF00000E0",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "224",
            "clean": "224"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xvmaxdp",
      "rel_url": "powerisa/xvmaxdp/",
      "linked_summary": "Selects maximum value for two pairs of doubles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvmindp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Minimum Double-Precision",
      "summary": "Selects minimum value for two pairs of doubles.",
      "syntax": "xvmindp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 232",
        "hex_opcode": "0xF00000E8",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "232",
            "clean": "232"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xvmindp",
      "rel_url": "powerisa/xvmindp/",
      "linked_summary": "Selects minimum value for two pairs of doubles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvcmpeqdp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Compare Equal Double-Precision",
      "summary": "Compares doubles for equality. Sets result to all 1s or 0s.",
      "syntax": "xvcmpeqdp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 99",
        "hex_opcode": "0xF0000063",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "99",
            "clean": "99"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xvcmpeqdp",
      "rel_url": "powerisa/xvcmpeqdp/",
      "linked_summary": "Compares doubles for equality. Sets result to all 1s <a href=\"../../powerisa/or/\">or</a> 0s.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvcmpgtdp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Compare Greater Than Double-Precision",
      "summary": "Compares doubles (A > B).",
      "syntax": "xvcmpgtdp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 107",
        "hex_opcode": "0xF000006B",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "107",
            "clean": "107"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xvcmpgtdp",
      "rel_url": "powerisa/xvcmpgtdp/",
      "linked_summary": "Compares doubles (A > B).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvcmpgedp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Compare Greater or Equal Double-Precision",
      "summary": "Compares doubles (A >= B).",
      "syntax": "xvcmpgedp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 115",
        "hex_opcode": "0xF0000073",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "115",
            "clean": "115"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xvcmpgedp",
      "rel_url": "powerisa/xvcmpgedp/",
      "linked_summary": "Compares doubles (A >= B).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvaddsp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Add Single-Precision",
      "summary": "Adds four single-precision floats.",
      "syntax": "xvaddsp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 64",
        "hex_opcode": "0xF0000040",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "64",
            "clean": "64"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xvaddsp",
      "rel_url": "powerisa/xvaddsp/",
      "linked_summary": "Adds four single-precision floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvsubsp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Subtract Single-Precision",
      "summary": "Subtracts four single-precision floats.",
      "syntax": "xvsubsp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 72",
        "hex_opcode": "0xF0000048",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "72",
            "clean": "72"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xvsubsp",
      "rel_url": "powerisa/xvsubsp/",
      "linked_summary": "Subtracts four single-precision floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvmulsp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Multiply Single-Precision",
      "summary": "Multiplies four single-precision floats.",
      "syntax": "xvmulsp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 80",
        "hex_opcode": "0xF0000050",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "80",
            "clean": "80"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xvmulsp",
      "rel_url": "powerisa/xvmulsp/",
      "linked_summary": "Multiplies four single-precision floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvdivsp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Divide Single-Precision",
      "summary": "Divides four single-precision floats.",
      "syntax": "xvdivsp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 88",
        "hex_opcode": "0xF0000058",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "88",
            "clean": "88"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xvdivsp",
      "rel_url": "powerisa/xvdivsp/",
      "linked_summary": "Divides four single-precision floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvabssp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Absolute Value Single-Precision",
      "summary": "Computes absolute value for four single-precision floats.",
      "syntax": "xvabssp XT, XB",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | 0 | XB | 409",
        "hex_opcode": "0xF0000199",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "409",
            "clean": "409"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        }
      ],
      "extension": "VSX",
      "slug": "xvabssp",
      "rel_url": "powerisa/xvabssp/",
      "linked_summary": "Computes absolute value for four single-precision floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvnegsp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Negate Single-Precision",
      "summary": "Negates four single-precision floats.",
      "syntax": "xvnegsp XT, XB",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | 0 | XB | 425",
        "hex_opcode": "0xF00001A9",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "425",
            "clean": "425"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        }
      ],
      "extension": "VSX",
      "slug": "xvnegsp",
      "rel_url": "powerisa/xvnegsp/",
      "linked_summary": "Negates four single-precision floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvsqrtsp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Square Root Single-Precision",
      "summary": "Computes square root for four single-precision floats.",
      "syntax": "xvsqrtsp XT, XB",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | 0 | XB | 139",
        "hex_opcode": "0xF000008B",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "139",
            "clean": "139"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        }
      ],
      "extension": "VSX",
      "slug": "xvsqrtsp",
      "rel_url": "powerisa/xvsqrtsp/",
      "linked_summary": "Computes square root for four single-precision floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvmaxsp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Maximum Single-Precision",
      "summary": "Selects maximum value for four floats.",
      "syntax": "xvmaxsp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 192",
        "hex_opcode": "0xF00000C0",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "192",
            "clean": "192"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xvmaxsp",
      "rel_url": "powerisa/xvmaxsp/",
      "linked_summary": "Selects maximum value for four floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvminsp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Minimum Single-Precision",
      "summary": "Selects minimum value for four floats.",
      "syntax": "xvminsp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 200",
        "hex_opcode": "0xF00000C8",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "200",
            "clean": "200"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xvminsp",
      "rel_url": "powerisa/xvminsp/",
      "linked_summary": "Selects minimum value for four floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvcmpeqsp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Compare Equal Single-Precision",
      "summary": "Compares four floats for equality.",
      "syntax": "xvcmpeqsp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 67",
        "hex_opcode": "0xF0000043",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "67",
            "clean": "67"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xvcmpeqsp",
      "rel_url": "powerisa/xvcmpeqsp/",
      "linked_summary": "Compares four floats for equality.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvcmpgtsp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Compare Greater Than Single-Precision",
      "summary": "Compares four floats (A > B).",
      "syntax": "xvcmpgtsp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 75",
        "hex_opcode": "0xF000004B",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "75",
            "clean": "75"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xvcmpgtsp",
      "rel_url": "powerisa/xvcmpgtsp/",
      "linked_summary": "Compares four floats (A > B).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvcmpgesp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Compare Greater or Equal Single-Precision",
      "summary": "Compares four floats (A >= B).",
      "syntax": "xvcmpgesp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 83",
        "hex_opcode": "0xF0000053",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "83",
            "clean": "83"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xvcmpgesp",
      "rel_url": "powerisa/xvcmpgesp/",
      "linked_summary": "Compares four floats (A >= B).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xscvdpsxds",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Convert Double to Signed Doubleword",
      "summary": "Converts scalar Double to 64-bit Signed Integer.",
      "syntax": "xscvdpsxds XT, XB",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | 0 | XB | 344",
        "hex_opcode": "0xF0000158",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "344",
            "clean": "344"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        }
      ],
      "extension": "VSX",
      "slug": "xscvdpsxds",
      "rel_url": "powerisa/xscvdpsxds/",
      "linked_summary": "Converts scalar Double to 64-<a href=\"../../armv8-a/bit/\">bit</a> Signed Integer.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xscvdpuxds",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Convert Double to Unsigned Doubleword",
      "summary": "Converts scalar Double to 64-bit Unsigned Integer.",
      "syntax": "xscvdpuxds XT, XB",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | 0 | XB | 328",
        "hex_opcode": "0xF0000148",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "328",
            "clean": "328"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        }
      ],
      "extension": "VSX",
      "slug": "xscvdpuxds",
      "rel_url": "powerisa/xscvdpuxds/",
      "linked_summary": "Converts scalar Double to 64-<a href=\"../../armv8-a/bit/\">bit</a> Unsigned Integer.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xscvspdp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Convert Single to Double",
      "summary": "Promotes a Single to a Double.",
      "syntax": "xscvspdp XT, XB",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | 0 | XB | 408",
        "hex_opcode": "0xF0000198",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "408",
            "clean": "408"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        }
      ],
      "extension": "VSX",
      "slug": "xscvspdp",
      "rel_url": "powerisa/xscvspdp/",
      "linked_summary": "Promotes a Single to a Double.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xscvdpsp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Convert Double to Single",
      "summary": "Demotes a Double to a Single.",
      "syntax": "xscvdpsp XT, XB",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | 0 | XB | 264",
        "hex_opcode": "0xF0000108",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "264",
            "clean": "264"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        }
      ],
      "extension": "VSX",
      "slug": "xscvdpsp",
      "rel_url": "powerisa/xscvdpsp/",
      "linked_summary": "Demotes a Double to a Single.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvcvdpsp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Convert Double to Single",
      "summary": "Converts two doubles to two floats.",
      "syntax": "xvcvdpsp XT, XB",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | 0 | XB | 393",
        "hex_opcode": "0xF0000189",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "393",
            "clean": "393"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        }
      ],
      "extension": "VSX",
      "slug": "xvcvdpsp",
      "rel_url": "powerisa/xvcvdpsp/",
      "linked_summary": "Converts two doubles to two floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvcvspdp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Convert Single to Double",
      "summary": "Converts two floats to two doubles.",
      "syntax": "xvcvspdp XT, XB",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | 0 | XB | 457",
        "hex_opcode": "0xF00001C9",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "457",
            "clean": "457"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        }
      ],
      "extension": "VSX",
      "slug": "xvcvspdp",
      "rel_url": "powerisa/xvcvspdp/",
      "linked_summary": "Converts two floats to two doubles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvcvdpsxds",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Convert Double to Signed Doubleword",
      "summary": "Converts two doubles to two 64-bit signed integers.",
      "syntax": "xvcvdpsxds XT, XB",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | 0 | XB | 472",
        "hex_opcode": "0xF00001D8",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "472",
            "clean": "472"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        }
      ],
      "extension": "VSX",
      "slug": "xvcvdpsxds",
      "rel_url": "powerisa/xvcvdpsxds/",
      "linked_summary": "Converts two doubles to two 64-<a href=\"../../armv8-a/bit/\">bit</a> signed integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvcvdpuxds",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Convert Double to Unsigned Doubleword",
      "summary": "Converts two doubles to two 64-bit unsigned integers.",
      "syntax": "xvcvdpuxds XT, XB",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | 0 | XB | 456",
        "hex_opcode": "0xF00001C8",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "456",
            "clean": "456"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        }
      ],
      "extension": "VSX",
      "slug": "xvcvdpuxds",
      "rel_url": "powerisa/xvcvdpuxds/",
      "linked_summary": "Converts two doubles to two 64-<a href=\"../../armv8-a/bit/\">bit</a> unsigned integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvcvspsxds",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Convert Single to Signed Doubleword",
      "summary": "Converts two floats to two 64-bit signed integers.",
      "syntax": "xvcvspsxds XT, XB",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | 0 | XB | 408",
        "hex_opcode": "0xF0000198",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "408",
            "clean": "408"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        }
      ],
      "extension": "VSX",
      "slug": "xvcvspsxds",
      "rel_url": "powerisa/xvcvspsxds/",
      "linked_summary": "Converts two floats to two 64-<a href=\"../../armv8-a/bit/\">bit</a> signed integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvcvsxwsp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Convert Signed Word to Single",
      "summary": "Converts four 32-bit signed integers to four floats.",
      "syntax": "xvcvsxwsp XT, XB",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | 0 | XB | 168",
        "hex_opcode": "0xF00000A8",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "168",
            "clean": "168"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        }
      ],
      "extension": "VSX",
      "slug": "xvcvsxwsp",
      "rel_url": "powerisa/xvcvsxwsp/",
      "linked_summary": "Converts four 32-<a href=\"../../armv8-a/bit/\">bit</a> signed integers to four floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvcvuxwsp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Convert Unsigned Word to Single",
      "summary": "Converts four 32-bit unsigned integers to four floats.",
      "syntax": "xvcvuxwsp XT, XB",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | 0 | XB | 136",
        "hex_opcode": "0xF0000088",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "136",
            "clean": "136"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        }
      ],
      "extension": "VSX",
      "slug": "xvcvuxwsp",
      "rel_url": "powerisa/xvcvuxwsp/",
      "linked_summary": "Converts four 32-<a href=\"../../armv8-a/bit/\">bit</a> unsigned integers to four floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxspltiw",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Splat Immediate Word",
      "summary": "Spatially duplicates a 32-bit immediate into all 4 words of the target.",
      "syntax": "xxspltiw XT, IMM",
      "encoding": {
        "format": "8RR:D-form",
        "binary_pattern": "60 | XT | ...",
        "hex_opcode": "0xF0000000...",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "IMM",
          "desc": "32-bit Value"
        }
      ],
      "extension": "VSX",
      "slug": "xxspltiw",
      "rel_url": "powerisa/xxspltiw/",
      "linked_summary": "Spatially duplicates a 32-<a href=\"../../armv8-a/bit/\">bit</a> immediate into all 4 words of the target.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxspltidp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Splat Immediate Double-Precision",
      "summary": "Spatially duplicates a 32-bit immediate (converted to double) into both double elements.",
      "syntax": "xxspltidp XT, IMM",
      "encoding": {
        "format": "8RR:D-form",
        "binary_pattern": "60 | XT | ...",
        "hex_opcode": "0xF0000000...",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "IMM",
          "desc": "32-bit Value"
        }
      ],
      "extension": "VSX",
      "slug": "xxspltidp",
      "rel_url": "powerisa/xxspltidp/",
      "linked_summary": "Spatially duplicates a 32-<a href=\"../../armv8-a/bit/\">bit</a> immediate (converted to double) into both double elements.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxmrghd",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Merge High Doubleword",
      "summary": "Merges high doublewords from XA and XB.",
      "syntax": "xxmrghd XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 144",
        "hex_opcode": "0xF0000090",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "144",
            "clean": "144"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xxmrghd",
      "rel_url": "powerisa/xxmrghd/",
      "linked_summary": "Merges high doublewords from XA <a href=\"../../armv8-a/and_6/\">and</a> XB.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxmrgld",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Merge Low Doubleword",
      "summary": "Merges low doublewords from XA and XB.",
      "syntax": "xxmrgld XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 208",
        "hex_opcode": "0xF00000D0",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "208",
            "clean": "208"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xxmrgld",
      "rel_url": "powerisa/xxmrgld/",
      "linked_summary": "Merges low doublewords from XA <a href=\"../../armv8-a/and_6/\">and</a> XB.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxswapd",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Swap Doubleword",
      "summary": "Swaps the two doublewords in the register.",
      "syntax": "xxswapd XT, XB",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | 0 | XB | 250",
        "hex_opcode": "0xF00000FA",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "250",
            "clean": "250"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        }
      ],
      "extension": "VSX",
      "slug": "xxswapd",
      "rel_url": "powerisa/xxswapd/",
      "linked_summary": "Swaps the two doublewords <a href=\"../../x86/in/\">in</a> the register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxsel",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Select",
      "summary": "Bitwise select between XA and XB based on XC.",
      "syntax": "xxsel XT, XA, XB, XC",
      "encoding": {
        "format": "XX4-form",
        "binary_pattern": "60 | XT | XA | XB | XC | 3",
        "hex_opcode": "0xF0000003",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "XC",
            "clean": "XC"
          },
          {
            "raw": "3",
            "clean": "3"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "True Src"
        },
        {
          "name": "XB",
          "desc": "False Src"
        },
        {
          "name": "XC",
          "desc": "Mask"
        }
      ],
      "extension": "VSX",
      "slug": "xxsel",
      "rel_url": "powerisa/xxsel/",
      "linked_summary": "Bitwise select between XA <a href=\"../../armv8-a/and_6/\">and</a> XB based on XC.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxlor",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Logical OR",
      "summary": "Bitwise OR.",
      "syntax": "xxlor XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 448",
        "hex_opcode": "0xF00001C0",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "448",
            "clean": "448"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xxlor",
      "rel_url": "powerisa/xxlor/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/or/\">OR</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxlxor",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Logical XOR",
      "summary": "Bitwise XOR.",
      "syntax": "xxlxor XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 456",
        "hex_opcode": "0xF00001C8",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "456",
            "clean": "456"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xxlxor",
      "rel_url": "powerisa/xxlxor/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/xor/\">XOR</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxland",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Logical AND",
      "summary": "Bitwise AND.",
      "syntax": "xxland XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 440",
        "hex_opcode": "0xF00001B8",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "440",
            "clean": "440"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xxland",
      "rel_url": "powerisa/xxland/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/and/\">AND</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxlnor",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Logical NOR",
      "summary": "Bitwise NOR.",
      "syntax": "xxlnor XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 464",
        "hex_opcode": "0xF00001D0",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "464",
            "clean": "464"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xxlnor",
      "rel_url": "powerisa/xxlnor/",
      "linked_summary": "Bitwise NOR.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmulouw",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Odd Unsigned Word",
      "summary": "Multiplies odd words (1,3) to 64-bit result.",
      "syntax": "vmulouw vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 136",
        "hex_opcode": "0x10000088",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "136",
            "clean": "136"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vmulouw",
      "rel_url": "powerisa/vmulouw/",
      "linked_summary": "Multiplies odd words (1,3) to 64-<a href=\"../../armv8-a/bit/\">bit</a> result.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmulosw",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Odd Signed Word",
      "summary": "Multiplies odd words (1,3) to 64-bit signed result.",
      "syntax": "vmulosw vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 392",
        "hex_opcode": "0x10000188",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "392",
            "clean": "392"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vmulosw",
      "rel_url": "powerisa/vmulosw/",
      "linked_summary": "Multiplies odd words (1,3) to 64-<a href=\"../../armv8-a/bit/\">bit</a> signed result.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmuleuw",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Even Unsigned Word",
      "summary": "Multiplies even words (0,2) to 64-bit result.",
      "syntax": "vmuleuw vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 136",
        "hex_opcode": "0x10000088",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "136",
            "clean": "136"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vmuleuw",
      "rel_url": "powerisa/vmuleuw/",
      "linked_summary": "Multiplies even words (0,2) to 64-<a href=\"../../armv8-a/bit/\">bit</a> result.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmulesw",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Even Signed Word",
      "summary": "Multiplies even words (0,2) to 64-bit signed result.",
      "syntax": "vmulesw vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 392",
        "hex_opcode": "0x10000188",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "392",
            "clean": "392"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vmulesw",
      "rel_url": "powerisa/vmulesw/",
      "linked_summary": "Multiplies even words (0,2) to 64-<a href=\"../../armv8-a/bit/\">bit</a> signed result.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmsumubm",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply-Sum Unsigned Byte Modulo",
      "summary": "Multiplies bytes and sums adjacent results into words.",
      "syntax": "vmsumubm vD, vA, vB, vC",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | vC | 36",
        "hex_opcode": "0x10000024",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "vC",
            "clean": "vC"
          },
          {
            "raw": "36",
            "clean": "36"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        },
        {
          "name": "vC",
          "desc": "Accumulator"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vmsumubm",
      "rel_url": "powerisa/vmsumubm/",
      "linked_summary": "Multiplies bytes <a href=\"../../armv8-a/and_6/\">and</a> sums adjacent results into words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmsumshm",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply-Sum Signed Halfword Modulo",
      "summary": "Multiplies halfwords and sums adjacent results into words.",
      "syntax": "vmsumshm vD, vA, vB, vC",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | vC | 40",
        "hex_opcode": "0x10000028",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "vC",
            "clean": "vC"
          },
          {
            "raw": "40",
            "clean": "40"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        },
        {
          "name": "vC",
          "desc": "Accumulator"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vmsumshm",
      "rel_url": "powerisa/vmsumshm/",
      "linked_summary": "Multiplies halfwords <a href=\"../../armv8-a/and_6/\">and</a> sums adjacent results into words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmsumshs",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply-Sum Signed Halfword Saturate",
      "summary": "Multiplies halfwords and sums with saturation.",
      "syntax": "vmsumshs vD, vA, vB, vC",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | vC | 41",
        "hex_opcode": "0x10000029",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "vC",
            "clean": "vC"
          },
          {
            "raw": "41",
            "clean": "41"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        },
        {
          "name": "vC",
          "desc": "Accumulator"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vmsumshs",
      "rel_url": "powerisa/vmsumshs/",
      "linked_summary": "Multiplies halfwords <a href=\"../../armv8-a/and_6/\">and</a> sums with saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsum4ubs",
      "architecture": "PowerISA",
      "full_name": "Vector Sum-across Partial (1/4) Unsigned Byte Saturate",
      "summary": "Sums every 4 bytes into a word.",
      "syntax": "vsum4ubs vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 1632",
        "hex_opcode": "0x10000660",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1632",
            "clean": "1632"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Accumulator"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vsum4ubs",
      "rel_url": "powerisa/vsum4ubs/",
      "linked_summary": "Sums every 4 bytes into a word.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsum4sbs",
      "architecture": "PowerISA",
      "full_name": "Vector Sum-across Partial (1/4) Signed Byte Saturate",
      "summary": "Sums every 4 signed bytes into a word.",
      "syntax": "vsum4sbs vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 1888",
        "hex_opcode": "0x10000760",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1888",
            "clean": "1888"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Accumulator"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vsum4sbs",
      "rel_url": "powerisa/vsum4sbs/",
      "linked_summary": "Sums every 4 signed bytes into a word.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsum4shs",
      "architecture": "PowerISA",
      "full_name": "Vector Sum-across Partial (1/4) Signed Halfword Saturate",
      "summary": "Sums every 2 halfwords into a word.",
      "syntax": "vsum4shs vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 1608",
        "hex_opcode": "0x10000648",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1608",
            "clean": "1608"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Accumulator"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vsum4shs",
      "rel_url": "powerisa/vsum4shs/",
      "linked_summary": "Sums every 2 halfwords into a word.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsum2sws",
      "architecture": "PowerISA",
      "full_name": "Vector Sum-across Partial (1/2) Signed Word Saturate",
      "summary": "Sums pairs of words into signed words.",
      "syntax": "vsum2sws vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 1672",
        "hex_opcode": "0x10000688",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1672",
            "clean": "1672"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Accumulator"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vsum2sws",
      "rel_url": "powerisa/vsum2sws/",
      "linked_summary": "Sums pairs of words into signed words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsumsws",
      "architecture": "PowerISA",
      "full_name": "Vector Sum-across Signed Word Saturate",
      "summary": "Sums all 4 words into a single word result.",
      "syntax": "vsumsws vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 1928",
        "hex_opcode": "0x10000788",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1928",
            "clean": "1928"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Accumulator"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vsumsws",
      "rel_url": "powerisa/vsumsws/",
      "linked_summary": "Sums all 4 words into a single word result.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vaddfp",
      "architecture": "PowerISA",
      "full_name": "Vector Add Floating-Point",
      "summary": "Adds four single-precision floats (Classic VMX).",
      "syntax": "vaddfp vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 10",
        "hex_opcode": "0x1000000A",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "10",
            "clean": "10"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vaddfp",
      "rel_url": "powerisa/vaddfp/",
      "linked_summary": "Adds four single-precision floats (Classic VMX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsubfp",
      "architecture": "PowerISA",
      "full_name": "Vector Subtract Floating-Point",
      "summary": "Subtracts four single-precision floats (Classic VMX).",
      "syntax": "vsubfp vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 74",
        "hex_opcode": "0x1000004A",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "74",
            "clean": "74"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vsubfp",
      "rel_url": "powerisa/vsubfp/",
      "linked_summary": "Subtracts four single-precision floats (Classic VMX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmulfp",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Floating-Point",
      "summary": "Multiplies four single-precision floats (Classic VMX).",
      "syntax": "vmulfp vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 74",
        "hex_opcode": "0x1000004A",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "74",
            "clean": "74"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vmulfp",
      "rel_url": "powerisa/vmulfp/",
      "linked_summary": "Multiplies four single-precision floats (Classic VMX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vctuxs",
      "architecture": "PowerISA",
      "full_name": "Vector Convert to Unsigned Fixed-Point Word Saturate",
      "summary": "Converts 4 floats to 4 unsigned 32-bit integers.",
      "syntax": "vctuxs vD, vB, UIM",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | UIM | vB | 906",
        "hex_opcode": "0x1000038A",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "906",
            "clean": "906"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        },
        {
          "name": "UIM",
          "desc": "Fraction bits"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vctuxs",
      "rel_url": "powerisa/vctuxs/",
      "linked_summary": "Converts 4 floats to 4 unsigned 32-<a href=\"../../armv8-a/bit/\">bit</a> integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vctsxs",
      "architecture": "PowerISA",
      "full_name": "Vector Convert to Signed Fixed-Point Word Saturate",
      "summary": "Converts 4 floats to 4 signed 32-bit integers.",
      "syntax": "vctsxs vD, vB, UIM",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | UIM | vB | 970",
        "hex_opcode": "0x100003CA",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "970",
            "clean": "970"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        },
        {
          "name": "UIM",
          "desc": "Fraction bits"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vctsxs",
      "rel_url": "powerisa/vctsxs/",
      "linked_summary": "Converts 4 floats to 4 signed 32-<a href=\"../../armv8-a/bit/\">bit</a> integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcfux",
      "architecture": "PowerISA",
      "full_name": "Vector Convert from Unsigned Fixed-Point Word",
      "summary": "Converts 4 unsigned 32-bit integers to floats.",
      "syntax": "vcfux vD, vB, UIM",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | UIM | vB | 778",
        "hex_opcode": "0x1000030A",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "778",
            "clean": "778"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        },
        {
          "name": "UIM",
          "desc": "Fraction bits"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vcfux",
      "rel_url": "powerisa/vcfux/",
      "linked_summary": "Converts 4 unsigned 32-<a href=\"../../armv8-a/bit/\">bit</a> integers to floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcfsx",
      "architecture": "PowerISA",
      "full_name": "Vector Convert from Signed Fixed-Point Word",
      "summary": "Converts 4 signed 32-bit integers to floats.",
      "syntax": "vcfsx vD, vB, UIM",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | UIM | vB | 842",
        "hex_opcode": "0x1000034A",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "842",
            "clean": "842"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        },
        {
          "name": "UIM",
          "desc": "Fraction bits"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vcfsx",
      "rel_url": "powerisa/vcfsx/",
      "linked_summary": "Converts 4 signed 32-<a href=\"../../armv8-a/bit/\">bit</a> integers to floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vrfim",
      "architecture": "PowerISA",
      "full_name": "Vector Round to Floating-Point Integer towards Minus Infinity",
      "summary": "Rounds 4 floats to integer (floor).",
      "syntax": "vrfim vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 714",
        "hex_opcode": "0x100002CA",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "714",
            "clean": "714"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vrfim",
      "rel_url": "powerisa/vrfim/",
      "linked_summary": "Rounds 4 floats to integer (floor).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vrfin",
      "architecture": "PowerISA",
      "full_name": "Vector Round to Floating-Point Integer Nearest",
      "summary": "Rounds 4 floats to nearest integer.",
      "syntax": "vrfin vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 522",
        "hex_opcode": "0x1000020A",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "522",
            "clean": "522"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vrfin",
      "rel_url": "powerisa/vrfin/",
      "linked_summary": "Rounds 4 floats to nearest integer.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vrfip",
      "architecture": "PowerISA",
      "full_name": "Vector Round to Floating-Point Integer towards Plus Infinity",
      "summary": "Rounds 4 floats to integer (ceil).",
      "syntax": "vrfip vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 650",
        "hex_opcode": "0x1000028A",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "650",
            "clean": "650"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vrfip",
      "rel_url": "powerisa/vrfip/",
      "linked_summary": "Rounds 4 floats to integer (ceil).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vrfiz",
      "architecture": "PowerISA",
      "full_name": "Vector Round to Floating-Point Integer towards Zero",
      "summary": "Rounds 4 floats to integer (trunc).",
      "syntax": "vrfiz vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 586",
        "hex_opcode": "0x1000024A",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "586",
            "clean": "586"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vrfiz",
      "rel_url": "powerisa/vrfiz/",
      "linked_summary": "Rounds 4 floats to integer (trunc).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcmpeqfp",
      "architecture": "PowerISA",
      "full_name": "Vector Compare Equal Floating-Point",
      "summary": "Compares 4 floats for equality.",
      "syntax": "vcmpeqfp vD, vA, vB",
      "encoding": {
        "format": "VC-form",
        "binary_pattern": "4 | vD | vA | vB | 198",
        "hex_opcode": "0x100000C6",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "198",
            "clean": "198"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vcmpeqfp",
      "rel_url": "powerisa/vcmpeqfp/",
      "linked_summary": "Compares 4 floats for equality.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcmpgtfp",
      "architecture": "PowerISA",
      "full_name": "Vector Compare Greater Than Floating-Point",
      "summary": "Compares 4 floats (A > B).",
      "syntax": "vcmpgtfp vD, vA, vB",
      "encoding": {
        "format": "VC-form",
        "binary_pattern": "4 | vD | vA | vB | 710",
        "hex_opcode": "0x100002C6",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "710",
            "clean": "710"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vcmpgtfp",
      "rel_url": "powerisa/vcmpgtfp/",
      "linked_summary": "Compares 4 floats (A > B).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcmpgefp",
      "architecture": "PowerISA",
      "full_name": "Vector Compare Greater Equal Floating-Point",
      "summary": "Compares 4 floats (A >= B).",
      "syntax": "vcmpgefp vD, vA, vB",
      "encoding": {
        "format": "VC-form",
        "binary_pattern": "4 | vD | vA | vB | 454",
        "hex_opcode": "0x100001C6",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "454",
            "clean": "454"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vcmpgefp",
      "rel_url": "powerisa/vcmpgefp/",
      "linked_summary": "Compares 4 floats (A >= B).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcmpbfp",
      "architecture": "PowerISA",
      "full_name": "Vector Compare Bounds Floating-Point",
      "summary": "Compares 4 floats to see if they are within bounds.",
      "syntax": "vcmpbfp vD, vA, vB",
      "encoding": {
        "format": "VC-form",
        "binary_pattern": "4 | vD | vA | vB | 966",
        "hex_opcode": "0x100003C6",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "966",
            "clean": "966"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vcmpbfp",
      "rel_url": "powerisa/vcmpbfp/",
      "linked_summary": "Compares 4 floats to see if they are within bounds.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpkpx",
      "architecture": "PowerISA",
      "full_name": "Vector Pack Pixel",
      "summary": "Packs 8 words into 8 pixels (1/5/5/5 format).",
      "syntax": "vpkpx vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 782",
        "hex_opcode": "0x1000030E",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "782",
            "clean": "782"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vpkpx",
      "rel_url": "powerisa/vpkpx/",
      "linked_summary": "Packs 8 words into 8 pixels (1/5/5/5 format).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vupkhpx",
      "architecture": "PowerISA",
      "full_name": "Vector Unpack High Pixel",
      "summary": "Unpacks high 4 pixels to 4 words.",
      "syntax": "vupkhpx vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 846",
        "hex_opcode": "0x1000034E",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "846",
            "clean": "846"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vupkhpx",
      "rel_url": "powerisa/vupkhpx/",
      "linked_summary": "Unpacks high 4 pixels to 4 words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vupklpx",
      "architecture": "PowerISA",
      "full_name": "Vector Unpack Low Pixel",
      "summary": "Unpacks low 4 pixels to 4 words.",
      "syntax": "vupklpx vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 974",
        "hex_opcode": "0x100003CE",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "974",
            "clean": "974"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vupklpx",
      "rel_url": "powerisa/vupklpx/",
      "linked_summary": "Unpacks low 4 pixels to 4 words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpermr",
      "architecture": "PowerISA",
      "full_name": "Vector Permute Right",
      "summary": "Bitwise byte shuffle similar to vperm but for little-endian access optimization.",
      "syntax": "vpermr vD, vA, vB, vC",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | vC | 59",
        "hex_opcode": "0x1000003B",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "vC",
            "clean": "vC"
          },
          {
            "raw": "59",
            "clean": "59"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        },
        {
          "name": "vC",
          "desc": "Permute"
        }
      ],
      "extension": "VMX (AltiVec)",
      "slug": "vpermr",
      "rel_url": "powerisa/vpermr/",
      "linked_summary": "Bitwise byte shuffle similar to <a href=\"../../powerisa/vperm/\">vperm</a> but for little-endian access optimization.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmsumb",
      "architecture": "PowerISA",
      "full_name": "Vector Polynomial Multiply-Sum Byte",
      "summary": "Performs GF(2) polynomial arithmetic (Carryless Multiply) on bytes.",
      "syntax": "vpmsumb vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1032",
        "hex_opcode": "0x10000408",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1032",
            "clean": "1032"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "Vector Crypto",
      "slug": "vpmsumb",
      "rel_url": "powerisa/vpmsumb/",
      "linked_summary": "Performs GF(2) polynomial arithmetic (Carryless Multiply) on bytes.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmsumh",
      "architecture": "PowerISA",
      "full_name": "Vector Polynomial Multiply-Sum Halfword",
      "summary": "Performs GF(2) polynomial arithmetic on halfwords.",
      "syntax": "vpmsumh vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1096",
        "hex_opcode": "0x10000448",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1096",
            "clean": "1096"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "Vector Crypto",
      "slug": "vpmsumh",
      "rel_url": "powerisa/vpmsumh/",
      "linked_summary": "Performs GF(2) polynomial arithmetic on halfwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmsumw",
      "architecture": "PowerISA",
      "full_name": "Vector Polynomial Multiply-Sum Word",
      "summary": "Performs GF(2) polynomial arithmetic on words.",
      "syntax": "vpmsumw vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1160",
        "hex_opcode": "0x10000488",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1160",
            "clean": "1160"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "Vector Crypto",
      "slug": "vpmsumw",
      "rel_url": "powerisa/vpmsumw/",
      "linked_summary": "Performs GF(2) polynomial arithmetic on words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmsumd",
      "architecture": "PowerISA",
      "full_name": "Vector Polynomial Multiply-Sum Doubleword",
      "summary": "Performs GF(2) polynomial arithmetic on doublewords.",
      "syntax": "vpmsumd vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1224",
        "hex_opcode": "0x100004C8",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1224",
            "clean": "1224"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "Vector Crypto",
      "slug": "vpmsumd",
      "rel_url": "powerisa/vpmsumd/",
      "linked_summary": "Performs GF(2) polynomial arithmetic on doublewords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lxv",
      "architecture": "PowerISA",
      "full_name": "Load VSX Vector",
      "summary": "Loads a 128-bit vector from memory (VSX aligned offset).",
      "syntax": "lxv XT, DQ(RA)",
      "encoding": {
        "format": "DQ-form",
        "binary_pattern": "61 | XT | RA | DQ | 1",
        "hex_opcode": "0xF4000001",
        "visual_parts": [
          {
            "raw": "61",
            "clean": "61"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "DQ",
            "clean": "DQ"
          },
          {
            "raw": "1",
            "clean": "1"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "DQ",
          "desc": "Offset"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VSX",
      "slug": "lxv",
      "rel_url": "powerisa/lxv/",
      "linked_summary": "Loads a 128-<a href=\"../../armv8-a/bit/\">bit</a> vector from memory (VSX aligned offset).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stxv",
      "architecture": "PowerISA",
      "full_name": "Store VSX Vector",
      "summary": "Stores a 128-bit vector to memory (VSX aligned offset).",
      "syntax": "stxv XS, DQ(RA)",
      "encoding": {
        "format": "DQ-form",
        "binary_pattern": "61 | XS | RA | DQ | 5",
        "hex_opcode": "0xF4000005",
        "visual_parts": [
          {
            "raw": "61",
            "clean": "61"
          },
          {
            "raw": "XS",
            "clean": "XS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "DQ",
            "clean": "DQ"
          },
          {
            "raw": "5",
            "clean": "5"
          }
        ]
      },
      "operands": [
        {
          "name": "XS",
          "desc": "Source"
        },
        {
          "name": "DQ",
          "desc": "Offset"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VSX",
      "slug": "stxv",
      "rel_url": "powerisa/stxv/",
      "linked_summary": "Stores a 128-<a href=\"../../armv8-a/bit/\">bit</a> vector to memory (VSX aligned offset).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lxvdsx",
      "architecture": "PowerISA",
      "full_name": "Load VSX Vector Doubleword and Splat Indexed",
      "summary": "Loads a doubleword and duplicates it to fill the vector.",
      "syntax": "lxvdsx XT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | XT | RA | RB | 332",
        "hex_opcode": "0x7C00014C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "332",
            "clean": "332"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "VSX",
      "slug": "lxvdsx",
      "rel_url": "powerisa/lxvdsx/",
      "linked_summary": "Loads a doubleword <a href=\"../../armv8-a/and_6/\">and</a> duplicates <a href=\"../../armv8-a/it/\">it</a> to fill the vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lxvw4x",
      "architecture": "PowerISA",
      "full_name": "Load VSX Vector Word*4 Indexed",
      "summary": "Loads four words into a vector (unaligned).",
      "syntax": "lxvw4x XT, RA, RB",
      "encoding": {
        "format": "XX1-form",
        "binary_pattern": "31 | XT | RA | RB | 780",
        "hex_opcode": "0x7C00030C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "780",
            "clean": "780"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "VSX",
      "slug": "lxvw4x",
      "rel_url": "powerisa/lxvw4x/",
      "linked_summary": "Loads four words into a vector (unaligned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stxvw4x",
      "architecture": "PowerISA",
      "full_name": "Store VSX Vector Word*4 Indexed",
      "summary": "Stores four words from a vector (unaligned).",
      "syntax": "stxvw4x XS, RA, RB",
      "encoding": {
        "format": "XX1-form",
        "binary_pattern": "31 | XS | RA | RB | 972",
        "hex_opcode": "0x7C0003CC",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "XS",
            "clean": "XS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "972",
            "clean": "972"
          }
        ]
      },
      "operands": [
        {
          "name": "XS",
          "desc": "Source"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "VSX",
      "slug": "stxvw4x",
      "rel_url": "powerisa/stxvw4x/",
      "linked_summary": "Stores four words from a vector (unaligned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lxsiwax",
      "architecture": "PowerISA",
      "full_name": "Load VSX Scalar as Integer Word Algebraic Indexed",
      "summary": "Loads a 32-bit signed integer into a VSX register (scalar).",
      "syntax": "lxsiwax XT, RA, RB",
      "encoding": {
        "format": "XX1-form",
        "binary_pattern": "31 | XT | RA | RB | 76",
        "hex_opcode": "0x7C00004C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "76",
            "clean": "76"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "VSX",
      "slug": "lxsiwax",
      "rel_url": "powerisa/lxsiwax/",
      "linked_summary": "Loads a 32-<a href=\"../../armv8-a/bit/\">bit</a> signed integer into a VSX register (scalar).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lxsiwzx",
      "architecture": "PowerISA",
      "full_name": "Load VSX Scalar as Integer Word Zero Indexed",
      "summary": "Loads a 32-bit unsigned integer into a VSX register (scalar).",
      "syntax": "lxsiwzx XT, RA, RB",
      "encoding": {
        "format": "XX1-form",
        "binary_pattern": "31 | XT | RA | RB | 12",
        "hex_opcode": "0x7C00000C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "12",
            "clean": "12"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "VSX",
      "slug": "lxsiwzx",
      "rel_url": "powerisa/lxsiwzx/",
      "linked_summary": "Loads a 32-<a href=\"../../armv8-a/bit/\">bit</a> unsigned integer into a VSX register (scalar).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stxsiwx",
      "architecture": "PowerISA",
      "full_name": "Store VSX Scalar as Integer Word Indexed",
      "summary": "Stores the low 32 bits of a VSX register to memory.",
      "syntax": "stxsiwx XS, RA, RB",
      "encoding": {
        "format": "XX1-form",
        "binary_pattern": "31 | XS | RA | RB | 140",
        "hex_opcode": "0x7C00008C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "XS",
            "clean": "XS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "140",
            "clean": "140"
          }
        ]
      },
      "operands": [
        {
          "name": "XS",
          "desc": "Source"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "VSX",
      "slug": "stxsiwx",
      "rel_url": "powerisa/stxsiwx/",
      "linked_summary": "Stores the low 32 bits of a VSX register to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mfvsrd",
      "architecture": "PowerISA",
      "full_name": "Move From VSR Doubleword",
      "summary": "Moves 64 bits from a VSR to a GPR.",
      "syntax": "mfvsrd RA, XS",
      "encoding": {
        "format": "XX1-form",
        "binary_pattern": "31 | XS | RA | 0 | 51",
        "hex_opcode": "0x7C000033",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "XS",
            "clean": "XS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "51",
            "clean": "51"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target GPR"
        },
        {
          "name": "XS",
          "desc": "Source VSR"
        }
      ],
      "extension": "VSX",
      "slug": "mfvsrd",
      "rel_url": "powerisa/mfvsrd/",
      "linked_summary": "Moves 64 bits from a VSR to a GPR.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mtvsrd",
      "architecture": "PowerISA",
      "full_name": "Move To VSR Doubleword",
      "summary": "Moves 64 bits from a GPR to a VSR.",
      "syntax": "mtvsrd XT, RA",
      "encoding": {
        "format": "XX1-form",
        "binary_pattern": "31 | XT | RA | 0 | 179",
        "hex_opcode": "0x7C0000B3",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "179",
            "clean": "179"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target VSR"
        },
        {
          "name": "RA",
          "desc": "Source GPR"
        }
      ],
      "extension": "VSX",
      "slug": "mtvsrd",
      "rel_url": "powerisa/mtvsrd/",
      "linked_summary": "Moves 64 bits from a GPR to a VSR.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mfvsrwz",
      "architecture": "PowerISA",
      "full_name": "Move From VSR Word and Zero",
      "summary": "Moves low 32 bits from VSR to GPR (zero extend).",
      "syntax": "mfvsrwz RA, XS",
      "encoding": {
        "format": "XX1-form",
        "binary_pattern": "31 | XS | RA | 0 | 115",
        "hex_opcode": "0x7C000073",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "XS",
            "clean": "XS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "115",
            "clean": "115"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target GPR"
        },
        {
          "name": "XS",
          "desc": "Source VSR"
        }
      ],
      "extension": "VSX",
      "slug": "mfvsrwz",
      "rel_url": "powerisa/mfvsrwz/",
      "linked_summary": "Moves low 32 bits from VSR to GPR (<a href=\"../../armv9-a/zero_2/\">zero</a> extend).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mtvsrwa",
      "architecture": "PowerISA",
      "full_name": "Move To VSR Word Algebraic",
      "summary": "Moves low 32 bits from GPR to VSR (sign extend).",
      "syntax": "mtvsrwa XT, RA",
      "encoding": {
        "format": "XX1-form",
        "binary_pattern": "31 | XT | RA | 0 | 211",
        "hex_opcode": "0x7C0000D3",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "211",
            "clean": "211"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target VSR"
        },
        {
          "name": "RA",
          "desc": "Source GPR"
        }
      ],
      "extension": "VSX",
      "slug": "mtvsrwa",
      "rel_url": "powerisa/mtvsrwa/",
      "linked_summary": "Moves low 32 bits from GPR to VSR (sign extend).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmp",
      "architecture": "PowerISA",
      "full_name": "Compare",
      "summary": "Compares two registers as signed integers and records the result in the specified Condition Register Field.",
      "syntax": "cmp BF, L, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | BF | / | L | RA | RB | 0000000000 | 1",
        "hex_opcode": "0x7C000000",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "L",
            "clean": "L"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "0000000000",
            "clean": "0000000000"
          },
          {
            "raw": "1",
            "clean": "1"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "Condition Register Field (0-7)"
        },
        {
          "name": "L",
          "desc": "Operand Size (0=32-bit, 1=64-bit)"
        },
        {
          "name": "RA",
          "desc": "Source Register 1"
        },
        {
          "name": "RB",
          "desc": "Source Register 2"
        }
      ],
      "pseudocode": "if (RA) < (RB) then CR[BF] <- 0b1000 (LT)...",
      "example": "cmp cr7, 0, r3, r4",
      "example_note": "Compare r3 vs r4 (32-bit signed), result in cr7.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">if (RA) &lt; (RB) then CR[BF] &lt;- 0b1000 (LT)...</code></pre>",
      "slug": "cmp",
      "rel_url": "powerisa/cmp/",
      "linked_summary": "Compares two registers as signed integers <a href=\"../../armv8-a/and_6/\">and</a> records the result <a href=\"../../x86/in/\">in</a> the specified Condition Register Field.",
      "linked_pseudocode": "if (RA) < (RB) then CR[BF] <- 0b1000 (LT)..."
    },
    {
      "mnemonic": "cmpi",
      "architecture": "PowerISA",
      "full_name": "Compare Immediate",
      "summary": "Compares a register to a 16-bit signed immediate.",
      "syntax": "cmpi BF, L, RA, SI",
      "encoding": {
        "format": "D-form",
        "binary_pattern": "11 | BF | / | L | RA | SI",
        "hex_opcode": "0x2C000000",
        "visual_parts": [
          {
            "raw": "11",
            "clean": "11"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "L",
            "clean": "L"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "SI",
            "clean": "SI"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "Condition Register Field"
        },
        {
          "name": "L",
          "desc": "Size (0=32-bit, 1=64-bit)"
        },
        {
          "name": "RA",
          "desc": "Source Register"
        },
        {
          "name": "SI",
          "desc": "Signed 16-bit Immediate"
        }
      ],
      "pseudocode": "if (RA) < EXTS(SI) then CR[BF] <- LT...",
      "example": "cmpi cr0, 1, r3, -5",
      "example_note": "Compare r3 vs -5 (64-bit signed).",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">if (RA) &lt; EXTS(SI) then CR[BF] &lt;- LT...</code></pre>",
      "slug": "cmpi",
      "rel_url": "powerisa/cmpi/",
      "linked_summary": "Compares a register to a 16-<a href=\"../../armv8-a/bit/\">bit</a> signed immediate.",
      "linked_pseudocode": "if (RA) < EXTS(SI) then CR[BF] <- LT..."
    },
    {
      "mnemonic": "cmpl",
      "architecture": "PowerISA",
      "full_name": "Compare Logical",
      "summary": "Compares two registers as unsigned integers.",
      "syntax": "cmpl BF, L, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | BF | / | L | RA | RB | 0000100000 | 1",
        "hex_opcode": "0x7C000040",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "L",
            "clean": "L"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "0000100000",
            "clean": "0000100000"
          },
          {
            "raw": "1",
            "clean": "1"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "Condition Register Field"
        },
        {
          "name": "L",
          "desc": "Size (0=32-bit, 1=64-bit)"
        },
        {
          "name": "RA",
          "desc": "Source Register 1"
        },
        {
          "name": "RB",
          "desc": "Source Register 2"
        }
      ],
      "pseudocode": "if (RA) <u (RB) then CR[BF] <- LT...",
      "example": "cmpl cr1, 1, r3, r4",
      "example_note": "Unsigned compare of r3 vs r4.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">if (RA) &lt;u (RB) then CR[BF] &lt;- LT...</code></pre>",
      "slug": "cmpl",
      "rel_url": "powerisa/cmpl/",
      "linked_summary": "Compares two registers as unsigned integers.",
      "linked_pseudocode": "if (RA) <u (RB) then CR[BF] <- LT..."
    },
    {
      "mnemonic": "cmpli",
      "architecture": "PowerISA",
      "full_name": "Compare Logical Immediate",
      "summary": "Compares a register to a 16-bit unsigned immediate.",
      "syntax": "cmpli BF, L, RA, UI",
      "encoding": {
        "format": "D-form",
        "binary_pattern": "10 | BF | / | L | RA | UI",
        "hex_opcode": "0x28000000",
        "visual_parts": [
          {
            "raw": "10",
            "clean": "10"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "L",
            "clean": "L"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "UI",
            "clean": "UI"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "Condition Register Field"
        },
        {
          "name": "L",
          "desc": "Size"
        },
        {
          "name": "RA",
          "desc": "Source Register"
        },
        {
          "name": "UI",
          "desc": "Unsigned 16-bit Immediate"
        }
      ],
      "pseudocode": "if (RA) <u (00 || UI) then CR[BF] <- LT...",
      "example": "cmpli cr0, 0, r3, 0xFF",
      "example_note": "Check if r3 < 255 (unsigned).",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">if (RA) &lt;u (00 || UI) then CR[BF] &lt;- LT...</code></pre>",
      "slug": "cmpli",
      "rel_url": "powerisa/cmpli/",
      "linked_summary": "Compares a register to a 16-<a href=\"../../armv8-a/bit/\">bit</a> unsigned immediate.",
      "linked_pseudocode": "if (RA) <u (00 || UI) then CR[BF] <- LT..."
    },
    {
      "mnemonic": "cntlzw",
      "architecture": "PowerISA",
      "full_name": "Count Leading Zeros Word",
      "summary": "Counts the number of consecutive 0 bits starting from bit 32 (MSB of the low word).",
      "syntax": "cntlzw RA, RS",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | 00000 | 000011010 | Rc",
        "hex_opcode": "0x7C000034",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "000011010",
            "clean": "000011010"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target Register"
        },
        {
          "name": "RS",
          "desc": "Source Register"
        }
      ],
      "pseudocode": "n <- 0; while RS[32+n] = 0 do n <- n + 1; RA <- n",
      "example": "cntlzw r3, r4",
      "example_note": "r3 = Leading Zeros in lower 32-bits of r4.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">n &lt;- 0; while RS[32+n] = 0 do n &lt;- n + 1; RA &lt;- n</code></pre>",
      "slug": "cntlzw",
      "rel_url": "powerisa/cntlzw/",
      "linked_summary": "Counts the number of consecutive 0 bits starting from <a href=\"../../armv8-a/bit/\">bit</a> 32 (MSB of the low word).",
      "linked_pseudocode": "n <- 0; while RS[32+n] = 0 do n <- n + 1; RA <- n"
    },
    {
      "mnemonic": "cntlzd",
      "architecture": "PowerISA",
      "full_name": "Count Leading Zeros Doubleword",
      "summary": "Counts the number of consecutive 0 bits starting from bit 0 (MSB of 64-bit reg).",
      "syntax": "cntlzd RA, RS",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | 00000 | 000111010 | Rc",
        "hex_opcode": "0x7C000074",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "000111010",
            "clean": "000111010"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target Register"
        },
        {
          "name": "RS",
          "desc": "Source Register"
        }
      ],
      "pseudocode": "n <- 0; while RS[n] = 0 do n <- n + 1; RA <- n",
      "example": "cntlzd r3, r4",
      "example_note": "r3 = Leading Zeros in 64-bit r4.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">n &lt;- 0; while RS[n] = 0 do n &lt;- n + 1; RA &lt;- n</code></pre>",
      "slug": "cntlzd",
      "rel_url": "powerisa/cntlzd/",
      "linked_summary": "Counts the number of consecutive 0 bits starting from <a href=\"../../armv8-a/bit/\">bit</a> 0 (MSB of 64-<a href=\"../../armv8-a/bit/\">bit</a> reg).",
      "linked_pseudocode": "n <- 0; while RS[n] = 0 do n <- n + 1; RA <- n"
    },
    {
      "mnemonic": "crand",
      "architecture": "PowerISA",
      "full_name": "Condition Register AND",
      "summary": "Performs a bitwise AND between two bits in the Condition Register.",
      "syntax": "crand BT, BA, BB",
      "encoding": {
        "format": "XL-form",
        "binary_pattern": "19 | BT | BA | BB | 257 | /",
        "hex_opcode": "0x4C000202",
        "visual_parts": [
          {
            "raw": "19",
            "clean": "19"
          },
          {
            "raw": "BT",
            "clean": "BT"
          },
          {
            "raw": "BA",
            "clean": "BA"
          },
          {
            "raw": "BB",
            "clean": "BB"
          },
          {
            "raw": "257",
            "clean": "257"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "BT",
          "desc": "Target Bit (0-31)"
        },
        {
          "name": "BA",
          "desc": "Source Bit A"
        },
        {
          "name": "BB",
          "desc": "Source Bit B"
        }
      ],
      "pseudocode": "CR[BT] <- CR[BA] & CR[BB]",
      "example": "crand 4*cr0+eq, 4*cr1+lt, 4*cr2+gt",
      "example_note": "If (cr1.lt AND cr2.gt), set cr0.eq.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">CR[BT] &lt;- CR[BA] &amp; CR[BB]</code></pre>",
      "slug": "crand",
      "rel_url": "powerisa/crand/",
      "linked_summary": "Performs a bitwise <a href=\"../../risc-v/and/\">AND</a> between two bits <a href=\"../../x86/in/\">in</a> the Condition Register.",
      "linked_pseudocode": "CR[BT] <- CR[BA] & CR[BB]"
    },
    {
      "mnemonic": "cror",
      "architecture": "PowerISA",
      "full_name": "Condition Register OR",
      "summary": "Performs a bitwise OR between two bits in the Condition Register.",
      "syntax": "cror BT, BA, BB",
      "encoding": {
        "format": "XL-form",
        "binary_pattern": "19 | BT | BA | BB | 449 | /",
        "hex_opcode": "0x4C000382",
        "visual_parts": [
          {
            "raw": "19",
            "clean": "19"
          },
          {
            "raw": "BT",
            "clean": "BT"
          },
          {
            "raw": "BA",
            "clean": "BA"
          },
          {
            "raw": "BB",
            "clean": "BB"
          },
          {
            "raw": "449",
            "clean": "449"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "BT",
          "desc": "Target Bit"
        },
        {
          "name": "BA",
          "desc": "Source Bit A"
        },
        {
          "name": "BB",
          "desc": "Source Bit B"
        }
      ],
      "pseudocode": "CR[BT] <- CR[BA] | CR[BB]",
      "example": "cror 0, 1, 2",
      "example_note": "CR[0] = CR[1] | CR[2].",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">CR[BT] &lt;- CR[BA] | CR[BB]</code></pre>",
      "slug": "cror",
      "rel_url": "powerisa/cror/",
      "linked_summary": "Performs a bitwise <a href=\"../../risc-v/or/\">OR</a> between two bits <a href=\"../../x86/in/\">in</a> the Condition Register.",
      "linked_pseudocode": "CR[BT] <- CR[BA] | CR[BB]"
    },
    {
      "mnemonic": "crxor",
      "architecture": "PowerISA",
      "full_name": "Condition Register XOR",
      "summary": "Performs a bitwise XOR between two bits in the Condition Register. Used to clear CR bits (crxor x,x,x).",
      "syntax": "crxor BT, BA, BB",
      "encoding": {
        "format": "XL-form",
        "binary_pattern": "19 | BT | BA | BB | 193 | /",
        "hex_opcode": "0x4C000182",
        "visual_parts": [
          {
            "raw": "19",
            "clean": "19"
          },
          {
            "raw": "BT",
            "clean": "BT"
          },
          {
            "raw": "BA",
            "clean": "BA"
          },
          {
            "raw": "BB",
            "clean": "BB"
          },
          {
            "raw": "193",
            "clean": "193"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "BT",
          "desc": "Target Bit"
        },
        {
          "name": "BA",
          "desc": "Source Bit A"
        },
        {
          "name": "BB",
          "desc": "Source Bit B"
        }
      ],
      "pseudocode": "CR[BT] <- CR[BA] XOR CR[BB]",
      "example": "crxor 0, 0, 0",
      "example_note": "Clears CR bit 0 (sets it to 0).",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">CR[BT] &lt;- CR[BA] XOR CR[BB]</code></pre>",
      "slug": "crxor",
      "rel_url": "powerisa/crxor/",
      "linked_summary": "Performs a bitwise <a href=\"../../risc-v/xor/\">XOR</a> between two bits <a href=\"../../x86/in/\">in</a> the Condition Register. Used to clear CR bits (<a href=\"../../powerisa/crxor/\">crxor</a> x,x,x).",
      "linked_pseudocode": "CR[BT] <- CR[BA] <a href=\"../../risc-v/xor/\">XOR</a> CR[BB]"
    },
    {
      "mnemonic": "se_add",
      "architecture": "PowerISA",
      "full_name": "VLE Short Add",
      "summary": "Adds two registers (16-bit encoding). RX = RX + RY.",
      "syntax": "se_add RX, RY",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 0000 | RX | RY",
        "hex_opcode": "0x0000",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "RY",
            "clean": "RY"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Target/Src A"
        },
        {
          "name": "RY",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_add",
      "rel_url": "powerisa/se_add/",
      "linked_summary": "Adds two registers (16-<a href=\"../../armv8-a/bit/\">bit</a> encoding). RX = RX + RY.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_sub",
      "architecture": "PowerISA",
      "full_name": "VLE Short Subtract",
      "summary": "Subtracts two registers (16-bit). RX = RX - RY.",
      "syntax": "se_sub RX, RY",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 0001 | RX | RY",
        "hex_opcode": "0x0100",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0001",
            "clean": "0001"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "RY",
            "clean": "RY"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Target/Src A"
        },
        {
          "name": "RY",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_sub",
      "rel_url": "powerisa/se_sub/",
      "linked_summary": "Subtracts two registers (16-<a href=\"../../armv8-a/bit/\">bit</a>). RX = RX - RY.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_neg",
      "architecture": "PowerISA",
      "full_name": "VLE Short Negate",
      "summary": "Negates a register (16-bit). RX = -RX.",
      "syntax": "se_neg RX",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 0010 | RX | 0000",
        "hex_opcode": "0x0200",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0010",
            "clean": "0010"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "0000",
            "clean": "0000"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Target/Src"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_neg",
      "rel_url": "powerisa/se_neg/",
      "linked_summary": "Negates a register (16-<a href=\"../../armv8-a/bit/\">bit</a>). RX = -RX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_not",
      "architecture": "PowerISA",
      "full_name": "VLE Short NOT",
      "summary": "Bitwise NOT (16-bit). RX = ~RX.",
      "syntax": "se_not RX",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 0010 | RX | 0001",
        "hex_opcode": "0x0201",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0010",
            "clean": "0010"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "0001",
            "clean": "0001"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Target/Src"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_not",
      "rel_url": "powerisa/se_not/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/not/\">NOT</a> (16-<a href=\"../../armv8-a/bit/\">bit</a>). RX = ~RX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_slw",
      "architecture": "PowerISA",
      "full_name": "VLE Short Shift Left Word",
      "summary": "Shifts word left (16-bit). RX = RX << RY.",
      "syntax": "se_slw RX, RY",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 0010 | RX | RY",
        "hex_opcode": "0x0200",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0010",
            "clean": "0010"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "RY",
            "clean": "RY"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Target/Src A"
        },
        {
          "name": "RY",
          "desc": "Shift Amt"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_slw",
      "rel_url": "powerisa/se_slw/",
      "linked_summary": "Shifts word left (16-<a href=\"../../armv8-a/bit/\">bit</a>). RX = RX << RY.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_srw",
      "architecture": "PowerISA",
      "full_name": "VLE Short Shift Right Word",
      "summary": "Shifts word right (16-bit). RX = RX >> RY.",
      "syntax": "se_srw RX, RY",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 0011 | RX | RY",
        "hex_opcode": "0x0300",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0011",
            "clean": "0011"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "RY",
            "clean": "RY"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Target/Src A"
        },
        {
          "name": "RY",
          "desc": "Shift Amt"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_srw",
      "rel_url": "powerisa/se_srw/",
      "linked_summary": "Shifts word right (16-<a href=\"../../armv8-a/bit/\">bit</a>). RX = RX >> RY.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_and",
      "architecture": "PowerISA",
      "full_name": "VLE Short AND",
      "summary": "Bitwise AND (16-bit). RX = RX & RY.",
      "syntax": "se_and RX, RY",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 0100 | RX | RY",
        "hex_opcode": "0x0400",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0100",
            "clean": "0100"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "RY",
            "clean": "RY"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Target/Src A"
        },
        {
          "name": "RY",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_and",
      "rel_url": "powerisa/se_and/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/and/\">AND</a> (16-<a href=\"../../armv8-a/bit/\">bit</a>). RX = RX & RY.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_or",
      "architecture": "PowerISA",
      "full_name": "VLE Short OR",
      "summary": "Bitwise OR (16-bit). RX = RX | RY.",
      "syntax": "se_or RX, RY",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 0101 | RX | RY",
        "hex_opcode": "0x0500",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0101",
            "clean": "0101"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "RY",
            "clean": "RY"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Target/Src A"
        },
        {
          "name": "RY",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_or",
      "rel_url": "powerisa/se_or/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/or/\">OR</a> (16-<a href=\"../../armv8-a/bit/\">bit</a>). RX = RX | RY.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_xor",
      "architecture": "PowerISA",
      "full_name": "VLE Short XOR",
      "summary": "Bitwise XOR (16-bit). RX = RX ^ RY.",
      "syntax": "se_xor RX, RY",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 0110 | RX | RY",
        "hex_opcode": "0x0600",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0110",
            "clean": "0110"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "RY",
            "clean": "RY"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Target/Src A"
        },
        {
          "name": "RY",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_xor",
      "rel_url": "powerisa/se_xor/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/xor/\">XOR</a> (16-<a href=\"../../armv8-a/bit/\">bit</a>). RX = RX ^ RY.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_mullw",
      "architecture": "PowerISA",
      "full_name": "VLE Short Multiply Low Word",
      "summary": "Multiplies two words (16-bit). RX = RX * RY.",
      "syntax": "se_mullw RX, RY",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 1000 | RX | RY",
        "hex_opcode": "0x0800",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "RY",
            "clean": "RY"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Target/Src A"
        },
        {
          "name": "RY",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_mullw",
      "rel_url": "powerisa/se_mullw/",
      "linked_summary": "Multiplies two words (16-<a href=\"../../armv8-a/bit/\">bit</a>). RX = RX * RY.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_mfctr",
      "architecture": "PowerISA",
      "full_name": "VLE Short Move From Count Register",
      "summary": "Moves CTR to RX (16-bit).",
      "syntax": "se_mfctr RX",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 0000 | RX | 1010",
        "hex_opcode": "0x000A",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "1010",
            "clean": "1010"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Target"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_mfctr",
      "rel_url": "powerisa/se_mfctr/",
      "linked_summary": "Moves CTR to RX (16-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_mtctr",
      "architecture": "PowerISA",
      "full_name": "VLE Short Move To Count Register",
      "summary": "Moves RX to CTR (16-bit).",
      "syntax": "se_mtctr RX",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 0000 | RX | 1011",
        "hex_opcode": "0x000B",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "1011",
            "clean": "1011"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Source"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_mtctr",
      "rel_url": "powerisa/se_mtctr/",
      "linked_summary": "Moves RX to CTR (16-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_mflr",
      "architecture": "PowerISA",
      "full_name": "VLE Short Move From Link Register",
      "summary": "Moves LR to RX (16-bit).",
      "syntax": "se_mflr RX",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 0000 | RX | 1000",
        "hex_opcode": "0x0008",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "1000",
            "clean": "1000"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Target"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_mflr",
      "rel_url": "powerisa/se_mflr/",
      "linked_summary": "Moves LR to RX (16-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_mtlr",
      "architecture": "PowerISA",
      "full_name": "VLE Short Move To Link Register",
      "summary": "Moves RX to LR (16-bit).",
      "syntax": "se_mtlr RX",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 0000 | RX | 1001",
        "hex_opcode": "0x0009",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "1001",
            "clean": "1001"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Source"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_mtlr",
      "rel_url": "powerisa/se_mtlr/",
      "linked_summary": "Moves RX to LR (16-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_addaddi",
      "architecture": "PowerISA",
      "full_name": "VLE Short Add-Add Immediate",
      "summary": "Complex add (RX = RX + RY + OIM).",
      "syntax": "se_addaddi RX, RY, OIM",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 1001 | RX | RY | OIM",
        "hex_opcode": "0x0900",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "1001",
            "clean": "1001"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "RY",
            "clean": "RY"
          },
          {
            "raw": "OIM",
            "clean": "OIM"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Target"
        },
        {
          "name": "RY",
          "desc": "Src"
        },
        {
          "name": "OIM",
          "desc": "Immediate"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_addaddi",
      "rel_url": "powerisa/se_addaddi/",
      "linked_summary": "Complex <a href=\"../../armv8-a/add_8/\">add</a> (RX = RX + RY + OIM).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_cmpl",
      "architecture": "PowerISA",
      "full_name": "VLE Short Compare Logical",
      "summary": "Unsigned comparison of RX and RY.",
      "syntax": "se_cmpl RX, RY",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 1010 | RX | RY",
        "hex_opcode": "0x0A00",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "1010",
            "clean": "1010"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "RY",
            "clean": "RY"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Src A"
        },
        {
          "name": "RY",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_cmpl",
      "rel_url": "powerisa/se_cmpl/",
      "linked_summary": "Unsigned comparison of RX <a href=\"../../armv8-a/and_6/\">and</a> RY.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_cmp",
      "architecture": "PowerISA",
      "full_name": "VLE Short Compare",
      "summary": "Signed comparison of RX and RY.",
      "syntax": "se_cmp RX, RY",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 1011 | RX | RY",
        "hex_opcode": "0x0B00",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "1011",
            "clean": "1011"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "RY",
            "clean": "RY"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Src A"
        },
        {
          "name": "RY",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_cmp",
      "rel_url": "powerisa/se_cmp/",
      "linked_summary": "Signed comparison of RX <a href=\"../../armv8-a/and_6/\">and</a> RY.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_bgeni",
      "architecture": "PowerISA",
      "full_name": "VLE Short Bit Generate Immediate",
      "summary": "Generates a value with a single bit set.",
      "syntax": "se_bgeni RX, UIM",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0110 | 000 | RX | UIM",
        "hex_opcode": "0x6000",
        "visual_parts": [
          {
            "raw": "0110",
            "clean": "0110"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Target"
        },
        {
          "name": "UIM",
          "desc": "Bit Index"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_bgeni",
      "rel_url": "powerisa/se_bgeni/",
      "linked_summary": "Generates a value with a single <a href=\"../../armv8-a/bit/\">bit</a> set.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_bmaski",
      "architecture": "PowerISA",
      "full_name": "VLE Short Bit Mask Immediate",
      "summary": "Generates a mask of ones.",
      "syntax": "se_bmaski RX, UIM",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0010 | 110 | RX | UIM",
        "hex_opcode": "0x2C00",
        "visual_parts": [
          {
            "raw": "0010",
            "clean": "0010"
          },
          {
            "raw": "110",
            "clean": "110"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Target"
        },
        {
          "name": "UIM",
          "desc": "Length"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_bmaski",
      "rel_url": "powerisa/se_bmaski/",
      "linked_summary": "Generates a mask of ones.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_andi",
      "architecture": "PowerISA",
      "full_name": "VLE Short AND Immediate",
      "summary": "RX = RX & Immediate.",
      "syntax": "se_andi RX, UIM",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0010 | 100 | RX | UIM",
        "hex_opcode": "0x2800",
        "visual_parts": [
          {
            "raw": "0010",
            "clean": "0010"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Target/Src"
        },
        {
          "name": "UIM",
          "desc": "Imm"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_andi",
      "rel_url": "powerisa/se_andi/",
      "linked_summary": "RX = RX & Immediate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_addi",
      "architecture": "PowerISA",
      "full_name": "VLE Short Add Immediate",
      "summary": "RX = RX + Immediate.",
      "syntax": "se_addi RX, OIM",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0010 | 000 | RX | OIM",
        "hex_opcode": "0x2000",
        "visual_parts": [
          {
            "raw": "0010",
            "clean": "0010"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "OIM",
            "clean": "OIM"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Target/Src"
        },
        {
          "name": "OIM",
          "desc": "Imm"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_addi",
      "rel_url": "powerisa/se_addi/",
      "linked_summary": "RX = RX + Immediate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_cmpi",
      "architecture": "PowerISA",
      "full_name": "VLE Short Compare Immediate",
      "summary": "Compares RX with immediate.",
      "syntax": "se_cmpi RX, OIM",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0010 | 010 | RX | OIM",
        "hex_opcode": "0x2400",
        "visual_parts": [
          {
            "raw": "0010",
            "clean": "0010"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "OIM",
            "clean": "OIM"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Src"
        },
        {
          "name": "OIM",
          "desc": "Imm"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_cmpi",
      "rel_url": "powerisa/se_cmpi/",
      "linked_summary": "Compares RX with immediate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_cmpli",
      "architecture": "PowerISA",
      "full_name": "VLE Short Compare Logical Immediate",
      "summary": "Unsigned comparison of RX with immediate.",
      "syntax": "se_cmpli RX, UIM",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0010 | 011 | RX | UIM",
        "hex_opcode": "0x2600",
        "visual_parts": [
          {
            "raw": "0010",
            "clean": "0010"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Src"
        },
        {
          "name": "UIM",
          "desc": "Imm"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_cmpli",
      "rel_url": "powerisa/se_cmpli/",
      "linked_summary": "Unsigned comparison of RX with immediate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_li",
      "architecture": "PowerISA",
      "full_name": "VLE Short Load Immediate",
      "summary": "Loads a 7-bit immediate into RX.",
      "syntax": "se_li RX, UIM",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0100 | 100 | RX | UIM",
        "hex_opcode": "0x4800",
        "visual_parts": [
          {
            "raw": "0100",
            "clean": "0100"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Target"
        },
        {
          "name": "UIM",
          "desc": "Imm"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_li",
      "rel_url": "powerisa/se_li/",
      "linked_summary": "Loads a 7-<a href=\"../../armv8-a/bit/\">bit</a> immediate into RX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_b",
      "architecture": "PowerISA",
      "full_name": "VLE Short Branch",
      "summary": "Unconditional short branch (8-bit displacement).",
      "syntax": "se_b BD8",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "1110 | 1000 | BD8",
        "hex_opcode": "0xE800",
        "visual_parts": [
          {
            "raw": "1110",
            "clean": "1110"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "BD8",
            "clean": "BD8"
          }
        ]
      },
      "operands": [
        {
          "name": "BD8",
          "desc": "Displacement"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_b",
      "rel_url": "powerisa/se_b/",
      "linked_summary": "Unconditional short branch (8-<a href=\"../../armv8-a/bit/\">bit</a> displacement).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_bl",
      "architecture": "PowerISA",
      "full_name": "VLE Short Branch Link",
      "summary": "Function call (8-bit displacement).",
      "syntax": "se_bl BD8",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "1110 | 1001 | BD8",
        "hex_opcode": "0xE900",
        "visual_parts": [
          {
            "raw": "1110",
            "clean": "1110"
          },
          {
            "raw": "1001",
            "clean": "1001"
          },
          {
            "raw": "BD8",
            "clean": "BD8"
          }
        ]
      },
      "operands": [
        {
          "name": "BD8",
          "desc": "Displacement"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_bl",
      "rel_url": "powerisa/se_bl/",
      "linked_summary": "Function <a href=\"../../x86/call/\">call</a> (8-<a href=\"../../armv8-a/bit/\">bit</a> displacement).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_blr",
      "architecture": "PowerISA",
      "full_name": "VLE Short Branch to Link Register",
      "summary": "Return from function.",
      "syntax": "se_blr",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 0000 | 0000 | 0100",
        "hex_opcode": "0x0004",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0100",
            "clean": "0100"
          }
        ]
      },
      "operands": [],
      "extension": "VLE (16-bit)",
      "slug": "se_blr",
      "rel_url": "powerisa/se_blr/",
      "linked_summary": "Return from function.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_bctr",
      "architecture": "PowerISA",
      "full_name": "VLE Short Branch to Count Register",
      "summary": "Computed jump.",
      "syntax": "se_bctr",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 0000 | 0000 | 0110",
        "hex_opcode": "0x0006",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0110",
            "clean": "0110"
          }
        ]
      },
      "operands": [],
      "extension": "VLE (16-bit)",
      "slug": "se_bctr",
      "rel_url": "powerisa/se_bctr/",
      "linked_summary": "Computed jump.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_bc",
      "architecture": "PowerISA",
      "full_name": "VLE Short Branch Conditional",
      "summary": "Branches if CR bit is set/clear.",
      "syntax": "se_bc BO, BI, BD8",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "1110 | 0 | BO | BI | BD8",
        "hex_opcode": "0xE000",
        "visual_parts": [
          {
            "raw": "1110",
            "clean": "1110"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "BO",
            "clean": "BO"
          },
          {
            "raw": "BI",
            "clean": "BI"
          },
          {
            "raw": "BD8",
            "clean": "BD8"
          }
        ]
      },
      "operands": [
        {
          "name": "BO",
          "desc": "Condition"
        },
        {
          "name": "BI",
          "desc": "CR Bit"
        },
        {
          "name": "BD8",
          "desc": "Disp"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_bc",
      "rel_url": "powerisa/se_bc/",
      "linked_summary": "Branches if CR <a href=\"../../armv8-a/bit/\">bit</a> is set/clear.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_lwz",
      "architecture": "PowerISA",
      "full_name": "VLE Short Load Word and Zero",
      "summary": "Loads word with 4-bit compressed offset.",
      "syntax": "se_lwz RZ, SD4(RX)",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "1100 | SD4 | RZ | RX",
        "hex_opcode": "0xC000",
        "visual_parts": [
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "SD4",
            "clean": "SD4"
          },
          {
            "raw": "RZ",
            "clean": "RZ"
          },
          {
            "raw": "RX",
            "clean": "RX"
          }
        ]
      },
      "operands": [
        {
          "name": "RZ",
          "desc": "Target"
        },
        {
          "name": "SD4",
          "desc": "Offset"
        },
        {
          "name": "RX",
          "desc": "Base"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_lwz",
      "rel_url": "powerisa/se_lwz/",
      "linked_summary": "Loads word with 4-<a href=\"../../armv8-a/bit/\">bit</a> compressed offset.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_stw",
      "architecture": "PowerISA",
      "full_name": "VLE Short Store Word",
      "summary": "Stores word with 4-bit compressed offset.",
      "syntax": "se_stw RZ, SD4(RX)",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "1101 | SD4 | RZ | RX",
        "hex_opcode": "0xD000",
        "visual_parts": [
          {
            "raw": "1101",
            "clean": "1101"
          },
          {
            "raw": "SD4",
            "clean": "SD4"
          },
          {
            "raw": "RZ",
            "clean": "RZ"
          },
          {
            "raw": "RX",
            "clean": "RX"
          }
        ]
      },
      "operands": [
        {
          "name": "RZ",
          "desc": "Source"
        },
        {
          "name": "SD4",
          "desc": "Offset"
        },
        {
          "name": "RX",
          "desc": "Base"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_stw",
      "rel_url": "powerisa/se_stw/",
      "linked_summary": "Stores word with 4-<a href=\"../../armv8-a/bit/\">bit</a> compressed offset.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_lhz",
      "architecture": "PowerISA",
      "full_name": "VLE Short Load Halfword Zero",
      "summary": "Loads halfword with 4-bit offset.",
      "syntax": "se_lhz RZ, SD4(RX)",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "1010 | SD4 | RZ | RX",
        "hex_opcode": "0xA000",
        "visual_parts": [
          {
            "raw": "1010",
            "clean": "1010"
          },
          {
            "raw": "SD4",
            "clean": "SD4"
          },
          {
            "raw": "RZ",
            "clean": "RZ"
          },
          {
            "raw": "RX",
            "clean": "RX"
          }
        ]
      },
      "operands": [
        {
          "name": "RZ",
          "desc": "Target"
        },
        {
          "name": "SD4",
          "desc": "Offset"
        },
        {
          "name": "RX",
          "desc": "Base"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_lhz",
      "rel_url": "powerisa/se_lhz/",
      "linked_summary": "Loads halfword with 4-<a href=\"../../armv8-a/bit/\">bit</a> offset.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_sth",
      "architecture": "PowerISA",
      "full_name": "VLE Short Store Halfword",
      "summary": "Stores halfword with 4-bit offset.",
      "syntax": "se_sth RZ, SD4(RX)",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "1011 | SD4 | RZ | RX",
        "hex_opcode": "0xB000",
        "visual_parts": [
          {
            "raw": "1011",
            "clean": "1011"
          },
          {
            "raw": "SD4",
            "clean": "SD4"
          },
          {
            "raw": "RZ",
            "clean": "RZ"
          },
          {
            "raw": "RX",
            "clean": "RX"
          }
        ]
      },
      "operands": [
        {
          "name": "RZ",
          "desc": "Source"
        },
        {
          "name": "SD4",
          "desc": "Offset"
        },
        {
          "name": "RX",
          "desc": "Base"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_sth",
      "rel_url": "powerisa/se_sth/",
      "linked_summary": "Stores halfword with 4-<a href=\"../../armv8-a/bit/\">bit</a> offset.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_lbz",
      "architecture": "PowerISA",
      "full_name": "VLE Short Load Byte Zero",
      "summary": "Loads byte with 4-bit offset.",
      "syntax": "se_lbz RZ, SD4(RX)",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "1000 | SD4 | RZ | RX",
        "hex_opcode": "0x8000",
        "visual_parts": [
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "SD4",
            "clean": "SD4"
          },
          {
            "raw": "RZ",
            "clean": "RZ"
          },
          {
            "raw": "RX",
            "clean": "RX"
          }
        ]
      },
      "operands": [
        {
          "name": "RZ",
          "desc": "Target"
        },
        {
          "name": "SD4",
          "desc": "Offset"
        },
        {
          "name": "RX",
          "desc": "Base"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_lbz",
      "rel_url": "powerisa/se_lbz/",
      "linked_summary": "Loads byte with 4-<a href=\"../../armv8-a/bit/\">bit</a> offset.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_stb",
      "architecture": "PowerISA",
      "full_name": "VLE Short Store Byte",
      "summary": "Stores byte with 4-bit offset.",
      "syntax": "se_stb RZ, SD4(RX)",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "1001 | SD4 | RZ | RX",
        "hex_opcode": "0x9000",
        "visual_parts": [
          {
            "raw": "1001",
            "clean": "1001"
          },
          {
            "raw": "SD4",
            "clean": "SD4"
          },
          {
            "raw": "RZ",
            "clean": "RZ"
          },
          {
            "raw": "RX",
            "clean": "RX"
          }
        ]
      },
      "operands": [
        {
          "name": "RZ",
          "desc": "Source"
        },
        {
          "name": "SD4",
          "desc": "Offset"
        },
        {
          "name": "RX",
          "desc": "Base"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_stb",
      "rel_url": "powerisa/se_stb/",
      "linked_summary": "Stores byte with 4-<a href=\"../../armv8-a/bit/\">bit</a> offset.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_add16i",
      "architecture": "PowerISA",
      "full_name": "VLE Add 16-bit Immediate",
      "summary": "Adds a 16-bit immediate to a register.",
      "syntax": "e_add16i RT, RA, SI",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0001 | 1100 | ...",
        "hex_opcode": "0x1C00...",
        "visual_parts": [
          {
            "raw": "0001",
            "clean": "0001"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src"
        },
        {
          "name": "SI",
          "desc": "Imm"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_add16i",
      "rel_url": "powerisa/e_add16i/",
      "linked_summary": "Adds a 16-<a href=\"../../armv8-a/bit/\">bit</a> immediate to a register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_addi",
      "architecture": "PowerISA",
      "full_name": "VLE Add Immediate",
      "summary": "Adds immediate to register.",
      "syntax": "e_addi RT, RA, SI",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0001 | 1000 | ...",
        "hex_opcode": "0x1800...",
        "visual_parts": [
          {
            "raw": "0001",
            "clean": "0001"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src"
        },
        {
          "name": "SI",
          "desc": "Imm"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_addi",
      "rel_url": "powerisa/e_addi/",
      "linked_summary": "Adds immediate to register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_b",
      "architecture": "PowerISA",
      "full_name": "VLE Branch",
      "summary": "Unconditional branch (long range).",
      "syntax": "e_b BD24",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | BD24",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "BD24",
            "clean": "BD24"
          }
        ]
      },
      "operands": [
        {
          "name": "BD24",
          "desc": "Offset"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_b",
      "rel_url": "powerisa/e_b/",
      "linked_summary": "Unconditional branch (long range).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_bl",
      "architecture": "PowerISA",
      "full_name": "VLE Branch Link",
      "summary": "Function call (long range).",
      "syntax": "e_bl BD24",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1001 | BD24",
        "hex_opcode": "0x7900...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1001",
            "clean": "1001"
          },
          {
            "raw": "BD24",
            "clean": "BD24"
          }
        ]
      },
      "operands": [
        {
          "name": "BD24",
          "desc": "Offset"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_bl",
      "rel_url": "powerisa/e_bl/",
      "linked_summary": "Function <a href=\"../../x86/call/\">call</a> (long range).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_bc",
      "architecture": "PowerISA",
      "full_name": "VLE Branch Conditional",
      "summary": "Conditional branch.",
      "syntax": "e_bc BO, BI, BD15",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1010 | ...",
        "hex_opcode": "0x7A00...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1010",
            "clean": "1010"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "BO",
          "desc": "Cond"
        },
        {
          "name": "BI",
          "desc": "CR Bit"
        },
        {
          "name": "BD15",
          "desc": "Offset"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_bc",
      "rel_url": "powerisa/e_bc/",
      "linked_summary": "Conditional branch.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_lmw",
      "architecture": "PowerISA",
      "full_name": "VLE Load Multiple Word",
      "summary": "Loads words from memory into registers RT through R31.",
      "syntax": "e_lmw RT, D(RA)",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0001 | 1000 | ...",
        "hex_opcode": "0x1800...",
        "visual_parts": [
          {
            "raw": "0001",
            "clean": "0001"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Start Reg"
        },
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_lmw",
      "rel_url": "powerisa/e_lmw/",
      "linked_summary": "Loads words from memory into registers RT through R31.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_stmw",
      "architecture": "PowerISA",
      "full_name": "VLE Store Multiple Word",
      "summary": "Stores words from registers RT through R31 to memory.",
      "syntax": "e_stmw RT, D(RA)",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0001 | 1000 | ...",
        "hex_opcode": "0x1800...",
        "visual_parts": [
          {
            "raw": "0001",
            "clean": "0001"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Start Reg"
        },
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_stmw",
      "rel_url": "powerisa/e_stmw/",
      "linked_summary": "Stores words from registers RT through R31 to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_lwz",
      "architecture": "PowerISA",
      "full_name": "VLE Load Word and Zero",
      "summary": "Loads word with 16-bit offset.",
      "syntax": "e_lwz RT, D(RA)",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0101 | 0000 | ...",
        "hex_opcode": "0x5000...",
        "visual_parts": [
          {
            "raw": "0101",
            "clean": "0101"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "D",
          "desc": "Offset"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_lwz",
      "rel_url": "powerisa/e_lwz/",
      "linked_summary": "Loads word with 16-<a href=\"../../armv8-a/bit/\">bit</a> offset.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_stw",
      "architecture": "PowerISA",
      "full_name": "VLE Store Word",
      "summary": "Stores word with 16-bit offset.",
      "syntax": "e_stw RS, D(RA)",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0101 | 0100 | ...",
        "hex_opcode": "0x5400...",
        "visual_parts": [
          {
            "raw": "0101",
            "clean": "0101"
          },
          {
            "raw": "0100",
            "clean": "0100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "D",
          "desc": "Offset"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_stw",
      "rel_url": "powerisa/e_stw/",
      "linked_summary": "Stores word with 16-<a href=\"../../armv8-a/bit/\">bit</a> offset.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_lhz",
      "architecture": "PowerISA",
      "full_name": "VLE Load Halfword and Zero",
      "summary": "Loads halfword with 16-bit offset.",
      "syntax": "e_lhz RT, D(RA)",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0101 | 0010 | ...",
        "hex_opcode": "0x5200...",
        "visual_parts": [
          {
            "raw": "0101",
            "clean": "0101"
          },
          {
            "raw": "0010",
            "clean": "0010"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "D",
          "desc": "Offset"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_lhz",
      "rel_url": "powerisa/e_lhz/",
      "linked_summary": "Loads halfword with 16-<a href=\"../../armv8-a/bit/\">bit</a> offset.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_sth",
      "architecture": "PowerISA",
      "full_name": "VLE Store Halfword",
      "summary": "Stores halfword with 16-bit offset.",
      "syntax": "e_sth RS, D(RA)",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0101 | 0110 | ...",
        "hex_opcode": "0x5600...",
        "visual_parts": [
          {
            "raw": "0101",
            "clean": "0101"
          },
          {
            "raw": "0110",
            "clean": "0110"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "D",
          "desc": "Offset"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_sth",
      "rel_url": "powerisa/e_sth/",
      "linked_summary": "Stores halfword with 16-<a href=\"../../armv8-a/bit/\">bit</a> offset.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_lbz",
      "architecture": "PowerISA",
      "full_name": "VLE Load Byte and Zero",
      "summary": "Loads byte with 16-bit offset.",
      "syntax": "e_lbz RT, D(RA)",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0101 | 0001 | ...",
        "hex_opcode": "0x5100...",
        "visual_parts": [
          {
            "raw": "0101",
            "clean": "0101"
          },
          {
            "raw": "0001",
            "clean": "0001"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "D",
          "desc": "Offset"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_lbz",
      "rel_url": "powerisa/e_lbz/",
      "linked_summary": "Loads byte with 16-<a href=\"../../armv8-a/bit/\">bit</a> offset.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_stb",
      "architecture": "PowerISA",
      "full_name": "VLE Store Byte",
      "summary": "Stores byte with 16-bit offset.",
      "syntax": "e_stb RS, D(RA)",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0101 | 0101 | ...",
        "hex_opcode": "0x5500...",
        "visual_parts": [
          {
            "raw": "0101",
            "clean": "0101"
          },
          {
            "raw": "0101",
            "clean": "0101"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "D",
          "desc": "Offset"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_stb",
      "rel_url": "powerisa/e_stb/",
      "linked_summary": "Stores byte with 16-<a href=\"../../armv8-a/bit/\">bit</a> offset.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_or2i",
      "architecture": "PowerISA",
      "full_name": "VLE OR Immediate",
      "summary": "OR with 16-bit immediate.",
      "syntax": "e_or2i RT, UI",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 0000 | ...",
        "hex_opcode": "0x7000...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "UI",
          "desc": "Imm"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_or2i",
      "rel_url": "powerisa/e_or2i/",
      "linked_summary": "<a href=\"../../risc-v/or/\">OR</a> with 16-<a href=\"../../armv8-a/bit/\">bit</a> immediate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_and2i",
      "architecture": "PowerISA",
      "full_name": "VLE AND Immediate",
      "summary": "AND with 16-bit immediate.",
      "syntax": "e_and2i RT, UI",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 0000 | ...",
        "hex_opcode": "0x7000...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "UI",
          "desc": "Imm"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_and2i",
      "rel_url": "powerisa/e_and2i/",
      "linked_summary": "<a href=\"../../risc-v/and/\">AND</a> with 16-<a href=\"../../armv8-a/bit/\">bit</a> immediate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_xor2i",
      "architecture": "PowerISA",
      "full_name": "VLE XOR Immediate",
      "summary": "XOR with 16-bit immediate.",
      "syntax": "e_xor2i RT, UI",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 0000 | ...",
        "hex_opcode": "0x7000...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "UI",
          "desc": "Imm"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_xor2i",
      "rel_url": "powerisa/e_xor2i/",
      "linked_summary": "<a href=\"../../risc-v/xor/\">XOR</a> with 16-<a href=\"../../armv8-a/bit/\">bit</a> immediate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_lis",
      "architecture": "PowerISA",
      "full_name": "VLE Load Immediate Shifted",
      "summary": "Loads immediate into upper 16 bits.",
      "syntax": "e_lis RT, SI",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 0000 | ...",
        "hex_opcode": "0x7000...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "SI",
          "desc": "Imm"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_lis",
      "rel_url": "powerisa/e_lis/",
      "linked_summary": "Loads immediate into upper 16 bits.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_rlwimi",
      "architecture": "PowerISA",
      "full_name": "VLE Rotate Left Word Immediate Mask Insert",
      "summary": "Rotate and insert (Masking).",
      "syntax": "e_rlwimi RA, RS, SH, MB, ME",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 0100 | ...",
        "hex_opcode": "0x7400...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "0100",
            "clean": "0100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Dest"
        },
        {
          "name": "RS",
          "desc": "Src"
        },
        {
          "name": "SH",
          "desc": "Shift"
        },
        {
          "name": "MB",
          "desc": "Start"
        },
        {
          "name": "ME",
          "desc": "End"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_rlwimi",
      "rel_url": "powerisa/e_rlwimi/",
      "linked_summary": "Rotate <a href=\"../../armv8-a/and_6/\">and</a> insert (Masking).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_rlwinm",
      "architecture": "PowerISA",
      "full_name": "VLE Rotate Left Word Immediate AND Mask",
      "summary": "Rotate and mask.",
      "syntax": "e_rlwinm RA, RS, SH, MB, ME",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 0101 | ...",
        "hex_opcode": "0x7500...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "0101",
            "clean": "0101"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Dest"
        },
        {
          "name": "RS",
          "desc": "Src"
        },
        {
          "name": "SH",
          "desc": "Shift"
        },
        {
          "name": "MB",
          "desc": "Start"
        },
        {
          "name": "ME",
          "desc": "End"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_rlwinm",
      "rel_url": "powerisa/e_rlwinm/",
      "linked_summary": "Rotate <a href=\"../../armv8-a/and_6/\">and</a> mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_mullw",
      "architecture": "PowerISA",
      "full_name": "VLE Multiply Low Word",
      "summary": "Multiplies two words.",
      "syntax": "e_mullw RT, RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_mullw",
      "rel_url": "powerisa/e_mullw/",
      "linked_summary": "Multiplies two words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_divw",
      "architecture": "PowerISA",
      "full_name": "VLE Divide Word",
      "summary": "Divides two words.",
      "syntax": "e_divw RT, RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_divw",
      "rel_url": "powerisa/e_divw/",
      "linked_summary": "Divides two words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_slw",
      "architecture": "PowerISA",
      "full_name": "VLE Shift Left Word",
      "summary": "Shifts word left.",
      "syntax": "e_slw RA, RS, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Src"
        },
        {
          "name": "RB",
          "desc": "Shift"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_slw",
      "rel_url": "powerisa/e_slw/",
      "linked_summary": "Shifts word left.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_srw",
      "architecture": "PowerISA",
      "full_name": "VLE Shift Right Word",
      "summary": "Shifts word right.",
      "syntax": "e_srw RA, RS, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Src"
        },
        {
          "name": "RB",
          "desc": "Shift"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_srw",
      "rel_url": "powerisa/e_srw/",
      "linked_summary": "Shifts word right.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_sraw",
      "architecture": "PowerISA",
      "full_name": "VLE Shift Right Algebraic Word",
      "summary": "Arithmetic right shift.",
      "syntax": "e_sraw RA, RS, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Src"
        },
        {
          "name": "RB",
          "desc": "Shift"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_sraw",
      "rel_url": "powerisa/e_sraw/",
      "linked_summary": "Arithmetic right shift.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_crand",
      "architecture": "PowerISA",
      "full_name": "VLE Condition Register AND",
      "summary": "CR AND operation.",
      "syntax": "e_crand BT, BA, BB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "BT",
          "desc": "Dest"
        },
        {
          "name": "BA",
          "desc": "Src A"
        },
        {
          "name": "BB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_crand",
      "rel_url": "powerisa/e_crand/",
      "linked_summary": "CR <a href=\"../../risc-v/and/\">AND</a> operation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_cror",
      "architecture": "PowerISA",
      "full_name": "VLE Condition Register OR",
      "summary": "CR OR operation.",
      "syntax": "e_cror BT, BA, BB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "BT",
          "desc": "Dest"
        },
        {
          "name": "BA",
          "desc": "Src A"
        },
        {
          "name": "BB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_cror",
      "rel_url": "powerisa/e_cror/",
      "linked_summary": "CR <a href=\"../../risc-v/or/\">OR</a> operation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_stwu",
      "architecture": "PowerISA",
      "full_name": "VLE Store Word with Update",
      "summary": "Stores word and updates base register.",
      "syntax": "e_stwu RS, D(RA)",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0101 | 0100 | ...",
        "hex_opcode": "0x5400...",
        "visual_parts": [
          {
            "raw": "0101",
            "clean": "0101"
          },
          {
            "raw": "0100",
            "clean": "0100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "D",
          "desc": "Offset"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_stwu",
      "rel_url": "powerisa/e_stwu/",
      "linked_summary": "Stores word <a href=\"../../armv8-a/and_6/\">and</a> updates base register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_lwzu",
      "architecture": "PowerISA",
      "full_name": "VLE Load Word and Zero with Update",
      "summary": "Loads word and updates base register.",
      "syntax": "e_lwzu RT, D(RA)",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0101 | 0000 | ...",
        "hex_opcode": "0x5000...",
        "visual_parts": [
          {
            "raw": "0101",
            "clean": "0101"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "D",
          "desc": "Offset"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_lwzu",
      "rel_url": "powerisa/e_lwzu/",
      "linked_summary": "Loads word <a href=\"../../armv8-a/and_6/\">and</a> updates base register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "b",
      "architecture": "PowerISA",
      "full_name": "Branch",
      "summary": "Unconditionally branches to a target address relative to the current instruction pointer.",
      "syntax": "b target_addr",
      "encoding": {
        "format": "I-form",
        "binary_pattern": "18 | LI | AA | LK",
        "hex_opcode": "0x48000000",
        "visual_parts": [
          {
            "raw": "18",
            "clean": "18"
          },
          {
            "raw": "LI",
            "clean": "LI"
          },
          {
            "raw": "AA",
            "clean": "AA"
          },
          {
            "raw": "LK",
            "clean": "LK"
          }
        ]
      },
      "operands": [
        {
          "name": "LI",
          "desc": "24-bit Signed Immediate (Displacement / 4)"
        }
      ],
      "pseudocode": "NIA <- CIA + EXTS(LI || 00)",
      "example": "b label",
      "example_note": "Jump to 'label'.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">NIA &lt;- CIA + EXTS(LI || 00)</code></pre>",
      "slug": "b",
      "rel_url": "powerisa/b/",
      "linked_summary": "Unconditionally branches to a target address relative to the current instruction pointer.",
      "linked_pseudocode": "NIA <- CIA + EXTS(<a href=\"../../risc-v/li/\">LI</a> || 00)"
    },
    {
      "mnemonic": "ba",
      "architecture": "PowerISA",
      "full_name": "Branch Absolute",
      "summary": "Unconditionally branches to an absolute address.",
      "syntax": "ba target_addr",
      "encoding": {
        "format": "I-form",
        "binary_pattern": "18 | LI | 1 | LK",
        "hex_opcode": "0x48000002",
        "visual_parts": [
          {
            "raw": "18",
            "clean": "18"
          },
          {
            "raw": "LI",
            "clean": "LI"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "LK",
            "clean": "LK"
          }
        ]
      },
      "operands": [
        {
          "name": "LI",
          "desc": "24-bit Signed Immediate (Address / 4)"
        }
      ],
      "pseudocode": "NIA <- EXTS(LI || 00)",
      "example": "ba 0x1000",
      "example_note": "Jump to address 0x1000.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">NIA &lt;- EXTS(LI || 00)</code></pre>",
      "slug": "ba",
      "rel_url": "powerisa/ba/",
      "linked_summary": "Unconditionally branches to an absolute address.",
      "linked_pseudocode": "NIA <- EXTS(<a href=\"../../risc-v/li/\">LI</a> || 00)"
    },
    {
      "mnemonic": "bl",
      "architecture": "PowerISA",
      "full_name": "Branch and Link",
      "summary": "Branches to a target address and saves the return address (CIA + 4) in the Link Register (LR). Used for function calls.",
      "syntax": "bl target_addr",
      "encoding": {
        "format": "I-form",
        "binary_pattern": "18 | LI | AA | 1",
        "hex_opcode": "0x48000001",
        "visual_parts": [
          {
            "raw": "18",
            "clean": "18"
          },
          {
            "raw": "LI",
            "clean": "LI"
          },
          {
            "raw": "AA",
            "clean": "AA"
          },
          {
            "raw": "1",
            "clean": "1"
          }
        ]
      },
      "operands": [
        {
          "name": "LI",
          "desc": "24-bit Signed Immediate"
        }
      ],
      "pseudocode": "LR <- CIA + 4; NIA <- CIA + EXTS(LI || 00)",
      "example": "bl printf",
      "example_note": "Call 'printf' function.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">LR &lt;- CIA + 4; NIA &lt;- CIA + EXTS(LI || 00)</code></pre>",
      "slug": "bl",
      "rel_url": "powerisa/bl/",
      "linked_summary": "Branches to a target address <a href=\"../../armv8-a/and_6/\">and</a> saves the return address (CIA + 4) <a href=\"../../x86/in/\">in</a> the Link Register (LR). Used for function calls.",
      "linked_pseudocode": "LR <- CIA + 4; NIA <- CIA + EXTS(<a href=\"../../risc-v/li/\">LI</a> || 00)"
    },
    {
      "mnemonic": "bc",
      "architecture": "PowerISA",
      "full_name": "Branch Conditional",
      "summary": "Branches conditionally based on the Count Register (CTR) and/or a bit in the Condition Register (CR).",
      "syntax": "bc BO, BI, target_addr",
      "encoding": {
        "format": "B-form",
        "binary_pattern": "16 | BO | BI | BD | AA | LK",
        "hex_opcode": "0x40000000",
        "visual_parts": [
          {
            "raw": "16",
            "clean": "16"
          },
          {
            "raw": "BO",
            "clean": "BO"
          },
          {
            "raw": "BI",
            "clean": "BI"
          },
          {
            "raw": "BD",
            "clean": "BD"
          },
          {
            "raw": "AA",
            "clean": "AA"
          },
          {
            "raw": "LK",
            "clean": "LK"
          }
        ]
      },
      "operands": [
        {
          "name": "BO",
          "desc": "Branch Options (5 bits)"
        },
        {
          "name": "BI",
          "desc": "CR Bit Index (5 bits)"
        },
        {
          "name": "BD",
          "desc": "14-bit Signed Displacement"
        }
      ],
      "pseudocode": "if (Condition(BO, BI)) NIA <- CIA + EXTS(BD || 00)",
      "example": "bc 12, 2, label",
      "example_note": "Branch if CR bit 2 is set (beq).",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">if (Condition(BO, BI)) NIA &lt;- CIA + EXTS(BD || 00)</code></pre>",
      "slug": "bc",
      "rel_url": "powerisa/bc/",
      "linked_summary": "Branches conditionally based on the Count Register (CTR) <a href=\"../../armv8-a/and_6/\">and</a>/<a href=\"../../powerisa/or/\">or</a> a <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> the Condition Register (CR).",
      "linked_pseudocode": "if (Condition(BO, BI)) NIA <- CIA + EXTS(BD || 00)"
    },
    {
      "mnemonic": "bclr",
      "architecture": "PowerISA",
      "full_name": "Branch Conditional to Link Register",
      "summary": "Branches to the address in the Link Register (LR) if the condition is met. Used for function returns.",
      "syntax": "bclr BO, BI",
      "encoding": {
        "format": "XL-form",
        "binary_pattern": "19 | BO | BI | 000 | 16 | LK",
        "hex_opcode": "0x4C000020",
        "visual_parts": [
          {
            "raw": "19",
            "clean": "19"
          },
          {
            "raw": "BO",
            "clean": "BO"
          },
          {
            "raw": "BI",
            "clean": "BI"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "16",
            "clean": "16"
          },
          {
            "raw": "LK",
            "clean": "LK"
          }
        ]
      },
      "operands": [
        {
          "name": "BO",
          "desc": "Branch Options"
        },
        {
          "name": "BI",
          "desc": "CR Bit Index"
        }
      ],
      "pseudocode": "if (Condition(BO, BI)) NIA <- LR(0:61) || 00",
      "example": "bclr 20, 0",
      "example_note": "Unconditional return (blr).",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">if (Condition(BO, BI)) NIA &lt;- LR(0:61) || 00</code></pre>",
      "slug": "bclr",
      "rel_url": "powerisa/bclr/",
      "linked_summary": "Branches to the address <a href=\"../../x86/in/\">in</a> the Link Register (LR) if the condition is met. Used for function returns.",
      "linked_pseudocode": "if (Condition(BO, BI)) NIA <- LR(0:61) || 00"
    },
    {
      "mnemonic": "bcctr",
      "architecture": "PowerISA",
      "full_name": "Branch Conditional to Count Register",
      "summary": "Branches to the address in the Count Register (CTR) if the condition is met. Used for computed jumps and switch statements.",
      "syntax": "bcctr BO, BI",
      "encoding": {
        "format": "XL-form",
        "binary_pattern": "19 | BO | BI | 000 | 528 | LK",
        "hex_opcode": "0x4C000420",
        "visual_parts": [
          {
            "raw": "19",
            "clean": "19"
          },
          {
            "raw": "BO",
            "clean": "BO"
          },
          {
            "raw": "BI",
            "clean": "BI"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "528",
            "clean": "528"
          },
          {
            "raw": "LK",
            "clean": "LK"
          }
        ]
      },
      "operands": [
        {
          "name": "BO",
          "desc": "Branch Options"
        },
        {
          "name": "BI",
          "desc": "CR Bit Index"
        }
      ],
      "pseudocode": "if (Condition(BO, BI)) NIA <- CTR(0:61) || 00",
      "example": "bcctr 20, 0",
      "example_note": "Jump to address in CTR (bctr).",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">if (Condition(BO, BI)) NIA &lt;- CTR(0:61) || 00</code></pre>",
      "slug": "bcctr",
      "rel_url": "powerisa/bcctr/",
      "linked_summary": "Branches to the address <a href=\"../../x86/in/\">in</a> the Count Register (CTR) if the condition is met. Used for computed jumps <a href=\"../../armv8-a/and_6/\">and</a> switch statements.",
      "linked_pseudocode": "if (Condition(BO, BI)) NIA <- CTR(0:61) || 00"
    },
    {
      "mnemonic": "bpermd",
      "architecture": "PowerISA",
      "full_name": "Bit Permute Doubleword",
      "summary": "Permutes bits from RS based on the index values in RB. Highly optimized for bit shuffling.",
      "syntax": "bpermd RA, RS, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 252 | /",
        "hex_opcode": "0x7C0001F8",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "252",
            "clean": "252"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target Register"
        },
        {
          "name": "RS",
          "desc": "Source Register (Data)"
        },
        {
          "name": "RB",
          "desc": "Permute Control Byte Selects"
        }
      ],
      "pseudocode": "For i from 0 to 7: index = RB.byte[i]; if index < 64 then RA.bit[index] = RS.bit[i] else RA.bit[i] = 0",
      "example": "bpermd r3, r4, r5",
      "example_note": "Complex bit permutation.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">For i from 0 to 7: index = RB.byte[i]; if index &lt; 64 then RA.bit[index] = RS.bit[i] else RA.bit[i] = 0</code></pre>",
      "slug": "bpermd",
      "rel_url": "powerisa/bpermd/",
      "linked_summary": "Permutes bits from RS based on the <a href=\"../../armv8-a/index/\">index</a> values <a href=\"../../x86/in/\">in</a> RB. Highly optimized for <a href=\"../../armv8-a/bit/\">bit</a> shuffling.",
      "linked_pseudocode": "For i from 0 to 7: <a href=\"../../armv8-a/index/\">index</a> = RB.byte[i]; if <a href=\"../../armv8-a/index/\">index</a> < 64 then RA.<a href=\"../../armv8-a/bit/\">bit</a>[<a href=\"../../armv8-a/index/\">index</a>] = RS.<a href=\"../../armv8-a/bit/\">bit</a>[i] else RA.<a href=\"../../armv8-a/bit/\">bit</a>[i] = 0"
    },
    {
      "mnemonic": "cfuged",
      "architecture": "PowerISA",
      "full_name": "Centrifuge Doubleword",
      "summary": "Separates bits of the source register into two groups based on a mask (Power10 Scalar).",
      "syntax": "cfuged RA, RS, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 68 | /",
        "hex_opcode": "0x7C000044",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "68",
            "clean": "68"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "RB",
          "desc": "Mask"
        }
      ],
      "extension": "Base (Power10)",
      "slug": "cfuged",
      "rel_url": "powerisa/cfuged/",
      "linked_summary": "Separates bits of the source register into two groups based on a mask (Power10 Scalar).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pdepd",
      "architecture": "PowerISA",
      "full_name": "Parallel Bits Deposit Doubleword",
      "summary": "Deposits bits from RS to RA under control of mask RB (Scalar).",
      "syntax": "pdepd RA, RS, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 196 | /",
        "hex_opcode": "0x7C0000C4",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "196",
            "clean": "196"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "RB",
          "desc": "Mask"
        }
      ],
      "extension": "Base (Power10)",
      "slug": "pdepd",
      "rel_url": "powerisa/pdepd/",
      "linked_summary": "Deposits bits from RS to RA under control of mask RB (Scalar).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pextd",
      "architecture": "PowerISA",
      "full_name": "Parallel Bits Extract Doubleword",
      "summary": "Extracts bits from RS to RA under control of mask RB (Scalar).",
      "syntax": "pextd RA, RS, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 132 | /",
        "hex_opcode": "0x7C000084",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "132",
            "clean": "132"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "RB",
          "desc": "Mask"
        }
      ],
      "extension": "Base (Power10)",
      "slug": "pextd",
      "rel_url": "powerisa/pextd/",
      "linked_summary": "Extracts bits from RS to RA under control of mask RB (Scalar).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cntlzdm",
      "architecture": "PowerISA",
      "full_name": "Count Leading Zeros Doubleword under Mask",
      "summary": "Counts leading zeros in RS, but only considering bits set in mask RB.",
      "syntax": "cntlzdm RA, RS, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 59 | /",
        "hex_opcode": "0x7C00003B",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "59",
            "clean": "59"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "RB",
          "desc": "Mask"
        }
      ],
      "extension": "Base (Power10)",
      "slug": "cntlzdm",
      "rel_url": "powerisa/cntlzdm/",
      "linked_summary": "Counts leading zeros <a href=\"../../x86/in/\">in</a> RS, but only considering bits set <a href=\"../../x86/in/\">in</a> mask RB.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cnttzdm",
      "architecture": "PowerISA",
      "full_name": "Count Trailing Zeros Doubleword under Mask",
      "summary": "Counts trailing zeros in RS, but only considering bits set in mask RB.",
      "syntax": "cnttzdm RA, RS, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 571 | /",
        "hex_opcode": "0x7C00047B",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "571",
            "clean": "571"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "RB",
          "desc": "Mask"
        }
      ],
      "extension": "Base (Power10)",
      "slug": "cnttzdm",
      "rel_url": "powerisa/cnttzdm/",
      "linked_summary": "Counts trailing zeros <a href=\"../../x86/in/\">in</a> RS, but only considering bits set <a href=\"../../x86/in/\">in</a> mask RB.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "crc32b",
      "architecture": "PowerISA",
      "full_name": "Cyclic Redundancy Check 32-bit Byte",
      "summary": "Accumulates a CRC32 checksum using the low byte of RS.",
      "syntax": "crc32b RA, RS",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | 0 | 522 | /",
        "hex_opcode": "0x7C00020A",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "522",
            "clean": "522"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target/Accumulator"
        },
        {
          "name": "RS",
          "desc": "Data"
        }
      ],
      "extension": "Base",
      "slug": "crc32b",
      "rel_url": "powerisa/crc32b/",
      "linked_summary": "Accumulates a CRC32 checksum using the low byte of RS.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "crc32h",
      "architecture": "PowerISA",
      "full_name": "Cyclic Redundancy Check 32-bit Halfword",
      "summary": "Accumulates a CRC32 checksum using the low halfword of RS.",
      "syntax": "crc32h RA, RS",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | 0 | 586 | /",
        "hex_opcode": "0x7C00024A",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "586",
            "clean": "586"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target/Accumulator"
        },
        {
          "name": "RS",
          "desc": "Data"
        }
      ],
      "extension": "Base",
      "slug": "crc32h",
      "rel_url": "powerisa/crc32h/",
      "linked_summary": "Accumulates a CRC32 checksum using the low halfword of RS.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "crc32w",
      "architecture": "PowerISA",
      "full_name": "Cyclic Redundancy Check 32-bit Word",
      "summary": "Accumulates a CRC32 checksum using the word in RS.",
      "syntax": "crc32w RA, RS",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | 0 | 650 | /",
        "hex_opcode": "0x7C00028A",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "650",
            "clean": "650"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target/Accumulator"
        },
        {
          "name": "RS",
          "desc": "Data"
        }
      ],
      "extension": "Base",
      "slug": "crc32w",
      "rel_url": "powerisa/crc32w/",
      "linked_summary": "Accumulates a CRC32 checksum using the word <a href=\"../../x86/in/\">in</a> RS.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "crc32d",
      "architecture": "PowerISA",
      "full_name": "Cyclic Redundancy Check 32-bit Doubleword",
      "summary": "Accumulates a CRC32 checksum using the doubleword in RS.",
      "syntax": "crc32d RA, RS",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | 0 | 714 | /",
        "hex_opcode": "0x7C0002CA",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "714",
            "clean": "714"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target/Accumulator"
        },
        {
          "name": "RS",
          "desc": "Data"
        }
      ],
      "extension": "Base",
      "slug": "crc32d",
      "rel_url": "powerisa/crc32d/",
      "linked_summary": "Accumulates a CRC32 checksum using the doubleword <a href=\"../../x86/in/\">in</a> RS.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pli",
      "architecture": "PowerISA",
      "full_name": "Prefixed Load Immediate",
      "summary": "Loads a 34-bit signed immediate into a register. (Replaces multiple 'lis/ori' instructions).",
      "syntax": "pli RT, SI34",
      "encoding": {
        "format": "MLS:D-form",
        "binary_pattern": "000001 | 10 | 0 | ... | 14 | RT | ...",
        "hex_opcode": "0x06000000",
        "visual_parts": [
          {
            "raw": "000001",
            "clean": "000001"
          },
          {
            "raw": "10",
            "clean": "10"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "...",
            "clean": "..."
          },
          {
            "raw": "14",
            "clean": "14"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "SI34",
          "desc": "Immediate"
        }
      ],
      "extension": "Prefixed (64-bit)",
      "slug": "pli",
      "rel_url": "powerisa/pli/",
      "linked_summary": "Loads a 34-<a href=\"../../armv8-a/bit/\">bit</a> signed immediate into a register. (Replaces multiple '<a href=\"../../powerisa/lis/\">lis</a>/<a href=\"../../powerisa/ori/\">ori</a>' instructions).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxpermx",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Permute Extended",
      "summary": "Permutes bytes from two source vectors using a control vector and a 3-bit selector.",
      "syntax": "xxpermx XT, XA, XB, XC, UIM",
      "encoding": {
        "format": "XX4-form",
        "binary_pattern": "60 | XT | XA | XB | XC | UIM | ...",
        "hex_opcode": "0xF0000000",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "XC",
            "clean": "XC"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        },
        {
          "name": "XC",
          "desc": "Control"
        },
        {
          "name": "UIM",
          "desc": "Selector"
        }
      ],
      "extension": "VSX (P10)",
      "slug": "xxpermx",
      "rel_url": "powerisa/xxpermx/",
      "linked_summary": "Permutes bytes from two source vectors using a control vector <a href=\"../../armv8-a/and_6/\">and</a> a 3-<a href=\"../../armv8-a/bit/\">bit</a> selector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxblendvb",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Blend Variable Byte",
      "summary": "Selects bytes from XA or XB based on the MSB of bytes in XC.",
      "syntax": "xxblendvb XT, XA, XB, XC",
      "encoding": {
        "format": "XX4-form",
        "binary_pattern": "60 | XT | XA | XB | XC | 33",
        "hex_opcode": "0xF0000021",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "XC",
            "clean": "XC"
          },
          {
            "raw": "33",
            "clean": "33"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        },
        {
          "name": "XC",
          "desc": "Control"
        }
      ],
      "extension": "VSX (P10)",
      "slug": "xxblendvb",
      "rel_url": "powerisa/xxblendvb/",
      "linked_summary": "Selects bytes from XA <a href=\"../../powerisa/or/\">or</a> XB based on the MSB of bytes <a href=\"../../x86/in/\">in</a> XC.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxblendvh",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Blend Variable Halfword",
      "summary": "Selects halfwords from XA or XB based on the MSB of halfwords in XC.",
      "syntax": "xxblendvh XT, XA, XB, XC",
      "encoding": {
        "format": "XX4-form",
        "binary_pattern": "60 | XT | XA | XB | XC | 34",
        "hex_opcode": "0xF0000022",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "XC",
            "clean": "XC"
          },
          {
            "raw": "34",
            "clean": "34"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        },
        {
          "name": "XC",
          "desc": "Control"
        }
      ],
      "extension": "VSX (P10)",
      "slug": "xxblendvh",
      "rel_url": "powerisa/xxblendvh/",
      "linked_summary": "Selects halfwords from XA <a href=\"../../powerisa/or/\">or</a> XB based on the MSB of halfwords <a href=\"../../x86/in/\">in</a> XC.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxblendvw",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Blend Variable Word",
      "summary": "Selects words from XA or XB based on the MSB of words in XC.",
      "syntax": "xxblendvw XT, XA, XB, XC",
      "encoding": {
        "format": "XX4-form",
        "binary_pattern": "60 | XT | XA | XB | XC | 35",
        "hex_opcode": "0xF0000023",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "XC",
            "clean": "XC"
          },
          {
            "raw": "35",
            "clean": "35"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        },
        {
          "name": "XC",
          "desc": "Control"
        }
      ],
      "extension": "VSX (P10)",
      "slug": "xxblendvw",
      "rel_url": "powerisa/xxblendvw/",
      "linked_summary": "Selects words from XA <a href=\"../../powerisa/or/\">or</a> XB based on the MSB of words <a href=\"../../x86/in/\">in</a> XC.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxblendvd",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Blend Variable Doubleword",
      "summary": "Selects doublewords from XA or XB based on the MSB of doublewords in XC.",
      "syntax": "xxblendvd XT, XA, XB, XC",
      "encoding": {
        "format": "XX4-form",
        "binary_pattern": "60 | XT | XA | XB | XC | 36",
        "hex_opcode": "0xF0000024",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "XC",
            "clean": "XC"
          },
          {
            "raw": "36",
            "clean": "36"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        },
        {
          "name": "XC",
          "desc": "Control"
        }
      ],
      "extension": "VSX (P10)",
      "slug": "xxblendvd",
      "rel_url": "powerisa/xxblendvd/",
      "linked_summary": "Selects doublewords from XA <a href=\"../../powerisa/or/\">or</a> XB based on the MSB of doublewords <a href=\"../../x86/in/\">in</a> XC.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lxvwsx",
      "architecture": "PowerISA",
      "full_name": "Load VSX Vector Word and Splat Indexed",
      "summary": "Loads a 32-bit word and replicates it across the vector.",
      "syntax": "lxvwsx XT, RA, RB",
      "encoding": {
        "format": "XX1-form",
        "binary_pattern": "31 | XT | RA | RB | 364",
        "hex_opcode": "0x7C00016C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "364",
            "clean": "364"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "VSX",
      "slug": "lxvwsx",
      "rel_url": "powerisa/lxvwsx/",
      "linked_summary": "Loads a 32-<a href=\"../../armv8-a/bit/\">bit</a> word <a href=\"../../armv8-a/and_6/\">and</a> replicates <a href=\"../../armv8-a/it/\">it</a> across the vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mtvsrws",
      "architecture": "PowerISA",
      "full_name": "Move To VSR Word and Splat",
      "summary": "Moves a 32-bit word from a GPR and replicates it across the vector.",
      "syntax": "mtvsrws XT, RA",
      "encoding": {
        "format": "XX1-form",
        "binary_pattern": "31 | XT | RA | 0 | 243",
        "hex_opcode": "0x7C0000F3",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "243",
            "clean": "243"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Source GPR"
        }
      ],
      "extension": "VSX",
      "slug": "mtvsrws",
      "rel_url": "powerisa/mtvsrws/",
      "linked_summary": "Moves a 32-<a href=\"../../armv8-a/bit/\">bit</a> word from a GPR <a href=\"../../armv8-a/and_6/\">and</a> replicates <a href=\"../../armv8-a/it/\">it</a> across the vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsmaxcdp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Maximum Type-C Double-Precision",
      "summary": "Max of two doubles (IEEE 754-2008 compliant).",
      "syntax": "xsmaxcdp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 152",
        "hex_opcode": "0xF0000098",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "152",
            "clean": "152"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xsmaxcdp",
      "rel_url": "powerisa/xsmaxcdp/",
      "linked_summary": "Max of two doubles (IEEE 754-2008 compliant).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsmincdp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Minimum Type-C Double-Precision",
      "summary": "Min of two doubles (IEEE 754-2008 compliant).",
      "syntax": "xsmincdp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 153",
        "hex_opcode": "0xF0000099",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "153",
            "clean": "153"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xsmincdp",
      "rel_url": "powerisa/xsmincdp/",
      "linked_summary": "Min of two doubles (IEEE 754-2008 compliant).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsmaxjdp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Maximum Type-J Double-Precision",
      "summary": "Max of two doubles (Java compliant).",
      "syntax": "xsmaxjdp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 160",
        "hex_opcode": "0xF00000A0",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "160",
            "clean": "160"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xsmaxjdp",
      "rel_url": "powerisa/xsmaxjdp/",
      "linked_summary": "Max of two doubles (Java compliant).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsminjdp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Minimum Type-J Double-Precision",
      "summary": "Min of two doubles (Java compliant).",
      "syntax": "xsminjdp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 168",
        "hex_opcode": "0xF00000A8",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "168",
            "clean": "168"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xsminjdp",
      "rel_url": "powerisa/xsminjdp/",
      "linked_summary": "Min of two doubles (Java compliant).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxgenpcvbm",
      "architecture": "PowerISA",
      "full_name": "VSX Generate PCV from Byte Mask",
      "summary": "Generates a Permute Control Vector from a byte mask.",
      "syntax": "xxgenpcvbm XT, XB, IMM",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | IMM | XB | 916",
        "hex_opcode": "0xF0000394",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "IMM",
            "clean": "IMM"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "916",
            "clean": "916"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        },
        {
          "name": "IMM",
          "desc": "Mask"
        }
      ],
      "extension": "VSX (P10)",
      "slug": "xxgenpcvbm",
      "rel_url": "powerisa/xxgenpcvbm/",
      "linked_summary": "Generates a Permute Control Vector from a byte mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxgenpcvhm",
      "architecture": "PowerISA",
      "full_name": "VSX Generate PCV from Halfword Mask",
      "summary": "Generates a Permute Control Vector from a halfword mask.",
      "syntax": "xxgenpcvhm XT, XB, IMM",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | IMM | XB | 917",
        "hex_opcode": "0xF0000395",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "IMM",
            "clean": "IMM"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "917",
            "clean": "917"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        },
        {
          "name": "IMM",
          "desc": "Mask"
        }
      ],
      "extension": "VSX (P10)",
      "slug": "xxgenpcvhm",
      "rel_url": "powerisa/xxgenpcvhm/",
      "linked_summary": "Generates a Permute Control Vector from a halfword mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxgenpcvwm",
      "architecture": "PowerISA",
      "full_name": "VSX Generate PCV from Word Mask",
      "summary": "Generates a Permute Control Vector from a word mask.",
      "syntax": "xxgenpcvwm XT, XB, IMM",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | IMM | XB | 948",
        "hex_opcode": "0xF00003B4",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "IMM",
            "clean": "IMM"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "948",
            "clean": "948"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        },
        {
          "name": "IMM",
          "desc": "Mask"
        }
      ],
      "extension": "VSX (P10)",
      "slug": "xxgenpcvwm",
      "rel_url": "powerisa/xxgenpcvwm/",
      "linked_summary": "Generates a Permute Control Vector from a word mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxgenpcvdm",
      "architecture": "PowerISA",
      "full_name": "VSX Generate PCV from Doubleword Mask",
      "summary": "Generates a Permute Control Vector from a doubleword mask.",
      "syntax": "xxgenpcvdm XT, XB, IMM",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | IMM | XB | 949",
        "hex_opcode": "0xF00003B5",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "IMM",
            "clean": "IMM"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "949",
            "clean": "949"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        },
        {
          "name": "IMM",
          "desc": "Mask"
        }
      ],
      "extension": "VSX (P10)",
      "slug": "xxgenpcvdm",
      "rel_url": "powerisa/xxgenpcvdm/",
      "linked_summary": "Generates a Permute Control Vector from a doubleword mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vclzlsbb",
      "architecture": "PowerISA",
      "full_name": "Vector Count Leading Zero Least Significant Bits Byte",
      "summary": "Counts leading zeros on the LSB of each byte.",
      "syntax": "vclzlsbb RA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | RA | 0 | vB | 1541",
        "hex_opcode": "0x10000605",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1541",
            "clean": "1541"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target GPR"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (P10)",
      "slug": "vclzlsbb",
      "rel_url": "powerisa/vclzlsbb/",
      "linked_summary": "Counts leading zeros on the LSB of each byte.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vctzlsbb",
      "architecture": "PowerISA",
      "full_name": "Vector Count Trailing Zero Least Significant Bits Byte",
      "summary": "Counts trailing zeros on the LSB of each byte.",
      "syntax": "vctzlsbb RA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | RA | 0 | vB | 1543",
        "hex_opcode": "0x10000607",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1543",
            "clean": "1543"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target GPR"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (P10)",
      "slug": "vctzlsbb",
      "rel_url": "powerisa/vctzlsbb/",
      "linked_summary": "Counts trailing zeros on the LSB of each byte.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vstril",
      "architecture": "PowerISA",
      "full_name": "Vector String Isolate Left",
      "summary": "Isolates the leftmost element that matches the condition.",
      "syntax": "vstril vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1607",
        "hex_opcode": "0x10000647",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1607",
            "clean": "1607"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (P10)",
      "slug": "vstril",
      "rel_url": "powerisa/vstril/",
      "linked_summary": "Isolates the leftmost element that matches the condition.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vstrir",
      "architecture": "PowerISA",
      "full_name": "Vector String Isolate Right",
      "summary": "Isolates the rightmost element that matches the condition.",
      "syntax": "vstrir vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1671",
        "hex_opcode": "0x10000687",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1671",
            "clean": "1671"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (P10)",
      "slug": "vstrir",
      "rel_url": "powerisa/vstrir/",
      "linked_summary": "Isolates the rightmost element that matches the condition.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vstril_p",
      "architecture": "PowerISA",
      "full_name": "Vector String Isolate Left and Record",
      "summary": "Isolates the leftmost element and updates CR6.",
      "syntax": "vstril. vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1607",
        "hex_opcode": "0x10000647",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1607",
            "clean": "1607"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (P10)",
      "slug": "vstril_p",
      "rel_url": "powerisa/vstril_p/",
      "linked_summary": "Isolates the leftmost element <a href=\"../../armv8-a/and_6/\">and</a> updates CR6.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vstrir_p",
      "architecture": "PowerISA",
      "full_name": "Vector String Isolate Right and Record",
      "summary": "Isolates the rightmost element and updates CR6.",
      "syntax": "vstrir. vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1671",
        "hex_opcode": "0x10000687",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1671",
            "clean": "1671"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (P10)",
      "slug": "vstrir_p",
      "rel_url": "powerisa/vstrir_p/",
      "linked_summary": "Isolates the rightmost element <a href=\"../../armv8-a/and_6/\">and</a> updates CR6.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vinserth_p",
      "architecture": "PowerISA",
      "full_name": "Vector Insert Halfword from GPR",
      "summary": "Inserts halfword from GPR into Vector.",
      "syntax": "vinserth vD, RB, UIM",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | UIM | RB | 845",
        "hex_opcode": "0x1000034D",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "845",
            "clean": "845"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "RB",
          "desc": "Source"
        },
        {
          "name": "UIM",
          "desc": "Index"
        }
      ],
      "extension": "Vector (P10)",
      "slug": "vinserth_p",
      "rel_url": "powerisa/vinserth_p/",
      "linked_summary": "Inserts halfword from GPR into Vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vinsertw_p",
      "architecture": "PowerISA",
      "full_name": "Vector Insert Word from GPR",
      "summary": "Inserts word from GPR into Vector.",
      "syntax": "vinsertw vD, RB, UIM",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | UIM | RB | 909",
        "hex_opcode": "0x1000038D",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "909",
            "clean": "909"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "RB",
          "desc": "Source"
        },
        {
          "name": "UIM",
          "desc": "Index"
        }
      ],
      "extension": "Vector (P10)",
      "slug": "vinsertw_p",
      "rel_url": "powerisa/vinsertw_p/",
      "linked_summary": "Inserts word from GPR into Vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vinsertd_p",
      "architecture": "PowerISA",
      "full_name": "Vector Insert Doubleword from GPR",
      "summary": "Inserts doubleword from GPR into Vector.",
      "syntax": "vinsertd vD, RB, UIM",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | UIM | RB | 973",
        "hex_opcode": "0x100003CD",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "973",
            "clean": "973"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "RB",
          "desc": "Source"
        },
        {
          "name": "UIM",
          "desc": "Index"
        }
      ],
      "extension": "Vector (P10)",
      "slug": "vinsertd_p",
      "rel_url": "powerisa/vinsertd_p/",
      "linked_summary": "Inserts doubleword from GPR into Vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxsplti32dx",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Splat Immediate 32-bit Double Index",
      "summary": "Splats a 32-bit immediate into a doubleword index.",
      "syntax": "xxsplti32dx XT, IX, IMM",
      "encoding": {
        "format": "8RR:D-form",
        "binary_pattern": "60 | XT | IX | ...",
        "hex_opcode": "0xF0000000...",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "IX",
            "clean": "IX"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "IX",
          "desc": "Index"
        },
        {
          "name": "IMM",
          "desc": "Value"
        }
      ],
      "extension": "VSX (P10)",
      "slug": "xxsplti32dx",
      "rel_url": "powerisa/xxsplti32dx/",
      "linked_summary": "Splats a 32-<a href=\"../../armv8-a/bit/\">bit</a> immediate into a doubleword <a href=\"../../armv8-a/index/\">index</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxspltib",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Splat Immediate Byte",
      "summary": "Splats an 8-bit immediate into all bytes.",
      "syntax": "xxspltib XT, IMM",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "60 | XT | 0 | IMM | 360",
        "hex_opcode": "0xF0000168",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "IMM",
            "clean": "IMM"
          },
          {
            "raw": "360",
            "clean": "360"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "IMM",
          "desc": "Value"
        }
      ],
      "extension": "VSX",
      "slug": "xxspltib",
      "rel_url": "powerisa/xxspltib/",
      "linked_summary": "Splats an 8-<a href=\"../../armv8-a/bit/\">bit</a> immediate into all bytes.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "hashchk",
      "architecture": "PowerISA",
      "full_name": "Hash Check",
      "summary": "Checks the hash of the Return Address Stack (ROP Protection).",
      "syntax": "hashchk RA",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | RA | / | 754 | /",
        "hex_opcode": "0x7C0005E2",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "754",
            "clean": "754"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Address"
        }
      ],
      "extension": "Base (Security)",
      "slug": "hashchk",
      "rel_url": "powerisa/hashchk/",
      "linked_summary": "Checks the hash of the Return Address Stack (ROP Protection).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "hashchkp",
      "architecture": "PowerISA",
      "full_name": "Hash Check Privileged",
      "summary": "Privileged version of hash check.",
      "syntax": "hashchkp RA",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | RA | / | 722 | /",
        "hex_opcode": "0x7C0005A2",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "722",
            "clean": "722"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Address"
        }
      ],
      "extension": "Privileged (Security)",
      "slug": "hashchkp",
      "rel_url": "powerisa/hashchkp/",
      "linked_summary": "Privileged version of hash check.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "hashst",
      "architecture": "PowerISA",
      "full_name": "Hash Store",
      "summary": "Stores the hash of the Return Address.",
      "syntax": "hashst RA",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | RA | / | 755 | /",
        "hex_opcode": "0x7C0005E3",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "755",
            "clean": "755"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Address"
        }
      ],
      "extension": "Base (Security)",
      "slug": "hashst",
      "rel_url": "powerisa/hashst/",
      "linked_summary": "Stores the hash of the Return Address.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "hashstp",
      "architecture": "PowerISA",
      "full_name": "Hash Store Privileged",
      "summary": "Privileged version of hash store.",
      "syntax": "hashstp RA",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | RA | / | 723 | /",
        "hex_opcode": "0x7C0005A3",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "723",
            "clean": "723"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Address"
        }
      ],
      "extension": "Privileged (Security)",
      "slug": "hashstp",
      "rel_url": "powerisa/hashstp/",
      "linked_summary": "Privileged version of hash store.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psq_l",
      "architecture": "PowerISA",
      "full_name": "Paired Single Quantized Load",
      "summary": "Loads a paired single from memory (Embedded/Legacy).",
      "syntax": "psq_l FRT, D(RA), W, I",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "56 | FRT | RA | W | I | 6",
        "hex_opcode": "0xE0000006",
        "visual_parts": [
          {
            "raw": "56",
            "clean": "56"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "W",
            "clean": "W"
          },
          {
            "raw": "I",
            "clean": "I"
          },
          {
            "raw": "6",
            "clean": "6"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "W",
          "desc": "Width"
        },
        {
          "name": "I",
          "desc": "Scale"
        }
      ],
      "extension": "Paired Single",
      "slug": "psq_l",
      "rel_url": "powerisa/psq_l/",
      "linked_summary": "Loads a paired single from memory (Embedded/Legacy).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psq_st",
      "architecture": "PowerISA",
      "full_name": "Paired Single Quantized Store",
      "summary": "Stores a paired single to memory (Embedded/Legacy).",
      "syntax": "psq_st FRS, D(RA), W, I",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "60 | FRS | RA | W | I | 7",
        "hex_opcode": "0xF0000007",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "FRS",
            "clean": "FRS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "W",
            "clean": "W"
          },
          {
            "raw": "I",
            "clean": "I"
          },
          {
            "raw": "7",
            "clean": "7"
          }
        ]
      },
      "operands": [
        {
          "name": "FRS",
          "desc": "Source"
        },
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "W",
          "desc": "Width"
        },
        {
          "name": "I",
          "desc": "Scale"
        }
      ],
      "extension": "Paired Single",
      "slug": "psq_st",
      "rel_url": "powerisa/psq_st/",
      "linked_summary": "Stores a paired single to memory (Embedded/Legacy).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ps_add",
      "architecture": "PowerISA",
      "full_name": "Paired Single Add",
      "summary": "Adds two paired singles.",
      "syntax": "ps_add FRT, FRA, FRB",
      "encoding": {
        "format": "A-form",
        "binary_pattern": "60 | FRT | FRA | FRB | 21",
        "hex_opcode": "0xF0000015",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "FRA",
            "clean": "FRA"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "21",
            "clean": "21"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRA",
          "desc": "Src A"
        },
        {
          "name": "FRB",
          "desc": "Src B"
        }
      ],
      "extension": "Paired Single",
      "slug": "ps_add",
      "rel_url": "powerisa/ps_add/",
      "linked_summary": "Adds two paired singles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ps_sub",
      "architecture": "PowerISA",
      "full_name": "Paired Single Subtract",
      "summary": "Subtracts two paired singles.",
      "syntax": "ps_sub FRT, FRA, FRB",
      "encoding": {
        "format": "A-form",
        "binary_pattern": "60 | FRT | FRA | FRB | 20",
        "hex_opcode": "0xF0000014",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "FRA",
            "clean": "FRA"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "20",
            "clean": "20"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRA",
          "desc": "Src A"
        },
        {
          "name": "FRB",
          "desc": "Src B"
        }
      ],
      "extension": "Paired Single",
      "slug": "ps_sub",
      "rel_url": "powerisa/ps_sub/",
      "linked_summary": "Subtracts two paired singles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ps_mul",
      "architecture": "PowerISA",
      "full_name": "Paired Single Multiply",
      "summary": "Multiplies two paired singles.",
      "syntax": "ps_mul FRT, FRA, FRC",
      "encoding": {
        "format": "A-form",
        "binary_pattern": "60 | FRT | FRA | FRC | 25",
        "hex_opcode": "0xF0000019",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "FRA",
            "clean": "FRA"
          },
          {
            "raw": "FRC",
            "clean": "FRC"
          },
          {
            "raw": "25",
            "clean": "25"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRA",
          "desc": "Src A"
        },
        {
          "name": "FRC",
          "desc": "Src C"
        }
      ],
      "extension": "Paired Single",
      "slug": "ps_mul",
      "rel_url": "powerisa/ps_mul/",
      "linked_summary": "Multiplies two paired singles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ps_madd",
      "architecture": "PowerISA",
      "full_name": "Paired Single Multiply-Add",
      "summary": "Multiply-Add on paired singles.",
      "syntax": "ps_madd FRT, FRA, FRC, FRB",
      "encoding": {
        "format": "A-form",
        "binary_pattern": "60 | FRT | FRA | FRB | FRC | 29",
        "hex_opcode": "0xF000001D",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "FRA",
            "clean": "FRA"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "FRC",
            "clean": "FRC"
          },
          {
            "raw": "29",
            "clean": "29"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRA",
          "desc": "Src A"
        },
        {
          "name": "FRC",
          "desc": "Src C"
        },
        {
          "name": "FRB",
          "desc": "Src B"
        }
      ],
      "extension": "Paired Single",
      "slug": "ps_madd",
      "rel_url": "powerisa/ps_madd/",
      "linked_summary": "Multiply-Add on paired singles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_add",
      "architecture": "PowerISA",
      "full_name": "VLE Add",
      "summary": "Adds two registers. (RT = RA + RB)",
      "syntax": "e_add RT, RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_add",
      "rel_url": "powerisa/e_add/",
      "linked_summary": "Adds two registers. (RT = RA + RB)",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_addc",
      "architecture": "PowerISA",
      "full_name": "VLE Add Carrying",
      "summary": "Adds two registers and updates Carry (CA).",
      "syntax": "e_addc RT, RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_addc",
      "rel_url": "powerisa/e_addc/",
      "linked_summary": "Adds two registers <a href=\"../../armv8-a/and_6/\">and</a> updates Carry (CA).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_adde",
      "architecture": "PowerISA",
      "full_name": "VLE Add Extended",
      "summary": "Adds two registers and the Carry bit.",
      "syntax": "e_adde RT, RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_adde",
      "rel_url": "powerisa/e_adde/",
      "linked_summary": "Adds two registers <a href=\"../../armv8-a/and_6/\">and</a> the Carry <a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_addme",
      "architecture": "PowerISA",
      "full_name": "VLE Add to Minus One Extended",
      "summary": "Adds register to -1 with Carry.",
      "syntax": "e_addme RT, RA",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Source"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_addme",
      "rel_url": "powerisa/e_addme/",
      "linked_summary": "Adds register to -1 with Carry.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_addze",
      "architecture": "PowerISA",
      "full_name": "VLE Add to Zero Extended",
      "summary": "Adds register to 0 with Carry.",
      "syntax": "e_addze RT, RA",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Source"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_addze",
      "rel_url": "powerisa/e_addze/",
      "linked_summary": "Adds register to 0 with Carry.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_subf",
      "architecture": "PowerISA",
      "full_name": "VLE Subtract From",
      "summary": "Subtracts RA from RB (RT = RB - RA).",
      "syntax": "e_subf RT, RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_subf",
      "rel_url": "powerisa/e_subf/",
      "linked_summary": "Subtracts RA from RB (RT = RB - RA).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_subfc",
      "architecture": "PowerISA",
      "full_name": "VLE Subtract From Carrying",
      "summary": "Subtracts RA from RB and updates Carry.",
      "syntax": "e_subfc RT, RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_subfc",
      "rel_url": "powerisa/e_subfc/",
      "linked_summary": "Subtracts RA from RB <a href=\"../../armv8-a/and_6/\">and</a> updates Carry.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_subfe",
      "architecture": "PowerISA",
      "full_name": "VLE Subtract From Extended",
      "summary": "Subtracts RA from RB with Carry.",
      "syntax": "e_subfe RT, RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_subfe",
      "rel_url": "powerisa/e_subfe/",
      "linked_summary": "Subtracts RA from RB with Carry.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_subfic",
      "architecture": "PowerISA",
      "full_name": "VLE Subtract From Immediate Carrying",
      "summary": "Subtracts register from immediate.",
      "syntax": "e_subfic RT, RA, SI",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0001 | 1100 | ...",
        "hex_opcode": "0x1C00...",
        "visual_parts": [
          {
            "raw": "0001",
            "clean": "0001"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Source"
        },
        {
          "name": "SI",
          "desc": "Imm"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_subfic",
      "rel_url": "powerisa/e_subfic/",
      "linked_summary": "Subtracts register from immediate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_subfme",
      "architecture": "PowerISA",
      "full_name": "VLE Subtract From Minus One Extended",
      "summary": "Subtracts register from -1 with Carry.",
      "syntax": "e_subfme RT, RA",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Source"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_subfme",
      "rel_url": "powerisa/e_subfme/",
      "linked_summary": "Subtracts register from -1 with Carry.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_subfze",
      "architecture": "PowerISA",
      "full_name": "VLE Subtract From Zero Extended",
      "summary": "Subtracts register from 0 with Carry.",
      "syntax": "e_subfze RT, RA",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Source"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_subfze",
      "rel_url": "powerisa/e_subfze/",
      "linked_summary": "Subtracts register from 0 with Carry.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_neg",
      "architecture": "PowerISA",
      "full_name": "VLE Negate",
      "summary": "Negates a register (RT = -RA).",
      "syntax": "e_neg RT, RA",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Source"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_neg",
      "rel_url": "powerisa/e_neg/",
      "linked_summary": "Negates a register (RT = -RA).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_mulhw",
      "architecture": "PowerISA",
      "full_name": "VLE Multiply High Word",
      "summary": "Multiplies two words, keeps high 32 bits (Signed).",
      "syntax": "e_mulhw RT, RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_mulhw",
      "rel_url": "powerisa/e_mulhw/",
      "linked_summary": "Multiplies two words, keeps high 32 bits (Signed).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_mulhwu",
      "architecture": "PowerISA",
      "full_name": "VLE Multiply High Word Unsigned",
      "summary": "Multiplies two words, keeps high 32 bits (Unsigned).",
      "syntax": "e_mulhwu RT, RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_mulhwu",
      "rel_url": "powerisa/e_mulhwu/",
      "linked_summary": "Multiplies two words, keeps high 32 bits (Unsigned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_divwu",
      "architecture": "PowerISA",
      "full_name": "VLE Divide Word Unsigned",
      "summary": "Unsigned division.",
      "syntax": "e_divwu RT, RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_divwu",
      "rel_url": "powerisa/e_divwu/",
      "linked_summary": "Unsigned division.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_and",
      "architecture": "PowerISA",
      "full_name": "VLE AND",
      "summary": "Bitwise AND.",
      "syntax": "e_and RT, RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_and",
      "rel_url": "powerisa/e_and/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/and/\">AND</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_andc",
      "architecture": "PowerISA",
      "full_name": "VLE AND with Complement",
      "summary": "RT = RA & ~RB.",
      "syntax": "e_andc RT, RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_andc",
      "rel_url": "powerisa/e_andc/",
      "linked_summary": "RT = RA & ~RB.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_or",
      "architecture": "PowerISA",
      "full_name": "VLE OR",
      "summary": "Bitwise OR.",
      "syntax": "e_or RT, RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_or",
      "rel_url": "powerisa/e_or/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/or/\">OR</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_orc",
      "architecture": "PowerISA",
      "full_name": "VLE OR with Complement",
      "summary": "RT = RA | ~RB.",
      "syntax": "e_orc RT, RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_orc",
      "rel_url": "powerisa/e_orc/",
      "linked_summary": "RT = RA | ~RB.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_xor",
      "architecture": "PowerISA",
      "full_name": "VLE XOR",
      "summary": "Bitwise XOR.",
      "syntax": "e_xor RT, RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_xor",
      "rel_url": "powerisa/e_xor/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/xor/\">XOR</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_nand",
      "architecture": "PowerISA",
      "full_name": "VLE NAND",
      "summary": "Bitwise NAND.",
      "syntax": "e_nand RT, RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_nand",
      "rel_url": "powerisa/e_nand/",
      "linked_summary": "Bitwise NAND.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_nor",
      "architecture": "PowerISA",
      "full_name": "VLE NOR",
      "summary": "Bitwise NOR.",
      "syntax": "e_nor RT, RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_nor",
      "rel_url": "powerisa/e_nor/",
      "linked_summary": "Bitwise NOR.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_eqv",
      "architecture": "PowerISA",
      "full_name": "VLE Equivalence",
      "summary": "Bitwise XNOR.",
      "syntax": "e_eqv RT, RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_eqv",
      "rel_url": "powerisa/e_eqv/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/xnor/\">XNOR</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_extsb",
      "architecture": "PowerISA",
      "full_name": "VLE Extend Sign Byte",
      "summary": "Sign extends low byte.",
      "syntax": "e_extsb RT, RA",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Source"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_extsb",
      "rel_url": "powerisa/e_extsb/",
      "linked_summary": "Sign extends low byte.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_extsh",
      "architecture": "PowerISA",
      "full_name": "VLE Extend Sign Halfword",
      "summary": "Sign extends low halfword.",
      "syntax": "e_extsh RT, RA",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Source"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_extsh",
      "rel_url": "powerisa/e_extsh/",
      "linked_summary": "Sign extends low halfword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_cntlzw",
      "architecture": "PowerISA",
      "full_name": "VLE Count Leading Zeros Word",
      "summary": "Counts leading zeros.",
      "syntax": "e_cntlzw RT, RA",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Source"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_cntlzw",
      "rel_url": "powerisa/e_cntlzw/",
      "linked_summary": "Counts leading zeros.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_cmp",
      "architecture": "PowerISA",
      "full_name": "VLE Compare",
      "summary": "Signed comparison.",
      "syntax": "e_cmp BF, RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_cmp",
      "rel_url": "powerisa/e_cmp/",
      "linked_summary": "Signed comparison.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_cmpl",
      "architecture": "PowerISA",
      "full_name": "VLE Compare Logical",
      "summary": "Unsigned comparison.",
      "syntax": "e_cmpl BF, RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_cmpl",
      "rel_url": "powerisa/e_cmpl/",
      "linked_summary": "Unsigned comparison.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_cmpi",
      "architecture": "PowerISA",
      "full_name": "VLE Compare Immediate",
      "summary": "Compare with immediate.",
      "syntax": "e_cmpi BF, RA, SI",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0001 | 1000 | ...",
        "hex_opcode": "0x1800...",
        "visual_parts": [
          {
            "raw": "0001",
            "clean": "0001"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "RA",
          "desc": "Src"
        },
        {
          "name": "SI",
          "desc": "Imm"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_cmpi",
      "rel_url": "powerisa/e_cmpi/",
      "linked_summary": "Compare with immediate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_cmpli",
      "architecture": "PowerISA",
      "full_name": "VLE Compare Logical Immediate",
      "summary": "Unsigned compare with immediate.",
      "syntax": "e_cmpli BF, RA, UI",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0001 | 1000 | ...",
        "hex_opcode": "0x1800...",
        "visual_parts": [
          {
            "raw": "0001",
            "clean": "0001"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "RA",
          "desc": "Src"
        },
        {
          "name": "UI",
          "desc": "Imm"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_cmpli",
      "rel_url": "powerisa/e_cmpli/",
      "linked_summary": "Unsigned compare with immediate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_cmph",
      "architecture": "PowerISA",
      "full_name": "VLE Compare Halfword",
      "summary": "Compares 16-bit values.",
      "syntax": "e_cmph BF, RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_cmph",
      "rel_url": "powerisa/e_cmph/",
      "linked_summary": "Compares 16-<a href=\"../../armv8-a/bit/\">bit</a> values.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_cmphl",
      "architecture": "PowerISA",
      "full_name": "VLE Compare Halfword Logical",
      "summary": "Unsigned compare 16-bit values.",
      "syntax": "e_cmphl BF, RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_cmphl",
      "rel_url": "powerisa/e_cmphl/",
      "linked_summary": "Unsigned compare 16-<a href=\"../../armv8-a/bit/\">bit</a> values.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_cmph16i",
      "architecture": "PowerISA",
      "full_name": "VLE Compare Halfword 16-bit Immediate",
      "summary": "Compare halfword with immediate.",
      "syntax": "e_cmph16i BF, RA, SI",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0001 | 1100 | ...",
        "hex_opcode": "0x1C00...",
        "visual_parts": [
          {
            "raw": "0001",
            "clean": "0001"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "RA",
          "desc": "Src"
        },
        {
          "name": "SI",
          "desc": "Imm"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_cmph16i",
      "rel_url": "powerisa/e_cmph16i/",
      "linked_summary": "Compare halfword with immediate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_cmphl16i",
      "architecture": "PowerISA",
      "full_name": "VLE Compare Halfword Logical 16-bit Immediate",
      "summary": "Unsigned compare halfword with immediate.",
      "syntax": "e_cmphl16i BF, RA, UI",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0001 | 1100 | ...",
        "hex_opcode": "0x1C00...",
        "visual_parts": [
          {
            "raw": "0001",
            "clean": "0001"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "RA",
          "desc": "Src"
        },
        {
          "name": "UI",
          "desc": "Imm"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_cmphl16i",
      "rel_url": "powerisa/e_cmphl16i/",
      "linked_summary": "Unsigned compare halfword with immediate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_lbzu",
      "architecture": "PowerISA",
      "full_name": "VLE Load Byte and Zero with Update",
      "summary": "Loads byte and updates base register.",
      "syntax": "e_lbzu RT, D(RA)",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0101 | 0001 | ...",
        "hex_opcode": "0x5100...",
        "visual_parts": [
          {
            "raw": "0101",
            "clean": "0101"
          },
          {
            "raw": "0001",
            "clean": "0001"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_lbzu",
      "rel_url": "powerisa/e_lbzu/",
      "linked_summary": "Loads byte <a href=\"../../armv8-a/and_6/\">and</a> updates base register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_lhzu",
      "architecture": "PowerISA",
      "full_name": "VLE Load Halfword and Zero with Update",
      "summary": "Loads halfword and updates base register.",
      "syntax": "e_lhzu RT, D(RA)",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0101 | 0010 | ...",
        "hex_opcode": "0x5200...",
        "visual_parts": [
          {
            "raw": "0101",
            "clean": "0101"
          },
          {
            "raw": "0010",
            "clean": "0010"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_lhzu",
      "rel_url": "powerisa/e_lhzu/",
      "linked_summary": "Loads halfword <a href=\"../../armv8-a/and_6/\">and</a> updates base register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_stbu",
      "architecture": "PowerISA",
      "full_name": "VLE Store Byte with Update",
      "summary": "Stores byte and updates base register.",
      "syntax": "e_stbu RS, D(RA)",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0101 | 0101 | ...",
        "hex_opcode": "0x5500...",
        "visual_parts": [
          {
            "raw": "0101",
            "clean": "0101"
          },
          {
            "raw": "0101",
            "clean": "0101"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_stbu",
      "rel_url": "powerisa/e_stbu/",
      "linked_summary": "Stores byte <a href=\"../../armv8-a/and_6/\">and</a> updates base register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_sthu",
      "architecture": "PowerISA",
      "full_name": "VLE Store Halfword with Update",
      "summary": "Stores halfword and updates base register.",
      "syntax": "e_sthu RS, D(RA)",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0101 | 0110 | ...",
        "hex_opcode": "0x5600...",
        "visual_parts": [
          {
            "raw": "0101",
            "clean": "0101"
          },
          {
            "raw": "0110",
            "clean": "0110"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_sthu",
      "rel_url": "powerisa/e_sthu/",
      "linked_summary": "Stores halfword <a href=\"../../armv8-a/and_6/\">and</a> updates base register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lbzepx",
      "architecture": "PowerISA",
      "full_name": "Load Byte and Zero External Process ID Indexed",
      "summary": "Loads a byte using the External PID (for OS kernels accessing user memory).",
      "syntax": "lbzepx RT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | RA | RB | 31 | /",
        "hex_opcode": "0x7C00003E",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Embedded (External PID)",
      "slug": "lbzepx",
      "rel_url": "powerisa/lbzepx/",
      "linked_summary": "Loads a byte using the External PID (for OS kernels accessing user memory).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lhzepx",
      "architecture": "PowerISA",
      "full_name": "Load Halfword and Zero External Process ID Indexed",
      "summary": "Loads a halfword using the External PID.",
      "syntax": "lhzepx RT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | RA | RB | 95 | /",
        "hex_opcode": "0x7C0000BE",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "95",
            "clean": "95"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Embedded (External PID)",
      "slug": "lhzepx",
      "rel_url": "powerisa/lhzepx/",
      "linked_summary": "Loads a halfword using the External PID.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lwzepx",
      "architecture": "PowerISA",
      "full_name": "Load Word and Zero External Process ID Indexed",
      "summary": "Loads a word using the External PID.",
      "syntax": "lwzepx RT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | RA | RB | 63 | /",
        "hex_opcode": "0x7C00007E",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Embedded (External PID)",
      "slug": "lwzepx",
      "rel_url": "powerisa/lwzepx/",
      "linked_summary": "Loads a word using the External PID.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stbepx",
      "architecture": "PowerISA",
      "full_name": "Store Byte External Process ID Indexed",
      "summary": "Stores a byte using the External PID.",
      "syntax": "stbepx RS, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 159 | /",
        "hex_opcode": "0x7C00013E",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "159",
            "clean": "159"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Embedded (External PID)",
      "slug": "stbepx",
      "rel_url": "powerisa/stbepx/",
      "linked_summary": "Stores a byte using the External PID.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sthep",
      "architecture": "PowerISA",
      "full_name": "Store Halfword External Process ID Indexed",
      "summary": "Stores a halfword using the External PID.",
      "syntax": "sthepx RS, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 223 | /",
        "hex_opcode": "0x7C0001BE",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "223",
            "clean": "223"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Embedded (External PID)",
      "slug": "sthep",
      "rel_url": "powerisa/sthep/",
      "linked_summary": "Stores a halfword using the External PID.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stwepx",
      "architecture": "PowerISA",
      "full_name": "Store Word External Process ID Indexed",
      "summary": "Stores a word using the External PID.",
      "syntax": "stwepx RS, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 191 | /",
        "hex_opcode": "0x7C00017E",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "191",
            "clean": "191"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Embedded (External PID)",
      "slug": "stwepx",
      "rel_url": "powerisa/stwepx/",
      "linked_summary": "Stores a word using the External PID.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mfpmr",
      "architecture": "PowerISA",
      "full_name": "Move From Performance Monitor Register",
      "summary": "Reads a performance monitor register (Embedded).",
      "syntax": "mfpmr RT, PMRN",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | PMRN | 334 | /",
        "hex_opcode": "0x7C00029E",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "PMRN",
            "clean": "PMRN"
          },
          {
            "raw": "334",
            "clean": "334"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "PMRN",
          "desc": "Register Num"
        }
      ],
      "extension": "Embedded (PMU)",
      "slug": "mfpmr",
      "rel_url": "powerisa/mfpmr/",
      "linked_summary": "Reads a performance <a href=\"../../x86/monitor/\">monitor</a> register (Embedded).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mtpmr",
      "architecture": "PowerISA",
      "full_name": "Move To Performance Monitor Register",
      "summary": "Writes a performance monitor register (Embedded).",
      "syntax": "mtpmr PMRN, RS",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | PMRN | 462 | /",
        "hex_opcode": "0x7C00039E",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "PMRN",
            "clean": "PMRN"
          },
          {
            "raw": "462",
            "clean": "462"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "PMRN",
          "desc": "Register Num"
        },
        {
          "name": "RS",
          "desc": "Source"
        }
      ],
      "extension": "Embedded (PMU)",
      "slug": "mtpmr",
      "rel_url": "powerisa/mtpmr/",
      "linked_summary": "Writes a performance <a href=\"../../x86/monitor/\">monitor</a> register (Embedded).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dcblc",
      "architecture": "PowerISA",
      "full_name": "Data Cache Block Lock Clear",
      "summary": "Clears a cache line lock.",
      "syntax": "dcblc CT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | CT | RA | RB | 390 | /",
        "hex_opcode": "0x7C00030C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "CT",
            "clean": "CT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "390",
            "clean": "390"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "CT",
          "desc": "Cache Target"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Embedded (Cache Lock)",
      "slug": "dcblc",
      "rel_url": "powerisa/dcblc/",
      "linked_summary": "Clears a cache line lock.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "icblc",
      "architecture": "PowerISA",
      "full_name": "Instruction Cache Block Lock Clear",
      "summary": "Clears an instruction cache line lock.",
      "syntax": "icblc CT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | CT | RA | RB | 230 | /",
        "hex_opcode": "0x7C0001CC",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "CT",
            "clean": "CT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "230",
            "clean": "230"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "CT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Embedded (Cache Lock)",
      "slug": "icblc",
      "rel_url": "powerisa/icblc/",
      "linked_summary": "Clears an instruction cache line lock.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "waitimpl",
      "architecture": "PowerISA",
      "full_name": "Wait for Implementation Dependent",
      "summary": "Waits for a specific implementation event.",
      "syntax": "waitimpl",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | 0 | 0 | 0 | 62 | /",
        "hex_opcode": "0x7C00007C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "62",
            "clean": "62"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [],
      "extension": "Base (Wait)",
      "slug": "waitimpl",
      "rel_url": "powerisa/waitimpl/",
      "linked_summary": "Waits for a specific implementation event.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "waitrsv",
      "architecture": "PowerISA",
      "full_name": "Wait for Reservation Loss",
      "summary": "Waits until a reservation is lost (Multithreading sync).",
      "syntax": "waitrsv",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | 0 | 0 | 0 | 62 | /",
        "hex_opcode": "0x7C00007C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "62",
            "clean": "62"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [],
      "extension": "Base (Wait)",
      "slug": "waitrsv",
      "rel_url": "powerisa/waitrsv/",
      "linked_summary": "Waits until a reservation is lost (Multithreading <a href=\"../../powerisa/sync/\">sync</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "eieio",
      "architecture": "PowerISA",
      "full_name": "Enforce In-order Execution of I/O",
      "summary": "Ensures that load/store instructions preceding the EIEIO complete before those following it. Used for Memory-Mapped I/O synchronization.",
      "syntax": "eieio",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | 00000 | 00000 | 00000 | 854 | /",
        "hex_opcode": "0x7C0006AC",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "854",
            "clean": "854"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [],
      "pseudocode": "Barrier(IO_Storage)",
      "example": "eieio",
      "example_note": "I/O Barrier.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">Barrier(IO_Storage)</code></pre>",
      "slug": "eieio",
      "rel_url": "powerisa/eieio/",
      "linked_summary": "Ensures that load/store instructions preceding the EIEIO complete before those following <a href=\"../../armv8-a/it/\">it</a>. Used for Memory-Mapped I/O synchronization.",
      "linked_pseudocode": "Barrier(IO_Storage)"
    },
    {
      "mnemonic": "fadd",
      "architecture": "PowerISA",
      "full_name": "Floating Add",
      "summary": "Adds two double-precision floating-point registers.",
      "syntax": "fadd FRT, FRA, FRB",
      "encoding": {
        "format": "A-form",
        "binary_pattern": "63 | FRT | FRA | FRB | 00000 | 21 | Rc",
        "hex_opcode": "0xFC00002A",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "FRA",
            "clean": "FRA"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "21",
            "clean": "21"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target FPR"
        },
        {
          "name": "FRA",
          "desc": "Source FPR A"
        },
        {
          "name": "FRB",
          "desc": "Source FPR B"
        }
      ],
      "pseudocode": "FRT <- (FRA) + (FRB)",
      "example": "fadd f1, f2, f3",
      "example_note": "f1 = f2 + f3",
      "extension": "Float",
      "pseudocode_html": "<pre><code class=\"language-clike\">FRT &lt;- (FRA) + (FRB)</code></pre>",
      "slug": "fadd",
      "rel_url": "powerisa/fadd/",
      "linked_summary": "Adds two double-precision floating-point registers.",
      "linked_pseudocode": "FRT <- (FRA) + (FRB)"
    },
    {
      "mnemonic": "fmul",
      "architecture": "PowerISA",
      "full_name": "Floating Multiply",
      "summary": "Multiplies two double-precision floating-point registers.",
      "syntax": "fmul FRT, FRA, FRC",
      "encoding": {
        "format": "A-form",
        "binary_pattern": "63 | FRT | FRA | 00000 | FRC | 25 | Rc",
        "hex_opcode": "0xFC000032",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "FRA",
            "clean": "FRA"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "FRC",
            "clean": "FRC"
          },
          {
            "raw": "25",
            "clean": "25"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target FPR"
        },
        {
          "name": "FRA",
          "desc": "Source FPR A"
        },
        {
          "name": "FRC",
          "desc": "Source FPR C"
        }
      ],
      "pseudocode": "FRT <- (FRA) * (FRC)",
      "example": "fmul f1, f2, f3",
      "example_note": "f1 = f2 * f3",
      "extension": "Float",
      "pseudocode_html": "<pre><code class=\"language-clike\">FRT &lt;- (FRA) * (FRC)</code></pre>",
      "slug": "fmul",
      "rel_url": "powerisa/fmul/",
      "linked_summary": "Multiplies two double-precision floating-point registers.",
      "linked_pseudocode": "FRT <- (FRA) * (FRC)"
    },
    {
      "mnemonic": "fmadd",
      "architecture": "PowerISA",
      "full_name": "Floating Multiply-Add",
      "summary": "Performs (A * C) + B with a single rounding step. (The classic FMA).",
      "syntax": "fmadd FRT, FRA, FRC, FRB",
      "encoding": {
        "format": "A-form",
        "binary_pattern": "63 | FRT | FRA | FRB | FRC | 29 | Rc",
        "hex_opcode": "0xFC00003A",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "FRA",
            "clean": "FRA"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "FRC",
            "clean": "FRC"
          },
          {
            "raw": "29",
            "clean": "29"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target FPR"
        },
        {
          "name": "FRA",
          "desc": "Multiplier"
        },
        {
          "name": "FRC",
          "desc": "Multiplicand"
        },
        {
          "name": "FRB",
          "desc": "Addend"
        }
      ],
      "pseudocode": "FRT <- [(FRA) * (FRC)] + (FRB)",
      "example": "fmadd f1, f2, f3, f4",
      "example_note": "f1 = (f2 * f3) + f4",
      "extension": "Float",
      "pseudocode_html": "<pre><code class=\"language-clike\">FRT &lt;- [(FRA) * (FRC)] + (FRB)</code></pre>",
      "slug": "fmadd",
      "rel_url": "powerisa/fmadd/",
      "linked_summary": "Performs (A * C) + B with a single rounding step. (The classic FMA).",
      "linked_pseudocode": "FRT <- [(FRA) * (FRC)] + (FRB)"
    },
    {
      "mnemonic": "fcmpu",
      "architecture": "PowerISA",
      "full_name": "Floating Compare Unordered",
      "summary": "Compares two floating-point registers and sets the Condition Register (CR) field. Does not trap on NaNs.",
      "syntax": "fcmpu BF, FRA, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | BF | / | FRA | FRB | 0000000000 | /",
        "hex_opcode": "0xFC000000",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "FRA",
            "clean": "FRA"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "0000000000",
            "clean": "0000000000"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "FRA",
          "desc": "Source A"
        },
        {
          "name": "FRB",
          "desc": "Source B"
        }
      ],
      "pseudocode": "if NaN(FRA) or NaN(FRB) then CR[BF] <- U; else compare...",
      "example": "fcmpu cr0, f1, f2",
      "example_note": "Compare f1 vs f2.",
      "extension": "Float",
      "pseudocode_html": "<pre><code class=\"language-clike\">if NaN(FRA) or NaN(FRB) then CR[BF] &lt;- U; else compare...</code></pre>",
      "slug": "fcmpu",
      "rel_url": "powerisa/fcmpu/",
      "linked_summary": "Compares two floating-point registers <a href=\"../../armv8-a/and_6/\">and</a> sets the Condition Register (CR) field. Does <a href=\"../../armv8-a/not_1/\">not</a> <a href=\"../../powerisa/trap/\">trap</a> on NaNs.",
      "linked_pseudocode": "if NaN(FRA) <a href=\"../../powerisa/or/\">or</a> NaN(FRB) then CR[BF] <- U; else compare..."
    },
    {
      "mnemonic": "fctiw",
      "architecture": "PowerISA",
      "full_name": "Floating Convert to Integer Word",
      "summary": "Converts a float to a 32-bit signed integer (using the current rounding mode) and stores it in the lower half of the FPR.",
      "syntax": "fctiw FRT, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | FRT | / | FRB | 14 | Rc",
        "hex_opcode": "0xFC00001C",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "14",
            "clean": "14"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target FPR"
        },
        {
          "name": "FRB",
          "desc": "Source FPR"
        }
      ],
      "pseudocode": "FRT[32:63] <- ConvertToInt32(FRB)",
      "example": "fctiw f1, f2",
      "example_note": "Convert float f2 to int in f1.",
      "extension": "Float",
      "pseudocode_html": "<pre><code class=\"language-clike\">FRT[32:63] &lt;- ConvertToInt32(FRB)</code></pre>",
      "slug": "fctiw",
      "rel_url": "powerisa/fctiw/",
      "linked_summary": "Converts a float to a 32-<a href=\"../../armv8-a/bit/\">bit</a> signed integer (using the current rounding mode) <a href=\"../../armv8-a/and_6/\">and</a> stores <a href=\"../../armv8-a/it/\">it</a> <a href=\"../../x86/in/\">in</a> the lower half of the FPR.",
      "linked_pseudocode": "FRT[32:63] <- ConvertToInt32(FRB)"
    },
    {
      "mnemonic": "isel",
      "architecture": "PowerISA",
      "full_name": "Integer Select",
      "summary": "Conditionally copies RA or RB to RT based on a CR bit. (Equivalent to C ternary operator 'cond ? a : b').",
      "syntax": "isel RT, RA, RB, BC",
      "encoding": {
        "format": "A-form",
        "binary_pattern": "31 | RT | RA | RB | BC | 15 | /",
        "hex_opcode": "0x7C00001E",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "BC",
            "clean": "BC"
          },
          {
            "raw": "15",
            "clean": "15"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register"
        },
        {
          "name": "RA",
          "desc": "Source (If True) - 0 means 0"
        },
        {
          "name": "RB",
          "desc": "Source (If False)"
        },
        {
          "name": "BC",
          "desc": "CR Bit Index (Condition)"
        }
      ],
      "pseudocode": "if CR[BC]=1 then RT <- (RA) else RT <- (RB)",
      "example": "isel r3, r4, r5, 2",
      "example_note": "r3 = (CR.eq) ? r4 : r5",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">if CR[BC]=1 then RT &lt;- (RA) else RT &lt;- (RB)</code></pre>",
      "slug": "isel",
      "rel_url": "powerisa/isel/",
      "linked_summary": "Conditionally copies RA <a href=\"../../powerisa/or/\">or</a> RB to RT based on a CR <a href=\"../../armv8-a/bit/\">bit</a>. (Equivalent to C ternary operator 'cond ? a : <a href=\"../../armv8-a/b_1/\">b</a>').",
      "linked_pseudocode": "if CR[BC]=1 then RT <- (RA) else RT <- (RB)"
    },
    {
      "mnemonic": "icbi",
      "architecture": "PowerISA",
      "full_name": "Instruction Cache Block Invalidate",
      "summary": "Invalidates the instruction cache block associated with the address. Critical for self-modifying code or JITs.",
      "syntax": "icbi RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | RA | RB | 982 | /",
        "hex_opcode": "0x7C0007D6",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "982",
            "clean": "982"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Base Address"
        },
        {
          "name": "RB",
          "desc": "Index Address"
        }
      ],
      "pseudocode": "InvalidateICache(EffectiveAddr(RA, RB))",
      "example": "icbi 0, r3",
      "example_note": "Invalidate instruction cache at r3.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">InvalidateICache(EffectiveAddr(RA, RB))</code></pre>",
      "slug": "icbi",
      "rel_url": "powerisa/icbi/",
      "linked_summary": "Invalidates the instruction cache block associated with the address. Critical for self-modifying code <a href=\"../../powerisa/or/\">or</a> JITs.",
      "linked_pseudocode": "InvalidateICache(EffectiveAddr(RA, RB))"
    },
    {
      "mnemonic": "isync",
      "architecture": "PowerISA",
      "full_name": "Instruction Synchronize",
      "summary": "Waits for all previous instructions to complete and discards any prefetched instructions. Used after modifying code or changing context.",
      "syntax": "isync",
      "encoding": {
        "format": "XL-form",
        "binary_pattern": "19 | 00000 | 00000 | 00000 | 150 | /",
        "hex_opcode": "0x4C00012C",
        "visual_parts": [
          {
            "raw": "19",
            "clean": "19"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "150",
            "clean": "150"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [],
      "pseudocode": "ContextSynchronize()",
      "example": "isync",
      "example_note": "Refetch instructions.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">ContextSynchronize()</code></pre>",
      "slug": "isync",
      "rel_url": "powerisa/isync/",
      "linked_summary": "Waits for all previous instructions to complete <a href=\"../../armv8-a/and_6/\">and</a> discards any prefetched instructions. Used after modifying code <a href=\"../../powerisa/or/\">or</a> changing context.",
      "linked_pseudocode": "ContextSynchronize()"
    },
    {
      "mnemonic": "mcrf",
      "architecture": "PowerISA",
      "full_name": "Move Condition Register Field",
      "summary": "Copies the contents of one Condition Register field to another. Used to save comparison results.",
      "syntax": "mcrf BF, BFA",
      "encoding": {
        "format": "XL-form",
        "binary_pattern": "19 | BF | / | BFA | / | / | 16 | /",
        "hex_opcode": "0x4C000020",
        "visual_parts": [
          {
            "raw": "19",
            "clean": "19"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "BFA",
            "clean": "BFA"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "16",
            "clean": "16"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "Target Field (0-7)"
        },
        {
          "name": "BFA",
          "desc": "Source Field (0-7)"
        }
      ],
      "pseudocode": "CR[BF] <- CR[BFA]",
      "example": "mcrf cr0, cr7",
      "example_note": "Copy result from CR7 to CR0.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">CR[BF] &lt;- CR[BFA]</code></pre>",
      "slug": "mcrf",
      "rel_url": "powerisa/mcrf/",
      "linked_summary": "Copies the contents of one Condition Register field to another. Used to save comparison results.",
      "linked_pseudocode": "CR[BF] <- CR[BFA]"
    },
    {
      "mnemonic": "mfcr",
      "architecture": "PowerISA",
      "full_name": "Move From Condition Register",
      "summary": "Copies the entire 32-bit Condition Register into a General Purpose Register.",
      "syntax": "mfcr RT",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | 00000 | 00000 | 19 | /",
        "hex_opcode": "0x7C000026",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "19",
            "clean": "19"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register"
        }
      ],
      "pseudocode": "RT <- CR",
      "example": "mfcr r3",
      "example_note": "Save flags to r3.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RT &lt;- CR</code></pre>",
      "slug": "mfcr",
      "rel_url": "powerisa/mfcr/",
      "linked_summary": "Copies the entire 32-<a href=\"../../armv8-a/bit/\">bit</a> Condition Register into a General Purpose Register.",
      "linked_pseudocode": "RT <- CR"
    },
    {
      "mnemonic": "mtcrf",
      "architecture": "PowerISA",
      "full_name": "Move To Condition Register Fields",
      "summary": "Copies bits from a register into the Condition Register, updated only the fields specified by the mask (FXM).",
      "syntax": "mtcrf FXM, RS",
      "encoding": {
        "format": "XFX-form",
        "binary_pattern": "31 | RS | 0 | FXM | 144 | /",
        "hex_opcode": "0x7C000120",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "FXM",
            "clean": "FXM"
          },
          {
            "raw": "144",
            "clean": "144"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FXM",
          "desc": "Field Mask (8 bits)"
        },
        {
          "name": "RS",
          "desc": "Source Register"
        }
      ],
      "pseudocode": "If FXM[0]=1 then CR0 <- RS[0:3]...",
      "example": "mtcrf 0xFF, r3",
      "example_note": "Restore all CR fields from r3.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">If FXM[0]=1 then CR0 &lt;- RS[0:3]...</code></pre>",
      "slug": "mtcrf",
      "rel_url": "powerisa/mtcrf/",
      "linked_summary": "Copies bits from a register into the Condition Register, updated only the fields specified by the mask (FXM).",
      "linked_pseudocode": "If FXM[0]=1 then CR0 <- RS[0:3]..."
    },
    {
      "mnemonic": "xsaddqp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Add Quad-Precision",
      "summary": "Adds two 128-bit Quad-Precision floating-point numbers held in VSX registers (pairs).",
      "syntax": "xsaddqp vD, vA, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | vA | vB | 4 | /",
        "hex_opcode": "0xFC000004",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target (128-bit)"
        },
        {
          "name": "vA",
          "desc": "Source A"
        },
        {
          "name": "vB",
          "desc": "Source B"
        }
      ],
      "pseudocode": "vD <- vA + vB (IEEE 128-bit)",
      "example": "xsaddqp v2, v3, v4",
      "example_note": "Scientific Quad-Float Add.",
      "extension": "VSX (Quad)",
      "pseudocode_html": "<pre><code class=\"language-clike\">vD &lt;- vA + vB (IEEE 128-bit)</code></pre>",
      "slug": "xsaddqp",
      "rel_url": "powerisa/xsaddqp/",
      "linked_summary": "Adds two 128-<a href=\"../../armv8-a/bit/\">bit</a> Quad-Precision floating-point numbers held <a href=\"../../x86/in/\">in</a> VSX registers (pairs).",
      "linked_pseudocode": "vD <- vA + vB (IEEE 128-<a href=\"../../armv8-a/bit/\">bit</a>)"
    },
    {
      "mnemonic": "xsmulqp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Multiply Quad-Precision",
      "summary": "Multiplies two 128-bit Quad-Precision floating-point numbers.",
      "syntax": "xsmulqp vD, vA, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | vA | vB | 36 | /",
        "hex_opcode": "0xFC000048",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "36",
            "clean": "36"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Source A"
        },
        {
          "name": "vB",
          "desc": "Source B"
        }
      ],
      "pseudocode": "vD <- vA * vB (IEEE 128-bit)",
      "example": "xsmulqp v2, v3, v4",
      "example_note": "Scientific Quad-Float Multiply.",
      "extension": "VSX (Quad)",
      "pseudocode_html": "<pre><code class=\"language-clike\">vD &lt;- vA * vB (IEEE 128-bit)</code></pre>",
      "slug": "xsmulqp",
      "rel_url": "powerisa/xsmulqp/",
      "linked_summary": "Multiplies two 128-<a href=\"../../armv8-a/bit/\">bit</a> Quad-Precision floating-point numbers.",
      "linked_pseudocode": "vD <- vA * vB (IEEE 128-<a href=\"../../armv8-a/bit/\">bit</a>)"
    },
    {
      "mnemonic": "xscvdpqp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Convert Double to Quad-Precision",
      "summary": "Converts a 64-bit Double to a 128-bit Quad float.",
      "syntax": "xscvdpqp vD, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | / | vB | 340 | /",
        "hex_opcode": "0xFC0002A8",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "340",
            "clean": "340"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target (Quad)"
        },
        {
          "name": "vB",
          "desc": "Source (Double)"
        }
      ],
      "pseudocode": "vD <- (float128)vB",
      "example": "xscvdpqp v2, v3",
      "example_note": "Promote Double to Quad.",
      "extension": "VSX (Quad)",
      "pseudocode_html": "<pre><code class=\"language-clike\">vD &lt;- (float128)vB</code></pre>",
      "slug": "xscvdpqp",
      "rel_url": "powerisa/xscvdpqp/",
      "linked_summary": "Converts a 64-<a href=\"../../armv8-a/bit/\">bit</a> Double to a 128-<a href=\"../../armv8-a/bit/\">bit</a> Quad float.",
      "linked_pseudocode": "vD <- (float128)vB"
    },
    {
      "mnemonic": "dadd",
      "architecture": "PowerISA",
      "full_name": "Decimal Add",
      "summary": "Adds two 64-bit Decimal Floating Point (DFP) numbers. Used in financial calculations to avoid rounding errors.",
      "syntax": "dadd FRT, FRA, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "59 | FRT | FRA | FRB | 2 | /",
        "hex_opcode": "0xEC000004",
        "visual_parts": [
          {
            "raw": "59",
            "clean": "59"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "FRA",
            "clean": "FRA"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "2",
            "clean": "2"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target FPR"
        },
        {
          "name": "FRA",
          "desc": "Source A"
        },
        {
          "name": "FRB",
          "desc": "Source B"
        }
      ],
      "pseudocode": "FRT <- FRA + FRB (Decimal64)",
      "example": "dadd f1, f2, f3",
      "example_note": "Financial Add.",
      "extension": "Decimal Float",
      "pseudocode_html": "<pre><code class=\"language-clike\">FRT &lt;- FRA + FRB (Decimal64)</code></pre>",
      "slug": "dadd",
      "rel_url": "powerisa/dadd/",
      "linked_summary": "Adds two 64-<a href=\"../../armv8-a/bit/\">bit</a> Decimal Floating Point (DFP) numbers. Used <a href=\"../../x86/in/\">in</a> financial calculations to avoid rounding errors.",
      "linked_pseudocode": "FRT <- FRA + FRB (Decimal64)"
    },
    {
      "mnemonic": "dmul",
      "architecture": "PowerISA",
      "full_name": "Decimal Multiply",
      "summary": "Multiplies two 64-bit Decimal Floating Point numbers.",
      "syntax": "dmul FRT, FRA, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "59 | FRT | FRA | FRB | 34 | /",
        "hex_opcode": "0xEC000044",
        "visual_parts": [
          {
            "raw": "59",
            "clean": "59"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "FRA",
            "clean": "FRA"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "34",
            "clean": "34"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target FPR"
        },
        {
          "name": "FRA",
          "desc": "Source A"
        },
        {
          "name": "FRB",
          "desc": "Source B"
        }
      ],
      "pseudocode": "FRT <- FRA * FRB (Decimal64)",
      "example": "dmul f1, f2, f3",
      "example_note": "Financial Multiply.",
      "extension": "Decimal Float",
      "pseudocode_html": "<pre><code class=\"language-clike\">FRT &lt;- FRA * FRB (Decimal64)</code></pre>",
      "slug": "dmul",
      "rel_url": "powerisa/dmul/",
      "linked_summary": "Multiplies two 64-<a href=\"../../armv8-a/bit/\">bit</a> Decimal Floating Point numbers.",
      "linked_pseudocode": "FRT <- FRA * FRB (Decimal64)"
    },
    {
      "mnemonic": "dqua",
      "architecture": "PowerISA",
      "full_name": "Decimal Quantize",
      "summary": "Adjusts the exponent of a DFP number to match a reference. Critical for aligning decimal points before addition.",
      "syntax": "dqua FRT, FRA, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | FRT | FRA | FRB | 66 | /",
        "hex_opcode": "0xFC000084",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "FRA",
            "clean": "FRA"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "66",
            "clean": "66"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRA",
          "desc": "Source Value"
        },
        {
          "name": "FRB",
          "desc": "Reference Exponent"
        }
      ],
      "pseudocode": "Adjust FRA exponent to match FRB",
      "example": "dqua f1, f2, f3",
      "example_note": "Align decimal points.",
      "extension": "Decimal Float",
      "pseudocode_html": "<pre><code class=\"language-clike\">Adjust FRA exponent to match FRB</code></pre>",
      "slug": "dqua",
      "rel_url": "powerisa/dqua/",
      "linked_summary": "Adjusts the exponent of a DFP number to <a href=\"../../armv9-a/match_1/\">match</a> a reference. Critical for aligning decimal points before addition.",
      "linked_pseudocode": "Adjust FRA exponent to <a href=\"../../armv9-a/match_1/\">match</a> FRB"
    },
    {
      "mnemonic": "vbrh",
      "architecture": "PowerISA",
      "full_name": "Vector Byte-Reverse Halfword",
      "summary": "Reverses bytes within each halfword (Endian Swap).",
      "syntax": "vbrh vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1606",
        "hex_opcode": "0x10000646",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1606",
            "clean": "1606"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (VMX)",
      "slug": "vbrh",
      "rel_url": "powerisa/vbrh/",
      "linked_summary": "Reverses bytes within each halfword (Endian Swap).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vbrw",
      "architecture": "PowerISA",
      "full_name": "Vector Byte-Reverse Word",
      "summary": "Reverses bytes within each word.",
      "syntax": "vbrw vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1670",
        "hex_opcode": "0x10000686",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1670",
            "clean": "1670"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (VMX)",
      "slug": "vbrw",
      "rel_url": "powerisa/vbrw/",
      "linked_summary": "Reverses bytes within each word.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vbrd",
      "architecture": "PowerISA",
      "full_name": "Vector Byte-Reverse Doubleword",
      "summary": "Reverses bytes within each doubleword.",
      "syntax": "vbrd vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1734",
        "hex_opcode": "0x100006C6",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1734",
            "clean": "1734"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (VMX)",
      "slug": "vbrd",
      "rel_url": "powerisa/vbrd/",
      "linked_summary": "Reverses bytes within each doubleword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vbrq",
      "architecture": "PowerISA",
      "full_name": "Vector Byte-Reverse Quadword",
      "summary": "Reverses bytes within the entire 128-bit quadword.",
      "syntax": "vbrq vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1798",
        "hex_opcode": "0x10000706",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1798",
            "clean": "1798"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (VMX)",
      "slug": "vbrq",
      "rel_url": "powerisa/vbrq/",
      "linked_summary": "Reverses bytes within the entire 128-<a href=\"../../armv8-a/bit/\">bit</a> quadword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vextsb2w",
      "architecture": "PowerISA",
      "full_name": "Vector Extend Sign Byte To Word",
      "summary": "Sign-extends bytes to words.",
      "syntax": "vextsb2w vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1542",
        "hex_opcode": "0x10000606",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1542",
            "clean": "1542"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (VMX)",
      "slug": "vextsb2w",
      "rel_url": "powerisa/vextsb2w/",
      "linked_summary": "Sign-extends bytes to words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vextsh2w",
      "architecture": "PowerISA",
      "full_name": "Vector Extend Sign Halfword To Word",
      "summary": "Sign-extends halfwords to words.",
      "syntax": "vextsh2w vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1606",
        "hex_opcode": "0x10000646",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1606",
            "clean": "1606"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (VMX)",
      "slug": "vextsh2w",
      "rel_url": "powerisa/vextsh2w/",
      "linked_summary": "Sign-extends halfwords to words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vextsb2d",
      "architecture": "PowerISA",
      "full_name": "Vector Extend Sign Byte To Doubleword",
      "summary": "Sign-extends bytes to doublewords.",
      "syntax": "vextsb2d vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1798",
        "hex_opcode": "0x10000706",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1798",
            "clean": "1798"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (VMX)",
      "slug": "vextsb2d",
      "rel_url": "powerisa/vextsb2d/",
      "linked_summary": "Sign-extends bytes to doublewords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vextsh2d",
      "architecture": "PowerISA",
      "full_name": "Vector Extend Sign Halfword To Doubleword",
      "summary": "Sign-extends halfwords to doublewords.",
      "syntax": "vextsh2d vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1862",
        "hex_opcode": "0x10000746",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1862",
            "clean": "1862"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (VMX)",
      "slug": "vextsh2d",
      "rel_url": "powerisa/vextsh2d/",
      "linked_summary": "Sign-extends halfwords to doublewords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vextsw2d",
      "architecture": "PowerISA",
      "full_name": "Vector Extend Sign Word To Doubleword",
      "summary": "Sign-extends words to doublewords.",
      "syntax": "vextsw2d vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1926",
        "hex_opcode": "0x10000786",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1926",
            "clean": "1926"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (VMX)",
      "slug": "vextsw2d",
      "rel_url": "powerisa/vextsw2d/",
      "linked_summary": "Sign-extends words to doublewords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcmpneb",
      "architecture": "PowerISA",
      "full_name": "Vector Compare Not Equal Byte",
      "summary": "Compares bytes for inequality.",
      "syntax": "vcmpneb vD, vA, vB",
      "encoding": {
        "format": "VC-form",
        "binary_pattern": "4 | vD | vA | vB | 7",
        "hex_opcode": "0x10000007",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "7",
            "clean": "7"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "Vector (VMX)",
      "slug": "vcmpneb",
      "rel_url": "powerisa/vcmpneb/",
      "linked_summary": "Compares bytes for inequality.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcmpneh",
      "architecture": "PowerISA",
      "full_name": "Vector Compare Not Equal Halfword",
      "summary": "Compares halfwords for inequality.",
      "syntax": "vcmpneh vD, vA, vB",
      "encoding": {
        "format": "VC-form",
        "binary_pattern": "4 | vD | vA | vB | 71",
        "hex_opcode": "0x10000047",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "71",
            "clean": "71"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "Vector (VMX)",
      "slug": "vcmpneh",
      "rel_url": "powerisa/vcmpneh/",
      "linked_summary": "Compares halfwords for inequality.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcmpnew",
      "architecture": "PowerISA",
      "full_name": "Vector Compare Not Equal Word",
      "summary": "Compares words for inequality.",
      "syntax": "vcmpnew vD, vA, vB",
      "encoding": {
        "format": "VC-form",
        "binary_pattern": "4 | vD | vA | vB | 135",
        "hex_opcode": "0x10000087",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "135",
            "clean": "135"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "Vector (VMX)",
      "slug": "vcmpnew",
      "rel_url": "powerisa/vcmpnew/",
      "linked_summary": "Compares words for inequality.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vadduqm",
      "architecture": "PowerISA",
      "full_name": "Vector Add Unsigned Quadword Modulo",
      "summary": "Adds two 128-bit integers.",
      "syntax": "vadduqm vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 256",
        "hex_opcode": "0x10000100",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "256",
            "clean": "256"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "Vector (VMX)",
      "slug": "vadduqm",
      "rel_url": "powerisa/vadduqm/",
      "linked_summary": "Adds two 128-<a href=\"../../armv8-a/bit/\">bit</a> integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsubuqm",
      "architecture": "PowerISA",
      "full_name": "Vector Subtract Unsigned Quadword Modulo",
      "summary": "Subtracts two 128-bit integers.",
      "syntax": "vsubuqm vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 1280",
        "hex_opcode": "0x10000500",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1280",
            "clean": "1280"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "Vector (VMX)",
      "slug": "vsubuqm",
      "rel_url": "powerisa/vsubuqm/",
      "linked_summary": "Subtracts two 128-<a href=\"../../armv8-a/bit/\">bit</a> integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vrlq",
      "architecture": "PowerISA",
      "full_name": "Vector Rotate Left Quadword",
      "summary": "Rotates a 128-bit quadword left.",
      "syntax": "vrlq vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 260",
        "hex_opcode": "0x10000104",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "260",
            "clean": "260"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Data"
        },
        {
          "name": "vB",
          "desc": "Shift"
        }
      ],
      "extension": "Vector (VMX)",
      "slug": "vrlq",
      "rel_url": "powerisa/vrlq/",
      "linked_summary": "Rotates a 128-<a href=\"../../armv8-a/bit/\">bit</a> quadword left.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vslq",
      "architecture": "PowerISA",
      "full_name": "Vector Shift Left Quadword",
      "summary": "Shifts a 128-bit quadword left.",
      "syntax": "vslq vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 261",
        "hex_opcode": "0x10000105",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "261",
            "clean": "261"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Data"
        },
        {
          "name": "vB",
          "desc": "Shift"
        }
      ],
      "extension": "Vector (VMX)",
      "slug": "vslq",
      "rel_url": "powerisa/vslq/",
      "linked_summary": "Shifts a 128-<a href=\"../../armv8-a/bit/\">bit</a> quadword left.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsrq",
      "architecture": "PowerISA",
      "full_name": "Vector Shift Right Quadword",
      "summary": "Shifts a 128-bit quadword right.",
      "syntax": "vsrq vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 517",
        "hex_opcode": "0x10000205",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "517",
            "clean": "517"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Data"
        },
        {
          "name": "vB",
          "desc": "Shift"
        }
      ],
      "extension": "Vector (VMX)",
      "slug": "vsrq",
      "rel_url": "powerisa/vsrq/",
      "linked_summary": "Shifts a 128-<a href=\"../../armv8-a/bit/\">bit</a> quadword right.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsraq",
      "architecture": "PowerISA",
      "full_name": "Vector Shift Right Algebraic Quadword",
      "summary": "Arithmetic right shift of a 128-bit quadword.",
      "syntax": "vsraq vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 773",
        "hex_opcode": "0x10000305",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "773",
            "clean": "773"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Data"
        },
        {
          "name": "vB",
          "desc": "Shift"
        }
      ],
      "extension": "Vector (VMX)",
      "slug": "vsraq",
      "rel_url": "powerisa/vsraq/",
      "linked_summary": "Arithmetic right shift of a 128-<a href=\"../../armv8-a/bit/\">bit</a> quadword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmulhsw",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply High Signed Word",
      "summary": "Multiplies signed words, returning the high 32 bits.",
      "syntax": "vmulhsw vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 904",
        "hex_opcode": "0x10000388",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "904",
            "clean": "904"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "Vector (VMX)",
      "slug": "vmulhsw",
      "rel_url": "powerisa/vmulhsw/",
      "linked_summary": "Multiplies signed words, returning the high 32 bits.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmulhuw",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply High Unsigned Word",
      "summary": "Multiplies unsigned words, returning the high 32 bits.",
      "syntax": "vmulhuw vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 648",
        "hex_opcode": "0x10000288",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "648",
            "clean": "648"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "Vector (VMX)",
      "slug": "vmulhuw",
      "rel_url": "powerisa/vmulhuw/",
      "linked_summary": "Multiplies unsigned words, returning the high 32 bits.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmulhsd",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply High Signed Doubleword",
      "summary": "Multiplies signed doublewords, returning the high 64 bits.",
      "syntax": "vmulhsd vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 968",
        "hex_opcode": "0x100003C8",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "968",
            "clean": "968"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "Vector (VMX)",
      "slug": "vmulhsd",
      "rel_url": "powerisa/vmulhsd/",
      "linked_summary": "Multiplies signed doublewords, returning the high 64 bits.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmulhud",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply High Unsigned Doubleword",
      "summary": "Multiplies unsigned doublewords, returning the high 64 bits.",
      "syntax": "vmulhud vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 712",
        "hex_opcode": "0x100002C8",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "712",
            "clean": "712"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "Vector (VMX)",
      "slug": "vmulhud",
      "rel_url": "powerisa/vmulhud/",
      "linked_summary": "Multiplies unsigned doublewords, returning the high 64 bits.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxlandc",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Logical AND with Complement",
      "summary": "vD = vA & ~vB",
      "syntax": "xxlandc XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 444",
        "hex_opcode": "0xF00001BC",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "444",
            "clean": "444"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xxlandc",
      "rel_url": "powerisa/xxlandc/",
      "linked_summary": "vD = vA & ~vB",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxlorc",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Logical OR with Complement",
      "summary": "vD = vA | ~vB",
      "syntax": "xxlorc XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 452",
        "hex_opcode": "0xF00001C4",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "452",
            "clean": "452"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xxlorc",
      "rel_url": "powerisa/xxlorc/",
      "linked_summary": "vD = vA | ~vB",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxlnand",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Logical NAND",
      "summary": "vD = ~(vA & vB)",
      "syntax": "xxlnand XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 442",
        "hex_opcode": "0xF00001BA",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "442",
            "clean": "442"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xxlnand",
      "rel_url": "powerisa/xxlnand/",
      "linked_summary": "vD = ~(vA & vB)",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxleqv",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Logical Equivalence",
      "summary": "vD = ~(vA ^ vB) (XNOR)",
      "syntax": "xxleqv XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 458",
        "hex_opcode": "0xF00001CA",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "458",
            "clean": "458"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xxleqv",
      "rel_url": "powerisa/xxleqv/",
      "linked_summary": "vD = ~(vA ^ vB) (<a href=\"../../risc-v/xnor/\">XNOR</a>)",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vgbbd",
      "architecture": "PowerISA",
      "full_name": "Vector Gather Bits by Bytes by Doubleword",
      "summary": "Gathers the LSB of each byte into a single word. (Highly specific permutation).",
      "syntax": "vgbbd vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1282",
        "hex_opcode": "0x10000502",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1282",
            "clean": "1282"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (VMX)",
      "slug": "vgbbd",
      "rel_url": "powerisa/vgbbd/",
      "linked_summary": "Gathers the LSB of each byte into a single word. (Highly specific permutation).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpdepd",
      "architecture": "PowerISA",
      "full_name": "Vector Parallel Bits Deposit Doubleword",
      "summary": "Deposits bits from source to target under control of a mask (Power10).",
      "syntax": "vpdepd vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1485",
        "hex_opcode": "0x100005CD",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1485",
            "clean": "1485"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Source"
        },
        {
          "name": "vB",
          "desc": "Mask"
        }
      ],
      "extension": "Vector (VMX P10)",
      "slug": "vpdepd",
      "rel_url": "powerisa/vpdepd/",
      "linked_summary": "Deposits bits from source to target under control of a mask (Power10).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpextd",
      "architecture": "PowerISA",
      "full_name": "Vector Parallel Bits Extract Doubleword",
      "summary": "Extracts bits from source based on a mask (Power10).",
      "syntax": "vpextd vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1421",
        "hex_opcode": "0x1000058D",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1421",
            "clean": "1421"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Source"
        },
        {
          "name": "vB",
          "desc": "Mask"
        }
      ],
      "extension": "Vector (VMX P10)",
      "slug": "vpextd",
      "rel_url": "powerisa/vpextd/",
      "linked_summary": "Extracts bits from source based on a mask (Power10).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcfuged",
      "architecture": "PowerISA",
      "full_name": "Vector Centrifuge Doubleword",
      "summary": "Separates bits of source into two groups based on mask (Power10).",
      "syntax": "vcfuged vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1357",
        "hex_opcode": "0x1000054D",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1357",
            "clean": "1357"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Source"
        },
        {
          "name": "vB",
          "desc": "Mask"
        }
      ],
      "extension": "Vector (VMX P10)",
      "slug": "vcfuged",
      "rel_url": "powerisa/vcfuged/",
      "linked_summary": "Separates bits of source into two groups based on mask (Power10).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vgnb",
      "architecture": "PowerISA",
      "full_name": "Vector Gather Non-Zero Bytes",
      "summary": "Gathers non-zero bytes from a vector into the bottom of the target.",
      "syntax": "vgnb vD, vB, UIM",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | UIM | vB | 1228",
        "hex_opcode": "0x100004CC",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1228",
            "clean": "1228"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        },
        {
          "name": "UIM",
          "desc": "Stream"
        }
      ],
      "extension": "Vector (VMX P10)",
      "slug": "vgnb",
      "rel_url": "powerisa/vgnb/",
      "linked_summary": "Gathers non-<a href=\"../../armv9-a/zero_2/\">zero</a> bytes from a vector into the bottom of the target.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vclrlb",
      "architecture": "PowerISA",
      "full_name": "Vector Clear Left Bytes",
      "summary": "Clears the N leftmost bytes of a vector.",
      "syntax": "vclrlb vD, vA, RB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | RB | 397",
        "hex_opcode": "0x1000018D",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "397",
            "clean": "397"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Source"
        },
        {
          "name": "RB",
          "desc": "Count (GPR)"
        }
      ],
      "extension": "Vector (VMX)",
      "slug": "vclrlb",
      "rel_url": "powerisa/vclrlb/",
      "linked_summary": "Clears the N leftmost bytes of a vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vclrrb",
      "architecture": "PowerISA",
      "full_name": "Vector Clear Right Bytes",
      "summary": "Clears the N rightmost bytes of a vector.",
      "syntax": "vclrrb vD, vA, RB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | RB | 461",
        "hex_opcode": "0x100001CD",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "461",
            "clean": "461"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Source"
        },
        {
          "name": "RB",
          "desc": "Count (GPR)"
        }
      ],
      "extension": "Vector (VMX)",
      "slug": "vclrrb",
      "rel_url": "powerisa/vclrrb/",
      "linked_summary": "Clears the N rightmost bytes of a vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "plq",
      "architecture": "PowerISA",
      "full_name": "Prefixed Load Quadword",
      "summary": "Loads 128 bits into two GPRs using a 34-bit offset.",
      "syntax": "plq RTp, D(RA), R",
      "encoding": {
        "format": "MLS:D-form",
        "binary_pattern": "000001 | 10 | ... | 56 | ...",
        "hex_opcode": "0x06000000",
        "visual_parts": [
          {
            "raw": "000001",
            "clean": "000001"
          },
          {
            "raw": "10",
            "clean": "10"
          },
          {
            "raw": "...",
            "clean": "..."
          },
          {
            "raw": "56",
            "clean": "56"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RTp",
          "desc": "Target Pair"
        },
        {
          "name": "D",
          "desc": "Offset"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "R",
          "desc": "PC-Rel"
        }
      ],
      "extension": "Prefixed (64-bit)",
      "slug": "plq",
      "rel_url": "powerisa/plq/",
      "linked_summary": "Loads 128 bits into two GPRs using a 34-<a href=\"../../armv8-a/bit/\">bit</a> offset.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pstq",
      "architecture": "PowerISA",
      "full_name": "Prefixed Store Quadword",
      "summary": "Stores 128 bits from two GPRs using a 34-bit offset.",
      "syntax": "pstq RSp, D(RA), R",
      "encoding": {
        "format": "MLS:D-form",
        "binary_pattern": "000001 | 10 | ... | 60 | ...",
        "hex_opcode": "0x06000000",
        "visual_parts": [
          {
            "raw": "000001",
            "clean": "000001"
          },
          {
            "raw": "10",
            "clean": "10"
          },
          {
            "raw": "...",
            "clean": "..."
          },
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RSp",
          "desc": "Src Pair"
        },
        {
          "name": "D",
          "desc": "Offset"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "R",
          "desc": "PC-Rel"
        }
      ],
      "extension": "Prefixed (64-bit)",
      "slug": "pstq",
      "rel_url": "powerisa/pstq/",
      "linked_summary": "Stores 128 bits from two GPRs using a 34-<a href=\"../../armv8-a/bit/\">bit</a> offset.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxmrghw",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Merge High Word",
      "summary": "Merges high words from two VSRs.",
      "syntax": "xxmrghw XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 18",
        "hex_opcode": "0xF0000012",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "18",
            "clean": "18"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xxmrghw",
      "rel_url": "powerisa/xxmrghw/",
      "linked_summary": "Merges high words from two VSRs.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxmrglw",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Merge Low Word",
      "summary": "Merges low words from two VSRs.",
      "syntax": "xxmrglw XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 82",
        "hex_opcode": "0xF0000052",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "82",
            "clean": "82"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xxmrglw",
      "rel_url": "powerisa/xxmrglw/",
      "linked_summary": "Merges low words from two VSRs.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vexpandbm",
      "architecture": "PowerISA",
      "full_name": "Vector Expand Byte Mask",
      "summary": "Expands bits from a GPR mask into a byte-element vector.",
      "syntax": "vexpandbm vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1602",
        "hex_opcode": "0x10000642",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1602",
            "clean": "1602"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (VMX P10)",
      "slug": "vexpandbm",
      "rel_url": "powerisa/vexpandbm/",
      "linked_summary": "Expands bits from a GPR mask into a byte-element vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vexpandhm",
      "architecture": "PowerISA",
      "full_name": "Vector Expand Halfword Mask",
      "summary": "Expands bits from a GPR mask into a halfword-element vector.",
      "syntax": "vexpandhm vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1666",
        "hex_opcode": "0x10000682",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1666",
            "clean": "1666"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (VMX P10)",
      "slug": "vexpandhm",
      "rel_url": "powerisa/vexpandhm/",
      "linked_summary": "Expands bits from a GPR mask into a halfword-element vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vexpandwm",
      "architecture": "PowerISA",
      "full_name": "Vector Expand Word Mask",
      "summary": "Expands bits from a GPR mask into a word-element vector.",
      "syntax": "vexpandwm vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1730",
        "hex_opcode": "0x100006C2",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1730",
            "clean": "1730"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (VMX P10)",
      "slug": "vexpandwm",
      "rel_url": "powerisa/vexpandwm/",
      "linked_summary": "Expands bits from a GPR mask into a word-element vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vexpanddm",
      "architecture": "PowerISA",
      "full_name": "Vector Expand Doubleword Mask",
      "summary": "Expands bits from a GPR mask into a doubleword-element vector.",
      "syntax": "vexpanddm vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1794",
        "hex_opcode": "0x10000702",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1794",
            "clean": "1794"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (VMX P10)",
      "slug": "vexpanddm",
      "rel_url": "powerisa/vexpanddm/",
      "linked_summary": "Expands bits from a GPR mask into a doubleword-element vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vexpandqm",
      "architecture": "PowerISA",
      "full_name": "Vector Expand Quadword Mask",
      "summary": "Expands bits from a GPR mask into a quadword-element vector.",
      "syntax": "vexpandqm vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1858",
        "hex_opcode": "0x10000742",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1858",
            "clean": "1858"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (VMX P10)",
      "slug": "vexpandqm",
      "rel_url": "powerisa/vexpandqm/",
      "linked_summary": "Expands bits from a GPR mask into a quadword-element vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vextractbm",
      "architecture": "PowerISA",
      "full_name": "Vector Extract Byte Mask",
      "summary": "Extracts MSB of each byte into a GPR mask.",
      "syntax": "vextractbm RA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | RA | 0 | vB | 1602",
        "hex_opcode": "0x10000642",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1602",
            "clean": "1602"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (VMX P10)",
      "slug": "vextractbm",
      "rel_url": "powerisa/vextractbm/",
      "linked_summary": "Extracts MSB of each byte into a GPR mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vextracthm",
      "architecture": "PowerISA",
      "full_name": "Vector Extract Halfword Mask",
      "summary": "Extracts MSB of each halfword into a GPR mask.",
      "syntax": "vextracthm RA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | RA | 0 | vB | 1666",
        "hex_opcode": "0x10000682",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1666",
            "clean": "1666"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (VMX P10)",
      "slug": "vextracthm",
      "rel_url": "powerisa/vextracthm/",
      "linked_summary": "Extracts MSB of each halfword into a GPR mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vextractwm",
      "architecture": "PowerISA",
      "full_name": "Vector Extract Word Mask",
      "summary": "Extracts MSB of each word into a GPR mask.",
      "syntax": "vextractwm RA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | RA | 0 | vB | 1730",
        "hex_opcode": "0x100006C2",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1730",
            "clean": "1730"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (VMX P10)",
      "slug": "vextractwm",
      "rel_url": "powerisa/vextractwm/",
      "linked_summary": "Extracts MSB of each word into a GPR mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vextractdm",
      "architecture": "PowerISA",
      "full_name": "Vector Extract Doubleword Mask",
      "summary": "Extracts MSB of each doubleword into a GPR mask.",
      "syntax": "vextractdm RA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | RA | 0 | vB | 1794",
        "hex_opcode": "0x10000702",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1794",
            "clean": "1794"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (VMX P10)",
      "slug": "vextractdm",
      "rel_url": "powerisa/vextractdm/",
      "linked_summary": "Extracts MSB of each doubleword into a GPR mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vextractqm",
      "architecture": "PowerISA",
      "full_name": "Vector Extract Quadword Mask",
      "summary": "Extracts MSB of quadword into a GPR mask.",
      "syntax": "vextractqm RA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | RA | 0 | vB | 1858",
        "hex_opcode": "0x10000742",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1858",
            "clean": "1858"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (VMX P10)",
      "slug": "vextractqm",
      "rel_url": "powerisa/vextractqm/",
      "linked_summary": "Extracts MSB of quadword into a GPR mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mtvsrdd",
      "architecture": "PowerISA",
      "full_name": "Move To VSR Double Double",
      "summary": "Moves two 64-bit GPRs into one 128-bit VSR.",
      "syntax": "mtvsrdd XT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | XT | RA | RB | 435 | /",
        "hex_opcode": "0x7C000363",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "435",
            "clean": "435"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target VSR"
        },
        {
          "name": "RA",
          "desc": "High GPR"
        },
        {
          "name": "RB",
          "desc": "Low GPR"
        }
      ],
      "extension": "VSX",
      "slug": "mtvsrdd",
      "rel_url": "powerisa/mtvsrdd/",
      "linked_summary": "Moves two 64-<a href=\"../../armv8-a/bit/\">bit</a> GPRs into one 128-<a href=\"../../armv8-a/bit/\">bit</a> VSR.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mfvsrld",
      "architecture": "PowerISA",
      "full_name": "Move From VSR Lower Doubleword",
      "summary": "Extracts the lower 64-bits of a VSR to a GPR.",
      "syntax": "mfvsrld RA, XS",
      "encoding": {
        "format": "XX1-form",
        "binary_pattern": "31 | XS | RA | 0 | 307",
        "hex_opcode": "0x7C000263",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "XS",
            "clean": "XS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "307",
            "clean": "307"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target GPR"
        },
        {
          "name": "XS",
          "desc": "Source VSR"
        }
      ],
      "extension": "VSX",
      "slug": "mfvsrld",
      "rel_url": "powerisa/mfvsrld/",
      "linked_summary": "Extracts the lower 64-bits of a VSR to a GPR.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vstribl",
      "architecture": "PowerISA",
      "full_name": "Vector String Isolate Byte Left",
      "summary": "Identifies the first zero byte from the left.",
      "syntax": "vstribl vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 518",
        "hex_opcode": "0x10000206",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "518",
            "clean": "518"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (VMX P9)",
      "slug": "vstribl",
      "rel_url": "powerisa/vstribl/",
      "linked_summary": "Identifies the first <a href=\"../../armv9-a/zero_2/\">zero</a> byte from the left.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vstribr",
      "architecture": "PowerISA",
      "full_name": "Vector String Isolate Byte Right",
      "summary": "Identifies the first zero byte from the right.",
      "syntax": "vstribr vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 582",
        "hex_opcode": "0x10000246",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "582",
            "clean": "582"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (VMX P9)",
      "slug": "vstribr",
      "rel_url": "powerisa/vstribr/",
      "linked_summary": "Identifies the first <a href=\"../../armv9-a/zero_2/\">zero</a> byte from the right.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xststdcsp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Test Data Class Single-Precision",
      "summary": "Tests a Single-Precision float for class membership (NaN, Inf, etc.).",
      "syntax": "xststdcsp BF, vB, DCM",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | BF | / | DCM | vB | 298",
        "hex_opcode": "0xF000012A",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "DCM",
            "clean": "DCM"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "298",
            "clean": "298"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "vB",
          "desc": "Source"
        },
        {
          "name": "DCM",
          "desc": "Mask"
        }
      ],
      "extension": "VSX",
      "slug": "xststdcsp",
      "rel_url": "powerisa/xststdcsp/",
      "linked_summary": "Tests a Single-Precision float for class membership (NaN, Inf, etc.).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tlbiel",
      "architecture": "PowerISA",
      "full_name": "TLB Invalidate Entry Local",
      "summary": "Invalidates a TLB entry on the current processor only.",
      "syntax": "tlbiel RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | / | RB | 274 | /",
        "hex_opcode": "0x7C000224",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "274",
            "clean": "274"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RB",
          "desc": "Addr"
        }
      ],
      "extension": "Privileged",
      "slug": "tlbiel",
      "rel_url": "powerisa/tlbiel/",
      "linked_summary": "Invalidates a TLB entry on the current processor only.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "msgsync",
      "architecture": "PowerISA",
      "full_name": "Message Synchronize",
      "summary": "Waits for previous messages to be accepted.",
      "syntax": "msgsync",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | / | / | 894 | /",
        "hex_opcode": "0x7C0006FE",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "894",
            "clean": "894"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [],
      "extension": "Privileged",
      "slug": "msgsync",
      "rel_url": "powerisa/msgsync/",
      "linked_summary": "Waits for previous messages to be accepted.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "msgslp",
      "architecture": "PowerISA",
      "full_name": "Message Sleep",
      "summary": "Transitions the processor to a sleep state via message.",
      "syntax": "msgslp RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | / | RB | 118 | /",
        "hex_opcode": "0x7C0000EC",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "118",
            "clean": "118"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RB",
          "desc": "Msg"
        }
      ],
      "extension": "Privileged",
      "slug": "msgslp",
      "rel_url": "powerisa/msgslp/",
      "linked_summary": "Transitions the processor to a <a href=\"../../powerisa/sleep/\">sleep</a> state via message.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vnegw",
      "architecture": "PowerISA",
      "full_name": "Vector Negate Word",
      "summary": "Negates each word integer.",
      "syntax": "vnegw vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1540",
        "hex_opcode": "0x10000604",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1540",
            "clean": "1540"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (VMX)",
      "slug": "vnegw",
      "rel_url": "powerisa/vnegw/",
      "linked_summary": "Negates each word integer.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vnegd",
      "architecture": "PowerISA",
      "full_name": "Vector Negate Doubleword",
      "summary": "Negates each doubleword integer.",
      "syntax": "vnegd vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1604",
        "hex_opcode": "0x10000644",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1604",
            "clean": "1604"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector (VMX)",
      "slug": "vnegd",
      "rel_url": "powerisa/vnegd/",
      "linked_summary": "Negates each doubleword integer.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mtocrf",
      "architecture": "PowerISA",
      "full_name": "Move To One Condition Register Field",
      "summary": "Moves a GPR field to a single CR field.",
      "syntax": "mtocrf FXM, RS",
      "encoding": {
        "format": "XFX-form",
        "binary_pattern": "31 | RS | FXM | 144",
        "hex_opcode": "0x7C000120",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "FXM",
            "clean": "FXM"
          },
          {
            "raw": "144",
            "clean": "144"
          }
        ]
      },
      "operands": [
        {
          "name": "FXM",
          "desc": "Mask"
        },
        {
          "name": "RS",
          "desc": "Source"
        }
      ],
      "extension": "Base",
      "slug": "mtocrf",
      "rel_url": "powerisa/mtocrf/",
      "linked_summary": "Moves a GPR field to a single CR field.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mfocrf",
      "architecture": "PowerISA",
      "full_name": "Move From One Condition Register Field",
      "summary": "Moves a single CR field to a GPR.",
      "syntax": "mfocrf RT, FXM",
      "encoding": {
        "format": "XFX-form",
        "binary_pattern": "31 | RT | FXM | 19",
        "hex_opcode": "0x7C000026",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "FXM",
            "clean": "FXM"
          },
          {
            "raw": "19",
            "clean": "19"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "FXM",
          "desc": "Mask"
        }
      ],
      "extension": "Base",
      "slug": "mfocrf",
      "rel_url": "powerisa/mfocrf/",
      "linked_summary": "Moves a single CR field to a GPR.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "neg",
      "architecture": "PowerISA",
      "full_name": "Negate",
      "summary": "Computes the two's complement negation of a register (0 - RT).",
      "syntax": "neg RT, RA",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "31 | RT | RA | 00000 | OE | 104 | Rc",
        "hex_opcode": "0x7C0000D0",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "OE",
            "clean": "OE"
          },
          {
            "raw": "104",
            "clean": "104"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register"
        },
        {
          "name": "RA",
          "desc": "Source Register"
        }
      ],
      "pseudocode": "RT <- (~RA) + 1",
      "example": "neg r3, r4",
      "example_note": "r3 = -r4",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RT &lt;- (~RA) + 1</code></pre>",
      "slug": "neg",
      "rel_url": "powerisa/neg/",
      "linked_summary": "Computes the two's complement negation of a register (0 - RT).",
      "linked_pseudocode": "RT <- (~RA) + 1"
    },
    {
      "mnemonic": "or",
      "architecture": "PowerISA",
      "full_name": "OR",
      "summary": "Performs a bitwise OR comparison.",
      "syntax": "or RA, RS, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 444 | Rc",
        "hex_opcode": "0x7C000378",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "444",
            "clean": "444"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target Register"
        },
        {
          "name": "RS",
          "desc": "Source Register 1"
        },
        {
          "name": "RB",
          "desc": "Source Register 2"
        }
      ],
      "pseudocode": "RA <- RS | RB",
      "example": "or r3, r4, r5",
      "example_note": "r3 = r4 | r5",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RA &lt;- RS | RB</code></pre>",
      "slug": "or",
      "rel_url": "powerisa/or/",
      "linked_summary": "Performs a bitwise <a href=\"../../risc-v/or/\">OR</a> comparison.",
      "linked_pseudocode": "RA <- RS | RB"
    },
    {
      "mnemonic": "ori",
      "architecture": "PowerISA",
      "full_name": "OR Immediate",
      "summary": "Performs a bitwise OR with a 16-bit unsigned immediate.",
      "syntax": "ori RA, RS, UI",
      "encoding": {
        "format": "D-form",
        "binary_pattern": "24 | RS | RA | UI",
        "hex_opcode": "0x60000000",
        "visual_parts": [
          {
            "raw": "24",
            "clean": "24"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "UI",
            "clean": "UI"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target Register"
        },
        {
          "name": "RS",
          "desc": "Source Register"
        },
        {
          "name": "UI",
          "desc": "Unsigned 16-bit Immediate"
        }
      ],
      "pseudocode": "RA <- RS | (0x0000 || UI)",
      "example": "ori r3, r4, 0x1",
      "example_note": "Set bit 0.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RA &lt;- RS | (0x0000 || UI)</code></pre>",
      "slug": "ori",
      "rel_url": "powerisa/ori/",
      "linked_summary": "Performs a bitwise <a href=\"../../risc-v/or/\">OR</a> with a 16-<a href=\"../../armv8-a/bit/\">bit</a> unsigned immediate.",
      "linked_pseudocode": "RA <- RS | (0x0000 || UI)"
    },
    {
      "mnemonic": "oris",
      "architecture": "PowerISA",
      "full_name": "OR Immediate Shifted",
      "summary": "Performs a bitwise OR with a 16-bit immediate shifted left by 16 bits.",
      "syntax": "oris RA, RS, UI",
      "encoding": {
        "format": "D-form",
        "binary_pattern": "25 | RS | RA | UI",
        "hex_opcode": "0x64000000",
        "visual_parts": [
          {
            "raw": "25",
            "clean": "25"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "UI",
            "clean": "UI"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target Register"
        },
        {
          "name": "RS",
          "desc": "Source Register"
        },
        {
          "name": "UI",
          "desc": "Unsigned 16-bit Immediate"
        }
      ],
      "pseudocode": "RA <- RS | (UI || 0x0000)",
      "example": "oris r3, r4, 0xFFFF",
      "example_note": "Set upper 16 bits.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RA &lt;- RS | (UI || 0x0000)</code></pre>",
      "slug": "oris",
      "rel_url": "powerisa/oris/",
      "linked_summary": "Performs a bitwise <a href=\"../../risc-v/or/\">OR</a> with a 16-<a href=\"../../armv8-a/bit/\">bit</a> immediate shifted left by 16 bits.",
      "linked_pseudocode": "RA <- RS | (UI || 0x0000)"
    },
    {
      "mnemonic": "popcntd",
      "architecture": "PowerISA",
      "full_name": "Population Count Doubleword",
      "summary": "Counts the number of set bits (1s) in a 64-bit register.",
      "syntax": "popcntd RA, RS",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | 00000 | 506 | /",
        "hex_opcode": "0x7C0003F4",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "506",
            "clean": "506"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target Register"
        },
        {
          "name": "RS",
          "desc": "Source Register"
        }
      ],
      "pseudocode": "RA <- CountOnes(RS)",
      "example": "popcntd r3, r4",
      "example_note": "Hamming weight of r4.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RA &lt;- CountOnes(RS)</code></pre>",
      "slug": "popcntd",
      "rel_url": "powerisa/popcntd/",
      "linked_summary": "Counts the number of set bits (1s) <a href=\"../../x86/in/\">in</a> a 64-<a href=\"../../armv8-a/bit/\">bit</a> register.",
      "linked_pseudocode": "RA <- CountOnes(RS)"
    },
    {
      "mnemonic": "popcntw",
      "architecture": "PowerISA",
      "full_name": "Population Count Word",
      "summary": "Counts the number of set bits (1s) in the lower 32 bits of a register.",
      "syntax": "popcntw RA, RS",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | 00000 | 378 | /",
        "hex_opcode": "0x7C0002F4",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "378",
            "clean": "378"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target Register"
        },
        {
          "name": "RS",
          "desc": "Source Register"
        }
      ],
      "pseudocode": "RA <- CountOnes(RS[32:63])",
      "example": "popcntw r3, r4",
      "example_note": "Hamming weight of 32-bit word.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RA &lt;- CountOnes(RS[32:63])</code></pre>",
      "slug": "popcntw",
      "rel_url": "powerisa/popcntw/",
      "linked_summary": "Counts the number of set bits (1s) <a href=\"../../x86/in/\">in</a> the lower 32 bits of a register.",
      "linked_pseudocode": "RA <- CountOnes(RS[32:63])"
    },
    {
      "mnemonic": "rldic",
      "architecture": "PowerISA",
      "full_name": "Rotate Left Doubleword Immediate Clear",
      "summary": "Rotates a 64-bit register left, then clears bits based on a mask. 64-bit equivalent of rlwinm.",
      "syntax": "rldic RA, RS, SH, MB",
      "encoding": {
        "format": "MD-form",
        "binary_pattern": "30 | RS | RA | SH | MB | 00 | Rc",
        "hex_opcode": "0x78000000",
        "visual_parts": [
          {
            "raw": "30",
            "clean": "30"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "SH",
            "clean": "SH"
          },
          {
            "raw": "MB",
            "clean": "MB"
          },
          {
            "raw": "00",
            "clean": "00"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "SH",
          "desc": "Shift Amount"
        },
        {
          "name": "MB",
          "desc": "Mask Begin"
        }
      ],
      "pseudocode": "rot <- ROTL64(RS, SH); mask <- ONES(MB, 63); RA <- rot & mask",
      "example": "rldic r3, r4, 4, 10",
      "example_note": "Rotate left 4, clear bits 0-9.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">rot &lt;- ROTL64(RS, SH); mask &lt;- ONES(MB, 63); RA &lt;- rot &amp; mask</code></pre>",
      "slug": "rldic_1",
      "rel_url": "powerisa/rldic_1/",
      "linked_summary": "Rotates a 64-<a href=\"../../armv8-a/bit/\">bit</a> register left, then clears bits based on a mask. 64-<a href=\"../../armv8-a/bit/\">bit</a> equivalent of <a href=\"../../powerisa/rlwinm/\">rlwinm</a>.",
      "linked_pseudocode": "rot <- ROTL64(RS, <a href=\"../../risc-v/sh/\">SH</a>); mask <- ONES(MB, 63); RA <- rot & mask"
    },
    {
      "mnemonic": "rldicr",
      "architecture": "PowerISA",
      "full_name": "Rotate Left Doubleword Immediate Clear Right",
      "summary": "Rotates 64-bit RS left by SH, then clears the low-order bits (ME+1 to 63).",
      "syntax": "rldicr RA, RS, SH, ME",
      "encoding": {
        "format": "MD-form",
        "binary_pattern": "30 | RS | RA | SH | ME | 01 | Rc",
        "hex_opcode": "0x78000004",
        "visual_parts": [
          {
            "raw": "30",
            "clean": "30"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "SH",
            "clean": "SH"
          },
          {
            "raw": "ME",
            "clean": "ME"
          },
          {
            "raw": "01",
            "clean": "01"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "SH",
          "desc": "Shift Amount"
        },
        {
          "name": "ME",
          "desc": "Mask End"
        }
      ],
      "pseudocode": "rot <- ROTL64(RS, SH); mask <- MASK(0, ME); RA <- rot & mask",
      "example": "rldicr r3, r4, 2, 60",
      "example_note": "Align address to 8 bytes.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">rot &lt;- ROTL64(RS, SH); mask &lt;- MASK(0, ME); RA &lt;- rot &amp; mask</code></pre>",
      "slug": "rldicr_1",
      "rel_url": "powerisa/rldicr_1/",
      "linked_summary": "Rotates 64-<a href=\"../../armv8-a/bit/\">bit</a> RS left by <a href=\"../../risc-v/sh/\">SH</a>, then clears the low-order bits (ME+1 to 63).",
      "linked_pseudocode": "rot <- ROTL64(RS, <a href=\"../../risc-v/sh/\">SH</a>); mask <- MASK(0, ME); RA <- rot & mask"
    },
    {
      "mnemonic": "e_crandc",
      "architecture": "PowerISA",
      "full_name": "VLE Condition Register AND with Complement",
      "summary": "CR bit logical AND with complement (BT = BA & ~BB).",
      "syntax": "e_crandc BT, BA, BB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "BT",
          "desc": "Target Bit"
        },
        {
          "name": "BA",
          "desc": "Src A"
        },
        {
          "name": "BB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_crandc",
      "rel_url": "powerisa/e_crandc/",
      "linked_summary": "CR <a href=\"../../armv8-a/bit/\">bit</a> logical <a href=\"../../risc-v/and/\">AND</a> with complement (BT = BA & ~BB).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_creqv",
      "architecture": "PowerISA",
      "full_name": "VLE Condition Register Equivalent",
      "summary": "CR bit logical XNOR.",
      "syntax": "e_creqv BT, BA, BB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "BT",
          "desc": "Target Bit"
        },
        {
          "name": "BA",
          "desc": "Src A"
        },
        {
          "name": "BB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_creqv",
      "rel_url": "powerisa/e_creqv/",
      "linked_summary": "CR <a href=\"../../armv8-a/bit/\">bit</a> logical <a href=\"../../risc-v/xnor/\">XNOR</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_crnand",
      "architecture": "PowerISA",
      "full_name": "VLE Condition Register NAND",
      "summary": "CR bit logical NAND.",
      "syntax": "e_crnand BT, BA, BB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "BT",
          "desc": "Target Bit"
        },
        {
          "name": "BA",
          "desc": "Src A"
        },
        {
          "name": "BB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_crnand",
      "rel_url": "powerisa/e_crnand/",
      "linked_summary": "CR <a href=\"../../armv8-a/bit/\">bit</a> logical NAND.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_crnor",
      "architecture": "PowerISA",
      "full_name": "VLE Condition Register NOR",
      "summary": "CR bit logical NOR.",
      "syntax": "e_crnor BT, BA, BB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "BT",
          "desc": "Target Bit"
        },
        {
          "name": "BA",
          "desc": "Src A"
        },
        {
          "name": "BB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_crnor",
      "rel_url": "powerisa/e_crnor/",
      "linked_summary": "CR <a href=\"../../armv8-a/bit/\">bit</a> logical NOR.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_crorc",
      "architecture": "PowerISA",
      "full_name": "VLE Condition Register OR with Complement",
      "summary": "CR bit logical OR with complement (BT = BA | ~BB).",
      "syntax": "e_crorc BT, BA, BB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "BT",
          "desc": "Target Bit"
        },
        {
          "name": "BA",
          "desc": "Src A"
        },
        {
          "name": "BB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_crorc",
      "rel_url": "powerisa/e_crorc/",
      "linked_summary": "CR <a href=\"../../armv8-a/bit/\">bit</a> logical <a href=\"../../risc-v/or/\">OR</a> with complement (BT = BA | ~BB).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_crxor",
      "architecture": "PowerISA",
      "full_name": "VLE Condition Register XOR",
      "summary": "CR bit logical XOR.",
      "syntax": "e_crxor BT, BA, BB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "BT",
          "desc": "Target Bit"
        },
        {
          "name": "BA",
          "desc": "Src A"
        },
        {
          "name": "BB",
          "desc": "Src B"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_crxor",
      "rel_url": "powerisa/e_crxor/",
      "linked_summary": "CR <a href=\"../../armv8-a/bit/\">bit</a> logical <a href=\"../../risc-v/xor/\">XOR</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_mcrf",
      "architecture": "PowerISA",
      "full_name": "VLE Move Condition Register Field",
      "summary": "Copies one CR field to another.",
      "syntax": "e_mcrf BF, BFA",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "Target"
        },
        {
          "name": "BFA",
          "desc": "Source"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_mcrf",
      "rel_url": "powerisa/e_mcrf/",
      "linked_summary": "Copies one CR field to another.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_mfar",
      "architecture": "PowerISA",
      "full_name": "VLE Short Move From Alternate Register",
      "summary": "Moves AR to RX (16-bit).",
      "syntax": "se_mfar RX, ARY",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 0000 | RX | 1100",
        "hex_opcode": "0x000C",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "1100",
            "clean": "1100"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Target"
        },
        {
          "name": "ARY",
          "desc": "Source AR"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_mfar",
      "rel_url": "powerisa/se_mfar/",
      "linked_summary": "Moves AR to RX (16-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_mtar",
      "architecture": "PowerISA",
      "full_name": "VLE Short Move To Alternate Register",
      "summary": "Moves RX to AR (16-bit).",
      "syntax": "se_mtar ARX, RY",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 0000 | ARX | 1101",
        "hex_opcode": "0x000D",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "ARX",
            "clean": "ARX"
          },
          {
            "raw": "1101",
            "clean": "1101"
          }
        ]
      },
      "operands": [
        {
          "name": "ARX",
          "desc": "Target AR"
        },
        {
          "name": "RY",
          "desc": "Source"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_mtar",
      "rel_url": "powerisa/se_mtar/",
      "linked_summary": "Moves RX to AR (16-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_bclri",
      "architecture": "PowerISA",
      "full_name": "VLE Short Bit Clear Immediate",
      "summary": "Clears a specific bit in RX.",
      "syntax": "se_bclri RX, UIM",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0110 | 001 | RX | UIM",
        "hex_opcode": "0x6200",
        "visual_parts": [
          {
            "raw": "0110",
            "clean": "0110"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Target"
        },
        {
          "name": "UIM",
          "desc": "Bit Index"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_bclri",
      "rel_url": "powerisa/se_bclri/",
      "linked_summary": "Clears a specific <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> RX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_bseti",
      "architecture": "PowerISA",
      "full_name": "VLE Short Bit Set Immediate",
      "summary": "Sets a specific bit in RX.",
      "syntax": "se_bseti RX, UIM",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0110 | 010 | RX | UIM",
        "hex_opcode": "0x6400",
        "visual_parts": [
          {
            "raw": "0110",
            "clean": "0110"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Target"
        },
        {
          "name": "UIM",
          "desc": "Bit Index"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_bseti",
      "rel_url": "powerisa/se_bseti/",
      "linked_summary": "Sets a specific <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> RX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_btsti",
      "architecture": "PowerISA",
      "full_name": "VLE Short Bit Test Immediate",
      "summary": "Tests a bit in RX and updates CR0.",
      "syntax": "se_btsti RX, UIM",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0110 | 011 | RX | UIM",
        "hex_opcode": "0x6600",
        "visual_parts": [
          {
            "raw": "0110",
            "clean": "0110"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Source"
        },
        {
          "name": "UIM",
          "desc": "Bit Index"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_btsti",
      "rel_url": "powerisa/se_btsti/",
      "linked_summary": "Tests a <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> RX <a href=\"../../armv8-a/and_6/\">and</a> updates CR0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_rfci",
      "architecture": "PowerISA",
      "full_name": "VLE Short Return From Critical Interrupt",
      "summary": "Returns from critical interrupt.",
      "syntax": "se_rfci",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 0000 | 0000 | 0101",
        "hex_opcode": "0x0005",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0101",
            "clean": "0101"
          }
        ]
      },
      "operands": [],
      "extension": "VLE (16-bit)",
      "slug": "se_rfci",
      "rel_url": "powerisa/se_rfci/",
      "linked_summary": "Returns from critical interrupt.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_rfdi",
      "architecture": "PowerISA",
      "full_name": "VLE Short Return From Debug Interrupt",
      "summary": "Returns from debug interrupt.",
      "syntax": "se_rfdi",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 0000 | 0000 | 0111",
        "hex_opcode": "0x0007",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0111",
            "clean": "0111"
          }
        ]
      },
      "operands": [],
      "extension": "VLE (16-bit)",
      "slug": "se_rfdi",
      "rel_url": "powerisa/se_rfdi/",
      "linked_summary": "Returns from debug interrupt.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_rfi",
      "architecture": "PowerISA",
      "full_name": "VLE Short Return From Interrupt",
      "summary": "Returns from standard interrupt.",
      "syntax": "se_rfi",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 0000 | 0000 | 1000",
        "hex_opcode": "0x0008",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "1000",
            "clean": "1000"
          }
        ]
      },
      "operands": [],
      "extension": "VLE (16-bit)",
      "slug": "se_rfi",
      "rel_url": "powerisa/se_rfi/",
      "linked_summary": "Returns from standard interrupt.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_sc",
      "architecture": "PowerISA",
      "full_name": "VLE Short System Call",
      "summary": "System call (16-bit encoding).",
      "syntax": "se_sc",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 0000 | 0000 | 0100",
        "hex_opcode": "0x0004",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0100",
            "clean": "0100"
          }
        ]
      },
      "operands": [],
      "extension": "VLE (16-bit)",
      "slug": "se_sc",
      "rel_url": "powerisa/se_sc/",
      "linked_summary": "System <a href=\"../../x86/call/\">call</a> (16-<a href=\"../../armv8-a/bit/\">bit</a> encoding).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_sc",
      "architecture": "PowerISA",
      "full_name": "VLE System Call",
      "summary": "System call (32-bit encoding).",
      "syntax": "e_sc",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1100 | ...",
        "hex_opcode": "0x7C00...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [],
      "extension": "VLE (32-bit)",
      "slug": "e_sc",
      "rel_url": "powerisa/e_sc/",
      "linked_summary": "System <a href=\"../../x86/call/\">call</a> (32-<a href=\"../../armv8-a/bit/\">bit</a> encoding).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_trap",
      "architecture": "PowerISA",
      "full_name": "VLE Short Trap",
      "summary": "Unconditional trap (16-bit).",
      "syntax": "se_trap",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 0000 | 0000 | 1001",
        "hex_opcode": "0x0009",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "1001",
            "clean": "1001"
          }
        ]
      },
      "operands": [],
      "extension": "VLE (16-bit)",
      "slug": "se_trap",
      "rel_url": "powerisa/se_trap/",
      "linked_summary": "Unconditional <a href=\"../../powerisa/trap/\">trap</a> (16-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_trap",
      "architecture": "PowerISA",
      "full_name": "VLE Trap",
      "summary": "Unconditional trap (32-bit).",
      "syntax": "e_trap",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1100 | ...",
        "hex_opcode": "0x7C00...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [],
      "extension": "VLE (32-bit)",
      "slug": "e_trap",
      "rel_url": "powerisa/e_trap/",
      "linked_summary": "Unconditional <a href=\"../../powerisa/trap/\">trap</a> (32-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_tlbwe",
      "architecture": "PowerISA",
      "full_name": "VLE TLB Write Entry",
      "summary": "Writes a TLB entry.",
      "syntax": "e_tlbwe",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1100 | ...",
        "hex_opcode": "0x7C00...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [],
      "extension": "VLE (Privileged)",
      "slug": "e_tlbwe",
      "rel_url": "powerisa/e_tlbwe/",
      "linked_summary": "Writes a TLB entry.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_tlbre",
      "architecture": "PowerISA",
      "full_name": "VLE TLB Read Entry",
      "summary": "Reads a TLB entry.",
      "syntax": "e_tlbre",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1100 | ...",
        "hex_opcode": "0x7C00...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [],
      "extension": "VLE (Privileged)",
      "slug": "e_tlbre",
      "rel_url": "powerisa/e_tlbre/",
      "linked_summary": "Reads a TLB entry.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_tlbivax",
      "architecture": "PowerISA",
      "full_name": "VLE TLB Invalidate Virtual Address Indexed",
      "summary": "Invalidates a TLB entry by address.",
      "syntax": "e_tlbivax RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1100 | ...",
        "hex_opcode": "0x7C00...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "VLE (Privileged)",
      "slug": "e_tlbivax",
      "rel_url": "powerisa/e_tlbivax/",
      "linked_summary": "Invalidates a TLB entry by address.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_tlbsx",
      "architecture": "PowerISA",
      "full_name": "VLE TLB Search Indexed",
      "summary": "Searches for a TLB entry.",
      "syntax": "e_tlbsx RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1100 | ...",
        "hex_opcode": "0x7C00...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "VLE (Privileged)",
      "slug": "e_tlbsx",
      "rel_url": "powerisa/e_tlbsx/",
      "linked_summary": "Searches for a TLB entry.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_mfspr",
      "architecture": "PowerISA",
      "full_name": "VLE Move From Special Purpose Register",
      "summary": "Reads an SPR.",
      "syntax": "e_mfspr RT, SPR",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1100 | ...",
        "hex_opcode": "0x7C00...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "SPR",
          "desc": "Reg"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_mfspr",
      "rel_url": "powerisa/e_mfspr/",
      "linked_summary": "Reads an SPR.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_mtspr",
      "architecture": "PowerISA",
      "full_name": "VLE Move To Special Purpose Register",
      "summary": "Writes an SPR.",
      "syntax": "e_mtspr SPR, RS",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1100 | ...",
        "hex_opcode": "0x7C00...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "SPR",
          "desc": "Reg"
        },
        {
          "name": "RS",
          "desc": "Source"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_mtspr",
      "rel_url": "powerisa/e_mtspr/",
      "linked_summary": "Writes an SPR.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_rlw",
      "architecture": "PowerISA",
      "full_name": "VLE Rotate Left Word",
      "summary": "Rotates word left.",
      "syntax": "e_rlw RA, RS, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1100 | ...",
        "hex_opcode": "0x7C00...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Src"
        },
        {
          "name": "RB",
          "desc": "Shift"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_rlw",
      "rel_url": "powerisa/e_rlw/",
      "linked_summary": "Rotates word left.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_slw",
      "architecture": "PowerISA",
      "full_name": "VLE Shift Left Word",
      "summary": "Shifts word left.",
      "syntax": "e_slw RA, RS, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1100 | ...",
        "hex_opcode": "0x7C00...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Src"
        },
        {
          "name": "RB",
          "desc": "Shift"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_slw_1",
      "rel_url": "powerisa/e_slw_1/",
      "linked_summary": "Shifts word left.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_srw",
      "architecture": "PowerISA",
      "full_name": "VLE Shift Right Word",
      "summary": "Shifts word right.",
      "syntax": "e_srw RA, RS, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1100 | ...",
        "hex_opcode": "0x7C00...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Src"
        },
        {
          "name": "RB",
          "desc": "Shift"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_srw_1",
      "rel_url": "powerisa/e_srw_1/",
      "linked_summary": "Shifts word right.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_sraw",
      "architecture": "PowerISA",
      "full_name": "VLE Shift Right Algebraic Word",
      "summary": "Arithmetic right shift.",
      "syntax": "e_sraw RA, RS, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1100 | ...",
        "hex_opcode": "0x7C00...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Src"
        },
        {
          "name": "RB",
          "desc": "Shift"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_sraw_1",
      "rel_url": "powerisa/e_sraw_1/",
      "linked_summary": "Arithmetic right shift.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_srawi",
      "architecture": "PowerISA",
      "full_name": "VLE Shift Right Algebraic Word Immediate",
      "summary": "Arithmetic right shift by immediate.",
      "syntax": "e_srawi RA, RS, SH",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1100 | ...",
        "hex_opcode": "0x7C00...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Src"
        },
        {
          "name": "SH",
          "desc": "Shift"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_srawi",
      "rel_url": "powerisa/e_srawi/",
      "linked_summary": "Arithmetic right shift by immediate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tlbilx",
      "architecture": "PowerISA",
      "full_name": "TLB Invalidate Local Extended",
      "summary": "Invalidates TLB entries on the local processor based on Process ID (PID).",
      "syntax": "tlbilx T, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | T | RA | RB | 18 | /",
        "hex_opcode": "0x7C000012",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "T",
            "clean": "T"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "18",
            "clean": "18"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "T",
          "desc": "Type"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Embedded (TLB)",
      "slug": "tlbilx",
      "rel_url": "powerisa/tlbilx/",
      "linked_summary": "Invalidates TLB entries on the local processor based on Process ID (PID).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lwdi",
      "architecture": "PowerISA",
      "full_name": "Load Word with Decoration Indexed",
      "summary": "Loads a word and sends decoration sideband signals to the bus.",
      "syntax": "lwdi RT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | RA | RB | 788 | /",
        "hex_opcode": "0x7C00062C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "788",
            "clean": "788"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Embedded (Decorated)",
      "slug": "lwdi",
      "rel_url": "powerisa/lwdi/",
      "linked_summary": "Loads a word <a href=\"../../armv8-a/and_6/\">and</a> sends decoration sideband signals to the bus.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stdi",
      "architecture": "PowerISA",
      "full_name": "Store Word with Decoration Indexed",
      "summary": "Stores a word and sends decoration sideband signals.",
      "syntax": "stdi RS, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 916 | /",
        "hex_opcode": "0x7C00072C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "916",
            "clean": "916"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Embedded (Decorated)",
      "slug": "stdi",
      "rel_url": "powerisa/stdi/",
      "linked_summary": "Stores a word <a href=\"../../armv8-a/and_6/\">and</a> sends decoration sideband signals.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ehpriv",
      "architecture": "PowerISA",
      "full_name": "Embedded Hypervisor Privilege",
      "summary": "Enters embedded hypervisor privileged state.",
      "syntax": "ehpriv OC",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | 0 | 0 | OC | 270 | /",
        "hex_opcode": "0x7C00021E",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "OC",
            "clean": "OC"
          },
          {
            "raw": "270",
            "clean": "270"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "OC",
          "desc": "Opcode"
        }
      ],
      "extension": "Embedded (Hypervisor)",
      "slug": "ehpriv",
      "rel_url": "powerisa/ehpriv/",
      "linked_summary": "Enters embedded hypervisor privileged state.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mbar",
      "architecture": "PowerISA",
      "full_name": "Memory Barrier",
      "summary": "Ensures memory access ordering (Embedded version of 'sync').",
      "syntax": "mbar MO",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | 0 | 0 | MO | 854 | /",
        "hex_opcode": "0x7C0006AC",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "MO",
            "clean": "MO"
          },
          {
            "raw": "854",
            "clean": "854"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "MO",
          "desc": "Ordering"
        }
      ],
      "extension": "Embedded (Control)",
      "slug": "mbar",
      "rel_url": "powerisa/mbar/",
      "linked_summary": "Ensures memory access ordering (Embedded version of '<a href=\"../../powerisa/sync/\">sync</a>').",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "msync",
      "architecture": "PowerISA",
      "full_name": "Memory Synchronize",
      "summary": "Synchronizes memory accesses (Alias for sync).",
      "syntax": "msync",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | 0 | 0 | 0 | 598 | /",
        "hex_opcode": "0x7C0004AC",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "598",
            "clean": "598"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [],
      "extension": "Embedded (Control)",
      "slug": "msync",
      "rel_url": "powerisa/msync/",
      "linked_summary": "Synchronizes memory accesses (Alias for <a href=\"../../powerisa/sync/\">sync</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_rfmci",
      "architecture": "PowerISA",
      "full_name": "VLE Short Return From Machine Check Interrupt",
      "summary": "Returns from machine check.",
      "syntax": "se_rfmci",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 0000 | 0000 | 1100",
        "hex_opcode": "0x000C",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "1100",
            "clean": "1100"
          }
        ]
      },
      "operands": [],
      "extension": "VLE (16-bit)",
      "slug": "se_rfmci",
      "rel_url": "powerisa/se_rfmci/",
      "linked_summary": "Returns from machine check.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_li",
      "architecture": "PowerISA",
      "full_name": "VLE Short Load Immediate",
      "summary": "Loads small immediate.",
      "syntax": "se_li RX, UI7",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0100 | 100 | RX | UI7",
        "hex_opcode": "0x4800",
        "visual_parts": [
          {
            "raw": "0100",
            "clean": "0100"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "UI7",
            "clean": "UI7"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Target"
        },
        {
          "name": "UI7",
          "desc": "Imm"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_li_1",
      "rel_url": "powerisa/se_li_1/",
      "linked_summary": "Loads small immediate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_bmaski",
      "architecture": "PowerISA",
      "full_name": "VLE Short Bit Mask Immediate",
      "summary": "Creates a mask.",
      "syntax": "se_bmaski RX, UI5",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0010 | 110 | RX | UI5",
        "hex_opcode": "0x2C00",
        "visual_parts": [
          {
            "raw": "0010",
            "clean": "0010"
          },
          {
            "raw": "110",
            "clean": "110"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "UI5",
            "clean": "UI5"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Target"
        },
        {
          "name": "UI5",
          "desc": "Mask Len"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_bmaski_1",
      "rel_url": "powerisa/se_bmaski_1/",
      "linked_summary": "Creates a mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_bgeni",
      "architecture": "PowerISA",
      "full_name": "VLE Short Bit Generate Immediate",
      "summary": "Generates a single bit.",
      "syntax": "se_bgeni RX, UI5",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0110 | 000 | RX | UI5",
        "hex_opcode": "0x6000",
        "visual_parts": [
          {
            "raw": "0110",
            "clean": "0110"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "UI5",
            "clean": "UI5"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Target"
        },
        {
          "name": "UI5",
          "desc": "Bit"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_bgeni_1",
      "rel_url": "powerisa/se_bgeni_1/",
      "linked_summary": "Generates a single <a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_extsb",
      "architecture": "PowerISA",
      "full_name": "VLE Short Extend Sign Byte",
      "summary": "Sign extends byte.",
      "syntax": "se_extsb RX",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 0000 | RX | 1101",
        "hex_opcode": "0x000D",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "1101",
            "clean": "1101"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Target"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_extsb",
      "rel_url": "powerisa/se_extsb/",
      "linked_summary": "Sign extends byte.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_extsh",
      "architecture": "PowerISA",
      "full_name": "VLE Short Extend Sign Halfword",
      "summary": "Sign extends halfword.",
      "syntax": "se_extsh RX",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 0000 | RX | 1110",
        "hex_opcode": "0x000E",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "1110",
            "clean": "1110"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Target"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_extsh",
      "rel_url": "powerisa/se_extsh/",
      "linked_summary": "Sign extends halfword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_extzb",
      "architecture": "PowerISA",
      "full_name": "VLE Short Extend Zero Byte",
      "summary": "Zero extends byte.",
      "syntax": "se_extzb RX",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 0000 | RX | 1111",
        "hex_opcode": "0x000F",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "1111",
            "clean": "1111"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Target"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_extzb",
      "rel_url": "powerisa/se_extzb/",
      "linked_summary": "Zero extends byte.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "se_extzh",
      "architecture": "PowerISA",
      "full_name": "VLE Short Extend Zero Halfword",
      "summary": "Zero extends halfword.",
      "syntax": "se_extzh RX",
      "encoding": {
        "format": "SE-form",
        "binary_pattern": "0000 | 0000 | RX | 1000",
        "hex_opcode": "0x0008",
        "visual_parts": [
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "RX",
            "clean": "RX"
          },
          {
            "raw": "1000",
            "clean": "1000"
          }
        ]
      },
      "operands": [
        {
          "name": "RX",
          "desc": "Target"
        }
      ],
      "extension": "VLE (16-bit)",
      "slug": "se_extzh",
      "rel_url": "powerisa/se_extzh/",
      "linked_summary": "Zero extends halfword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_mull2i",
      "architecture": "PowerISA",
      "full_name": "VLE Multiply Low Word Immediate",
      "summary": "Multiplies register by immediate.",
      "syntax": "e_mull2i RT, RA, SI",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 0000 | ...",
        "hex_opcode": "0x7000...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src"
        },
        {
          "name": "SI",
          "desc": "Imm"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_mull2i",
      "rel_url": "powerisa/e_mull2i/",
      "linked_summary": "Multiplies register by immediate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "add",
      "architecture": "PowerISA",
      "full_name": "Add",
      "summary": "Adds the contents of two registers.",
      "syntax": "add RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "31 | RT | RA | RB | OE | 266 | Rc",
        "hex_opcode": "0x7C000214 (Base)",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "OE",
            "clean": "OE"
          },
          {
            "raw": "266",
            "clean": "266"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register"
        },
        {
          "name": "RA",
          "desc": "Source Register 1"
        },
        {
          "name": "RB",
          "desc": "Source Register 2"
        }
      ],
      "pseudocode": "RT <- (RA) + (RB)",
      "example": "add r3, r4, r5",
      "example_note": "r3 = r4 + r5",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RT &lt;- (RA) + (RB)</code></pre>",
      "slug": "add",
      "rel_url": "powerisa/add/",
      "linked_summary": "Adds the contents of two registers.",
      "linked_pseudocode": "RT <- (RA) + (RB)"
    },
    {
      "mnemonic": "addc",
      "architecture": "PowerISA",
      "full_name": "Add Carrying",
      "summary": "Adds two registers and updates the Carry Architecture (CA) bit.",
      "syntax": "addc RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "31 | RT | RA | RB | OE | 10 | Rc",
        "hex_opcode": "0x7C000014 (Base)",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "OE",
            "clean": "OE"
          },
          {
            "raw": "10",
            "clean": "10"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register"
        },
        {
          "name": "RA",
          "desc": "Source Register 1"
        },
        {
          "name": "RB",
          "desc": "Source Register 2"
        }
      ],
      "pseudocode": "RT <- (RA) + (RB); CA <- Carry",
      "example": "addc r3, r4, r5",
      "example_note": "r3 = r4 + r5 (Updates Carry)",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RT &lt;- (RA) + (RB); CA &lt;- Carry</code></pre>",
      "slug": "addc",
      "rel_url": "powerisa/addc/",
      "linked_summary": "Adds two registers <a href=\"../../armv8-a/and_6/\">and</a> updates the Carry Architecture (CA) <a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": "RT <- (RA) + (RB); CA <- Carry"
    },
    {
      "mnemonic": "adde",
      "architecture": "PowerISA",
      "full_name": "Add Extended",
      "summary": "Adds two registers plus the current Carry bit.",
      "syntax": "adde RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "31 | RT | RA | RB | OE | 138 | Rc",
        "hex_opcode": "0x7C000114 (Base)",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "OE",
            "clean": "OE"
          },
          {
            "raw": "138",
            "clean": "138"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register"
        },
        {
          "name": "RA",
          "desc": "Source Register 1"
        },
        {
          "name": "RB",
          "desc": "Source Register 2"
        }
      ],
      "pseudocode": "RT <- (RA) + (RB) + CA",
      "example": "adde r3, r4, r5",
      "example_note": "r3 = r4 + r5 + CA",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RT &lt;- (RA) + (RB) + CA</code></pre>",
      "slug": "adde",
      "rel_url": "powerisa/adde/",
      "linked_summary": "Adds two registers plus the current Carry <a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": "RT <- (RA) + (RB) + CA"
    },
    {
      "mnemonic": "addi",
      "architecture": "PowerISA",
      "full_name": "Add Immediate",
      "summary": "Adds a 16-bit signed immediate value to a register.",
      "syntax": "addi RT, RA, SI",
      "encoding": {
        "format": "D-form",
        "binary_pattern": "14 | RT | RA | SI",
        "hex_opcode": "0x38000000 (Base)",
        "visual_parts": [
          {
            "raw": "14",
            "clean": "14"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "SI",
            "clean": "SI"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register"
        },
        {
          "name": "RA",
          "desc": "Source Register (0 means 0)"
        },
        {
          "name": "SI",
          "desc": "Signed 16-bit Immediate"
        }
      ],
      "pseudocode": "if RA=0 then RT <- EXTS(SI) else RT <- (RA) + EXTS(SI)",
      "example": "addi r3, r4, 10",
      "example_note": "r3 = r4 + 10",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">if RA=0 then RT &lt;- EXTS(SI) else RT &lt;- (RA) + EXTS(SI)</code></pre>",
      "slug": "addi",
      "rel_url": "powerisa/addi/",
      "linked_summary": "Adds a 16-<a href=\"../../armv8-a/bit/\">bit</a> signed immediate value to a register.",
      "linked_pseudocode": "if RA=0 then RT <- EXTS(SI) else RT <- (RA) + EXTS(SI)"
    },
    {
      "mnemonic": "addic",
      "architecture": "PowerISA",
      "full_name": "Add Immediate Carrying",
      "summary": "Adds an immediate to a register and updates the Carry bit.",
      "syntax": "addic RT, RA, SI",
      "encoding": {
        "format": "D-form",
        "binary_pattern": "12 | RT | RA | SI",
        "hex_opcode": "0x30000000",
        "visual_parts": [
          {
            "raw": "12",
            "clean": "12"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "SI",
            "clean": "SI"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register"
        },
        {
          "name": "RA",
          "desc": "Source Register"
        },
        {
          "name": "SI",
          "desc": "Signed 16-bit Immediate"
        }
      ],
      "pseudocode": "RT <- (RA) + EXTS(SI); CA <- Carry",
      "example": "addic r3, r4, 10",
      "example_note": "r3 = r4 + 10 (Updates CA)",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RT &lt;- (RA) + EXTS(SI); CA &lt;- Carry</code></pre>",
      "slug": "addic",
      "rel_url": "powerisa/addic/",
      "linked_summary": "Adds an immediate to a register <a href=\"../../armv8-a/and_6/\">and</a> updates the Carry <a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": "RT <- (RA) + EXTS(SI); CA <- Carry"
    },
    {
      "mnemonic": "addic.",
      "architecture": "PowerISA",
      "full_name": "Add Immediate Carrying and Record",
      "summary": "Adds an immediate, updates Carry, and updates Condition Register Field 0 (CR0).",
      "syntax": "addic. RT, RA, SI",
      "encoding": {
        "format": "D-form",
        "binary_pattern": "13 | RT | RA | SI",
        "hex_opcode": "0x34000000",
        "visual_parts": [
          {
            "raw": "13",
            "clean": "13"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "SI",
            "clean": "SI"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register"
        },
        {
          "name": "RA",
          "desc": "Source Register"
        },
        {
          "name": "SI",
          "desc": "Signed 16-bit Immediate"
        }
      ],
      "pseudocode": "RT <- (RA) + EXTS(SI); CA <- Carry; CR0 <- Compare(RT, 0)",
      "example": "addic. r3, r4, -5",
      "example_note": "r3 = r4 - 5 (Updates CA and CR0)",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RT &lt;- (RA) + EXTS(SI); CA &lt;- Carry; CR0 &lt;- Compare(RT, 0)</code></pre>",
      "slug": "addic_",
      "rel_url": "powerisa/addic_/",
      "linked_summary": "Adds an immediate, updates Carry, <a href=\"../../armv8-a/and_6/\">and</a> updates Condition Register Field 0 (CR0).",
      "linked_pseudocode": "RT <- (RA) + EXTS(SI); CA <- Carry; CR0 <- Compare(RT, 0)"
    },
    {
      "mnemonic": "addis",
      "architecture": "PowerISA",
      "full_name": "Add Immediate Shifted",
      "summary": "Adds a 16-bit immediate shifted left by 16 bits to a register.",
      "syntax": "addis RT, RA, SI",
      "encoding": {
        "format": "D-form",
        "binary_pattern": "15 | RT | RA | SI",
        "hex_opcode": "0x3C000000",
        "visual_parts": [
          {
            "raw": "15",
            "clean": "15"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "SI",
            "clean": "SI"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register"
        },
        {
          "name": "RA",
          "desc": "Source Register (0 means 0)"
        },
        {
          "name": "SI",
          "desc": "Signed 16-bit Immediate"
        }
      ],
      "pseudocode": "if RA=0 then RT <- EXTS(SI || 0x0000) else RT <- (RA) + EXTS(SI || 0x0000)",
      "example": "addis r3, r4, 1",
      "example_note": "r3 = r4 + 65536 (0x10000)",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">if RA=0 then RT &lt;- EXTS(SI || 0x0000) else RT &lt;- (RA) + EXTS(SI || 0x0000)</code></pre>",
      "slug": "addis",
      "rel_url": "powerisa/addis/",
      "linked_summary": "Adds a 16-<a href=\"../../armv8-a/bit/\">bit</a> immediate shifted left by 16 bits to a register.",
      "linked_pseudocode": "if RA=0 then RT <- EXTS(SI || 0x0000) else RT <- (RA) + EXTS(SI || 0x0000)"
    },
    {
      "mnemonic": "addme",
      "architecture": "PowerISA",
      "full_name": "Add to Minus One Extended",
      "summary": "Adds a register, -1, and the Carry bit.",
      "syntax": "addme RT, RA",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "31 | RT | RA | 00000 | OE | 234 | Rc",
        "hex_opcode": "0x7C0001D4",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "OE",
            "clean": "OE"
          },
          {
            "raw": "234",
            "clean": "234"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register"
        },
        {
          "name": "RA",
          "desc": "Source Register"
        }
      ],
      "pseudocode": "RT <- (RA) + CA - 1",
      "example": "addme r3, r4",
      "example_note": "r3 = r4 + CA - 1",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RT &lt;- (RA) + CA - 1</code></pre>",
      "slug": "addme",
      "rel_url": "powerisa/addme/",
      "linked_summary": "Adds a register, -1, <a href=\"../../armv8-a/and_6/\">and</a> the Carry <a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": "RT <- (RA) + CA - 1"
    },
    {
      "mnemonic": "addze",
      "architecture": "PowerISA",
      "full_name": "Add to Zero Extended",
      "summary": "Adds a register, 0, and the Carry bit.",
      "syntax": "addze RT, RA",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "31 | RT | RA | 00000 | OE | 202 | Rc",
        "hex_opcode": "0x7C000194",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "OE",
            "clean": "OE"
          },
          {
            "raw": "202",
            "clean": "202"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register"
        },
        {
          "name": "RA",
          "desc": "Source Register"
        }
      ],
      "pseudocode": "RT <- (RA) + CA",
      "example": "addze r3, r4",
      "example_note": "r3 = r4 + CA",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RT &lt;- (RA) + CA</code></pre>",
      "slug": "addze",
      "rel_url": "powerisa/addze/",
      "linked_summary": "Adds a register, 0, <a href=\"../../armv8-a/and_6/\">and</a> the Carry <a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": "RT <- (RA) + CA"
    },
    {
      "mnemonic": "and",
      "architecture": "PowerISA",
      "full_name": "AND",
      "summary": "Performs a bitwise AND between two registers.",
      "syntax": "and RA, RS, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 28 | Rc",
        "hex_opcode": "0x7C000038",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "28",
            "clean": "28"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target Register"
        },
        {
          "name": "RS",
          "desc": "Source Register 1"
        },
        {
          "name": "RB",
          "desc": "Source Register 2"
        }
      ],
      "pseudocode": "RA <- (RS) & (RB)",
      "example": "and r3, r4, r5",
      "example_note": "r3 = r4 & r5",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RA &lt;- (RS) &amp; (RB)</code></pre>",
      "slug": "and",
      "rel_url": "powerisa/and/",
      "linked_summary": "Performs a bitwise <a href=\"../../risc-v/and/\">AND</a> between two registers.",
      "linked_pseudocode": "RA <- (RS) & (RB)"
    },
    {
      "mnemonic": "andc",
      "architecture": "PowerISA",
      "full_name": "AND with Complement",
      "summary": "Performs a bitwise AND between RS and the one's complement of RB.",
      "syntax": "andc RA, RS, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 60 | Rc",
        "hex_opcode": "0x7C000078",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target Register"
        },
        {
          "name": "RS",
          "desc": "Source Register 1"
        },
        {
          "name": "RB",
          "desc": "Source Register 2"
        }
      ],
      "pseudocode": "RA <- (RS) & ~(RB)",
      "example": "andc r3, r4, r5",
      "example_note": "r3 = r4 & ~r5",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RA &lt;- (RS) &amp; ~(RB)</code></pre>",
      "slug": "andc",
      "rel_url": "powerisa/andc/",
      "linked_summary": "Performs a bitwise <a href=\"../../risc-v/and/\">AND</a> between RS <a href=\"../../armv8-a/and_6/\">and</a> the one's complement of RB.",
      "linked_pseudocode": "RA <- (RS) & ~(RB)"
    },
    {
      "mnemonic": "andi.",
      "architecture": "PowerISA",
      "full_name": "AND Immediate",
      "summary": "Performs a bitwise AND between a register and a 16-bit unsigned immediate (zero-extended). Always updates CR0.",
      "syntax": "andi. RA, RS, UI",
      "encoding": {
        "format": "D-form",
        "binary_pattern": "28 | RS | RA | UI",
        "hex_opcode": "0x70000000",
        "visual_parts": [
          {
            "raw": "28",
            "clean": "28"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "UI",
            "clean": "UI"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target Register"
        },
        {
          "name": "RS",
          "desc": "Source Register"
        },
        {
          "name": "UI",
          "desc": "Unsigned 16-bit Immediate"
        }
      ],
      "pseudocode": "RA <- (RS) & (0x0000 || UI); CR0 <- Compare(RA, 0)",
      "example": "andi. r3, r4, 0xF",
      "example_note": "r3 = r4 & 0xF",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RA &lt;- (RS) &amp; (0x0000 || UI); CR0 &lt;- Compare(RA, 0)</code></pre>",
      "slug": "andi_",
      "rel_url": "powerisa/andi_/",
      "linked_summary": "Performs a bitwise <a href=\"../../risc-v/and/\">AND</a> between a register <a href=\"../../armv8-a/and_6/\">and</a> a 16-<a href=\"../../armv8-a/bit/\">bit</a> unsigned immediate (<a href=\"../../armv9-a/zero_2/\">zero</a>-extended). Always updates CR0.",
      "linked_pseudocode": "RA <- (RS) & (0x0000 || UI); CR0 <- Compare(RA, 0)"
    },
    {
      "mnemonic": "andis.",
      "architecture": "PowerISA",
      "full_name": "AND Immediate Shifted",
      "summary": "Performs a bitwise AND between a register and a 16-bit immediate shifted left by 16 bits. Always updates CR0.",
      "syntax": "andis. RA, RS, UI",
      "encoding": {
        "format": "D-form",
        "binary_pattern": "29 | RS | RA | UI",
        "hex_opcode": "0x74000000",
        "visual_parts": [
          {
            "raw": "29",
            "clean": "29"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "UI",
            "clean": "UI"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target Register"
        },
        {
          "name": "RS",
          "desc": "Source Register"
        },
        {
          "name": "UI",
          "desc": "Unsigned 16-bit Immediate"
        }
      ],
      "pseudocode": "RA <- (RS) & (UI || 0x0000); CR0 <- Compare(RA, 0)",
      "example": "andis. r3, r4, 0x1234",
      "example_note": "r3 = r4 & 0x12340000",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RA &lt;- (RS) &amp; (UI || 0x0000); CR0 &lt;- Compare(RA, 0)</code></pre>",
      "slug": "andis_",
      "rel_url": "powerisa/andis_/",
      "linked_summary": "Performs a bitwise <a href=\"../../risc-v/and/\">AND</a> between a register <a href=\"../../armv8-a/and_6/\">and</a> a 16-<a href=\"../../armv8-a/bit/\">bit</a> immediate shifted left by 16 bits. Always updates CR0.",
      "linked_pseudocode": "RA <- (RS) & (UI || 0x0000); CR0 <- Compare(RA, 0)"
    },
    {
      "mnemonic": "paddi",
      "architecture": "PowerISA",
      "full_name": "Prefixed Add Immediate",
      "summary": "Adds a 34-bit signed immediate to a register. Supports PC-relative addressing (LEA).",
      "syntax": "paddi RT, RA, SI34, R",
      "encoding": {
        "format": "MLS:D-form (64-bit)",
        "binary_pattern": "000001 | 10 | 0 | 00000 | 0000000000000000 | 14 | RT | RA | SI34",
        "hex_opcode": "0x06000000... (Prefix)",
        "visual_parts": [
          {
            "raw": "000001",
            "clean": "000001"
          },
          {
            "raw": "10",
            "clean": "10"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "0000000000000000",
            "clean": "0000000000000000"
          },
          {
            "raw": "14",
            "clean": "14"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "SI34",
            "clean": "SI34"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register"
        },
        {
          "name": "RA",
          "desc": "Source Register (0 means 0 or PC)"
        },
        {
          "name": "SI34",
          "desc": "34-bit Signed Immediate"
        },
        {
          "name": "R",
          "desc": "PC-Relative Flag (0=Abs, 1=PC-Rel)"
        }
      ],
      "pseudocode": "if R=1 then RT <- PC + EXTS(SI34) else RT <- (RA|0) + EXTS(SI34)",
      "example": "paddi r3, 0, label, 1",
      "example_note": "Load address of 'label' (PC-relative).",
      "extension": "Prefixed (v3.1)",
      "pseudocode_html": "<pre><code class=\"language-clike\">if R=1 then RT &lt;- PC + EXTS(SI34) else RT &lt;- (RA|0) + EXTS(SI34)</code></pre>",
      "slug": "paddi",
      "rel_url": "powerisa/paddi/",
      "linked_summary": "Adds a 34-<a href=\"../../armv8-a/bit/\">bit</a> signed immediate to a register. Supports PC-relative addressing (LEA).",
      "linked_pseudocode": "if R=1 then RT <- PC + EXTS(SI34) else RT <- (RA|0) + EXTS(SI34)"
    },
    {
      "mnemonic": "pla",
      "architecture": "PowerISA",
      "full_name": "Prefixed Load Address (Pseudo)",
      "summary": "Pseudo-instruction for paddi with R=1. Loads the address of a label.",
      "syntax": "pla RT, label",
      "encoding": {
        "format": "Pseudo",
        "binary_pattern": "paddi RT, 0, label, 1",
        "hex_opcode": "See paddi",
        "visual_parts": [
          {
            "raw": "paddi RT, 0, label, 1",
            "clean": "paddi RT, 0, label, 1"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register"
        },
        {
          "name": "label",
          "desc": "Symbol Name"
        }
      ],
      "pseudocode": "RT <- PC + offset(label)",
      "example": "pla r3, my_var",
      "example_note": "Get address of my_var without TOC.",
      "extension": "Prefixed (v3.1)",
      "pseudocode_html": "<pre><code class=\"language-clike\">RT &lt;- PC + offset(label)</code></pre>",
      "slug": "pla",
      "rel_url": "powerisa/pla/",
      "linked_summary": "Pseudo-instruction for <a href=\"../../powerisa/paddi_1/\">paddi</a> with R=1. Loads the address of a label.",
      "linked_pseudocode": "RT <- PC + offset(label)"
    },
    {
      "mnemonic": "pld",
      "architecture": "PowerISA",
      "full_name": "Prefixed Load Doubleword",
      "summary": "Loads a 64-bit value from memory using a 34-bit immediate offset (PC-relative or absolute).",
      "syntax": "pld RT, D34(RA), R",
      "encoding": {
        "format": "MLS:D-form",
        "binary_pattern": "000001 | 10 | 0 | 00000 | ... | 57 | RT | RA | D34",
        "hex_opcode": "0x06000000...",
        "visual_parts": [
          {
            "raw": "000001",
            "clean": "000001"
          },
          {
            "raw": "10",
            "clean": "10"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "...",
            "clean": "..."
          },
          {
            "raw": "57",
            "clean": "57"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D34",
            "clean": "D34"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register"
        },
        {
          "name": "D34",
          "desc": "34-bit Displacement"
        },
        {
          "name": "RA",
          "desc": "Base Register"
        },
        {
          "name": "R",
          "desc": "PC-Relative Flag"
        }
      ],
      "pseudocode": "EA <- (R=1 ? PC : RA|0) + EXTS(D34); RT <- MEM(EA, 8)",
      "example": "pld r3, label@pcrel(0), 1",
      "example_note": "Load value from label.",
      "extension": "Prefixed (v3.1)",
      "pseudocode_html": "<pre><code class=\"language-clike\">EA &lt;- (R=1 ? PC : RA|0) + EXTS(D34); RT &lt;- MEM(EA, 8)</code></pre>",
      "slug": "pld",
      "rel_url": "powerisa/pld/",
      "linked_summary": "Loads a 64-<a href=\"../../armv8-a/bit/\">bit</a> value from memory using a 34-<a href=\"../../armv8-a/bit/\">bit</a> immediate offset (PC-relative <a href=\"../../powerisa/or/\">or</a> absolute).",
      "linked_pseudocode": "EA <- (R=1 ? PC : RA|0) + EXTS(D34); RT <- MEM(EA, 8)"
    },
    {
      "mnemonic": "pststd",
      "architecture": "PowerISA",
      "full_name": "Prefixed Store Doubleword",
      "summary": "Stores a 64-bit value to memory using a 34-bit immediate offset.",
      "syntax": "pststd RS, D34(RA), R",
      "encoding": {
        "format": "MLS:D-form",
        "binary_pattern": "000001 | 10 | 0 | 00000 | ... | 61 | RS | RA | D34",
        "hex_opcode": "0x06000000...",
        "visual_parts": [
          {
            "raw": "000001",
            "clean": "000001"
          },
          {
            "raw": "10",
            "clean": "10"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "...",
            "clean": "..."
          },
          {
            "raw": "61",
            "clean": "61"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D34",
            "clean": "D34"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source Register"
        },
        {
          "name": "D34",
          "desc": "34-bit Displacement"
        },
        {
          "name": "RA",
          "desc": "Base Register"
        },
        {
          "name": "R",
          "desc": "PC-Relative Flag"
        }
      ],
      "pseudocode": "EA <- (R=1 ? PC : RA|0) + EXTS(D34); MEM(EA, 8) <- RS",
      "example": "pststd r3, label@pcrel(0), 1",
      "example_note": "Store value to label.",
      "extension": "Prefixed (v3.1)",
      "pseudocode_html": "<pre><code class=\"language-clike\">EA &lt;- (R=1 ? PC : RA|0) + EXTS(D34); MEM(EA, 8) &lt;- RS</code></pre>",
      "slug": "pststd",
      "rel_url": "powerisa/pststd/",
      "linked_summary": "Stores a 64-<a href=\"../../armv8-a/bit/\">bit</a> value to memory using a 34-<a href=\"../../armv8-a/bit/\">bit</a> immediate offset.",
      "linked_pseudocode": "EA <- (R=1 ? PC : RA|0) + EXTS(D34); MEM(EA, 8) <- RS"
    },
    {
      "mnemonic": "plwz",
      "architecture": "PowerISA",
      "full_name": "Prefixed Load Word and Zero",
      "summary": "Loads a 32-bit word and zero-extends it to 64 bits, using a 34-bit offset.",
      "syntax": "plwz RT, D34(RA), R",
      "encoding": {
        "format": "MLS:D-form",
        "binary_pattern": "000001 | 10 | 0 | 00000 | ... | 34 | RT | RA | D34",
        "hex_opcode": "0x06000000...",
        "visual_parts": [
          {
            "raw": "000001",
            "clean": "000001"
          },
          {
            "raw": "10",
            "clean": "10"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "...",
            "clean": "..."
          },
          {
            "raw": "34",
            "clean": "34"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D34",
            "clean": "D34"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register"
        },
        {
          "name": "D34",
          "desc": "34-bit Displacement"
        },
        {
          "name": "RA",
          "desc": "Base Register"
        }
      ],
      "pseudocode": "RT <- zext(MEM(EA, 4))",
      "example": "plwz r3, 0(r4), 0",
      "example_note": "Load word with large offset.",
      "extension": "Prefixed (v3.1)",
      "pseudocode_html": "<pre><code class=\"language-clike\">RT &lt;- zext(MEM(EA, 4))</code></pre>",
      "slug": "plwz",
      "rel_url": "powerisa/plwz/",
      "linked_summary": "Loads a 32-<a href=\"../../armv8-a/bit/\">bit</a> word <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../armv9-a/zero_2/\">zero</a>-extends <a href=\"../../armv8-a/it/\">it</a> to 64 bits, using a 34-<a href=\"../../armv8-a/bit/\">bit</a> offset.",
      "linked_pseudocode": "RT <- zext(MEM(EA, 4))"
    },
    {
      "mnemonic": "plbz",
      "architecture": "PowerISA",
      "full_name": "Prefixed Load Byte and Zero",
      "summary": "Loads a byte and zero-extends it, using a 34-bit offset.",
      "syntax": "plbz RT, D34(RA), R",
      "encoding": {
        "format": "MLS:D-form",
        "binary_pattern": "000001 | 10 | 0 | 00000 | ... | 35 | RT | RA | D34",
        "hex_opcode": "0x06000000...",
        "visual_parts": [
          {
            "raw": "000001",
            "clean": "000001"
          },
          {
            "raw": "10",
            "clean": "10"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "...",
            "clean": "..."
          },
          {
            "raw": "35",
            "clean": "35"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D34",
            "clean": "D34"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register"
        },
        {
          "name": "D34",
          "desc": "34-bit Displacement"
        },
        {
          "name": "RA",
          "desc": "Base Register"
        }
      ],
      "pseudocode": "RT <- zext(MEM(EA, 1))",
      "example": "plbz r3, 0x12345678(0), 0",
      "example_note": "Load byte from absolute address.",
      "extension": "Prefixed (v3.1)",
      "pseudocode_html": "<pre><code class=\"language-clike\">RT &lt;- zext(MEM(EA, 1))</code></pre>",
      "slug": "plbz",
      "rel_url": "powerisa/plbz/",
      "linked_summary": "Loads a byte <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../armv9-a/zero_2/\">zero</a>-extends <a href=\"../../armv8-a/it/\">it</a>, using a 34-<a href=\"../../armv8-a/bit/\">bit</a> offset.",
      "linked_pseudocode": "RT <- zext(MEM(EA, 1))"
    },
    {
      "mnemonic": "pmxvbf16ger2",
      "architecture": "PowerISA",
      "full_name": "Prefixed Masked VSX Vector BFloat16 Ger (Rank-2 Update)",
      "summary": "Matrix Multiply Assist (MMA) instruction. Computes ACC <- ACC + (A * B) using BF16 inputs.",
      "syntax": "pmxvbf16ger2 AT, XA, XB, XMSK, YMSK",
      "encoding": {
        "format": "MMIRR-form",
        "binary_pattern": "000001 | 11 | ... | 59 | ...",
        "hex_opcode": "0x06000000...",
        "visual_parts": [
          {
            "raw": "000001",
            "clean": "000001"
          },
          {
            "raw": "11",
            "clean": "11"
          },
          {
            "raw": "...",
            "clean": "..."
          },
          {
            "raw": "59",
            "clean": "59"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "AT",
          "desc": "Accumulator (0-7)"
        },
        {
          "name": "XA",
          "desc": "Vector A"
        },
        {
          "name": "XB",
          "desc": "Vector B"
        },
        {
          "name": "XMSK",
          "desc": "Mask for A"
        },
        {
          "name": "YMSK",
          "desc": "Mask for B"
        }
      ],
      "pseudocode": "Matrix Multiply Accumulate (BF16)",
      "example": "pmxvbf16ger2 0, 1, 2, 0, 0",
      "example_note": "AI Tensor Core operation.",
      "extension": "Prefixed (MMA)",
      "pseudocode_html": "<pre><code class=\"language-clike\">Matrix Multiply Accumulate (BF16)</code></pre>",
      "slug": "pmxvbf16ger2",
      "rel_url": "powerisa/pmxvbf16ger2/",
      "linked_summary": "Matrix Multiply Assist (MMA) instruction. Computes ACC <- ACC + (A * B) using BF16 inputs.",
      "linked_pseudocode": "Matrix Multiply Accumulate (BF16)"
    },
    {
      "mnemonic": "xxeval",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Evaluation",
      "summary": "Performs an arbitrary 3-input boolean logic function (LUT3) on vectors. The 8-bit immediate 'IMM' defines the truth table.",
      "syntax": "xxeval XT, XA, XB, XC, IMM",
      "encoding": {
        "format": "8RR:XX4-form",
        "binary_pattern": "000001 | 01 | ... | XT | XA | XB | XC | IMM",
        "hex_opcode": "0x06000000...",
        "visual_parts": [
          {
            "raw": "000001",
            "clean": "000001"
          },
          {
            "raw": "01",
            "clean": "01"
          },
          {
            "raw": "...",
            "clean": "..."
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "XC",
            "clean": "XC"
          },
          {
            "raw": "IMM",
            "clean": "IMM"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Source A"
        },
        {
          "name": "XB",
          "desc": "Source B"
        },
        {
          "name": "XC",
          "desc": "Source C"
        },
        {
          "name": "IMM",
          "desc": "Truth Table (8-bits)"
        }
      ],
      "pseudocode": "For each bit i: XT[i] = TruthTable[ (XA[i]<<2) | (XB[i]<<1) | XC[i] ]",
      "example": "xxeval 0, 1, 2, 3, 0x96",
      "example_note": "Custom logic function (e.g., A^B^C).",
      "extension": "Prefixed (v3.1)",
      "pseudocode_html": "<pre><code class=\"language-clike\">For each bit i: XT[i] = TruthTable[ (XA[i]&lt;&lt;2) | (XB[i]&lt;&lt;1) | XC[i] ]</code></pre>",
      "slug": "xxeval",
      "rel_url": "powerisa/xxeval/",
      "linked_summary": "Performs an arbitrary 3-input boolean logic function (LUT3) on vectors. The 8-<a href=\"../../armv8-a/bit/\">bit</a> immediate 'IMM' defines the truth table.",
      "linked_pseudocode": "For each <a href=\"../../armv8-a/bit/\">bit</a> i: XT[i] = TruthTable[ (XA[i]<<2) | (XB[i]<<1) | XC[i] ]"
    },
    {
      "mnemonic": "divw",
      "architecture": "PowerISA",
      "full_name": "Divide Word",
      "summary": "Divides the lower 32 bits of RA by the lower 32 bits of RB (Signed).",
      "syntax": "divw RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "31 | RT | RA | RB | OE | 491 | Rc",
        "hex_opcode": "0x7C0003D6",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "OE",
            "clean": "OE"
          },
          {
            "raw": "491",
            "clean": "491"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register (Quotient)"
        },
        {
          "name": "RA",
          "desc": "Dividend"
        },
        {
          "name": "RB",
          "desc": "Divisor"
        }
      ],
      "pseudocode": "RT <- (RA)[32:63] / (RB)[32:63]",
      "example": "divw r3, r4, r5",
      "example_note": "r3 = r4 / r5 (32-bit Signed).",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RT &lt;- (RA)[32:63] / (RB)[32:63]</code></pre>",
      "slug": "divw",
      "rel_url": "powerisa/divw/",
      "linked_summary": "Divides the lower 32 bits of RA by the lower 32 bits of RB (Signed).",
      "linked_pseudocode": "RT <- (RA)[32:63] / (RB)[32:63]"
    },
    {
      "mnemonic": "divwu",
      "architecture": "PowerISA",
      "full_name": "Divide Word Unsigned",
      "summary": "Divides the lower 32 bits of RA by the lower 32 bits of RB (Unsigned).",
      "syntax": "divwu RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "31 | RT | RA | RB | OE | 459 | Rc",
        "hex_opcode": "0x7C000396",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "OE",
            "clean": "OE"
          },
          {
            "raw": "459",
            "clean": "459"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register (Quotient)"
        },
        {
          "name": "RA",
          "desc": "Dividend"
        },
        {
          "name": "RB",
          "desc": "Divisor"
        }
      ],
      "pseudocode": "RT <- (RA)[32:63] /u (RB)[32:63]",
      "example": "divwu r3, r4, r5",
      "example_note": "r3 = r4 / r5 (32-bit Unsigned).",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RT &lt;- (RA)[32:63] /u (RB)[32:63]</code></pre>",
      "slug": "divwu",
      "rel_url": "powerisa/divwu/",
      "linked_summary": "Divides the lower 32 bits of RA by the lower 32 bits of RB (Unsigned).",
      "linked_pseudocode": "RT <- (RA)[32:63] /u (RB)[32:63]"
    },
    {
      "mnemonic": "divd",
      "architecture": "PowerISA",
      "full_name": "Divide Doubleword",
      "summary": "Divides the 64-bit value in RA by the 64-bit value in RB (Signed).",
      "syntax": "divd RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "31 | RT | RA | RB | OE | 489 | Rc",
        "hex_opcode": "0x7C0003D2",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "OE",
            "clean": "OE"
          },
          {
            "raw": "489",
            "clean": "489"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register (Quotient)"
        },
        {
          "name": "RA",
          "desc": "Dividend"
        },
        {
          "name": "RB",
          "desc": "Divisor"
        }
      ],
      "pseudocode": "RT <- (RA) / (RB)",
      "example": "divd r3, r4, r5",
      "example_note": "r3 = r4 / r5 (64-bit Signed).",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RT &lt;- (RA) / (RB)</code></pre>",
      "slug": "divd",
      "rel_url": "powerisa/divd/",
      "linked_summary": "Divides the 64-<a href=\"../../armv8-a/bit/\">bit</a> value <a href=\"../../x86/in/\">in</a> RA by the 64-<a href=\"../../armv8-a/bit/\">bit</a> value <a href=\"../../x86/in/\">in</a> RB (Signed).",
      "linked_pseudocode": "RT <- (RA) / (RB)"
    },
    {
      "mnemonic": "divdu",
      "architecture": "PowerISA",
      "full_name": "Divide Doubleword Unsigned",
      "summary": "Divides the 64-bit value in RA by the 64-bit value in RB (Unsigned).",
      "syntax": "divdu RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "31 | RT | RA | RB | OE | 457 | Rc",
        "hex_opcode": "0x7C000392",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "OE",
            "clean": "OE"
          },
          {
            "raw": "457",
            "clean": "457"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target Register (Quotient)"
        },
        {
          "name": "RA",
          "desc": "Dividend"
        },
        {
          "name": "RB",
          "desc": "Divisor"
        }
      ],
      "pseudocode": "RT <- (RA) /u (RB)",
      "example": "divdu r3, r4, r5",
      "example_note": "r3 = r4 / r5 (64-bit Unsigned).",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RT &lt;- (RA) /u (RB)</code></pre>",
      "slug": "divdu",
      "rel_url": "powerisa/divdu/",
      "linked_summary": "Divides the 64-<a href=\"../../armv8-a/bit/\">bit</a> value <a href=\"../../x86/in/\">in</a> RA by the 64-<a href=\"../../armv8-a/bit/\">bit</a> value <a href=\"../../x86/in/\">in</a> RB (Unsigned).",
      "linked_pseudocode": "RT <- (RA) /u (RB)"
    },
    {
      "mnemonic": "dcbz",
      "architecture": "PowerISA",
      "full_name": "Data Cache Block Set to Zero",
      "summary": "Zeros out an entire cache block (usually 128 bytes) in memory. Critical for optimizing memory clears (memset).",
      "syntax": "dcbz RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | RA | RB | 1014 | /",
        "hex_opcode": "0x7C0007EC",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1014",
            "clean": "1014"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Base Address"
        },
        {
          "name": "RB",
          "desc": "Index Address"
        }
      ],
      "pseudocode": "memset(EffectiveAddr(RA,RB), 0, BlockSize)",
      "example": "dcbz 0, r3",
      "example_note": "Zero the cache line at address in r3.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">memset(EffectiveAddr(RA,RB), 0, BlockSize)</code></pre>",
      "slug": "dcbz",
      "rel_url": "powerisa/dcbz/",
      "linked_summary": "Zeros <a href=\"../../x86/out/\">out</a> an entire cache block (usually 128 bytes) <a href=\"../../x86/in/\">in</a> memory. Critical for optimizing memory clears (memset).",
      "linked_pseudocode": "memset(EffectiveAddr(RA,RB), 0, BlockSize)"
    },
    {
      "mnemonic": "dcbt",
      "architecture": "PowerISA",
      "full_name": "Data Cache Block Touch",
      "summary": "Hints to the hardware to prefetch the cache block at the specified address into the cache.",
      "syntax": "dcbt TH, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | TH | RA | RB | 278 | /",
        "hex_opcode": "0x7C00022C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "TH",
            "clean": "TH"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "278",
            "clean": "278"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "TH",
          "desc": "Touch Hint (Stream ID)"
        },
        {
          "name": "RA",
          "desc": "Base Address"
        },
        {
          "name": "RB",
          "desc": "Index Address"
        }
      ],
      "pseudocode": "Prefetch(EffectiveAddr(RA, RB))",
      "example": "dcbt 0, 0, r3",
      "example_note": "Prefetch data at r3.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">Prefetch(EffectiveAddr(RA, RB))</code></pre>",
      "slug": "dcbt",
      "rel_url": "powerisa/dcbt/",
      "linked_summary": "Hints to the hardware to prefetch the cache block <a href=\"../../armv8-a/at_2/\">at</a> the specified address into the cache.",
      "linked_pseudocode": "Prefetch(EffectiveAddr(RA, RB))"
    },
    {
      "mnemonic": "dcbf",
      "architecture": "PowerISA",
      "full_name": "Data Cache Block Flush",
      "summary": "Flushes the cache block from the data cache to main memory and invalidates it. Used for DMA coherency.",
      "syntax": "dcbf RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | RA | RB | 86 | /",
        "hex_opcode": "0x7C0000AC",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "86",
            "clean": "86"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Base Address"
        },
        {
          "name": "RB",
          "desc": "Index Address"
        }
      ],
      "pseudocode": "Flush(EffectiveAddr(RA, RB))",
      "example": "dcbf 0, r3",
      "example_note": "Flush cache line at r3 to RAM.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">Flush(EffectiveAddr(RA, RB))</code></pre>",
      "slug": "dcbf",
      "rel_url": "powerisa/dcbf/",
      "linked_summary": "Flushes the cache block from the data cache to main memory <a href=\"../../armv8-a/and_6/\">and</a> invalidates <a href=\"../../armv8-a/it/\">it</a>. Used for DMA coherency.",
      "linked_pseudocode": "Flush(EffectiveAddr(RA, RB))"
    },
    {
      "mnemonic": "dcbst",
      "architecture": "PowerISA",
      "full_name": "Data Cache Block Store",
      "summary": "Writes the cache block to main memory if it is modified (Clean), but keeps it in the cache.",
      "syntax": "dcbst RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | RA | RB | 54 | /",
        "hex_opcode": "0x7C00006C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "54",
            "clean": "54"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Base Address"
        },
        {
          "name": "RB",
          "desc": "Index Address"
        }
      ],
      "pseudocode": "Clean(EffectiveAddr(RA, RB))",
      "example": "dcbst 0, r3",
      "example_note": "Ensure RAM has latest data for r3.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">Clean(EffectiveAddr(RA, RB))</code></pre>",
      "slug": "dcbst",
      "rel_url": "powerisa/dcbst/",
      "linked_summary": "Writes the cache block to main memory if <a href=\"../../armv8-a/it/\">it</a> is modified (Clean), but keeps <a href=\"../../armv8-a/it/\">it</a> <a href=\"../../x86/in/\">in</a> the cache.",
      "linked_pseudocode": "Clean(EffectiveAddr(RA, RB))"
    },
    {
      "mnemonic": "xxsetaccz",
      "architecture": "PowerISA",
      "full_name": "VSX Set Accumulator to Zero",
      "summary": "Clears a 512-bit Accumulator register (composed of 4 VSRs) to zero.",
      "syntax": "xxsetaccz AT",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | / | AT | 185 | /",
        "hex_opcode": "0x7C000171",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "AT",
            "clean": "AT"
          },
          {
            "raw": "185",
            "clean": "185"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "AT",
          "desc": "Accumulator (0-7)"
        }
      ],
      "extension": "Matrix Math (MMA)",
      "slug": "xxsetaccz",
      "rel_url": "powerisa/xxsetaccz/",
      "linked_summary": "Clears a 512-<a href=\"../../armv8-a/bit/\">bit</a> Accumulator register (composed of 4 VSRs) to <a href=\"../../armv9-a/zero_2/\">zero</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxmtacc",
      "architecture": "PowerISA",
      "full_name": "VSX Move to Accumulator",
      "summary": "Copies data from 4 adjacent VSRs into an Accumulator.",
      "syntax": "xxmtacc AT",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | / | AT | 153 | /",
        "hex_opcode": "0x7C000131",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "AT",
            "clean": "AT"
          },
          {
            "raw": "153",
            "clean": "153"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "AT",
          "desc": "Target ACC"
        }
      ],
      "extension": "Matrix Math (MMA)",
      "slug": "xxmtacc",
      "rel_url": "powerisa/xxmtacc/",
      "linked_summary": "Copies data from 4 adjacent VSRs into an Accumulator.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxmfacc",
      "architecture": "PowerISA",
      "full_name": "VSX Move from Accumulator",
      "summary": "Copies data from an Accumulator back to 4 adjacent VSRs.",
      "syntax": "xxmfacc AT",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | / | AT | 185 | /",
        "hex_opcode": "0x7C000171",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "AT",
            "clean": "AT"
          },
          {
            "raw": "185",
            "clean": "185"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "AT",
          "desc": "Source ACC"
        }
      ],
      "extension": "Matrix Math (MMA)",
      "slug": "xxmfacc",
      "rel_url": "powerisa/xxmfacc/",
      "linked_summary": "Copies data from an Accumulator back to 4 adjacent VSRs.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvi8ger4",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Integer 8-bit GER (Rank-4 Update)",
      "summary": "Performs an 8-bit integer outer product (GER) and accumulates into a 512-bit register.",
      "syntax": "xvi8ger4 AT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | AT | XA | XB | 34",
        "hex_opcode": "0xF0000022",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "AT",
            "clean": "AT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "34",
            "clean": "34"
          }
        ]
      },
      "operands": [
        {
          "name": "AT",
          "desc": "Accumulator"
        },
        {
          "name": "XA",
          "desc": "Vector A (8-bit)"
        },
        {
          "name": "XB",
          "desc": "Vector B (8-bit)"
        }
      ],
      "extension": "Matrix Math (MMA)",
      "slug": "xvi8ger4",
      "rel_url": "powerisa/xvi8ger4/",
      "linked_summary": "Performs an 8-<a href=\"../../armv8-a/bit/\">bit</a> integer outer product (GER) <a href=\"../../armv8-a/and_6/\">and</a> accumulates into a 512-<a href=\"../../armv8-a/bit/\">bit</a> register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvi8ger4pp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Integer 8-bit GER (Rank-4 Update) Plus/Plus",
      "summary": "Signed/Unsigned variations of 8-bit matrix multiply accumulate.",
      "syntax": "xvi8ger4pp AT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | AT | XA | XB | 35",
        "hex_opcode": "0xF0000023",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "AT",
            "clean": "AT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "35",
            "clean": "35"
          }
        ]
      },
      "operands": [
        {
          "name": "AT",
          "desc": "Accumulator"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "Matrix Math (MMA)",
      "slug": "xvi8ger4pp",
      "rel_url": "powerisa/xvi8ger4pp/",
      "linked_summary": "Signed/Unsigned variations of 8-<a href=\"../../armv8-a/bit/\">bit</a> matrix multiply accumulate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvi16ger2",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Integer 16-bit GER (Rank-2 Update)",
      "summary": "Performs a 16-bit integer outer product and accumulates.",
      "syntax": "xvi16ger2 AT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | AT | XA | XB | 75",
        "hex_opcode": "0xF000004B",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "AT",
            "clean": "AT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "75",
            "clean": "75"
          }
        ]
      },
      "operands": [
        {
          "name": "AT",
          "desc": "Accumulator"
        },
        {
          "name": "XA",
          "desc": "Src A (16-bit)"
        },
        {
          "name": "XB",
          "desc": "Src B (16-bit)"
        }
      ],
      "extension": "Matrix Math (MMA)",
      "slug": "xvi16ger2",
      "rel_url": "powerisa/xvi16ger2/",
      "linked_summary": "Performs a 16-<a href=\"../../armv8-a/bit/\">bit</a> integer outer product <a href=\"../../armv8-a/and_6/\">and</a> accumulates.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvi16ger2s",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Integer 16-bit GER (Rank-2 Update) Saturate",
      "summary": "Performs a 16-bit integer outer product with saturation.",
      "syntax": "xvi16ger2s AT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | AT | XA | XB | 43",
        "hex_opcode": "0xF000002B",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "AT",
            "clean": "AT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "43",
            "clean": "43"
          }
        ]
      },
      "operands": [
        {
          "name": "AT",
          "desc": "Accumulator"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "Matrix Math (MMA)",
      "slug": "xvi16ger2s",
      "rel_url": "powerisa/xvi16ger2s/",
      "linked_summary": "Performs a 16-<a href=\"../../armv8-a/bit/\">bit</a> integer outer product with saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvf16ger2",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Float16 GER (Rank-2 Update)",
      "summary": "Performs IEEE Float16 matrix multiply accumulate.",
      "syntax": "xvf16ger2 AT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | AT | XA | XB | 19",
        "hex_opcode": "0xF0000013",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "AT",
            "clean": "AT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "19",
            "clean": "19"
          }
        ]
      },
      "operands": [
        {
          "name": "AT",
          "desc": "Accumulator"
        },
        {
          "name": "XA",
          "desc": "Src A (FP16)"
        },
        {
          "name": "XB",
          "desc": "Src B (FP16)"
        }
      ],
      "extension": "Matrix Math (MMA)",
      "slug": "xvf16ger2",
      "rel_url": "powerisa/xvf16ger2/",
      "linked_summary": "Performs IEEE Float16 matrix multiply accumulate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvbf16ger2",
      "architecture": "PowerISA",
      "full_name": "VSX Vector BFloat16 GER (Rank-2 Update)",
      "summary": "Performs BFloat16 (Brain Float) matrix multiply accumulate.",
      "syntax": "xvbf16ger2 AT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | AT | XA | XB | 51",
        "hex_opcode": "0xF0000033",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "AT",
            "clean": "AT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "51",
            "clean": "51"
          }
        ]
      },
      "operands": [
        {
          "name": "AT",
          "desc": "Accumulator"
        },
        {
          "name": "XA",
          "desc": "Src A (BF16)"
        },
        {
          "name": "XB",
          "desc": "Src B (BF16)"
        }
      ],
      "extension": "Matrix Math (MMA)",
      "slug": "xvbf16ger2",
      "rel_url": "powerisa/xvbf16ger2/",
      "linked_summary": "Performs BFloat16 (Brain Float) matrix multiply accumulate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvf32ger",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Float32 GER (Rank-1 Update)",
      "summary": "Performs Single-Precision Float matrix multiply accumulate.",
      "syntax": "xvf32ger AT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | AT | XA | XB | 27",
        "hex_opcode": "0xF000001B",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "AT",
            "clean": "AT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "27",
            "clean": "27"
          }
        ]
      },
      "operands": [
        {
          "name": "AT",
          "desc": "Accumulator"
        },
        {
          "name": "XA",
          "desc": "Src A (FP32)"
        },
        {
          "name": "XB",
          "desc": "Src B (FP32)"
        }
      ],
      "extension": "Matrix Math (MMA)",
      "slug": "xvf32ger",
      "rel_url": "powerisa/xvf32ger/",
      "linked_summary": "Performs Single-Precision Float matrix multiply accumulate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvf64ger",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Float64 GER (Rank-1 Update)",
      "summary": "Performs Double-Precision Float matrix multiply accumulate.",
      "syntax": "xvf64ger AT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | AT | XA | XB | 59",
        "hex_opcode": "0xF000003B",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "AT",
            "clean": "AT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "59",
            "clean": "59"
          }
        ]
      },
      "operands": [
        {
          "name": "AT",
          "desc": "Accumulator"
        },
        {
          "name": "XA",
          "desc": "Src A (FP64)"
        },
        {
          "name": "XB",
          "desc": "Src B (FP64)"
        }
      ],
      "extension": "Matrix Math (MMA)",
      "slug": "xvf64ger",
      "rel_url": "powerisa/xvf64ger/",
      "linked_summary": "Performs Double-Precision Float matrix multiply accumulate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmxvi8ger4",
      "architecture": "PowerISA",
      "full_name": "Prefixed Masked VSX Vector Integer 8-bit GER",
      "summary": "Masked version of 8-bit integer MMA.",
      "syntax": "pmxvi8ger4 AT, XA, XB, XMSK, YMSK",
      "encoding": {
        "format": "MMIRR-form",
        "binary_pattern": "000001 | 11 | ...",
        "hex_opcode": "0x06000000...",
        "visual_parts": [
          {
            "raw": "000001",
            "clean": "000001"
          },
          {
            "raw": "11",
            "clean": "11"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "AT",
          "desc": "Accumulator"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        },
        {
          "name": "XMSK",
          "desc": "Mask A"
        },
        {
          "name": "YMSK",
          "desc": "Mask B"
        }
      ],
      "extension": "Prefixed (MMA)",
      "slug": "pmxvi8ger4",
      "rel_url": "powerisa/pmxvi8ger4/",
      "linked_summary": "Masked version of 8-<a href=\"../../armv8-a/bit/\">bit</a> integer MMA.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmxvf64ger",
      "architecture": "PowerISA",
      "full_name": "Prefixed Masked VSX Vector Float64 GER",
      "summary": "Masked version of Double-Precision MMA.",
      "syntax": "pmxvf64ger AT, XA, XB, XMSK, YMSK",
      "encoding": {
        "format": "MMIRR-form",
        "binary_pattern": "000001 | 11 | ...",
        "hex_opcode": "0x06000000...",
        "visual_parts": [
          {
            "raw": "000001",
            "clean": "000001"
          },
          {
            "raw": "11",
            "clean": "11"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "AT",
          "desc": "Accumulator"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        },
        {
          "name": "XMSK",
          "desc": "Mask A"
        },
        {
          "name": "YMSK",
          "desc": "Mask B"
        }
      ],
      "extension": "Prefixed (MMA)",
      "slug": "pmxvf64ger",
      "rel_url": "powerisa/pmxvf64ger/",
      "linked_summary": "Masked version of Double-Precision MMA.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cnttzw",
      "architecture": "PowerISA",
      "full_name": "Count Trailing Zeros Word",
      "summary": "Counts the number of trailing zeros in the low 32-bits.",
      "syntax": "cnttzw RA, RS",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | / | 538 | /",
        "hex_opcode": "0x7C00043A",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "538",
            "clean": "538"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Source"
        }
      ],
      "extension": "Base",
      "slug": "cnttzw",
      "rel_url": "powerisa/cnttzw/",
      "linked_summary": "Counts the number of trailing zeros <a href=\"../../x86/in/\">in</a> the low 32-bits.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cnttzd",
      "architecture": "PowerISA",
      "full_name": "Count Trailing Zeros Doubleword",
      "summary": "Counts the number of trailing zeros in 64-bits.",
      "syntax": "cnttzd RA, RS",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | / | 570 | /",
        "hex_opcode": "0x7C00047A",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "570",
            "clean": "570"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Target"
        },
        {
          "name": "RS",
          "desc": "Source"
        }
      ],
      "extension": "Base",
      "slug": "cnttzd",
      "rel_url": "powerisa/cnttzd/",
      "linked_summary": "Counts the number of trailing zeros <a href=\"../../x86/in/\">in</a> 64-bits.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bctar",
      "architecture": "PowerISA",
      "full_name": "Branch Conditional to Target Address Register",
      "summary": "Branches to the address in the TAR. Used for fast indirect jumps (JIT).",
      "syntax": "bctar BO, BI, BH",
      "encoding": {
        "format": "XL-form",
        "binary_pattern": "19 | BO | BI | / | BH | 560 | /",
        "hex_opcode": "0x4C000460",
        "visual_parts": [
          {
            "raw": "19",
            "clean": "19"
          },
          {
            "raw": "BO",
            "clean": "BO"
          },
          {
            "raw": "BI",
            "clean": "BI"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "BH",
            "clean": "BH"
          },
          {
            "raw": "560",
            "clean": "560"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "BO",
          "desc": "Options"
        },
        {
          "name": "BI",
          "desc": "CR Bit"
        },
        {
          "name": "BH",
          "desc": "Hint"
        }
      ],
      "extension": "Branch & Control",
      "slug": "bctar",
      "rel_url": "powerisa/bctar/",
      "linked_summary": "Branches to the address <a href=\"../../x86/in/\">in</a> the TAR. Used for fast indirect jumps (JIT).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mttar",
      "architecture": "PowerISA",
      "full_name": "Move To Target Address Register",
      "summary": "Moves a GPR value to the TAR.",
      "syntax": "mttar RS",
      "encoding": {
        "format": "XFX-form",
        "binary_pattern": "mtspr 129, RS",
        "hex_opcode": "See mtspr",
        "visual_parts": [
          {
            "raw": "mtspr 129, RS",
            "clean": "mtspr 129, RS"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        }
      ],
      "extension": "Branch & Control",
      "slug": "mttar",
      "rel_url": "powerisa/mttar/",
      "linked_summary": "Moves a GPR value to the TAR.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mftar",
      "architecture": "PowerISA",
      "full_name": "Move From Target Address Register",
      "summary": "Reads the TAR into a GPR.",
      "syntax": "mftar RT",
      "encoding": {
        "format": "XFX-form",
        "binary_pattern": "mfspr RT, 129",
        "hex_opcode": "See mfspr",
        "visual_parts": [
          {
            "raw": "mfspr RT, 129",
            "clean": "mfspr RT, 129"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        }
      ],
      "extension": "Branch & Control",
      "slug": "mftar",
      "rel_url": "powerisa/mftar/",
      "linked_summary": "Reads the TAR into a GPR.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmprb",
      "architecture": "PowerISA",
      "full_name": "Compare Ranged Byte",
      "summary": "Compares a byte against a range of values. (Is byte in [min, max]?)",
      "syntax": "cmprb BF, L, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | BF | L | RA | RB | 192 | /",
        "hex_opcode": "0x7C000180",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "L",
            "clean": "L"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "192",
            "clean": "192"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "L",
          "desc": "Mode"
        },
        {
          "name": "RA",
          "desc": "Byte"
        },
        {
          "name": "RB",
          "desc": "Range"
        }
      ],
      "extension": "Base",
      "slug": "cmprb",
      "rel_url": "powerisa/cmprb/",
      "linked_summary": "Compares a byte against a range of values. (Is byte <a href=\"../../x86/in/\">in</a> [min, max]?)",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "paste.",
      "architecture": "PowerISA",
      "full_name": "Paste and Record",
      "summary": "Paste operation that updates CR0 to indicate success/fail.",
      "syntax": "paste. RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | RA | RB | 770 | 1",
        "hex_opcode": "0x7C000605",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "770",
            "clean": "770"
          },
          {
            "raw": "1",
            "clean": "1"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Dest"
        },
        {
          "name": "RB",
          "desc": "Control"
        }
      ],
      "extension": "Privileged",
      "slug": "paste_",
      "rel_url": "powerisa/paste_/",
      "linked_summary": "Paste operation that updates CR0 to indicate success/fail.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stqcx.",
      "architecture": "PowerISA",
      "full_name": "Store Quadword Conditional Indexed",
      "summary": "Atomic 128-bit store. Stores if reservation exists.",
      "syntax": "stqcx. RS, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 182 | 1",
        "hex_opcode": "0x7C00016D",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "182",
            "clean": "182"
          },
          {
            "raw": "1",
            "clean": "1"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Src Pair (Even/Odd)"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base (Quad Math)",
      "slug": "stqcx_",
      "rel_url": "powerisa/stqcx_/",
      "linked_summary": "Atomic 128-<a href=\"../../armv8-a/bit/\">bit</a> store. Stores if reservation exists.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lq",
      "architecture": "PowerISA",
      "full_name": "Load Quadword",
      "summary": "Loads 128 bits into two adjacent GPRs (Even/Odd pair).",
      "syntax": "lq RTp, DQ(RA)",
      "encoding": {
        "format": "DQ-form",
        "binary_pattern": "56 | RTp | RA | DQ | 0",
        "hex_opcode": "0xE0000000",
        "visual_parts": [
          {
            "raw": "56",
            "clean": "56"
          },
          {
            "raw": "RTp",
            "clean": "RTp"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "DQ",
            "clean": "DQ"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "RTp",
          "desc": "Target Pair"
        },
        {
          "name": "DQ",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "Base (Quad Math)",
      "slug": "lq",
      "rel_url": "powerisa/lq/",
      "linked_summary": "Loads 128 bits into two adjacent GPRs (Even/Odd pair).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stq",
      "architecture": "PowerISA",
      "full_name": "Store Quadword",
      "summary": "Stores 128 bits from two adjacent GPRs.",
      "syntax": "stq RSp, DQ(RA)",
      "encoding": {
        "format": "DQ-form",
        "binary_pattern": "62 | RSp | RA | DQ | 2",
        "hex_opcode": "0xF8000002",
        "visual_parts": [
          {
            "raw": "62",
            "clean": "62"
          },
          {
            "raw": "RSp",
            "clean": "RSp"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "DQ",
            "clean": "DQ"
          },
          {
            "raw": "2",
            "clean": "2"
          }
        ]
      },
      "operands": [
        {
          "name": "RSp",
          "desc": "Src Pair"
        },
        {
          "name": "DQ",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "Base (Quad Math)",
      "slug": "stq",
      "rel_url": "powerisa/stq/",
      "linked_summary": "Stores 128 bits from two adjacent GPRs.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "plh",
      "architecture": "PowerISA",
      "full_name": "Prefixed Load Halfword",
      "summary": "Loads 16-bit halfword using 34-bit offset.",
      "syntax": "plh RT, D(RA), R",
      "encoding": {
        "format": "MLS:D-form",
        "binary_pattern": "000001 | 10 | ... | 40 | ...",
        "hex_opcode": "0x06000000",
        "visual_parts": [
          {
            "raw": "000001",
            "clean": "000001"
          },
          {
            "raw": "10",
            "clean": "10"
          },
          {
            "raw": "...",
            "clean": "..."
          },
          {
            "raw": "40",
            "clean": "40"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "D",
          "desc": "Offset"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "R",
          "desc": "PC-Rel"
        }
      ],
      "extension": "Prefixed (64-bit)",
      "slug": "plh",
      "rel_url": "powerisa/plh/",
      "linked_summary": "Loads 16-<a href=\"../../armv8-a/bit/\">bit</a> halfword using 34-<a href=\"../../armv8-a/bit/\">bit</a> offset.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "plha",
      "architecture": "PowerISA",
      "full_name": "Prefixed Load Halfword Algebraic",
      "summary": "Loads 16-bit halfword (Sign Extended) using 34-bit offset.",
      "syntax": "plha RT, D(RA), R",
      "encoding": {
        "format": "MLS:D-form",
        "binary_pattern": "000001 | 10 | ... | 42 | ...",
        "hex_opcode": "0x06000000",
        "visual_parts": [
          {
            "raw": "000001",
            "clean": "000001"
          },
          {
            "raw": "10",
            "clean": "10"
          },
          {
            "raw": "...",
            "clean": "..."
          },
          {
            "raw": "42",
            "clean": "42"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "D",
          "desc": "Offset"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "R",
          "desc": "PC-Rel"
        }
      ],
      "extension": "Prefixed (64-bit)",
      "slug": "plha",
      "rel_url": "powerisa/plha/",
      "linked_summary": "Loads 16-<a href=\"../../armv8-a/bit/\">bit</a> halfword (Sign Extended) using 34-<a href=\"../../armv8-a/bit/\">bit</a> offset.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "plwa",
      "architecture": "PowerISA",
      "full_name": "Prefixed Load Word Algebraic",
      "summary": "Loads 32-bit word (Sign Extended) using 34-bit offset.",
      "syntax": "plwa RT, D(RA), R",
      "encoding": {
        "format": "MLS:D-form",
        "binary_pattern": "000001 | 10 | ... | 41 | ...",
        "hex_opcode": "0x06000000",
        "visual_parts": [
          {
            "raw": "000001",
            "clean": "000001"
          },
          {
            "raw": "10",
            "clean": "10"
          },
          {
            "raw": "...",
            "clean": "..."
          },
          {
            "raw": "41",
            "clean": "41"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "D",
          "desc": "Offset"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "R",
          "desc": "PC-Rel"
        }
      ],
      "extension": "Prefixed (64-bit)",
      "slug": "plwa",
      "rel_url": "powerisa/plwa/",
      "linked_summary": "Loads 32-<a href=\"../../armv8-a/bit/\">bit</a> word (Sign Extended) using 34-<a href=\"../../armv8-a/bit/\">bit</a> offset.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pstb",
      "architecture": "PowerISA",
      "full_name": "Prefixed Store Byte",
      "summary": "Stores byte using 34-bit offset.",
      "syntax": "pstb RS, D(RA), R",
      "encoding": {
        "format": "MLS:D-form",
        "binary_pattern": "000001 | 10 | ... | 38 | ...",
        "hex_opcode": "0x06000000",
        "visual_parts": [
          {
            "raw": "000001",
            "clean": "000001"
          },
          {
            "raw": "10",
            "clean": "10"
          },
          {
            "raw": "...",
            "clean": "..."
          },
          {
            "raw": "38",
            "clean": "38"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "D",
          "desc": "Offset"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "R",
          "desc": "PC-Rel"
        }
      ],
      "extension": "Prefixed (64-bit)",
      "slug": "pstb",
      "rel_url": "powerisa/pstb/",
      "linked_summary": "Stores byte using 34-<a href=\"../../armv8-a/bit/\">bit</a> offset.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psth",
      "architecture": "PowerISA",
      "full_name": "Prefixed Store Halfword",
      "summary": "Stores halfword using 34-bit offset.",
      "syntax": "psth RS, D(RA), R",
      "encoding": {
        "format": "MLS:D-form",
        "binary_pattern": "000001 | 10 | ... | 44 | ...",
        "hex_opcode": "0x06000000",
        "visual_parts": [
          {
            "raw": "000001",
            "clean": "000001"
          },
          {
            "raw": "10",
            "clean": "10"
          },
          {
            "raw": "...",
            "clean": "..."
          },
          {
            "raw": "44",
            "clean": "44"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "D",
          "desc": "Offset"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "R",
          "desc": "PC-Rel"
        }
      ],
      "extension": "Prefixed (64-bit)",
      "slug": "psth",
      "rel_url": "powerisa/psth/",
      "linked_summary": "Stores halfword using 34-<a href=\"../../armv8-a/bit/\">bit</a> offset.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pstw",
      "architecture": "PowerISA",
      "full_name": "Prefixed Store Word",
      "summary": "Stores word using 34-bit offset.",
      "syntax": "pstw RS, D(RA), R",
      "encoding": {
        "format": "MLS:D-form",
        "binary_pattern": "000001 | 10 | ... | 36 | ...",
        "hex_opcode": "0x06000000",
        "visual_parts": [
          {
            "raw": "000001",
            "clean": "000001"
          },
          {
            "raw": "10",
            "clean": "10"
          },
          {
            "raw": "...",
            "clean": "..."
          },
          {
            "raw": "36",
            "clean": "36"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "D",
          "desc": "Offset"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "R",
          "desc": "PC-Rel"
        }
      ],
      "extension": "Prefixed (64-bit)",
      "slug": "pstw",
      "rel_url": "powerisa/pstw/",
      "linked_summary": "Stores word using 34-<a href=\"../../armv8-a/bit/\">bit</a> offset.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "paddi",
      "architecture": "PowerISA",
      "full_name": "Prefixed Add Immediate",
      "summary": "Adds 34-bit immediate.",
      "syntax": "paddi RT, RA, SI, R",
      "encoding": {
        "format": "MLS:D-form",
        "binary_pattern": "000001 | 10 | ... | 14 | ...",
        "hex_opcode": "0x06000000",
        "visual_parts": [
          {
            "raw": "000001",
            "clean": "000001"
          },
          {
            "raw": "10",
            "clean": "10"
          },
          {
            "raw": "...",
            "clean": "..."
          },
          {
            "raw": "14",
            "clean": "14"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src"
        },
        {
          "name": "SI",
          "desc": "Imm"
        },
        {
          "name": "R",
          "desc": "PC-Rel"
        }
      ],
      "extension": "Prefixed (64-bit)",
      "slug": "paddi_1",
      "rel_url": "powerisa/paddi_1/",
      "linked_summary": "Adds 34-<a href=\"../../armv8-a/bit/\">bit</a> immediate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xscvudqp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Convert Unsigned Doubleword to Quad-Precision",
      "summary": "Converts 64-bit Unsigned Integer to 128-bit Float.",
      "syntax": "xscvudqp vD, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | / | vB | 724 | /",
        "hex_opcode": "0xFC0005D4",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "724",
            "clean": "724"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VSX (Quad)",
      "slug": "xscvudqp",
      "rel_url": "powerisa/xscvudqp/",
      "linked_summary": "Converts 64-<a href=\"../../armv8-a/bit/\">bit</a> Unsigned Integer to 128-<a href=\"../../armv8-a/bit/\">bit</a> Float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xscvsdqp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Convert Signed Doubleword to Quad-Precision",
      "summary": "Converts 64-bit Signed Integer to 128-bit Float.",
      "syntax": "xscvsdqp vD, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | / | vB | 756 | /",
        "hex_opcode": "0xFC0005F4",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "756",
            "clean": "756"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VSX (Quad)",
      "slug": "xscvsdqp",
      "rel_url": "powerisa/xscvsdqp/",
      "linked_summary": "Converts 64-<a href=\"../../armv8-a/bit/\">bit</a> Signed Integer to 128-<a href=\"../../armv8-a/bit/\">bit</a> Float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xscvqpud",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Convert Quad-Precision to Unsigned Doubleword",
      "summary": "Converts 128-bit Float to 64-bit Unsigned Integer.",
      "syntax": "xscvqpud vD, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | / | vB | 708 | /",
        "hex_opcode": "0xFC00058C",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "708",
            "clean": "708"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VSX (Quad)",
      "slug": "xscvqpud",
      "rel_url": "powerisa/xscvqpud/",
      "linked_summary": "Converts 128-<a href=\"../../armv8-a/bit/\">bit</a> Float to 64-<a href=\"../../armv8-a/bit/\">bit</a> Unsigned Integer.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xscvqpsd",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Convert Quad-Precision to Signed Doubleword",
      "summary": "Converts 128-bit Float to 64-bit Signed Integer.",
      "syntax": "xscvqpsd vD, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | / | vB | 740 | /",
        "hex_opcode": "0xFC0005CC",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "740",
            "clean": "740"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VSX (Quad)",
      "slug": "xscvqpsd",
      "rel_url": "powerisa/xscvqpsd/",
      "linked_summary": "Converts 128-<a href=\"../../armv8-a/bit/\">bit</a> Float to 64-<a href=\"../../armv8-a/bit/\">bit</a> Signed Integer.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xscvqpdp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Convert Quad-Precision to Double",
      "summary": "Demotes 128-bit Float to 64-bit Float.",
      "syntax": "xscvqpdp vD, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | / | vB | 836 | /",
        "hex_opcode": "0xFC000688",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "836",
            "clean": "836"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VSX (Quad)",
      "slug": "xscvqpdp",
      "rel_url": "powerisa/xscvqpdp/",
      "linked_summary": "Demotes 128-<a href=\"../../armv8-a/bit/\">bit</a> Float to 64-<a href=\"../../armv8-a/bit/\">bit</a> Float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsaddqpo",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Add Quad-Precision Odd",
      "summary": "Used for Quad-Precision arithmetic on hardware that splits quads.",
      "syntax": "xsaddqpo vD, vA, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | vA | vB | 4 | /",
        "hex_opcode": "0xFC000004",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX (Quad)",
      "slug": "xsaddqpo",
      "rel_url": "powerisa/xsaddqpo/",
      "linked_summary": "Used for Quad-Precision arithmetic on hardware that splits quads.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xssubqpo",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Subtract Quad-Precision Odd",
      "summary": "Used for Quad-Precision arithmetic on hardware that splits quads.",
      "syntax": "xssubqpo vD, vA, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | vA | vB | 516 | /",
        "hex_opcode": "0xFC000404",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "516",
            "clean": "516"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX (Quad)",
      "slug": "xssubqpo",
      "rel_url": "powerisa/xssubqpo/",
      "linked_summary": "Used for Quad-Precision arithmetic on hardware that splits quads.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsdivqpo",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Divide Quad-Precision Odd",
      "summary": "Used for Quad-Precision arithmetic on hardware that splits quads.",
      "syntax": "xsdivqpo vD, vA, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | vA | vB | 548 | /",
        "hex_opcode": "0xFC000444",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "548",
            "clean": "548"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX (Quad)",
      "slug": "xsdivqpo",
      "rel_url": "powerisa/xsdivqpo/",
      "linked_summary": "Used for Quad-Precision arithmetic on hardware that splits quads.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xssqrtqpo",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Square Root Quad-Precision Odd",
      "summary": "Used for Quad-Precision arithmetic on hardware that splits quads.",
      "syntax": "xssqrtqpo vD, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | 0 | vB | 676 | /",
        "hex_opcode": "0xFC000544",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "676",
            "clean": "676"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VSX (Quad)",
      "slug": "xssqrtqpo",
      "rel_url": "powerisa/xssqrtqpo/",
      "linked_summary": "Used for Quad-Precision arithmetic on hardware that splits quads.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsrqpi",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Round Quad-Precision to Integer",
      "summary": "Rounds a Quad float to a Quad integer.",
      "syntax": "xsrqpi vD, vB, R",
      "encoding": {
        "format": "Z23-form",
        "binary_pattern": "63 | vD | / | vB | R | 5",
        "hex_opcode": "0xFC000005",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "R",
            "clean": "R"
          },
          {
            "raw": "5",
            "clean": "5"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        },
        {
          "name": "R",
          "desc": "Mode"
        }
      ],
      "extension": "VSX (Quad)",
      "slug": "xsrqpi",
      "rel_url": "powerisa/xsrqpi/",
      "linked_summary": "Rounds a Quad float to a Quad integer.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsrqpix",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Round Quad-Precision to Integer Extended",
      "summary": "Rounds a Quad float to a Quad integer (Exact).",
      "syntax": "xsrqpix vD, vB, R",
      "encoding": {
        "format": "Z23-form",
        "binary_pattern": "63 | vD | / | vB | R | 37",
        "hex_opcode": "0xFC000025",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "R",
            "clean": "R"
          },
          {
            "raw": "37",
            "clean": "37"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        },
        {
          "name": "R",
          "desc": "Mode"
        }
      ],
      "extension": "VSX (Quad)",
      "slug": "xsrqpix",
      "rel_url": "powerisa/xsrqpix/",
      "linked_summary": "Rounds a Quad float to a Quad integer (Exact).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fmr",
      "architecture": "PowerISA",
      "full_name": "Floating Move Register",
      "summary": "Copies a float register (Pseudo: for FRB).",
      "syntax": "fmr FRT, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | FRT | 0 | FRB | 72 | /",
        "hex_opcode": "0xFC000090",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "72",
            "clean": "72"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRB",
          "desc": "Source"
        }
      ],
      "extension": "Float",
      "slug": "fmr",
      "rel_url": "powerisa/fmr/",
      "linked_summary": "Copies a float register (Pseudo: for FRB).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fabs",
      "architecture": "PowerISA",
      "full_name": "Floating Absolute Value",
      "summary": "Computes absolute value of a float.",
      "syntax": "fabs FRT, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | FRT | 0 | FRB | 264 | /",
        "hex_opcode": "0xFC000210",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "264",
            "clean": "264"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRB",
          "desc": "Source"
        }
      ],
      "extension": "Float",
      "slug": "fabs",
      "rel_url": "powerisa/fabs/",
      "linked_summary": "Computes absolute value of a float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fneg",
      "architecture": "PowerISA",
      "full_name": "Floating Negate",
      "summary": "Negates a float.",
      "syntax": "fneg FRT, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | FRT | 0 | FRB | 40 | /",
        "hex_opcode": "0xFC000050",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "40",
            "clean": "40"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRB",
          "desc": "Source"
        }
      ],
      "extension": "Float",
      "slug": "fneg",
      "rel_url": "powerisa/fneg/",
      "linked_summary": "Negates a float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fnabs",
      "architecture": "PowerISA",
      "full_name": "Floating Negative Absolute Value",
      "summary": "Computes negative absolute value of a float.",
      "syntax": "fnabs FRT, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | FRT | 0 | FRB | 136 | /",
        "hex_opcode": "0xFC000110",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "136",
            "clean": "136"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRB",
          "desc": "Source"
        }
      ],
      "extension": "Float",
      "slug": "fnabs",
      "rel_url": "powerisa/fnabs/",
      "linked_summary": "Computes negative absolute value of a float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fcpsgn",
      "architecture": "PowerISA",
      "full_name": "Floating Copy Sign",
      "summary": "Copies sign from FRB to FRA.",
      "syntax": "fcpsgn FRT, FRA, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | FRT | FRA | FRB | 8 | /",
        "hex_opcode": "0xFC000010",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "FRA",
            "clean": "FRA"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "8",
            "clean": "8"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRA",
          "desc": "Source"
        },
        {
          "name": "FRB",
          "desc": "Sign Source"
        }
      ],
      "extension": "Float",
      "slug": "fcpsgn",
      "rel_url": "powerisa/fcpsgn/",
      "linked_summary": "Copies sign from FRB to FRA.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fsel",
      "architecture": "PowerISA",
      "full_name": "Floating Select",
      "summary": "Selects FRA if FRC >= 0, else FRB (Optional).",
      "syntax": "fsel FRT, FRA, FRC, FRB",
      "encoding": {
        "format": "A-form",
        "binary_pattern": "63 | FRT | FRA | FRB | FRC | 23 | /",
        "hex_opcode": "0xFC00002E",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "FRA",
            "clean": "FRA"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "FRC",
            "clean": "FRC"
          },
          {
            "raw": "23",
            "clean": "23"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRA",
          "desc": "True"
        },
        {
          "name": "FRC",
          "desc": "Cond"
        },
        {
          "name": "FRB",
          "desc": "False"
        }
      ],
      "extension": "Float",
      "slug": "fsel",
      "rel_url": "powerisa/fsel/",
      "linked_summary": "Selects FRA if FRC >= 0, else FRB (Optional).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fsqrt",
      "architecture": "PowerISA",
      "full_name": "Floating Square Root",
      "summary": "Computes square root (Double).",
      "syntax": "fsqrt FRT, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | FRT | 0 | FRB | 22 | /",
        "hex_opcode": "0xFC00002C",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "22",
            "clean": "22"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRB",
          "desc": "Source"
        }
      ],
      "extension": "Float",
      "slug": "fsqrt",
      "rel_url": "powerisa/fsqrt/",
      "linked_summary": "Computes square root (Double).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fsqrts",
      "architecture": "PowerISA",
      "full_name": "Floating Square Root Single",
      "summary": "Computes square root (Single).",
      "syntax": "fsqrts FRT, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "59 | FRT | 0 | FRB | 22 | /",
        "hex_opcode": "0xEC00002C",
        "visual_parts": [
          {
            "raw": "59",
            "clean": "59"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "22",
            "clean": "22"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRB",
          "desc": "Source"
        }
      ],
      "extension": "Float",
      "slug": "fsqrts",
      "rel_url": "powerisa/fsqrts/",
      "linked_summary": "Computes square root (Single).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fmsub",
      "architecture": "PowerISA",
      "full_name": "Floating Multiply-Subtract",
      "summary": "A*C - B",
      "syntax": "fmsub FRT, FRA, FRC, FRB",
      "encoding": {
        "format": "A-form",
        "binary_pattern": "63 | FRT | FRA | FRB | FRC | 28 | /",
        "hex_opcode": "0xFC000038",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "FRA",
            "clean": "FRA"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "FRC",
            "clean": "FRC"
          },
          {
            "raw": "28",
            "clean": "28"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRA",
          "desc": "A"
        },
        {
          "name": "FRC",
          "desc": "C"
        },
        {
          "name": "FRB",
          "desc": "B"
        }
      ],
      "extension": "Float",
      "slug": "fmsub",
      "rel_url": "powerisa/fmsub/",
      "linked_summary": "A*C - B",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fnmadd",
      "architecture": "PowerISA",
      "full_name": "Floating Negative Multiply-Add",
      "summary": "-(A*C + B)",
      "syntax": "fnmadd FRT, FRA, FRC, FRB",
      "encoding": {
        "format": "A-form",
        "binary_pattern": "63 | FRT | FRA | FRB | FRC | 31 | /",
        "hex_opcode": "0xFC00003E",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "FRA",
            "clean": "FRA"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "FRC",
            "clean": "FRC"
          },
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRA",
          "desc": "A"
        },
        {
          "name": "FRC",
          "desc": "C"
        },
        {
          "name": "FRB",
          "desc": "B"
        }
      ],
      "extension": "Float",
      "slug": "fnmadd",
      "rel_url": "powerisa/fnmadd/",
      "linked_summary": "-(A*C + B)",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fnmsub",
      "architecture": "PowerISA",
      "full_name": "Floating Negative Multiply-Subtract",
      "summary": "-(A*C - B)",
      "syntax": "fnmsub FRT, FRA, FRC, FRB",
      "encoding": {
        "format": "A-form",
        "binary_pattern": "63 | FRT | FRA | FRB | FRC | 30 | /",
        "hex_opcode": "0xFC00003C",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "FRA",
            "clean": "FRA"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "FRC",
            "clean": "FRC"
          },
          {
            "raw": "30",
            "clean": "30"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRA",
          "desc": "A"
        },
        {
          "name": "FRC",
          "desc": "C"
        },
        {
          "name": "FRB",
          "desc": "B"
        }
      ],
      "extension": "Float",
      "slug": "fnmsub",
      "rel_url": "powerisa/fnmsub/",
      "linked_summary": "-(A*C - B)",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "frsp",
      "architecture": "PowerISA",
      "full_name": "Floating Round to Single-Precision",
      "summary": "Rounds Double to Single.",
      "syntax": "frsp FRT, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | FRT | 0 | FRB | 12 | /",
        "hex_opcode": "0xFC000018",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "12",
            "clean": "12"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRB",
          "desc": "Source"
        }
      ],
      "extension": "Float",
      "slug": "frsp",
      "rel_url": "powerisa/frsp/",
      "linked_summary": "Rounds Double to Single.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fctid",
      "architecture": "PowerISA",
      "full_name": "Floating Convert to Integer Doubleword",
      "summary": "Converts Double to 64-bit Int.",
      "syntax": "fctid FRT, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | FRT | 0 | FRB | 814 | /",
        "hex_opcode": "0xFC00065C",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "814",
            "clean": "814"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRB",
          "desc": "Source"
        }
      ],
      "extension": "Float",
      "slug": "fctid",
      "rel_url": "powerisa/fctid/",
      "linked_summary": "Converts Double to 64-<a href=\"../../armv8-a/bit/\">bit</a> Int.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fctidz",
      "architecture": "PowerISA",
      "full_name": "Floating Convert to Integer Doubleword with Round to Zero",
      "summary": "Converts Double to 64-bit Int (Truncate).",
      "syntax": "fctidz FRT, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | FRT | 0 | FRB | 815 | /",
        "hex_opcode": "0xFC00065E",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "815",
            "clean": "815"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRB",
          "desc": "Source"
        }
      ],
      "extension": "Float",
      "slug": "fctidz",
      "rel_url": "powerisa/fctidz/",
      "linked_summary": "Converts Double to 64-<a href=\"../../armv8-a/bit/\">bit</a> Int (Truncate).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fctiwz",
      "architecture": "PowerISA",
      "full_name": "Floating Convert to Integer Word with Round to Zero",
      "summary": "Converts Double to 32-bit Int (Truncate).",
      "syntax": "fctiwz FRT, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | FRT | 0 | FRB | 15 | /",
        "hex_opcode": "0xFC00001E",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "15",
            "clean": "15"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRB",
          "desc": "Source"
        }
      ],
      "extension": "Float",
      "slug": "fctiwz",
      "rel_url": "powerisa/fctiwz/",
      "linked_summary": "Converts Double to 32-<a href=\"../../armv8-a/bit/\">bit</a> Int (Truncate).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fcfid",
      "architecture": "PowerISA",
      "full_name": "Floating Convert from Integer Doubleword",
      "summary": "Converts 64-bit Int to Double.",
      "syntax": "fcfid FRT, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | FRT | 0 | FRB | 846 | /",
        "hex_opcode": "0xFC00069C",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "846",
            "clean": "846"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRB",
          "desc": "Source"
        }
      ],
      "extension": "Float",
      "slug": "fcfid",
      "rel_url": "powerisa/fcfid/",
      "linked_summary": "Converts 64-<a href=\"../../armv8-a/bit/\">bit</a> Int to Double.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fcfids",
      "architecture": "PowerISA",
      "full_name": "Floating Convert from Integer Doubleword Single",
      "summary": "Converts 64-bit Int to Single.",
      "syntax": "fcfids FRT, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "59 | FRT | 0 | FRB | 846 | /",
        "hex_opcode": "0xEC00069C",
        "visual_parts": [
          {
            "raw": "59",
            "clean": "59"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "846",
            "clean": "846"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRB",
          "desc": "Source"
        }
      ],
      "extension": "Float",
      "slug": "fcfids",
      "rel_url": "powerisa/fcfids/",
      "linked_summary": "Converts 64-<a href=\"../../armv8-a/bit/\">bit</a> Int to Single.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fcfidu",
      "architecture": "PowerISA",
      "full_name": "Floating Convert from Unsigned Integer Doubleword",
      "summary": "Converts 64-bit Unsigned Int to Double.",
      "syntax": "fcfidu FRT, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | FRT | 0 | FRB | 974 | /",
        "hex_opcode": "0xFC00079C",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "974",
            "clean": "974"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRB",
          "desc": "Source"
        }
      ],
      "extension": "Float",
      "slug": "fcfidu",
      "rel_url": "powerisa/fcfidu/",
      "linked_summary": "Converts 64-<a href=\"../../armv8-a/bit/\">bit</a> Unsigned Int to Double.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fcfidus",
      "architecture": "PowerISA",
      "full_name": "Floating Convert from Unsigned Integer Doubleword Single",
      "summary": "Converts 64-bit Unsigned Int to Single.",
      "syntax": "fcfidus FRT, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "59 | FRT | 0 | FRB | 974 | /",
        "hex_opcode": "0xEC00079C",
        "visual_parts": [
          {
            "raw": "59",
            "clean": "59"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "974",
            "clean": "974"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRB",
          "desc": "Source"
        }
      ],
      "extension": "Float",
      "slug": "fcfidus",
      "rel_url": "powerisa/fcfidus/",
      "linked_summary": "Converts 64-<a href=\"../../armv8-a/bit/\">bit</a> Unsigned Int to Single.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_stmw",
      "architecture": "PowerISA",
      "full_name": "VLE Store Multiple Word",
      "summary": "Stores words from registers RT through R31 to memory.",
      "syntax": "e_stmw RS, D(RA)",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0001 | 1000 | ...",
        "hex_opcode": "0x1800...",
        "visual_parts": [
          {
            "raw": "0001",
            "clean": "0001"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Start Reg"
        },
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_stmw_1",
      "rel_url": "powerisa/e_stmw_1/",
      "linked_summary": "Stores words from registers RT through R31 to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_lmv",
      "architecture": "PowerISA",
      "full_name": "VLE Load Multiple Volatile",
      "summary": "Loads volatile registers (R0, R3-R12) from memory.",
      "syntax": "e_lmv D(RA)",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0001 | 1000 | ...",
        "hex_opcode": "0x1800...",
        "visual_parts": [
          {
            "raw": "0001",
            "clean": "0001"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_lmv",
      "rel_url": "powerisa/e_lmv/",
      "linked_summary": "Loads volatile registers (R0, R3-R12) from memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_stmv",
      "architecture": "PowerISA",
      "full_name": "VLE Store Multiple Volatile",
      "summary": "Stores volatile registers (R0, R3-R12) to memory.",
      "syntax": "e_stmv D(RA)",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0001 | 1000 | ...",
        "hex_opcode": "0x1800...",
        "visual_parts": [
          {
            "raw": "0001",
            "clean": "0001"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_stmv",
      "rel_url": "powerisa/e_stmv/",
      "linked_summary": "Stores volatile registers (R0, R3-R12) to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_lmvgprw",
      "architecture": "PowerISA",
      "full_name": "VLE Load Multiple Volatile GPR Word",
      "summary": "Loads volatile GPRs from memory (Word aligned).",
      "syntax": "e_lmvgprw D(RA)",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0001 | 1000 | ...",
        "hex_opcode": "0x1800...",
        "visual_parts": [
          {
            "raw": "0001",
            "clean": "0001"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_lmvgprw",
      "rel_url": "powerisa/e_lmvgprw/",
      "linked_summary": "Loads volatile GPRs from memory (Word aligned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_stmvgprw",
      "architecture": "PowerISA",
      "full_name": "VLE Store Multiple Volatile GPR Word",
      "summary": "Stores volatile GPRs to memory (Word aligned).",
      "syntax": "e_stmvgprw D(RA)",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0001 | 1000 | ...",
        "hex_opcode": "0x1800...",
        "visual_parts": [
          {
            "raw": "0001",
            "clean": "0001"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_stmvgprw",
      "rel_url": "powerisa/e_stmvgprw/",
      "linked_summary": "Stores volatile GPRs to memory (Word aligned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_lmvsprw",
      "architecture": "PowerISA",
      "full_name": "VLE Load Multiple Volatile SPR Word",
      "summary": "Loads volatile SPRs (CR, LR, CTR, XER) from memory.",
      "syntax": "e_lmvsprw D(RA)",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0001 | 1000 | ...",
        "hex_opcode": "0x1800...",
        "visual_parts": [
          {
            "raw": "0001",
            "clean": "0001"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_lmvsprw",
      "rel_url": "powerisa/e_lmvsprw/",
      "linked_summary": "Loads volatile SPRs (CR, LR, CTR, XER) from memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_stmvsprw",
      "architecture": "PowerISA",
      "full_name": "VLE Store Multiple Volatile SPR Word",
      "summary": "Stores volatile SPRs (CR, LR, CTR, XER) to memory.",
      "syntax": "e_stmvsprw D(RA)",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0001 | 1000 | ...",
        "hex_opcode": "0x1800...",
        "visual_parts": [
          {
            "raw": "0001",
            "clean": "0001"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_stmvsprw",
      "rel_url": "powerisa/e_stmvsprw/",
      "linked_summary": "Stores volatile SPRs (CR, LR, CTR, XER) to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_lmvsrrw",
      "architecture": "PowerISA",
      "full_name": "VLE Load Multiple Volatile SRR Word",
      "summary": "Loads volatile Save/Restore Registers (SRR0, SRR1) from memory.",
      "syntax": "e_lmvsrrw D(RA)",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0001 | 1000 | ...",
        "hex_opcode": "0x1800...",
        "visual_parts": [
          {
            "raw": "0001",
            "clean": "0001"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_lmvsrrw",
      "rel_url": "powerisa/e_lmvsrrw/",
      "linked_summary": "Loads volatile Save/Restore Registers (SRR0, SRR1) from memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_stmvsrrw",
      "architecture": "PowerISA",
      "full_name": "VLE Store Multiple Volatile SRR Word",
      "summary": "Stores volatile Save/Restore Registers (SRR0, SRR1) to memory.",
      "syntax": "e_stmvsrrw D(RA)",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0001 | 1000 | ...",
        "hex_opcode": "0x1800...",
        "visual_parts": [
          {
            "raw": "0001",
            "clean": "0001"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_stmvsrrw",
      "rel_url": "powerisa/e_stmvsrrw/",
      "linked_summary": "Stores volatile Save/Restore Registers (SRR0, SRR1) to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_lmvcsrrw",
      "architecture": "PowerISA",
      "full_name": "VLE Load Multiple Volatile CSRR Word",
      "summary": "Loads volatile Critical SRRs (CSRR0, CSRR1) from memory.",
      "syntax": "e_lmvcsrrw D(RA)",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0001 | 1000 | ...",
        "hex_opcode": "0x1800...",
        "visual_parts": [
          {
            "raw": "0001",
            "clean": "0001"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_lmvcsrrw",
      "rel_url": "powerisa/e_lmvcsrrw/",
      "linked_summary": "Loads volatile Critical SRRs (CSRR0, CSRR1) from memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_stmvcsrrw",
      "architecture": "PowerISA",
      "full_name": "VLE Store Multiple Volatile CSRR Word",
      "summary": "Stores volatile Critical SRRs (CSRR0, CSRR1) to memory.",
      "syntax": "e_stmvcsrrw D(RA)",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0001 | 1000 | ...",
        "hex_opcode": "0x1800...",
        "visual_parts": [
          {
            "raw": "0001",
            "clean": "0001"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_stmvcsrrw",
      "rel_url": "powerisa/e_stmvcsrrw/",
      "linked_summary": "Stores volatile Critical SRRs (CSRR0, CSRR1) to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_lmvdsrrw",
      "architecture": "PowerISA",
      "full_name": "VLE Load Multiple Volatile DSRR Word",
      "summary": "Loads volatile Debug SRRs (DSRR0, DSRR1) from memory.",
      "syntax": "e_lmvdsrrw D(RA)",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0001 | 1000 | ...",
        "hex_opcode": "0x1800...",
        "visual_parts": [
          {
            "raw": "0001",
            "clean": "0001"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_lmvdsrrw",
      "rel_url": "powerisa/e_lmvdsrrw/",
      "linked_summary": "Loads volatile Debug SRRs (DSRR0, DSRR1) from memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_stmvdsrrw",
      "architecture": "PowerISA",
      "full_name": "VLE Store Multiple Volatile DSRR Word",
      "summary": "Stores volatile Debug SRRs (DSRR0, DSRR1) to memory.",
      "syntax": "e_stmvdsrrw D(RA)",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0001 | 1000 | ...",
        "hex_opcode": "0x1800...",
        "visual_parts": [
          {
            "raw": "0001",
            "clean": "0001"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "D",
          "desc": "Disp"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_stmvdsrrw",
      "rel_url": "powerisa/e_stmvdsrrw/",
      "linked_summary": "Stores volatile Debug SRRs (DSRR0, DSRR1) to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_bdnz",
      "architecture": "PowerISA",
      "full_name": "VLE Branch Decrement Not Zero",
      "summary": "Decrements CTR, branches if CTR != 0.",
      "syntax": "e_bdnz BD",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "BD",
          "desc": "Disp"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_bdnz",
      "rel_url": "powerisa/e_bdnz/",
      "linked_summary": "Decrements CTR, branches if CTR != 0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_bdnzf",
      "architecture": "PowerISA",
      "full_name": "VLE Branch Decrement Not Zero False",
      "summary": "Decrements CTR, branches if CTR != 0 AND CR bit is false.",
      "syntax": "e_bdnzf BI, BD",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "BI",
          "desc": "CR Bit"
        },
        {
          "name": "BD",
          "desc": "Disp"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_bdnzf",
      "rel_url": "powerisa/e_bdnzf/",
      "linked_summary": "Decrements CTR, branches if CTR != 0 <a href=\"../../risc-v/and/\">AND</a> CR <a href=\"../../armv8-a/bit/\">bit</a> is false.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_bdnzt",
      "architecture": "PowerISA",
      "full_name": "VLE Branch Decrement Not Zero True",
      "summary": "Decrements CTR, branches if CTR != 0 AND CR bit is true.",
      "syntax": "e_bdnzt BI, BD",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "BI",
          "desc": "CR Bit"
        },
        {
          "name": "BD",
          "desc": "Disp"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_bdnzt",
      "rel_url": "powerisa/e_bdnzt/",
      "linked_summary": "Decrements CTR, branches if CTR != 0 <a href=\"../../risc-v/and/\">AND</a> CR <a href=\"../../armv8-a/bit/\">bit</a> is true.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_bdz",
      "architecture": "PowerISA",
      "full_name": "VLE Branch Decrement Zero",
      "summary": "Decrements CTR, branches if CTR == 0.",
      "syntax": "e_bdz BD",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "BD",
          "desc": "Disp"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_bdz",
      "rel_url": "powerisa/e_bdz/",
      "linked_summary": "Decrements CTR, branches if CTR == 0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_bdzf",
      "architecture": "PowerISA",
      "full_name": "VLE Branch Decrement Zero False",
      "summary": "Decrements CTR, branches if CTR == 0 AND CR bit is false.",
      "syntax": "e_bdzf BI, BD",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "BI",
          "desc": "CR Bit"
        },
        {
          "name": "BD",
          "desc": "Disp"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_bdzf",
      "rel_url": "powerisa/e_bdzf/",
      "linked_summary": "Decrements CTR, branches if CTR == 0 <a href=\"../../risc-v/and/\">AND</a> CR <a href=\"../../armv8-a/bit/\">bit</a> is false.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_bdzt",
      "architecture": "PowerISA",
      "full_name": "VLE Branch Decrement Zero True",
      "summary": "Decrements CTR, branches if CTR == 0 AND CR bit is true.",
      "syntax": "e_bdzt BI, BD",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1000 | ...",
        "hex_opcode": "0x7800...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "BI",
          "desc": "CR Bit"
        },
        {
          "name": "BD",
          "desc": "Disp"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_bdzt",
      "rel_url": "powerisa/e_bdzt/",
      "linked_summary": "Decrements CTR, branches if CTR == 0 <a href=\"../../risc-v/and/\">AND</a> CR <a href=\"../../armv8-a/bit/\">bit</a> is true.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_add16is",
      "architecture": "PowerISA",
      "full_name": "VLE Add 16-bit Immediate Shifted",
      "summary": "Adds a 16-bit immediate shifted left by 16 bits.",
      "syntax": "e_add16is RT, RA, SI",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0001 | 1100 | ...",
        "hex_opcode": "0x1C00...",
        "visual_parts": [
          {
            "raw": "0001",
            "clean": "0001"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src"
        },
        {
          "name": "SI",
          "desc": "Imm"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_add16is",
      "rel_url": "powerisa/e_add16is/",
      "linked_summary": "Adds a 16-<a href=\"../../armv8-a/bit/\">bit</a> immediate shifted left by 16 bits.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_cmp16i",
      "architecture": "PowerISA",
      "full_name": "VLE Compare 16-bit Immediate",
      "summary": "Compares word with 16-bit immediate.",
      "syntax": "e_cmp16i BF, RA, SI",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0001 | 1100 | ...",
        "hex_opcode": "0x1C00...",
        "visual_parts": [
          {
            "raw": "0001",
            "clean": "0001"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "RA",
          "desc": "Src"
        },
        {
          "name": "SI",
          "desc": "Imm"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_cmp16i",
      "rel_url": "powerisa/e_cmp16i/",
      "linked_summary": "Compares word with 16-<a href=\"../../armv8-a/bit/\">bit</a> immediate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_cmpl16i",
      "architecture": "PowerISA",
      "full_name": "VLE Compare Logical 16-bit Immediate",
      "summary": "Unsigned compare word with 16-bit immediate.",
      "syntax": "e_cmpl16i BF, RA, UI",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0001 | 1100 | ...",
        "hex_opcode": "0x1C00...",
        "visual_parts": [
          {
            "raw": "0001",
            "clean": "0001"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "RA",
          "desc": "Src"
        },
        {
          "name": "UI",
          "desc": "Imm"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_cmpl16i",
      "rel_url": "powerisa/e_cmpl16i/",
      "linked_summary": "Unsigned compare word with 16-<a href=\"../../armv8-a/bit/\">bit</a> immediate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_or2is",
      "architecture": "PowerISA",
      "full_name": "VLE OR Immediate Shifted",
      "summary": "OR with 16-bit immediate shifted left by 16 bits.",
      "syntax": "e_or2is RT, UI",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 0000 | ...",
        "hex_opcode": "0x7000...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "UI",
          "desc": "Imm"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_or2is",
      "rel_url": "powerisa/e_or2is/",
      "linked_summary": "<a href=\"../../risc-v/or/\">OR</a> with 16-<a href=\"../../armv8-a/bit/\">bit</a> immediate shifted left by 16 bits.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_and2is",
      "architecture": "PowerISA",
      "full_name": "VLE AND Immediate Shifted",
      "summary": "AND with 16-bit immediate shifted left by 16 bits.",
      "syntax": "e_and2is RT, UI",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 0000 | ...",
        "hex_opcode": "0x7000...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "UI",
          "desc": "Imm"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_and2is",
      "rel_url": "powerisa/e_and2is/",
      "linked_summary": "<a href=\"../../risc-v/and/\">AND</a> with 16-<a href=\"../../armv8-a/bit/\">bit</a> immediate shifted left by 16 bits.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_xor2is",
      "architecture": "PowerISA",
      "full_name": "VLE XOR Immediate Shifted",
      "summary": "XOR with 16-bit immediate shifted left by 16 bits.",
      "syntax": "e_xor2is RT, UI",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 0000 | ...",
        "hex_opcode": "0x7000...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "0000",
            "clean": "0000"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "UI",
          "desc": "Imm"
        }
      ],
      "extension": "VLE (32-bit)",
      "slug": "e_xor2is",
      "rel_url": "powerisa/e_xor2is/",
      "linked_summary": "<a href=\"../../risc-v/xor/\">XOR</a> with 16-<a href=\"../../armv8-a/bit/\">bit</a> immediate shifted left by 16 bits.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_dcbf",
      "architecture": "PowerISA",
      "full_name": "VLE Data Cache Block Flush",
      "summary": "Flushes a data cache block.",
      "syntax": "e_dcbf RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1100 | ...",
        "hex_opcode": "0x7C00...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "VLE (Cache)",
      "slug": "e_dcbf",
      "rel_url": "powerisa/e_dcbf/",
      "linked_summary": "Flushes a data cache block.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_dcbst",
      "architecture": "PowerISA",
      "full_name": "VLE Data Cache Block Store",
      "summary": "Stores a data cache block.",
      "syntax": "e_dcbst RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1100 | ...",
        "hex_opcode": "0x7C00...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "VLE (Cache)",
      "slug": "e_dcbst",
      "rel_url": "powerisa/e_dcbst/",
      "linked_summary": "Stores a data cache block.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_dcbt",
      "architecture": "PowerISA",
      "full_name": "VLE Data Cache Block Touch",
      "summary": "Prefetches a data cache block.",
      "syntax": "e_dcbt RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1100 | ...",
        "hex_opcode": "0x7C00...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "VLE (Cache)",
      "slug": "e_dcbt",
      "rel_url": "powerisa/e_dcbt/",
      "linked_summary": "Prefetches a data cache block.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_dcbtst",
      "architecture": "PowerISA",
      "full_name": "VLE Data Cache Block Touch for Store",
      "summary": "Prefetches a data cache block for writing.",
      "syntax": "e_dcbtst RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1100 | ...",
        "hex_opcode": "0x7C00...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "VLE (Cache)",
      "slug": "e_dcbtst",
      "rel_url": "powerisa/e_dcbtst/",
      "linked_summary": "Prefetches a data cache block for writing.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_dcbz",
      "architecture": "PowerISA",
      "full_name": "VLE Data Cache Block Zero",
      "summary": "Zeros a data cache block.",
      "syntax": "e_dcbz RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1100 | ...",
        "hex_opcode": "0x7C00...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "VLE (Cache)",
      "slug": "e_dcbz",
      "rel_url": "powerisa/e_dcbz/",
      "linked_summary": "Zeros a data cache block.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_icbi",
      "architecture": "PowerISA",
      "full_name": "VLE Instruction Cache Block Invalidate",
      "summary": "Invalidates an instruction cache block.",
      "syntax": "e_icbi RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1100 | ...",
        "hex_opcode": "0x7C00...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "VLE (Cache)",
      "slug": "e_icbi",
      "rel_url": "powerisa/e_icbi/",
      "linked_summary": "Invalidates an instruction cache block.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_icbt",
      "architecture": "PowerISA",
      "full_name": "VLE Instruction Cache Block Touch",
      "summary": "Prefetches an instruction cache block.",
      "syntax": "e_icbt RA, RB",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1100 | ...",
        "hex_opcode": "0x7C00...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "VLE (Cache)",
      "slug": "e_icbt",
      "rel_url": "powerisa/e_icbt/",
      "linked_summary": "Prefetches an instruction cache block.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_mbar",
      "architecture": "PowerISA",
      "full_name": "VLE Memory Barrier",
      "summary": "Ensures memory access ordering.",
      "syntax": "e_mbar MO",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1100 | ...",
        "hex_opcode": "0x7C00...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "MO",
          "desc": "Ordering"
        }
      ],
      "extension": "VLE (Control)",
      "slug": "e_mbar",
      "rel_url": "powerisa/e_mbar/",
      "linked_summary": "Ensures memory access ordering.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_msync",
      "architecture": "PowerISA",
      "full_name": "VLE Memory Synchronize",
      "summary": "Synchronizes memory accesses.",
      "syntax": "e_msync",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1100 | ...",
        "hex_opcode": "0x7C00...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [],
      "extension": "VLE (Control)",
      "slug": "e_msync",
      "rel_url": "powerisa/e_msync/",
      "linked_summary": "Synchronizes memory accesses.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_isync",
      "architecture": "PowerISA",
      "full_name": "VLE Instruction Synchronize",
      "summary": "Waits for previous instructions to complete.",
      "syntax": "e_isync",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1100 | ...",
        "hex_opcode": "0x7C00...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [],
      "extension": "VLE (Control)",
      "slug": "e_isync",
      "rel_url": "powerisa/e_isync/",
      "linked_summary": "Waits for previous instructions to complete.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "e_wait",
      "architecture": "PowerISA",
      "full_name": "VLE Wait",
      "summary": "Waits for an interrupt.",
      "syntax": "e_wait",
      "encoding": {
        "format": "E-form",
        "binary_pattern": "0111 | 1100 | ...",
        "hex_opcode": "0x7C00...",
        "visual_parts": [
          {
            "raw": "0111",
            "clean": "0111"
          },
          {
            "raw": "1100",
            "clean": "1100"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [],
      "extension": "VLE (Control)",
      "slug": "e_wait",
      "rel_url": "powerisa/e_wait/",
      "linked_summary": "Waits for an interrupt.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lvx",
      "architecture": "PowerISA",
      "full_name": "Load Vector Indexed",
      "summary": "Loads a 128-bit vector from memory into a Vector Register. Address must be 16-byte aligned (bits 60-63 of effective address are ignored).",
      "syntax": "lvx vD, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | vD | RA | RB | 7 | /",
        "hex_opcode": "0x7C00000E",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "7",
            "clean": "7"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target Vector Register"
        },
        {
          "name": "RA",
          "desc": "Base Register"
        },
        {
          "name": "RB",
          "desc": "Index Register"
        }
      ],
      "pseudocode": "EA <- (RA + RB) & 0xFFFFFFF0; vD <- MEM(EA, 16)",
      "example": "lvx v1, r3, r4",
      "example_note": "Load aligned vector.",
      "extension": "VMX (AltiVec)",
      "pseudocode_html": "<pre><code class=\"language-clike\">EA &lt;- (RA + RB) &amp; 0xFFFFFFF0; vD &lt;- MEM(EA, 16)</code></pre>",
      "slug": "lvx",
      "rel_url": "powerisa/lvx/",
      "linked_summary": "Loads a 128-<a href=\"../../armv8-a/bit/\">bit</a> vector from memory into a Vector Register. Address must be 16-byte aligned (bits 60-63 of effective address are ignored).",
      "linked_pseudocode": "EA <- (RA + RB) & 0xFFFFFFF0; vD <- MEM(EA, 16)"
    },
    {
      "mnemonic": "stvx",
      "architecture": "PowerISA",
      "full_name": "Store Vector Indexed",
      "summary": "Stores a 128-bit vector to memory. Address must be 16-byte aligned.",
      "syntax": "stvx vS, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | vS | RA | RB | 231 | /",
        "hex_opcode": "0x7C0001C6",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "vS",
            "clean": "vS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "231",
            "clean": "231"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vS",
          "desc": "Source Vector Register"
        },
        {
          "name": "RA",
          "desc": "Base Register"
        },
        {
          "name": "RB",
          "desc": "Index Register"
        }
      ],
      "pseudocode": "EA <- (RA + RB) & 0xFFFFFFF0; MEM(EA, 16) <- vS",
      "example": "stvx v1, r3, r4",
      "example_note": "Store aligned vector.",
      "extension": "VMX (AltiVec)",
      "pseudocode_html": "<pre><code class=\"language-clike\">EA &lt;- (RA + RB) &amp; 0xFFFFFFF0; MEM(EA, 16) &lt;- vS</code></pre>",
      "slug": "stvx",
      "rel_url": "powerisa/stvx/",
      "linked_summary": "Stores a 128-<a href=\"../../armv8-a/bit/\">bit</a> vector to memory. Address must be 16-byte aligned.",
      "linked_pseudocode": "EA <- (RA + RB) & 0xFFFFFFF0; MEM(EA, 16) <- vS"
    },
    {
      "mnemonic": "vsubuwm",
      "architecture": "PowerISA",
      "full_name": "Vector Subtract Unsigned Word Modulo",
      "summary": "Subtracts four 32-bit integers in parallel.",
      "syntax": "vsubuwm vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 1152",
        "hex_opcode": "0x10000480",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1152",
            "clean": "1152"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Source A"
        },
        {
          "name": "vB",
          "desc": "Source B"
        }
      ],
      "pseudocode": "For i=0 to 3: vD.word[i] <- vA.word[i] - vB.word[i]",
      "example": "vsubuwm v1, v2, v3",
      "example_note": "4 parallel word subtractions.",
      "extension": "VMX (AltiVec)",
      "pseudocode_html": "<pre><code class=\"language-clike\">For i=0 to 3: vD.word[i] &lt;- vA.word[i] - vB.word[i]</code></pre>",
      "slug": "vsubuwm",
      "rel_url": "powerisa/vsubuwm/",
      "linked_summary": "Subtracts four 32-<a href=\"../../armv8-a/bit/\">bit</a> integers <a href=\"../../x86/in/\">in</a> parallel.",
      "linked_pseudocode": "For i=0 to 3: vD.word[i] <- vA.word[i] - vB.word[i]"
    },
    {
      "mnemonic": "vmulouw",
      "architecture": "PowerISA",
      "full_name": "Vector Multiply Odd Unsigned Word",
      "summary": "Multiplies the 1st and 3rd words of the source vectors to produce two 64-bit results.",
      "syntax": "vmulouw vD, vA, vB",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | 128",
        "hex_opcode": "0x10000080",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "128",
            "clean": "128"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Source A"
        },
        {
          "name": "vB",
          "desc": "Source B"
        }
      ],
      "pseudocode": "vD.dword[0] <- vA.word[1] * vB.word[1]; vD.dword[1] <- vA.word[3] * vB.word[3]",
      "example": "vmulouw v1, v2, v3",
      "example_note": "Widening multiply (32x32->64).",
      "extension": "VMX (AltiVec)",
      "pseudocode_html": "<pre><code class=\"language-clike\">vD.dword[0] &lt;- vA.word[1] * vB.word[1]; vD.dword[1] &lt;- vA.word[3] * vB.word[3]</code></pre>",
      "slug": "vmulouw_1",
      "rel_url": "powerisa/vmulouw_1/",
      "linked_summary": "Multiplies the 1st <a href=\"../../armv8-a/and_6/\">and</a> 3rd words of the source vectors to produce two 64-<a href=\"../../armv8-a/bit/\">bit</a> results.",
      "linked_pseudocode": "vD.dword[0] <- vA.word[1] * vB.word[1]; vD.dword[1] <- vA.word[3] * vB.word[3]"
    },
    {
      "mnemonic": "vspltw",
      "architecture": "PowerISA",
      "full_name": "Vector Splat Word",
      "summary": "Copies a single word element from the source vector into all four word elements of the destination.",
      "syntax": "vspltw vD, vB, UIM",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | UIM | vB | 652",
        "hex_opcode": "0x1000028C",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "652",
            "clean": "652"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        },
        {
          "name": "UIM",
          "desc": "Element Index (0-3)"
        }
      ],
      "pseudocode": "vD.word[0..3] <- vB.word[UIM]",
      "example": "vspltw v1, v2, 0",
      "example_note": "Broadcast word 0 to all lanes.",
      "extension": "VMX (AltiVec)",
      "pseudocode_html": "<pre><code class=\"language-clike\">vD.word[0..3] &lt;- vB.word[UIM]</code></pre>",
      "slug": "vspltw",
      "rel_url": "powerisa/vspltw/",
      "linked_summary": "Copies a single word element from the source vector into all four word elements of the destination.",
      "linked_pseudocode": "vD.word[0..3] <- vB.word[UIM]"
    },
    {
      "mnemonic": "vperm",
      "architecture": "PowerISA",
      "full_name": "Vector Permute",
      "summary": "The signature AltiVec instruction. Constructs a new vector by selecting bytes from two source vectors based on a permute control vector.",
      "syntax": "vperm vD, vA, vB, vC",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | vC | 43",
        "hex_opcode": "0x1000002B",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "vC",
            "clean": "vC"
          },
          {
            "raw": "43",
            "clean": "43"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Source 1 (Bytes 0-15)"
        },
        {
          "name": "vB",
          "desc": "Source 2 (Bytes 16-31)"
        },
        {
          "name": "vC",
          "desc": "Control Vector"
        }
      ],
      "pseudocode": "For i=0 to 15: index = vC.byte[i] & 0x1F; vD.byte[i] <- (vA || vB).byte[index]",
      "example": "vperm v1, v2, v3, v4",
      "example_note": "Arbitrary byte shuffle/merge.",
      "extension": "VMX (AltiVec)",
      "pseudocode_html": "<pre><code class=\"language-clike\">For i=0 to 15: index = vC.byte[i] &amp; 0x1F; vD.byte[i] &lt;- (vA || vB).byte[index]</code></pre>",
      "slug": "vperm",
      "rel_url": "powerisa/vperm/",
      "linked_summary": "The signature AltiVec instruction. Constructs a new vector by selecting bytes from two source vectors based on a permute control vector.",
      "linked_pseudocode": "For i=0 to 15: <a href=\"../../armv8-a/index/\">index</a> = vC.byte[i] & 0x1F; vD.byte[i] <- (vA || vB).byte[<a href=\"../../armv8-a/index/\">index</a>]"
    },
    {
      "mnemonic": "vslw",
      "architecture": "PowerISA",
      "full_name": "Vector Shift Left Word",
      "summary": "Shifts each of the four words in vA left by the number of bits specified in the corresponding word of vB.",
      "syntax": "vslw vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 388",
        "hex_opcode": "0x10000184",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "388",
            "clean": "388"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Source Data"
        },
        {
          "name": "vB",
          "desc": "Shift Amounts"
        }
      ],
      "pseudocode": "vD.word[i] <- vA.word[i] << (vB.word[i] & 7)",
      "example": "vslw v1, v2, v3",
      "example_note": "Parallel shift.",
      "extension": "VMX (AltiVec)",
      "pseudocode_html": "<pre><code class=\"language-clike\">vD.word[i] &lt;- vA.word[i] &lt;&lt; (vB.word[i] &amp; 7)</code></pre>",
      "slug": "vslw",
      "rel_url": "powerisa/vslw/",
      "linked_summary": "Shifts each of the four words <a href=\"../../x86/in/\">in</a> vA left by the number of bits specified <a href=\"../../x86/in/\">in</a> the corresponding word of vB.",
      "linked_pseudocode": "vD.word[i] <- vA.word[i] << (vB.word[i] & 7)"
    },
    {
      "mnemonic": "vcmpequw",
      "architecture": "PowerISA",
      "full_name": "Vector Compare Equal Word",
      "summary": "Compares words for equality. Sets result bits to all 1s (True) or all 0s (False).",
      "syntax": "vcmpequw vD, vA, vB",
      "encoding": {
        "format": "VC-form",
        "binary_pattern": "4 | vD | vA | vB | 134",
        "hex_opcode": "0x10000086",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "134",
            "clean": "134"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target (Mask)"
        },
        {
          "name": "vA",
          "desc": "Source A"
        },
        {
          "name": "vB",
          "desc": "Source B"
        }
      ],
      "pseudocode": "vD.word[i] <- (vA.word[i] == vB.word[i]) ? 0xFFFFFFFF : 0x00000000",
      "example": "vcmpequw v1, v2, v3",
      "example_note": "Generate mask for equality.",
      "extension": "VMX (AltiVec)",
      "pseudocode_html": "<pre><code class=\"language-clike\">vD.word[i] &lt;- (vA.word[i] == vB.word[i]) ? 0xFFFFFFFF : 0x00000000</code></pre>",
      "slug": "vcmpequw",
      "rel_url": "powerisa/vcmpequw/",
      "linked_summary": "Compares words for equality. Sets result bits to all 1s (True) <a href=\"../../powerisa/or/\">or</a> all 0s (False).",
      "linked_pseudocode": "vD.word[i] <- (vA.word[i] == vB.word[i]) ? 0xFFFFFFFF : 0x00000000"
    },
    {
      "mnemonic": "vsel",
      "architecture": "PowerISA",
      "full_name": "Vector Select",
      "summary": "Bitwise selection. copies bits from vA if the corresponding bit in vC is 0, or from vB if vC is 1. (Like 'mux').",
      "syntax": "vsel vD, vA, vB, vC",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | vC | 42",
        "hex_opcode": "0x1000002A",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "vC",
            "clean": "vC"
          },
          {
            "raw": "42",
            "clean": "42"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Source 0"
        },
        {
          "name": "vB",
          "desc": "Source 1"
        },
        {
          "name": "vC",
          "desc": "Control (Selector)"
        }
      ],
      "pseudocode": "vD <- (vA & ~vC) | (vB & vC)",
      "example": "vsel v1, v2, v3, v4",
      "example_note": "Bitwise MUX.",
      "extension": "VMX (AltiVec)",
      "pseudocode_html": "<pre><code class=\"language-clike\">vD &lt;- (vA &amp; ~vC) | (vB &amp; vC)</code></pre>",
      "slug": "vsel",
      "rel_url": "powerisa/vsel/",
      "linked_summary": "Bitwise selection. copies bits from vA if the corresponding <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> vC is 0, <a href=\"../../powerisa/or/\">or</a> from vB if vC is 1. (Like 'mux').",
      "linked_pseudocode": "vD <- (vA & ~vC) | (vB & vC)"
    },
    {
      "mnemonic": "lxvd2x",
      "architecture": "PowerISA",
      "full_name": "Load VSX Vector Doubleword*2 Indexed",
      "summary": "Loads a 128-bit vector from memory into a VSX register. Does NOT require 16-byte alignment (unlike lvx).",
      "syntax": "lxvd2x XT, RA, RB",
      "encoding": {
        "format": "XX1-form",
        "binary_pattern": "31 | XT | RA | RB | 844 | 1",
        "hex_opcode": "0x7C00034D",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "844",
            "clean": "844"
          },
          {
            "raw": "1",
            "clean": "1"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target VSR (0-63)"
        },
        {
          "name": "RA",
          "desc": "Base Register"
        },
        {
          "name": "RB",
          "desc": "Index Register"
        }
      ],
      "pseudocode": "XT <- MEM(RA + RB, 16)",
      "example": "lxvd2x 32, r3, r4",
      "example_note": "Unaligned 128-bit load to vs32 (v0).",
      "extension": "VSX",
      "pseudocode_html": "<pre><code class=\"language-clike\">XT &lt;- MEM(RA + RB, 16)</code></pre>",
      "slug": "lxvd2x",
      "rel_url": "powerisa/lxvd2x/",
      "linked_summary": "Loads a 128-<a href=\"../../armv8-a/bit/\">bit</a> vector from memory into a VSX register. Does <a href=\"../../risc-v/not/\">NOT</a> require 16-byte alignment (unlike <a href=\"../../powerisa/lvx/\">lvx</a>).",
      "linked_pseudocode": "XT <- MEM(RA + RB, 16)"
    },
    {
      "mnemonic": "stxvd2x",
      "architecture": "PowerISA",
      "full_name": "Store VSX Vector Doubleword*2 Indexed",
      "summary": "Stores a 128-bit VSX register to memory. Does NOT require alignment.",
      "syntax": "stxvd2x XS, RA, RB",
      "encoding": {
        "format": "XX1-form",
        "binary_pattern": "31 | XS | RA | RB | 972 | 1",
        "hex_opcode": "0x7C0003CD",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "XS",
            "clean": "XS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "972",
            "clean": "972"
          },
          {
            "raw": "1",
            "clean": "1"
          }
        ]
      },
      "operands": [
        {
          "name": "XS",
          "desc": "Source VSR"
        },
        {
          "name": "RA",
          "desc": "Base Register"
        },
        {
          "name": "RB",
          "desc": "Index Register"
        }
      ],
      "pseudocode": "MEM(RA + RB, 16) <- XS",
      "example": "stxvd2x 32, r3, r4",
      "example_note": "Unaligned 128-bit store.",
      "extension": "VSX",
      "pseudocode_html": "<pre><code class=\"language-clike\">MEM(RA + RB, 16) &lt;- XS</code></pre>",
      "slug": "stxvd2x",
      "rel_url": "powerisa/stxvd2x/",
      "linked_summary": "Stores a 128-<a href=\"../../armv8-a/bit/\">bit</a> VSX register to memory. Does <a href=\"../../risc-v/not/\">NOT</a> require alignment.",
      "linked_pseudocode": "MEM(RA + RB, 16) <- XS"
    },
    {
      "mnemonic": "xvadddp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Add Double-Precision",
      "summary": "Adds two pairs of double-precision floating-point numbers.",
      "syntax": "xvadddp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 96",
        "hex_opcode": "0xF0000060",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "96",
            "clean": "96"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Source A"
        },
        {
          "name": "XB",
          "desc": "Source B"
        }
      ],
      "pseudocode": "XT.double[0] <- XA[0] + XB[0]; XT.double[1] <- XA[1] + XB[1]",
      "example": "xvadddp 0, 1, 2",
      "example_note": "2-way parallel double add.",
      "extension": "VSX",
      "pseudocode_html": "<pre><code class=\"language-clike\">XT.double[0] &lt;- XA[0] + XB[0]; XT.double[1] &lt;- XA[1] + XB[1]</code></pre>",
      "slug": "xvadddp",
      "rel_url": "powerisa/xvadddp/",
      "linked_summary": "Adds two pairs of double-precision floating-point numbers.",
      "linked_pseudocode": "XT.double[0] <- XA[0] + XB[0]; XT.double[1] <- XA[1] + XB[1]"
    },
    {
      "mnemonic": "xvmaddadp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Multiply-Add Double-Precision",
      "summary": "Performs (A * B) + T on vectors of doubles.",
      "syntax": "xvmaddadp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 104",
        "hex_opcode": "0xF0000068",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "104",
            "clean": "104"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target/Addend (Accumulator)"
        },
        {
          "name": "XA",
          "desc": "Multiplier"
        },
        {
          "name": "XB",
          "desc": "Multiplicand"
        }
      ],
      "pseudocode": "XT <- (XA * XB) + XT",
      "example": "xvmaddadp 0, 1, 2",
      "example_note": "Vector FMA.",
      "extension": "VSX",
      "pseudocode_html": "<pre><code class=\"language-clike\">XT &lt;- (XA * XB) + XT</code></pre>",
      "slug": "xvmaddadp",
      "rel_url": "powerisa/xvmaddadp/",
      "linked_summary": "Performs (A * B) + T on vectors of doubles.",
      "linked_pseudocode": "XT <- (XA * XB) + XT"
    },
    {
      "mnemonic": "xxpermdi",
      "architecture": "PowerISA",
      "full_name": "VSX Permute Doubleword Immediate",
      "summary": "Selects two doublewords from the four available in source registers XA and XB based on a 2-bit selector.",
      "syntax": "xxpermdi XT, XA, XB, DM",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 10 | DM",
        "hex_opcode": "0xF000000A",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "10",
            "clean": "10"
          },
          {
            "raw": "DM",
            "clean": "DM"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Source A"
        },
        {
          "name": "XB",
          "desc": "Source B"
        },
        {
          "name": "DM",
          "desc": "Selector (2 bits)"
        }
      ],
      "pseudocode": "Select doublewords from A and B into T.",
      "example": "xxpermdi 0, 1, 1, 2",
      "example_note": "Swap high/low doublewords of vs1.",
      "extension": "VSX",
      "pseudocode_html": "<pre><code class=\"language-clike\">Select doublewords from A and B into T.</code></pre>",
      "slug": "xxpermdi",
      "rel_url": "powerisa/xxpermdi/",
      "linked_summary": "Selects two doublewords from the four available <a href=\"../../x86/in/\">in</a> source registers XA <a href=\"../../armv8-a/and_6/\">and</a> XB based on a 2-<a href=\"../../armv8-a/bit/\">bit</a> selector.",
      "linked_pseudocode": "Select doublewords from A <a href=\"../../armv8-a/and_6/\">and</a> B into T."
    },
    {
      "mnemonic": "xsadddp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Add Double-Precision",
      "summary": "Adds the low doubleword of two VSX registers (scalar operation). The high doublewords are undefined or zeroed.",
      "syntax": "xsadddp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 32",
        "hex_opcode": "0xF0000020",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "32",
            "clean": "32"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Source A"
        },
        {
          "name": "XB",
          "desc": "Source B"
        }
      ],
      "pseudocode": "XT[0:63] <- XA[0:63] + XB[0:63]",
      "example": "xsadddp 0, 1, 2",
      "example_note": "Scalar float add using Vector unit.",
      "extension": "VSX",
      "pseudocode_html": "<pre><code class=\"language-clike\">XT[0:63] &lt;- XA[0:63] + XB[0:63]</code></pre>",
      "slug": "xsadddp",
      "rel_url": "powerisa/xsadddp/",
      "linked_summary": "Adds the low doubleword of two VSX registers (scalar operation). The high doublewords are undefined <a href=\"../../powerisa/or/\">or</a> zeroed.",
      "linked_pseudocode": "XT[0:63] <- XA[0:63] + XB[0:63]"
    },
    {
      "mnemonic": "dsub",
      "architecture": "PowerISA",
      "full_name": "Decimal Subtract",
      "summary": "Subtracts two 64-bit Decimal Floating Point numbers.",
      "syntax": "dsub FRT, FRA, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "59 | FRT | FRA | FRB | 514 | /",
        "hex_opcode": "0xEC000404",
        "visual_parts": [
          {
            "raw": "59",
            "clean": "59"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "FRA",
            "clean": "FRA"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "514",
            "clean": "514"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRA",
          "desc": "Src A"
        },
        {
          "name": "FRB",
          "desc": "Src B"
        }
      ],
      "extension": "Decimal Float",
      "slug": "dsub",
      "rel_url": "powerisa/dsub/",
      "linked_summary": "Subtracts two 64-<a href=\"../../armv8-a/bit/\">bit</a> Decimal Floating Point numbers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ddiv",
      "architecture": "PowerISA",
      "full_name": "Decimal Divide",
      "summary": "Divides two 64-bit Decimal Floating Point numbers.",
      "syntax": "ddiv FRT, FRA, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "59 | FRT | FRA | FRB | 546 | /",
        "hex_opcode": "0xEC000444",
        "visual_parts": [
          {
            "raw": "59",
            "clean": "59"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "FRA",
            "clean": "FRA"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "546",
            "clean": "546"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRA",
          "desc": "Src A"
        },
        {
          "name": "FRB",
          "desc": "Src B"
        }
      ],
      "extension": "Decimal Float",
      "slug": "ddiv",
      "rel_url": "powerisa/ddiv/",
      "linked_summary": "Divides two 64-<a href=\"../../armv8-a/bit/\">bit</a> Decimal Floating Point numbers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dcmpu",
      "architecture": "PowerISA",
      "full_name": "Decimal Compare Unordered",
      "summary": "Compares two DFP numbers (Non-signaling on NaN).",
      "syntax": "dcmpu BF, FRA, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "59 | BF | / | FRA | FRB | 642 | /",
        "hex_opcode": "0xEC000504",
        "visual_parts": [
          {
            "raw": "59",
            "clean": "59"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "FRA",
            "clean": "FRA"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "642",
            "clean": "642"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "FRA",
          "desc": "Src A"
        },
        {
          "name": "FRB",
          "desc": "Src B"
        }
      ],
      "extension": "Decimal Float",
      "slug": "dcmpu",
      "rel_url": "powerisa/dcmpu/",
      "linked_summary": "Compares two DFP numbers (Non-signaling on NaN).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dcmpo",
      "architecture": "PowerISA",
      "full_name": "Decimal Compare Ordered",
      "summary": "Compares two DFP numbers (Signaling on NaN).",
      "syntax": "dcmpo BF, FRA, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "59 | BF | / | FRA | FRB | 130 | /",
        "hex_opcode": "0xEC000104",
        "visual_parts": [
          {
            "raw": "59",
            "clean": "59"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "FRA",
            "clean": "FRA"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "130",
            "clean": "130"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "FRA",
          "desc": "Src A"
        },
        {
          "name": "FRB",
          "desc": "Src B"
        }
      ],
      "extension": "Decimal Float",
      "slug": "dcmpo",
      "rel_url": "powerisa/dcmpo/",
      "linked_summary": "Compares two DFP numbers (Signaling on NaN).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dctdp",
      "architecture": "PowerISA",
      "full_name": "Decimal Convert To DFP Long",
      "summary": "Converts DFP Short (32-bit compressed) to DFP Long (64-bit).",
      "syntax": "dctdp FRT, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "59 | FRT | 0 | FRB | 258 | /",
        "hex_opcode": "0xEC000204",
        "visual_parts": [
          {
            "raw": "59",
            "clean": "59"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "258",
            "clean": "258"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRB",
          "desc": "Source"
        }
      ],
      "extension": "Decimal Float",
      "slug": "dctdp",
      "rel_url": "powerisa/dctdp/",
      "linked_summary": "Converts DFP Short (32-<a href=\"../../armv8-a/bit/\">bit</a> compressed) to DFP Long (64-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "drsp",
      "architecture": "PowerISA",
      "full_name": "Decimal Round To DFP Short",
      "summary": "Rounds DFP Long (64-bit) to DFP Short (32-bit compressed).",
      "syntax": "drsp FRT, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "59 | FRT | 0 | FRB | 770 | /",
        "hex_opcode": "0xEC000604",
        "visual_parts": [
          {
            "raw": "59",
            "clean": "59"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "770",
            "clean": "770"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRB",
          "desc": "Source"
        }
      ],
      "extension": "Decimal Float",
      "slug": "drsp",
      "rel_url": "powerisa/drsp/",
      "linked_summary": "Rounds DFP Long (64-<a href=\"../../armv8-a/bit/\">bit</a>) to DFP Short (32-<a href=\"../../armv8-a/bit/\">bit</a> compressed).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dcffix",
      "architecture": "PowerISA",
      "full_name": "Decimal Convert From Fixed",
      "summary": "Converts a 64-bit integer to DFP.",
      "syntax": "dcffix FRT, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "59 | FRT | 0 | FRB | 802 | /",
        "hex_opcode": "0xEC000644",
        "visual_parts": [
          {
            "raw": "59",
            "clean": "59"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "802",
            "clean": "802"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRB",
          "desc": "Source"
        }
      ],
      "extension": "Decimal Float",
      "slug": "dcffix",
      "rel_url": "powerisa/dcffix/",
      "linked_summary": "Converts a 64-<a href=\"../../armv8-a/bit/\">bit</a> integer to DFP.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dctfix",
      "architecture": "PowerISA",
      "full_name": "Decimal Convert To Fixed",
      "summary": "Converts DFP to a 64-bit integer.",
      "syntax": "dctfix FRT, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "59 | FRT | 0 | FRB | 290 | /",
        "hex_opcode": "0xEC000244",
        "visual_parts": [
          {
            "raw": "59",
            "clean": "59"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "290",
            "clean": "290"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRB",
          "desc": "Source"
        }
      ],
      "extension": "Decimal Float",
      "slug": "dctfix",
      "rel_url": "powerisa/dctfix/",
      "linked_summary": "Converts DFP to a 64-<a href=\"../../armv8-a/bit/\">bit</a> integer.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "denbcd",
      "architecture": "PowerISA",
      "full_name": "Decimal Encode BCD",
      "summary": "Encodes a DFP number into BCD format.",
      "syntax": "denbcd FRT, FRB, S",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "59 | FRT | S | FRB | 834 | /",
        "hex_opcode": "0xEC000684",
        "visual_parts": [
          {
            "raw": "59",
            "clean": "59"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "S",
            "clean": "S"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "834",
            "clean": "834"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRB",
          "desc": "Source"
        },
        {
          "name": "S",
          "desc": "Sign Control"
        }
      ],
      "extension": "Decimal Float",
      "slug": "denbcd",
      "rel_url": "powerisa/denbcd/",
      "linked_summary": "Encodes a DFP number into BCD format.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ddedpd",
      "architecture": "PowerISA",
      "full_name": "Decimal Decode DPD",
      "summary": "Decodes BCD to DFP format.",
      "syntax": "ddedpd FRT, FRB, SP",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "59 | FRT | SP | FRB | 322 | /",
        "hex_opcode": "0xEC000284",
        "visual_parts": [
          {
            "raw": "59",
            "clean": "59"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "SP",
            "clean": "SP"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "322",
            "clean": "322"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRB",
          "desc": "Source"
        },
        {
          "name": "SP",
          "desc": "Sign Control"
        }
      ],
      "extension": "Decimal Float",
      "slug": "ddedpd",
      "rel_url": "powerisa/ddedpd/",
      "linked_summary": "Decodes BCD to DFP format.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "diex",
      "architecture": "PowerISA",
      "full_name": "Decimal Insert Exponent",
      "summary": "Combines a sign/coefficient from FRA and exponent from FRB.",
      "syntax": "diex FRT, FRA, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "59 | FRT | FRA | FRB | 866 | /",
        "hex_opcode": "0xEC0006C4",
        "visual_parts": [
          {
            "raw": "59",
            "clean": "59"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "FRA",
            "clean": "FRA"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "866",
            "clean": "866"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRA",
          "desc": "Coeff Source"
        },
        {
          "name": "FRB",
          "desc": "Exp Source"
        }
      ],
      "extension": "Decimal Float",
      "slug": "diex",
      "rel_url": "powerisa/diex/",
      "linked_summary": "Combines a sign/coefficient from FRA <a href=\"../../armv8-a/and_6/\">and</a> exponent from FRB.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dxex",
      "architecture": "PowerISA",
      "full_name": "Decimal Extract Exponent",
      "summary": "Extracts the exponent from a DFP number.",
      "syntax": "dxex FRT, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "59 | FRT | 0 | FRB | 354 | /",
        "hex_opcode": "0xEC0002C4",
        "visual_parts": [
          {
            "raw": "59",
            "clean": "59"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "354",
            "clean": "354"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRB",
          "desc": "Source"
        }
      ],
      "extension": "Decimal Float",
      "slug": "dxex",
      "rel_url": "powerisa/dxex/",
      "linked_summary": "Extracts the exponent from a DFP number.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dscli",
      "architecture": "PowerISA",
      "full_name": "Decimal Shift Coefficient Left Immediate",
      "summary": "Shifts the coefficient of a DFP number left.",
      "syntax": "dscli FRT, FRA, SH",
      "encoding": {
        "format": "Z23-form",
        "binary_pattern": "59 | FRT | FRA | SH | 66 | /",
        "hex_opcode": "0xEC000084",
        "visual_parts": [
          {
            "raw": "59",
            "clean": "59"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "FRA",
            "clean": "FRA"
          },
          {
            "raw": "SH",
            "clean": "SH"
          },
          {
            "raw": "66",
            "clean": "66"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRA",
          "desc": "Source"
        },
        {
          "name": "SH",
          "desc": "Shift Amount"
        }
      ],
      "extension": "Decimal Float",
      "slug": "dscli",
      "rel_url": "powerisa/dscli/",
      "linked_summary": "Shifts the coefficient of a DFP number left.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dsri",
      "architecture": "PowerISA",
      "full_name": "Decimal Shift Coefficient Right Immediate",
      "summary": "Shifts the coefficient of a DFP number right.",
      "syntax": "dsri FRT, FRA, SH",
      "encoding": {
        "format": "Z23-form",
        "binary_pattern": "59 | FRT | FRA | SH | 98 | /",
        "hex_opcode": "0xEC0000C4",
        "visual_parts": [
          {
            "raw": "59",
            "clean": "59"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "FRA",
            "clean": "FRA"
          },
          {
            "raw": "SH",
            "clean": "SH"
          },
          {
            "raw": "98",
            "clean": "98"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target"
        },
        {
          "name": "FRA",
          "desc": "Source"
        },
        {
          "name": "SH",
          "desc": "Shift Amount"
        }
      ],
      "extension": "Decimal Float",
      "slug": "dsri",
      "rel_url": "powerisa/dsri/",
      "linked_summary": "Shifts the coefficient of a DFP number right.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xssubqp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Subtract Quad-Precision",
      "summary": "Subtracts two 128-bit Quad-Precision floats.",
      "syntax": "xssubqp vD, vA, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | vA | vB | 516 | /",
        "hex_opcode": "0xFC000404",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "516",
            "clean": "516"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX (Quad)",
      "slug": "xssubqp",
      "rel_url": "powerisa/xssubqp/",
      "linked_summary": "Subtracts two 128-<a href=\"../../armv8-a/bit/\">bit</a> Quad-Precision floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsdivqp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Divide Quad-Precision",
      "summary": "Divides two 128-bit Quad-Precision floats.",
      "syntax": "xsdivqp vD, vA, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | vA | vB | 548 | /",
        "hex_opcode": "0xFC000444",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "548",
            "clean": "548"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX (Quad)",
      "slug": "xsdivqp",
      "rel_url": "powerisa/xsdivqp/",
      "linked_summary": "Divides two 128-<a href=\"../../armv8-a/bit/\">bit</a> Quad-Precision floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xssqrtqp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Square Root Quad-Precision",
      "summary": "Computes square root of a 128-bit Quad-Precision float.",
      "syntax": "xssqrtqp vD, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | 0 | vB | 676 | /",
        "hex_opcode": "0xFC000544",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "676",
            "clean": "676"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VSX (Quad)",
      "slug": "xssqrtqp",
      "rel_url": "powerisa/xssqrtqp/",
      "linked_summary": "Computes square root of a 128-<a href=\"../../armv8-a/bit/\">bit</a> Quad-Precision float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xscmpuqp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Compare Unordered Quad-Precision",
      "summary": "Compares Quad floats (Non-signaling on NaN).",
      "syntax": "xscmpuqp BF, vA, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | BF | / | vA | vB | 644 | /",
        "hex_opcode": "0xFC000504",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "644",
            "clean": "644"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX (Quad)",
      "slug": "xscmpuqp",
      "rel_url": "powerisa/xscmpuqp/",
      "linked_summary": "Compares Quad floats (Non-signaling on NaN).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xscmpopoqp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Compare Ordered Quad-Precision",
      "summary": "Compares Quad floats (Signaling on NaN).",
      "syntax": "xscmpopoqp BF, vA, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | BF | / | vA | vB | 132 | /",
        "hex_opcode": "0xFC000104",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "132",
            "clean": "132"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX (Quad)",
      "slug": "xscmpopoqp",
      "rel_url": "powerisa/xscmpopoqp/",
      "linked_summary": "Compares Quad floats (Signaling on NaN).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsnegqp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Negate Quad-Precision",
      "summary": "Negates a 128-bit Quad float.",
      "syntax": "xsnegqp vD, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | 0 | vB | 804 | /",
        "hex_opcode": "0xFC000644",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "804",
            "clean": "804"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VSX (Quad)",
      "slug": "xsnegqp",
      "rel_url": "powerisa/xsnegqp/",
      "linked_summary": "Negates a 128-<a href=\"../../armv8-a/bit/\">bit</a> Quad float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsabsqp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Absolute Quad-Precision",
      "summary": "Computes absolute value of a Quad float.",
      "syntax": "xsabsqp vD, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | 0 | vB | 772 | /",
        "hex_opcode": "0xFC000604",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "772",
            "clean": "772"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VSX (Quad)",
      "slug": "xsabsqp",
      "rel_url": "powerisa/xsabsqp/",
      "linked_summary": "Computes absolute value of a Quad float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsmaxqp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Maximum Quad-Precision",
      "summary": "Selects maximum of two Quad floats.",
      "syntax": "xsmaxqp vD, vA, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | vA | vB | 836 | /",
        "hex_opcode": "0xFC000684",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "836",
            "clean": "836"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX (Quad)",
      "slug": "xsmaxqp",
      "rel_url": "powerisa/xsmaxqp/",
      "linked_summary": "Selects maximum of two Quad floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsminqp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Minimum Quad-Precision",
      "summary": "Selects minimum of two Quad floats.",
      "syntax": "xsminqp vD, vA, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | vA | vB | 868 | /",
        "hex_opcode": "0xFC0006C4",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "868",
            "clean": "868"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX (Quad)",
      "slug": "xsminqp",
      "rel_url": "powerisa/xsminqp/",
      "linked_summary": "Selects minimum of two Quad floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxinsertw",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Insert Word",
      "summary": "Inserts a 32-bit word from a GPR into a specific element of a VSR.",
      "syntax": "xxinsertw XT, RB, UIM",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | UIM | RB | 181",
        "hex_opcode": "0xF00000B5",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "181",
            "clean": "181"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target VSR"
        },
        {
          "name": "RB",
          "desc": "Source GPR"
        },
        {
          "name": "UIM",
          "desc": "Element Index"
        }
      ],
      "extension": "VSX",
      "slug": "xxinsertw",
      "rel_url": "powerisa/xxinsertw/",
      "linked_summary": "Inserts a 32-<a href=\"../../armv8-a/bit/\">bit</a> word from a GPR into a specific element of a VSR.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxextractuw",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Extract Unsigned Word",
      "summary": "Extracts a 32-bit word from a VSR into a GPR.",
      "syntax": "xxextractuw RT, XS, UIM",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XS | UIM | RT | 165",
        "hex_opcode": "0xF00000A5",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XS",
            "clean": "XS"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "165",
            "clean": "165"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target GPR"
        },
        {
          "name": "XS",
          "desc": "Source VSR"
        },
        {
          "name": "UIM",
          "desc": "Element Index"
        }
      ],
      "extension": "VSX",
      "slug": "xxextractuw",
      "rel_url": "powerisa/xxextractuw/",
      "linked_summary": "Extracts a 32-<a href=\"../../armv8-a/bit/\">bit</a> word from a VSR into a GPR.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxspltw",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Splat Word",
      "summary": "Replicates one word element across the entire vector.",
      "syntax": "xxspltw XT, XS, UIM",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | UIM | XS | 164",
        "hex_opcode": "0xF00000A4",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "UIM",
            "clean": "UIM"
          },
          {
            "raw": "XS",
            "clean": "XS"
          },
          {
            "raw": "164",
            "clean": "164"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XS",
          "desc": "Source"
        },
        {
          "name": "UIM",
          "desc": "Index"
        }
      ],
      "extension": "VSX",
      "slug": "xxspltw",
      "rel_url": "powerisa/xxspltw/",
      "linked_summary": "Replicates one word element across the entire vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lmw",
      "architecture": "PowerISA",
      "full_name": "Load Multiple Word",
      "summary": "Loads words from memory into registers RT through R31 (Context Switch).",
      "syntax": "lmw RT, D(RA)",
      "encoding": {
        "format": "D-form",
        "binary_pattern": "46 | RT | RA | D",
        "hex_opcode": "0xB8000000",
        "visual_parts": [
          {
            "raw": "46",
            "clean": "46"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D",
            "clean": "D"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Start Register"
        },
        {
          "name": "D",
          "desc": "Displacement"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "Base (Legacy)",
      "slug": "lmw",
      "rel_url": "powerisa/lmw/",
      "linked_summary": "Loads words from memory into registers RT through R31 (Context Switch).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stmw",
      "architecture": "PowerISA",
      "full_name": "Store Multiple Word",
      "summary": "Stores words from registers RT through R31 to memory (Context Switch).",
      "syntax": "stmw RT, D(RA)",
      "encoding": {
        "format": "D-form",
        "binary_pattern": "47 | RT | RA | D",
        "hex_opcode": "0xBC000000",
        "visual_parts": [
          {
            "raw": "47",
            "clean": "47"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "D",
            "clean": "D"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Start Register"
        },
        {
          "name": "D",
          "desc": "Displacement"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "Base (Legacy)",
      "slug": "stmw",
      "rel_url": "powerisa/stmw/",
      "linked_summary": "Stores words from registers RT through R31 to memory (Context Switch).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lswi",
      "architecture": "PowerISA",
      "full_name": "Load String Word Immediate",
      "summary": "Loads N bytes from memory into registers.",
      "syntax": "lswi RT, RA, NB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | RA | NB | 597 | /",
        "hex_opcode": "0x7C0004A5",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "NB",
            "clean": "NB"
          },
          {
            "raw": "597",
            "clean": "597"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Start Register"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "NB",
          "desc": "Byte Count"
        }
      ],
      "extension": "Base (Legacy)",
      "slug": "lswi",
      "rel_url": "powerisa/lswi/",
      "linked_summary": "Loads N bytes from memory into registers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stswi",
      "architecture": "PowerISA",
      "full_name": "Store String Word Immediate",
      "summary": "Stores N bytes from registers to memory.",
      "syntax": "stswi RT, RA, NB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | RA | NB | 725 | /",
        "hex_opcode": "0x7C0005A5",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "NB",
            "clean": "NB"
          },
          {
            "raw": "725",
            "clean": "725"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Start Register"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "NB",
          "desc": "Byte Count"
        }
      ],
      "extension": "Base (Legacy)",
      "slug": "stswi",
      "rel_url": "powerisa/stswi/",
      "linked_summary": "Stores N bytes from registers to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "slbia",
      "architecture": "PowerISA",
      "full_name": "SLB Invalidate All",
      "summary": "Invalidates all Segment Lookaside Buffer entries (OS Management).",
      "syntax": "slbia IH",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | / | IH | 498 | /",
        "hex_opcode": "0x7C0003E4",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "IH",
            "clean": "IH"
          },
          {
            "raw": "498",
            "clean": "498"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "IH",
          "desc": "Hint"
        }
      ],
      "extension": "Privileged",
      "slug": "slbia",
      "rel_url": "powerisa/slbia/",
      "linked_summary": "Invalidates all Segment Lookaside Buffer entries (OS Management).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "slbmte",
      "architecture": "PowerISA",
      "full_name": "SLB Move To Entry",
      "summary": "Writes an SLB entry (Mapping effective to virtual address).",
      "syntax": "slbmte RS, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | / | RB | 402 | /",
        "hex_opcode": "0x7C000324",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "402",
            "clean": "402"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source VSID"
        },
        {
          "name": "RB",
          "desc": "Effective Addr"
        }
      ],
      "extension": "Privileged",
      "slug": "slbmte",
      "rel_url": "powerisa/slbmte/",
      "linked_summary": "Writes an SLB entry (Mapping effective to virtual address).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "msgclr",
      "architecture": "PowerISA",
      "full_name": "Message Clear",
      "summary": "Clears a pending doorbell interrupt (Inter-processor comms).",
      "syntax": "msgclr RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | / | RB | 118 | /",
        "hex_opcode": "0x7C0000EC",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "118",
            "clean": "118"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RB",
          "desc": "Message Type"
        }
      ],
      "extension": "Privileged",
      "slug": "msgclr",
      "rel_url": "powerisa/msgclr/",
      "linked_summary": "Clears a pending doorbell interrupt (Inter-processor comms).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "msgsnd",
      "architecture": "PowerISA",
      "full_name": "Message Send",
      "summary": "Sends a doorbell interrupt to another processor.",
      "syntax": "msgsnd RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | / | RB | 206 | /",
        "hex_opcode": "0x7C00019C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "206",
            "clean": "206"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RB",
          "desc": "Message Type"
        }
      ],
      "extension": "Privileged",
      "slug": "msgsnd",
      "rel_url": "powerisa/msgsnd/",
      "linked_summary": "Sends a doorbell interrupt to another processor.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "icbt",
      "architecture": "PowerISA",
      "full_name": "Instruction Cache Block Touch",
      "summary": "Prefetches an instruction cache block.",
      "syntax": "icbt RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | RA | RB | 22 | /",
        "hex_opcode": "0x7C00002C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "22",
            "clean": "22"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base",
      "slug": "icbt_1",
      "rel_url": "powerisa/icbt_1/",
      "linked_summary": "Prefetches an instruction cache block.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dcbtst",
      "architecture": "PowerISA",
      "full_name": "Data Cache Block Touch for Store",
      "summary": "Prefetches a cache block signaling intent to modify (RFO - Read For Ownership).",
      "syntax": "dcbtst TH, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | TH | RA | RB | 246 | /",
        "hex_opcode": "0x7C0001EC",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "TH",
            "clean": "TH"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "246",
            "clean": "246"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "TH",
          "desc": "Hint"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base",
      "slug": "dcbtst_1",
      "rel_url": "powerisa/dcbtst_1/",
      "linked_summary": "Prefetches a cache block signaling intent to modify (RFO - Read For Ownership).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "attn",
      "architecture": "PowerISA",
      "full_name": "Attention",
      "summary": "Stops execution and alerts the hardware debugger.",
      "syntax": "attn",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "000000 | 00000 | 00000 | 00000 | 256 | /",
        "hex_opcode": "0x00000200",
        "visual_parts": [
          {
            "raw": "000000",
            "clean": "000000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "256",
            "clean": "256"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [],
      "extension": "Privileged",
      "slug": "attn",
      "rel_url": "powerisa/attn/",
      "linked_summary": "Stops execution <a href=\"../../armv8-a/and_6/\">and</a> alerts the hardware debugger.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "clrbhrb",
      "architecture": "PowerISA",
      "full_name": "Clear Branch History Rolling Buffer",
      "summary": "Clears the hardware branch history buffer (Performance tuning).",
      "syntax": "clrbhrb",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | / | / | 892 | /",
        "hex_opcode": "0x7C0006FC",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "892",
            "clean": "892"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [],
      "extension": "Base",
      "slug": "clrbhrb",
      "rel_url": "powerisa/clrbhrb/",
      "linked_summary": "Clears the hardware branch history buffer (Performance tuning).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tabortwc",
      "architecture": "PowerISA",
      "full_name": "Transaction Abort Word Conditional",
      "summary": "Aborts a transaction if the condition is met (Word comparison).",
      "syntax": "tabortwc TO, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | TO | RA | RB | 782 | 1",
        "hex_opcode": "0x7C00061D",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "TO",
            "clean": "TO"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "782",
            "clean": "782"
          },
          {
            "raw": "1",
            "clean": "1"
          }
        ]
      },
      "operands": [
        {
          "name": "TO",
          "desc": "Options"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "TM (Transactional Memory)",
      "slug": "tabortwc",
      "rel_url": "powerisa/tabortwc/",
      "linked_summary": "Aborts a transaction if the condition is met (Word comparison).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tabortdc",
      "architecture": "PowerISA",
      "full_name": "Transaction Abort Doubleword Conditional",
      "summary": "Aborts a transaction if the condition is met (Doubleword comparison).",
      "syntax": "tabortdc TO, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | TO | RA | RB | 814 | 1",
        "hex_opcode": "0x7C00065D",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "TO",
            "clean": "TO"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "814",
            "clean": "814"
          },
          {
            "raw": "1",
            "clean": "1"
          }
        ]
      },
      "operands": [
        {
          "name": "TO",
          "desc": "Options"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "TM (Transactional Memory)",
      "slug": "tabortdc",
      "rel_url": "powerisa/tabortdc/",
      "linked_summary": "Aborts a transaction if the condition is met (Doubleword comparison).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "trechkpt",
      "architecture": "PowerISA",
      "full_name": "Transaction Recheckpoint",
      "summary": "Updates the transaction checkpoint.",
      "syntax": "trechkpt",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | / | / | 1006 | /",
        "hex_opcode": "0x7C0007DD",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "1006",
            "clean": "1006"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [],
      "extension": "TM (Transactional Memory)",
      "slug": "trechkpt",
      "rel_url": "powerisa/trechkpt/",
      "linked_summary": "Updates the transaction checkpoint.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lxvl",
      "architecture": "PowerISA",
      "full_name": "Load VSX Vector Length",
      "summary": "Loads N bytes into a vector, where N is specified in a GPR.",
      "syntax": "lxvl XT, RA, RB",
      "encoding": {
        "format": "XX1-form",
        "binary_pattern": "31 | XT | RA | RB | 269",
        "hex_opcode": "0x7C00021D",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "269",
            "clean": "269"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Length Reg"
        }
      ],
      "extension": "VSX",
      "slug": "lxvl",
      "rel_url": "powerisa/lxvl/",
      "linked_summary": "Loads N bytes into a vector, where N is specified <a href=\"../../x86/in/\">in</a> a GPR.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stxvl",
      "architecture": "PowerISA",
      "full_name": "Store VSX Vector Length",
      "summary": "Stores N bytes from a vector to memory.",
      "syntax": "stxvl XS, RA, RB",
      "encoding": {
        "format": "XX1-form",
        "binary_pattern": "31 | XS | RA | RB | 397",
        "hex_opcode": "0x7C00031D",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "XS",
            "clean": "XS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "397",
            "clean": "397"
          }
        ]
      },
      "operands": [
        {
          "name": "XS",
          "desc": "Source"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Length Reg"
        }
      ],
      "extension": "VSX",
      "slug": "stxvl",
      "rel_url": "powerisa/stxvl/",
      "linked_summary": "Stores N bytes from a vector to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxperm",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Permute",
      "summary": "General permute for VSX registers.",
      "syntax": "xxperm XT, XA, XB, XC",
      "encoding": {
        "format": "XX4-form",
        "binary_pattern": "60 | XT | XA | XB | XC | 26",
        "hex_opcode": "0xF000001A",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "XC",
            "clean": "XC"
          },
          {
            "raw": "26",
            "clean": "26"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        },
        {
          "name": "XC",
          "desc": "Control"
        }
      ],
      "extension": "VSX",
      "slug": "xxperm",
      "rel_url": "powerisa/xxperm/",
      "linked_summary": "General permute for VSX registers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xxpermr",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Permute Right",
      "summary": "Little-endian optimized permute.",
      "syntax": "xxpermr XT, XA, XB, XC",
      "encoding": {
        "format": "XX4-form",
        "binary_pattern": "60 | XT | XA | XB | XC | 58",
        "hex_opcode": "0xF000003A",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "XC",
            "clean": "XC"
          },
          {
            "raw": "58",
            "clean": "58"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        },
        {
          "name": "XC",
          "desc": "Control"
        }
      ],
      "extension": "VSX",
      "slug": "xxpermr",
      "rel_url": "powerisa/xxpermr/",
      "linked_summary": "Little-endian optimized permute.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lswx",
      "architecture": "PowerISA",
      "full_name": "Load String Word Indexed",
      "summary": "Loads N bytes from memory (N in XER).",
      "syntax": "lswx RT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | RA | RB | 533 | /",
        "hex_opcode": "0x7C000425",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "533",
            "clean": "533"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Start Reg"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base (Legacy)",
      "slug": "lswx",
      "rel_url": "powerisa/lswx/",
      "linked_summary": "Loads N bytes from memory (N <a href=\"../../x86/in/\">in</a> XER).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stswx",
      "architecture": "PowerISA",
      "full_name": "Store String Word Indexed",
      "summary": "Stores N bytes to memory (N in XER).",
      "syntax": "stswx RT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | RA | RB | 661 | /",
        "hex_opcode": "0x7C000525",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "661",
            "clean": "661"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Start Reg"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base (Legacy)",
      "slug": "stswx",
      "rel_url": "powerisa/stswx/",
      "linked_summary": "Stores N bytes to memory (N <a href=\"../../x86/in/\">in</a> XER).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "wait",
      "architecture": "PowerISA",
      "full_name": "Wait",
      "summary": "Pauses execution to save power.",
      "syntax": "wait",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | 0 | 0 | 0 | 62 | /",
        "hex_opcode": "0x7C00007C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "62",
            "clean": "62"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [],
      "extension": "Base",
      "slug": "wait",
      "rel_url": "powerisa/wait/",
      "linked_summary": "Pauses execution to save power.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "doze",
      "architecture": "PowerISA",
      "full_name": "Doze",
      "summary": "Enters Doze power-saving mode (Supervisor only).",
      "syntax": "doze",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | / | / | / | /",
        "hex_opcode": "See Manual",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [],
      "extension": "Privileged",
      "slug": "doze",
      "rel_url": "powerisa/doze/",
      "linked_summary": "Enters Doze power-saving mode (Supervisor only).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "nap",
      "architecture": "PowerISA",
      "full_name": "Nap",
      "summary": "Enters Nap power-saving mode (Supervisor only).",
      "syntax": "nap",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | / | / | / | /",
        "hex_opcode": "See Manual",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [],
      "extension": "Privileged",
      "slug": "nap",
      "rel_url": "powerisa/nap/",
      "linked_summary": "Enters Nap power-saving mode (Supervisor only).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sleep",
      "architecture": "PowerISA",
      "full_name": "Sleep",
      "summary": "Enters Sleep power-saving mode (Supervisor only).",
      "syntax": "sleep",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | / | / | / | /",
        "hex_opcode": "See Manual",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [],
      "extension": "Privileged",
      "slug": "sleep",
      "rel_url": "powerisa/sleep/",
      "linked_summary": "Enters Sleep power-saving mode (Supervisor only).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ripv",
      "architecture": "PowerISA",
      "full_name": "Rip Van Winkle",
      "summary": "Enters Deep Sleep mode (Supervisor only).",
      "syntax": "ripv",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | / | / | / | /",
        "hex_opcode": "See Manual",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [],
      "extension": "Privileged",
      "slug": "ripv",
      "rel_url": "powerisa/ripv/",
      "linked_summary": "Enters Deep Sleep mode (Supervisor only).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dcbzl",
      "architecture": "PowerISA",
      "full_name": "Data Cache Block Zero Long",
      "summary": "Zeros a cache block (implementation defined size).",
      "syntax": "dcbzl RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | RA | RB | 1014 | /",
        "hex_opcode": "0x7C0007EC",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1014",
            "clean": "1014"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base",
      "slug": "dcbzl",
      "rel_url": "powerisa/dcbzl/",
      "linked_summary": "Zeros a cache block (implementation defined size).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "slbmfee",
      "architecture": "PowerISA",
      "full_name": "SLB Move From Entry ESID",
      "summary": "Reads the ESID part of an SLB entry.",
      "syntax": "slbmfee RT, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | / | RB | 366 | /",
        "hex_opcode": "0x7C0002DE",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "366",
            "clean": "366"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Privileged",
      "slug": "slbmfee",
      "rel_url": "powerisa/slbmfee/",
      "linked_summary": "Reads the ESID part of an SLB entry.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "slbmfev",
      "architecture": "PowerISA",
      "full_name": "SLB Move From Entry VSID",
      "summary": "Reads the VSID part of an SLB entry.",
      "syntax": "slbmfev RT, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | / | RB | 334 | /",
        "hex_opcode": "0x7C00029E",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "334",
            "clean": "334"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Privileged",
      "slug": "slbmfev",
      "rel_url": "powerisa/slbmfev/",
      "linked_summary": "Reads the VSID part of an SLB entry.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "msgclrp",
      "architecture": "PowerISA",
      "full_name": "Message Clear Privileged",
      "summary": "Clears a privileged doorbell interrupt.",
      "syntax": "msgclrp RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | / | RB | 150 | /",
        "hex_opcode": "0x7C00012C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "150",
            "clean": "150"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RB",
          "desc": "Type"
        }
      ],
      "extension": "Privileged",
      "slug": "msgclrp",
      "rel_url": "powerisa/msgclrp/",
      "linked_summary": "Clears a privileged doorbell interrupt.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "msgsndp",
      "architecture": "PowerISA",
      "full_name": "Message Send Privileged",
      "summary": "Sends a privileged doorbell interrupt.",
      "syntax": "msgsndp RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | / | RB | 142 | /",
        "hex_opcode": "0x7C00011C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "142",
            "clean": "142"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RB",
          "desc": "Type"
        }
      ],
      "extension": "Privileged",
      "slug": "msgsndp",
      "rel_url": "powerisa/msgsndp/",
      "linked_summary": "Sends a privileged doorbell interrupt.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mfsr",
      "architecture": "PowerISA",
      "full_name": "Move From Segment Register",
      "summary": "Legacy 32-bit segment register read.",
      "syntax": "mfsr RT, SR",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | SR | / | 595 | /",
        "hex_opcode": "0x7C0004A6",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "SR",
            "clean": "SR"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "595",
            "clean": "595"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "SR",
          "desc": "Segment Reg"
        }
      ],
      "extension": "Base (Legacy)",
      "slug": "mfsr",
      "rel_url": "powerisa/mfsr/",
      "linked_summary": "Legacy 32-<a href=\"../../armv8-a/bit/\">bit</a> segment register read.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mtsr",
      "architecture": "PowerISA",
      "full_name": "Move To Segment Register",
      "summary": "Legacy 32-bit segment register write.",
      "syntax": "mtsr SR, RS",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | SR | / | 210 | /",
        "hex_opcode": "0x7C0001A6",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "SR",
            "clean": "SR"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "210",
            "clean": "210"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "SR",
          "desc": "Segment Reg"
        },
        {
          "name": "RS",
          "desc": "Source"
        }
      ],
      "extension": "Base (Legacy)",
      "slug": "mtsr",
      "rel_url": "powerisa/mtsr/",
      "linked_summary": "Legacy 32-<a href=\"../../armv8-a/bit/\">bit</a> segment register write.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mfsrin",
      "architecture": "PowerISA",
      "full_name": "Move From Segment Register Indirect",
      "summary": "Indirect read of segment register using RB.",
      "syntax": "mfsrin RT, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | / | RB | 659 | /",
        "hex_opcode": "0x7C000526",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "659",
            "clean": "659"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RB",
          "desc": "Effective Addr"
        }
      ],
      "extension": "Base (Legacy)",
      "slug": "mfsrin",
      "rel_url": "powerisa/mfsrin/",
      "linked_summary": "Indirect read of segment register using RB.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mtsrin",
      "architecture": "PowerISA",
      "full_name": "Move To Segment Register Indirect",
      "summary": "Indirect write of segment register using RB.",
      "syntax": "mtsrin RS, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | / | RB | 242 | /",
        "hex_opcode": "0x7C0001E6",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "242",
            "clean": "242"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "RB",
          "desc": "Effective Addr"
        }
      ],
      "extension": "Base (Legacy)",
      "slug": "mtsrin",
      "rel_url": "powerisa/mtsrin/",
      "linked_summary": "Indirect write of segment register using RB.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mfbhrbe",
      "architecture": "PowerISA",
      "full_name": "Move From Branch History Rolling Buffer Entry",
      "summary": "Reads a specific entry from the BHRB.",
      "syntax": "mfbhrbe RT, BHRBE",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | BHRBE | / | 302 | /",
        "hex_opcode": "0x7C00025E",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "BHRBE",
            "clean": "BHRBE"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "302",
            "clean": "302"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "BHRBE",
          "desc": "Entry Index"
        }
      ],
      "extension": "Base",
      "slug": "mfbhrbe",
      "rel_url": "powerisa/mfbhrbe/",
      "linked_summary": "Reads a specific entry from the BHRB.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tsr",
      "architecture": "PowerISA",
      "full_name": "Transaction Suspend or Resume",
      "summary": "Suspends or resumes a transaction based on L.",
      "syntax": "tsr L",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | L | / | / | 750 | /",
        "hex_opcode": "0x7C0005DE",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "L",
            "clean": "L"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "750",
            "clean": "750"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "L",
          "desc": "1=Suspend"
        }
      ],
      "extension": "TM (Transactional Memory)",
      "slug": "tsr",
      "rel_url": "powerisa/tsr/",
      "linked_summary": "Suspends <a href=\"../../powerisa/or/\">or</a> resumes a transaction based on L.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tabortwci",
      "architecture": "PowerISA",
      "full_name": "Transaction Abort Word Conditional Immediate",
      "summary": "Aborts transaction if word condition (Immediate) is met.",
      "syntax": "tabortwci TO, RA, SI",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | TO | RA | SI | 782 | 1",
        "hex_opcode": "0x7C00061D",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "TO",
            "clean": "TO"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "SI",
            "clean": "SI"
          },
          {
            "raw": "782",
            "clean": "782"
          },
          {
            "raw": "1",
            "clean": "1"
          }
        ]
      },
      "operands": [
        {
          "name": "TO",
          "desc": "Options"
        },
        {
          "name": "RA",
          "desc": "Src"
        },
        {
          "name": "SI",
          "desc": "Immediate"
        }
      ],
      "extension": "TM (Transactional Memory)",
      "slug": "tabortwci",
      "rel_url": "powerisa/tabortwci/",
      "linked_summary": "Aborts transaction if word condition (Immediate) is met.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tabortdci",
      "architecture": "PowerISA",
      "full_name": "Transaction Abort Doubleword Conditional Immediate",
      "summary": "Aborts transaction if doubleword condition (Immediate) is met.",
      "syntax": "tabortdci TO, RA, SI",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | TO | RA | SI | 814 | 1",
        "hex_opcode": "0x7C00065D",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "TO",
            "clean": "TO"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "SI",
            "clean": "SI"
          },
          {
            "raw": "814",
            "clean": "814"
          },
          {
            "raw": "1",
            "clean": "1"
          }
        ]
      },
      "operands": [
        {
          "name": "TO",
          "desc": "Options"
        },
        {
          "name": "RA",
          "desc": "Src"
        },
        {
          "name": "SI",
          "desc": "Immediate"
        }
      ],
      "extension": "TM (Transactional Memory)",
      "slug": "tabortdci",
      "rel_url": "powerisa/tabortdci/",
      "linked_summary": "Aborts transaction if doubleword condition (Immediate) is met.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsrintqp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Round to Integer Quad-Precision",
      "summary": "Rounds Quad float to nearest Integer.",
      "syntax": "xsrintqp vD, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | / | vB | 484 | /",
        "hex_opcode": "0xFC0003C4",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "484",
            "clean": "484"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "VSX (Quad)",
      "slug": "xsrintqp",
      "rel_url": "powerisa/xsrintqp/",
      "linked_summary": "Rounds Quad float to nearest Integer.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dctqpq",
      "architecture": "PowerISA",
      "full_name": "Decimal Convert To Quad-Precision DFP",
      "summary": "Converts DFP Long (64-bit) to DFP Quad (128-bit).",
      "syntax": "dctqpq vD, FRB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | vD | / | FRB | 258 | /",
        "hex_opcode": "0xFC000204",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "FRB",
            "clean": "FRB"
          },
          {
            "raw": "258",
            "clean": "258"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target Quad"
        },
        {
          "name": "FRB",
          "desc": "Source Long"
        }
      ],
      "extension": "Decimal Float",
      "slug": "dctqpq",
      "rel_url": "powerisa/dctqpq/",
      "linked_summary": "Converts DFP Long (64-<a href=\"../../armv8-a/bit/\">bit</a>) to DFP Quad (128-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "drdpq",
      "architecture": "PowerISA",
      "full_name": "Decimal Round To DFP Quad-Precision",
      "summary": "Rounds DFP Quad (128-bit) to DFP Long (64-bit).",
      "syntax": "drdpq FRT, vB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "63 | FRT | / | vB | 770 | /",
        "hex_opcode": "0xFC000604",
        "visual_parts": [
          {
            "raw": "63",
            "clean": "63"
          },
          {
            "raw": "FRT",
            "clean": "FRT"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "770",
            "clean": "770"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "FRT",
          "desc": "Target Long"
        },
        {
          "name": "vB",
          "desc": "Source Quad"
        }
      ],
      "extension": "Decimal Float",
      "slug": "drdpq",
      "rel_url": "powerisa/drdpq/",
      "linked_summary": "Rounds DFP Quad (128-<a href=\"../../armv8-a/bit/\">bit</a>) to DFP Long (64-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcipherlast",
      "architecture": "PowerISA",
      "full_name": "Vector Cipher Last",
      "summary": "Performs the final round of AES encryption (SubBytes, ShiftRows, AddRoundKey). No MixColumns.",
      "syntax": "vcipherlast vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1289",
        "hex_opcode": "0x10000509",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1289",
            "clean": "1289"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "State"
        },
        {
          "name": "vB",
          "desc": "Round Key"
        }
      ],
      "extension": "Vector Crypto",
      "slug": "vcipherlast",
      "rel_url": "powerisa/vcipherlast/",
      "linked_summary": "Performs the final round of AES encryption (SubBytes, ShiftRows, AddRoundKey). No MixColumns.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vncipherlast",
      "architecture": "PowerISA",
      "full_name": "Vector Inverse Cipher Last",
      "summary": "Performs the final round of AES decryption.",
      "syntax": "vncipherlast vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1353",
        "hex_opcode": "0x10000549",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1353",
            "clean": "1353"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "State"
        },
        {
          "name": "vB",
          "desc": "Round Key"
        }
      ],
      "extension": "Vector Crypto",
      "slug": "vncipherlast",
      "rel_url": "powerisa/vncipherlast/",
      "linked_summary": "Performs the final round of AES decryption.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsbox",
      "architecture": "PowerISA",
      "full_name": "Vector S-Box",
      "summary": "Performs the SubBytes operation (S-Box lookup) on a vector.",
      "syntax": "vsbox vD, vA",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vA | 1480",
        "hex_opcode": "0x100005C8",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "1480",
            "clean": "1480"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Source"
        }
      ],
      "extension": "Vector Crypto",
      "slug": "vsbox",
      "rel_url": "powerisa/vsbox/",
      "linked_summary": "Performs the SubBytes operation (S-Box lookup) on a vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vshasigmad",
      "architecture": "PowerISA",
      "full_name": "Vector SHA-512 Sigma Doubleword",
      "summary": "Performs the Sigma0/Sigma1 functions for SHA-512.",
      "syntax": "vshasigmad vD, vA, ST, SIX",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | ST | 1730",
        "hex_opcode": "0x100006C2",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "ST",
            "clean": "ST"
          },
          {
            "raw": "1730",
            "clean": "1730"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Source"
        },
        {
          "name": "ST",
          "desc": "Type"
        },
        {
          "name": "SIX",
          "desc": "Shift"
        }
      ],
      "extension": "Vector Crypto",
      "slug": "vshasigmad",
      "rel_url": "powerisa/vshasigmad/",
      "linked_summary": "Performs the Sigma0/Sigma1 functions for SHA-512.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpermxor",
      "architecture": "PowerISA",
      "full_name": "Vector Permute and Exclusive-OR",
      "summary": "Permutes bytes from vA and vB, then XORs with vC. Used for finite field arithmetic.",
      "syntax": "vpermxor vD, vA, vB, vC",
      "encoding": {
        "format": "VA-form",
        "binary_pattern": "4 | vD | vA | vB | vC | 45",
        "hex_opcode": "0x1000002D",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "vC",
            "clean": "vC"
          },
          {
            "raw": "45",
            "clean": "45"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Src A"
        },
        {
          "name": "vB",
          "desc": "Src B"
        },
        {
          "name": "vC",
          "desc": "Permute"
        }
      ],
      "extension": "Vector Crypto",
      "slug": "vpermxor",
      "rel_url": "powerisa/vpermxor/",
      "linked_summary": "Permutes bytes from vA <a href=\"../../armv8-a/and_6/\">and</a> vB, then XORs with vC. Used for finite field arithmetic.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bcdcfn.",
      "architecture": "PowerISA",
      "full_name": "Decimal Convert from National",
      "summary": "Converts BCD National format to Signed Packed BCD.",
      "syntax": "bcdcfn. vD, vB, PS",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 1 | vB | 1473",
        "hex_opcode": "0x102005C1",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1473",
            "clean": "1473"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        },
        {
          "name": "PS",
          "desc": "Sign"
        }
      ],
      "extension": "Vector BCD",
      "slug": "bcdcfn_",
      "rel_url": "powerisa/bcdcfn_/",
      "linked_summary": "Converts BCD National format to Signed Packed BCD.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bcdctn.",
      "architecture": "PowerISA",
      "full_name": "Decimal Convert to National",
      "summary": "Converts Signed Packed BCD to National format.",
      "syntax": "bcdctn. vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 1473",
        "hex_opcode": "0x100005C1",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1473",
            "clean": "1473"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector BCD",
      "slug": "bcdctn_",
      "rel_url": "powerisa/bcdctn_/",
      "linked_summary": "Converts Signed Packed BCD to National format.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bcdcfz.",
      "architecture": "PowerISA",
      "full_name": "Decimal Convert from Zoned",
      "summary": "Converts BCD Zoned format to Signed Packed BCD.",
      "syntax": "bcdcfz. vD, vB, PS",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 1 | vB | 1217",
        "hex_opcode": "0x102004C1",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1217",
            "clean": "1217"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        },
        {
          "name": "PS",
          "desc": "Sign"
        }
      ],
      "extension": "Vector BCD",
      "slug": "bcdcfz_",
      "rel_url": "powerisa/bcdcfz_/",
      "linked_summary": "Converts BCD Zoned format to Signed Packed BCD.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bcdctz.",
      "architecture": "PowerISA",
      "full_name": "Decimal Convert to Zoned",
      "summary": "Converts Signed Packed BCD to Zoned format.",
      "syntax": "bcdctz. vD, vB, PS",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 1 | vB | 1217",
        "hex_opcode": "0x102004C1",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1217",
            "clean": "1217"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        },
        {
          "name": "PS",
          "desc": "Sign"
        }
      ],
      "extension": "Vector BCD",
      "slug": "bcdctz_",
      "rel_url": "powerisa/bcdctz_/",
      "linked_summary": "Converts Signed Packed BCD to Zoned format.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bcdcfsq.",
      "architecture": "PowerISA",
      "full_name": "Decimal Convert from Signed Quadword",
      "summary": "Converts a 128-bit signed integer to BCD.",
      "syntax": "bcdcfsq. vD, vB, PS",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 1 | vB | 193",
        "hex_opcode": "0x102000C1",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "193",
            "clean": "193"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        },
        {
          "name": "PS",
          "desc": "Sign"
        }
      ],
      "extension": "Vector BCD",
      "slug": "bcdcfsq_",
      "rel_url": "powerisa/bcdcfsq_/",
      "linked_summary": "Converts a 128-<a href=\"../../armv8-a/bit/\">bit</a> signed integer to BCD.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bcdctsq.",
      "architecture": "PowerISA",
      "full_name": "Decimal Convert to Signed Quadword",
      "summary": "Converts BCD to a 128-bit signed integer.",
      "syntax": "bcdctsq. vD, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | 0 | vB | 193",
        "hex_opcode": "0x100000C1",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "193",
            "clean": "193"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vB",
          "desc": "Source"
        }
      ],
      "extension": "Vector BCD",
      "slug": "bcdctsq_",
      "rel_url": "powerisa/bcdctsq_/",
      "linked_summary": "Converts BCD to a 128-<a href=\"../../armv8-a/bit/\">bit</a> signed integer.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mulhd",
      "architecture": "PowerISA",
      "full_name": "Multiply High Doubleword",
      "summary": "Multiplies two 64-bit integers and returns the upper 64 bits of the 128-bit result (Signed).",
      "syntax": "mulhd RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "31 | RT | RA | RB | OE | 73 | Rc",
        "hex_opcode": "0x7C000092",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "OE",
            "clean": "OE"
          },
          {
            "raw": "73",
            "clean": "73"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Base",
      "slug": "mulhd",
      "rel_url": "powerisa/mulhd/",
      "linked_summary": "Multiplies two 64-<a href=\"../../armv8-a/bit/\">bit</a> integers <a href=\"../../armv8-a/and_6/\">and</a> returns the upper 64 bits of the 128-<a href=\"../../armv8-a/bit/\">bit</a> result (Signed).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mulhdu",
      "architecture": "PowerISA",
      "full_name": "Multiply High Doubleword Unsigned",
      "summary": "Multiplies two 64-bit integers and returns the upper 64 bits of the 128-bit result (Unsigned).",
      "syntax": "mulhdu RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "31 | RT | RA | RB | OE | 9 | Rc",
        "hex_opcode": "0x7C000012",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "OE",
            "clean": "OE"
          },
          {
            "raw": "9",
            "clean": "9"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Base",
      "slug": "mulhdu",
      "rel_url": "powerisa/mulhdu/",
      "linked_summary": "Multiplies two 64-<a href=\"../../armv8-a/bit/\">bit</a> integers <a href=\"../../armv8-a/and_6/\">and</a> returns the upper 64 bits of the 128-<a href=\"../../armv8-a/bit/\">bit</a> result (Unsigned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mulhw",
      "architecture": "PowerISA",
      "full_name": "Multiply High Word",
      "summary": "Multiplies two 32-bit integers and returns the upper 32 bits (Signed).",
      "syntax": "mulhw RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "31 | RT | RA | RB | OE | 75 | Rc",
        "hex_opcode": "0x7C000096",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "OE",
            "clean": "OE"
          },
          {
            "raw": "75",
            "clean": "75"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Base",
      "slug": "mulhw",
      "rel_url": "powerisa/mulhw/",
      "linked_summary": "Multiplies two 32-<a href=\"../../armv8-a/bit/\">bit</a> integers <a href=\"../../armv8-a/and_6/\">and</a> returns the upper 32 bits (Signed).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mulhwu",
      "architecture": "PowerISA",
      "full_name": "Multiply High Word Unsigned",
      "summary": "Multiplies two 32-bit integers and returns the upper 32 bits (Unsigned).",
      "syntax": "mulhwu RT, RA, RB",
      "encoding": {
        "format": "XO-form",
        "binary_pattern": "31 | RT | RA | RB | OE | 11 | Rc",
        "hex_opcode": "0x7C000016",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "OE",
            "clean": "OE"
          },
          {
            "raw": "11",
            "clean": "11"
          },
          {
            "raw": "Rc",
            "clean": "Rc"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Src A"
        },
        {
          "name": "RB",
          "desc": "Src B"
        }
      ],
      "extension": "Base",
      "slug": "mulhwu",
      "rel_url": "powerisa/mulhwu/",
      "linked_summary": "Multiplies two 32-<a href=\"../../armv8-a/bit/\">bit</a> integers <a href=\"../../armv8-a/and_6/\">and</a> returns the upper 32 bits (Unsigned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "divsq",
      "architecture": "PowerISA",
      "full_name": "Divide Signed Quadword",
      "summary": "Divides a 128-bit signed integer by a 128-bit signed integer (using VSX pairs).",
      "syntax": "divsq vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 265",
        "hex_opcode": "0x10000109",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "265",
            "clean": "265"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Dividend"
        },
        {
          "name": "vB",
          "desc": "Divisor"
        }
      ],
      "extension": "Base (Quad Math)",
      "slug": "divsq",
      "rel_url": "powerisa/divsq/",
      "linked_summary": "Divides a 128-<a href=\"../../armv8-a/bit/\">bit</a> signed integer by a 128-<a href=\"../../armv8-a/bit/\">bit</a> signed integer (using VSX pairs).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "divuq",
      "architecture": "PowerISA",
      "full_name": "Divide Unsigned Quadword",
      "summary": "Divides a 128-bit unsigned integer by a 128-bit unsigned integer.",
      "syntax": "divuq vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 9",
        "hex_opcode": "0x10000009",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "9",
            "clean": "9"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Dividend"
        },
        {
          "name": "vB",
          "desc": "Divisor"
        }
      ],
      "extension": "Base (Quad Math)",
      "slug": "divuq",
      "rel_url": "powerisa/divuq/",
      "linked_summary": "Divides a 128-<a href=\"../../armv8-a/bit/\">bit</a> unsigned integer by a 128-<a href=\"../../armv8-a/bit/\">bit</a> unsigned integer.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "modsq",
      "architecture": "PowerISA",
      "full_name": "Modulo Signed Quadword",
      "summary": "Computes remainder of 128-bit signed division.",
      "syntax": "modsq vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 267",
        "hex_opcode": "0x1000010B",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "267",
            "clean": "267"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Dividend"
        },
        {
          "name": "vB",
          "desc": "Divisor"
        }
      ],
      "extension": "Base (Quad Math)",
      "slug": "modsq",
      "rel_url": "powerisa/modsq/",
      "linked_summary": "Computes remainder of 128-<a href=\"../../armv8-a/bit/\">bit</a> signed division.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "moduq",
      "architecture": "PowerISA",
      "full_name": "Modulo Unsigned Quadword",
      "summary": "Computes remainder of 128-bit unsigned division.",
      "syntax": "moduq vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 11",
        "hex_opcode": "0x1000000B",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "11",
            "clean": "11"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Dividend"
        },
        {
          "name": "vB",
          "desc": "Divisor"
        }
      ],
      "extension": "Base (Quad Math)",
      "slug": "moduq",
      "rel_url": "powerisa/moduq/",
      "linked_summary": "Computes remainder of 128-<a href=\"../../armv8-a/bit/\">bit</a> unsigned division.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lbzci",
      "architecture": "PowerISA",
      "full_name": "Load Byte and Zero Caching Inhibited",
      "summary": "Loads a byte bypassing the cache. Used for memory-mapped I/O.",
      "syntax": "lbzci RT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | RA | RB | 854 | /",
        "hex_opcode": "0x7C0006AA",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "854",
            "clean": "854"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base (I/O)",
      "slug": "lbzci",
      "rel_url": "powerisa/lbzci/",
      "linked_summary": "Loads a byte bypassing the cache. Used for memory-mapped I/O.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lhzci",
      "architecture": "PowerISA",
      "full_name": "Load Halfword and Zero Caching Inhibited",
      "summary": "Loads a halfword bypassing the cache.",
      "syntax": "lhzci RT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | RA | RB | 886 | /",
        "hex_opcode": "0x7C0006EA",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "886",
            "clean": "886"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base (I/O)",
      "slug": "lhzci",
      "rel_url": "powerisa/lhzci/",
      "linked_summary": "Loads a halfword bypassing the cache.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lwzci",
      "architecture": "PowerISA",
      "full_name": "Load Word and Zero Caching Inhibited",
      "summary": "Loads a word bypassing the cache.",
      "syntax": "lwzci RT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | RA | RB | 855 | /",
        "hex_opcode": "0x7C0006AB",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "855",
            "clean": "855"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base (I/O)",
      "slug": "lwzci",
      "rel_url": "powerisa/lwzci/",
      "linked_summary": "Loads a word bypassing the cache.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ldci",
      "architecture": "PowerISA",
      "full_name": "Load Doubleword Caching Inhibited",
      "summary": "Loads a doubleword bypassing the cache.",
      "syntax": "ldci RT, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | RA | RB | 887 | /",
        "hex_opcode": "0x7C0006EB",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "887",
            "clean": "887"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base (I/O)",
      "slug": "ldci",
      "rel_url": "powerisa/ldci/",
      "linked_summary": "Loads a doubleword bypassing the cache.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stbci",
      "architecture": "PowerISA",
      "full_name": "Store Byte Caching Inhibited",
      "summary": "Stores a byte bypassing the cache.",
      "syntax": "stbci RS, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 982 | /",
        "hex_opcode": "0x7C0007AE",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "982",
            "clean": "982"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base (I/O)",
      "slug": "stbci",
      "rel_url": "powerisa/stbci/",
      "linked_summary": "Stores a byte bypassing the cache.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sthci",
      "architecture": "PowerISA",
      "full_name": "Store Halfword Caching Inhibited",
      "summary": "Stores a halfword bypassing the cache.",
      "syntax": "sthci RS, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 1014 | /",
        "hex_opcode": "0x7C0007EE",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1014",
            "clean": "1014"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base (I/O)",
      "slug": "sthci",
      "rel_url": "powerisa/sthci/",
      "linked_summary": "Stores a halfword bypassing the cache.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stwci",
      "architecture": "PowerISA",
      "full_name": "Store Word Caching Inhibited",
      "summary": "Stores a word bypassing the cache.",
      "syntax": "stwci RS, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 983 | /",
        "hex_opcode": "0x7C0007AF",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "983",
            "clean": "983"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base (I/O)",
      "slug": "stwci",
      "rel_url": "powerisa/stwci/",
      "linked_summary": "Stores a word bypassing the cache.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stdci",
      "architecture": "PowerISA",
      "full_name": "Store Doubleword Caching Inhibited",
      "summary": "Stores a doubleword bypassing the cache.",
      "syntax": "stdci RS, RA, RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | RA | RB | 1015 | /",
        "hex_opcode": "0x7C0007EF",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "1015",
            "clean": "1015"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RS",
          "desc": "Source"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "RB",
          "desc": "Index"
        }
      ],
      "extension": "Base (I/O)",
      "slug": "stdci",
      "rel_url": "powerisa/stdci/",
      "linked_summary": "Stores a doubleword bypassing the cache.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cp_abort",
      "architecture": "PowerISA",
      "full_name": "Copy-Paste Abort",
      "summary": "Aborts a hardware accelerator copy-paste sequence.",
      "syntax": "cp_abort",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | 0 | 0 | 0 | 450 | /",
        "hex_opcode": "0x7C000382",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "450",
            "clean": "450"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [],
      "extension": "Privileged",
      "slug": "cp_abort",
      "rel_url": "powerisa/cp_abort/",
      "linked_summary": "Aborts a hardware accelerator <a href=\"../../powerisa/copy/\">copy</a>-<a href=\"../../powerisa/paste/\">paste</a> sequence.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mcrxrx",
      "architecture": "PowerISA",
      "full_name": "Move to CR from XER Extended",
      "summary": "Copies XER[OV, SO] to a Condition Register field.",
      "syntax": "mcrxrx BF",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | BF | 0 | 0 | 512 | /",
        "hex_opcode": "0x7C000400",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "512",
            "clean": "512"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "Target CR Field"
        }
      ],
      "extension": "Base",
      "slug": "mcrxrx",
      "rel_url": "powerisa/mcrxrx/",
      "linked_summary": "Copies XER[OV, SO] to a Condition Register field.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "scv",
      "architecture": "PowerISA",
      "full_name": "System Call Vectored",
      "summary": "Performs a system call to a fixed vector address (Faster than 'sc').",
      "syntax": "scv LEV",
      "encoding": {
        "format": "SC-form",
        "binary_pattern": "17 | / | / | / | LEV | / | 1",
        "hex_opcode": "0x44000002",
        "visual_parts": [
          {
            "raw": "17",
            "clean": "17"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "LEV",
            "clean": "LEV"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "1",
            "clean": "1"
          }
        ]
      },
      "operands": [
        {
          "name": "LEV",
          "desc": "Level"
        }
      ],
      "extension": "Base",
      "slug": "scv",
      "rel_url": "powerisa/scv/",
      "linked_summary": "Performs a system <a href=\"../../x86/call/\">call</a> to a fixed vector address (Faster than '<a href=\"../../powerisa/sc/\">sc</a>').",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rfscv",
      "architecture": "PowerISA",
      "full_name": "Return from System Call Vectored",
      "summary": "Returns from a vectored system call.",
      "syntax": "rfscv",
      "encoding": {
        "format": "XL-form",
        "binary_pattern": "19 | / | / | / | 82 | /",
        "hex_opcode": "0x4C0000A4",
        "visual_parts": [
          {
            "raw": "19",
            "clean": "19"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "82",
            "clean": "82"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [],
      "extension": "Privileged",
      "slug": "rfscv",
      "rel_url": "powerisa/rfscv/",
      "linked_summary": "Returns from a vectored system <a href=\"../../x86/call/\">call</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stop",
      "architecture": "PowerISA",
      "full_name": "Stop",
      "summary": "Stops instruction execution and enters a power-saving state (replaces nap/doze on P9+).",
      "syntax": "stop",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "19 | / | / | / | 722 | /",
        "hex_opcode": "0x4C0005A4",
        "visual_parts": [
          {
            "raw": "19",
            "clean": "19"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "722",
            "clean": "722"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [],
      "extension": "Privileged",
      "slug": "stop",
      "rel_url": "powerisa/stop/",
      "linked_summary": "Stops instruction execution <a href=\"../../armv8-a/and_6/\">and</a> enters a power-saving state (replaces <a href=\"../../powerisa/nap/\">nap</a>/<a href=\"../../powerisa/doze/\">doze</a> on P9+).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "urfid",
      "architecture": "PowerISA",
      "full_name": "Ultravisor Return from Interrupt Doubleword",
      "summary": "Returns from an ultravisor interrupt.",
      "syntax": "urfid",
      "encoding": {
        "format": "XL-form",
        "binary_pattern": "19 | / | / | / | 274 | /",
        "hex_opcode": "0x4C000224",
        "visual_parts": [
          {
            "raw": "19",
            "clean": "19"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "274",
            "clean": "274"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [],
      "extension": "Privileged",
      "slug": "urfid",
      "rel_url": "powerisa/urfid/",
      "linked_summary": "Returns from an ultravisor interrupt.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "setbc",
      "architecture": "PowerISA",
      "full_name": "Set Boolean Condition",
      "summary": "Sets RT to 1 if CR bit is set, else 0. (Branchless logic).",
      "syntax": "setbc RT, BI",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | BI | / | 384 | /",
        "hex_opcode": "0x7C000300",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "BI",
            "clean": "BI"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "384",
            "clean": "384"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "BI",
          "desc": "CR Bit"
        }
      ],
      "extension": "Base",
      "slug": "setbc",
      "rel_url": "powerisa/setbc/",
      "linked_summary": "Sets RT to 1 if CR <a href=\"../../armv8-a/bit/\">bit</a> is set, else 0. (Branchless logic).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "setbcr",
      "architecture": "PowerISA",
      "full_name": "Set Boolean Condition Reverse",
      "summary": "Sets RT to 1 if CR bit is clear, else 0.",
      "syntax": "setbcr RT, BI",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | BI | / | 416 | /",
        "hex_opcode": "0x7C000340",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "BI",
            "clean": "BI"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "416",
            "clean": "416"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "BI",
          "desc": "CR Bit"
        }
      ],
      "extension": "Base",
      "slug": "setbcr",
      "rel_url": "powerisa/setbcr/",
      "linked_summary": "Sets RT to 1 if CR <a href=\"../../armv8-a/bit/\">bit</a> is clear, else 0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "setnbc",
      "architecture": "PowerISA",
      "full_name": "Set Negative Boolean Condition",
      "summary": "Sets RT to -1 if CR bit is set, else 0.",
      "syntax": "setnbc RT, BI",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | BI | / | 448 | /",
        "hex_opcode": "0x7C000380",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "BI",
            "clean": "BI"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "448",
            "clean": "448"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "BI",
          "desc": "CR Bit"
        }
      ],
      "extension": "Base",
      "slug": "setnbc",
      "rel_url": "powerisa/setnbc/",
      "linked_summary": "Sets RT to -1 if CR <a href=\"../../armv8-a/bit/\">bit</a> is set, else 0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "setnbcr",
      "architecture": "PowerISA",
      "full_name": "Set Negative Boolean Condition Reverse",
      "summary": "Sets RT to -1 if CR bit is clear, else 0.",
      "syntax": "setnbcr RT, BI",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RT | BI | / | 480 | /",
        "hex_opcode": "0x7C0003C0",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RT",
            "clean": "RT"
          },
          {
            "raw": "BI",
            "clean": "BI"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "480",
            "clean": "480"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RT",
          "desc": "Target"
        },
        {
          "name": "BI",
          "desc": "CR Bit"
        }
      ],
      "extension": "Base",
      "slug": "setnbcr",
      "rel_url": "powerisa/setnbcr/",
      "linked_summary": "Sets RT to -1 if CR <a href=\"../../armv8-a/bit/\">bit</a> is clear, else 0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xscmpexpdp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Compare Exponents Double-Precision",
      "summary": "Compares exponents of two double-precision floats.",
      "syntax": "xscmpexpdp BF, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | BF | / | XA | XB | 59",
        "hex_opcode": "0xF000003B",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "59",
            "clean": "59"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "XA",
          "desc": "Src A"
        },
        {
          "name": "XB",
          "desc": "Src B"
        }
      ],
      "extension": "VSX",
      "slug": "xscmpexpdp",
      "rel_url": "powerisa/xscmpexpdp/",
      "linked_summary": "Compares exponents of two double-precision floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsiexpdp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Insert Exponent Double-Precision",
      "summary": "Inserts exponent from one double into another.",
      "syntax": "xsiexpdp XT, XA, XB",
      "encoding": {
        "format": "XX3-form",
        "binary_pattern": "60 | XT | XA | XB | 219",
        "hex_opcode": "0xF00000DB",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "XA",
            "clean": "XA"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "219",
            "clean": "219"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XA",
          "desc": "Significand"
        },
        {
          "name": "XB",
          "desc": "Exponent"
        }
      ],
      "extension": "VSX",
      "slug": "xsiexpdp",
      "rel_url": "powerisa/xsiexpdp/",
      "linked_summary": "Inserts exponent from one double into another.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsxexpdp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Extract Exponent Double-Precision",
      "summary": "Extracts exponent from double as an integer.",
      "syntax": "xsxexpdp XT, XB",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | 0 | XB | 27",
        "hex_opcode": "0xF000001B",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "27",
            "clean": "27"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        }
      ],
      "extension": "VSX",
      "slug": "xsxexpdp",
      "rel_url": "powerisa/xsxexpdp/",
      "linked_summary": "Extracts exponent from double as an integer.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsxsigdp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Extract Significand Double-Precision",
      "summary": "Extracts significand from double as an integer.",
      "syntax": "xsxsigdp XT, XB",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | 0 | XB | 11",
        "hex_opcode": "0xF000000B",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "11",
            "clean": "11"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        }
      ],
      "extension": "VSX",
      "slug": "xsxsigdp",
      "rel_url": "powerisa/xsxsigdp/",
      "linked_summary": "Extracts significand from double as an integer.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xststdcdp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Test Data Class Double-Precision",
      "summary": "Tests if a double falls into a specific class (NaN, Inf, Zero, Denormal).",
      "syntax": "xststdcdp BF, XB, DCM",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | BF | / | DCM | XB | 362",
        "hex_opcode": "0xF000016A",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "BF",
            "clean": "BF"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "DCM",
            "clean": "DCM"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "362",
            "clean": "362"
          }
        ]
      },
      "operands": [
        {
          "name": "BF",
          "desc": "CR Field"
        },
        {
          "name": "XB",
          "desc": "Source"
        },
        {
          "name": "DCM",
          "desc": "Data Class Mask"
        }
      ],
      "extension": "VSX",
      "slug": "xststdcdp",
      "rel_url": "powerisa/xststdcdp/",
      "linked_summary": "Tests if a double falls into a specific class (NaN, Inf, Zero, Denormal).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lxvp",
      "architecture": "PowerISA",
      "full_name": "Load VSX Vector Pair",
      "summary": "Loads a 256-bit vector pair (two VSRs).",
      "syntax": "lxvp XT, DQ(RA)",
      "encoding": {
        "format": "DQ-form",
        "binary_pattern": "61 | XT | RA | DQ | 0",
        "hex_opcode": "0xF4000000",
        "visual_parts": [
          {
            "raw": "61",
            "clean": "61"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "DQ",
            "clean": "DQ"
          },
          {
            "raw": "0",
            "clean": "0"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target Even VSR"
        },
        {
          "name": "DQ",
          "desc": "Offset"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VSX",
      "slug": "lxvp",
      "rel_url": "powerisa/lxvp/",
      "linked_summary": "Loads a 256-<a href=\"../../armv8-a/bit/\">bit</a> vector pair (two VSRs).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stxvp",
      "architecture": "PowerISA",
      "full_name": "Store VSX Vector Pair",
      "summary": "Stores a 256-bit vector pair.",
      "syntax": "stxvp XS, DQ(RA)",
      "encoding": {
        "format": "DQ-form",
        "binary_pattern": "61 | XS | RA | DQ | 4",
        "hex_opcode": "0xF4000004",
        "visual_parts": [
          {
            "raw": "61",
            "clean": "61"
          },
          {
            "raw": "XS",
            "clean": "XS"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "DQ",
            "clean": "DQ"
          },
          {
            "raw": "4",
            "clean": "4"
          }
        ]
      },
      "operands": [
        {
          "name": "XS",
          "desc": "Source Even VSR"
        },
        {
          "name": "DQ",
          "desc": "Offset"
        },
        {
          "name": "RA",
          "desc": "Base"
        }
      ],
      "extension": "VSX",
      "slug": "stxvp",
      "rel_url": "powerisa/stxvp/",
      "linked_summary": "Stores a 256-<a href=\"../../armv8-a/bit/\">bit</a> vector pair.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "plxvp",
      "architecture": "PowerISA",
      "full_name": "Prefixed Load VSX Vector Pair",
      "summary": "Loads a 256-bit vector pair with 34-bit offset.",
      "syntax": "plxvp XT, D(RA), R",
      "encoding": {
        "format": "8LS:D-form",
        "binary_pattern": "000001 | 10 | 0 | ... | 58 | XT | ...",
        "hex_opcode": "0x06000000",
        "visual_parts": [
          {
            "raw": "000001",
            "clean": "000001"
          },
          {
            "raw": "10",
            "clean": "10"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "...",
            "clean": "..."
          },
          {
            "raw": "58",
            "clean": "58"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "D",
          "desc": "Offset"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "R",
          "desc": "PC-Rel"
        }
      ],
      "extension": "Prefixed",
      "slug": "plxvp",
      "rel_url": "powerisa/plxvp/",
      "linked_summary": "Loads a 256-<a href=\"../../armv8-a/bit/\">bit</a> vector pair with 34-<a href=\"../../armv8-a/bit/\">bit</a> offset.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pstxvp",
      "architecture": "PowerISA",
      "full_name": "Prefixed Store VSX Vector Pair",
      "summary": "Stores a 256-bit vector pair with 34-bit offset.",
      "syntax": "pstxvp XS, D(RA), R",
      "encoding": {
        "format": "8LS:D-form",
        "binary_pattern": "000001 | 10 | 0 | ... | 62 | XS | ...",
        "hex_opcode": "0x06000000",
        "visual_parts": [
          {
            "raw": "000001",
            "clean": "000001"
          },
          {
            "raw": "10",
            "clean": "10"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "...",
            "clean": "..."
          },
          {
            "raw": "62",
            "clean": "62"
          },
          {
            "raw": "XS",
            "clean": "XS"
          },
          {
            "raw": "...",
            "clean": "..."
          }
        ]
      },
      "operands": [
        {
          "name": "XS",
          "desc": "Source"
        },
        {
          "name": "D",
          "desc": "Offset"
        },
        {
          "name": "RA",
          "desc": "Base"
        },
        {
          "name": "R",
          "desc": "PC-Rel"
        }
      ],
      "extension": "Prefixed",
      "slug": "pstxvp",
      "rel_url": "powerisa/pstxvp/",
      "linked_summary": "Stores a 256-<a href=\"../../armv8-a/bit/\">bit</a> vector pair with 34-<a href=\"../../armv8-a/bit/\">bit</a> offset.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xscvhpdp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Convert Half-Precision to Double",
      "summary": "Converts a 16-bit float to 64-bit double.",
      "syntax": "xscvhpdp XT, XB",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | 0 | XB | 344",
        "hex_opcode": "0xF0000158",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "344",
            "clean": "344"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        }
      ],
      "extension": "VSX",
      "slug": "xscvhpdp",
      "rel_url": "powerisa/xscvhpdp/",
      "linked_summary": "Converts a 16-<a href=\"../../armv8-a/bit/\">bit</a> float to 64-<a href=\"../../armv8-a/bit/\">bit</a> double.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xscvdphp",
      "architecture": "PowerISA",
      "full_name": "VSX Scalar Convert Double to Half-Precision",
      "summary": "Converts a 64-bit double to 16-bit float.",
      "syntax": "xscvdphp XT, XB",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | 0 | XB | 376",
        "hex_opcode": "0xF0000178",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "376",
            "clean": "376"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        }
      ],
      "extension": "VSX",
      "slug": "xscvdphp",
      "rel_url": "powerisa/xscvdphp/",
      "linked_summary": "Converts a 64-<a href=\"../../armv8-a/bit/\">bit</a> double to 16-<a href=\"../../armv8-a/bit/\">bit</a> float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvcvhpsp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Convert Half-Precision to Single",
      "summary": "Converts four 16-bit floats to four 32-bit floats.",
      "syntax": "xvcvhpsp XT, XB",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | 0 | XB | 409",
        "hex_opcode": "0xF0000199",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "409",
            "clean": "409"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        }
      ],
      "extension": "VSX",
      "slug": "xvcvhpsp",
      "rel_url": "powerisa/xvcvhpsp/",
      "linked_summary": "Converts four 16-<a href=\"../../armv8-a/bit/\">bit</a> floats to four 32-<a href=\"../../armv8-a/bit/\">bit</a> floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xvcvsphp",
      "architecture": "PowerISA",
      "full_name": "VSX Vector Convert Single to Half-Precision",
      "summary": "Converts four 32-bit floats to four 16-bit floats.",
      "syntax": "xvcvsphp XT, XB",
      "encoding": {
        "format": "XX2-form",
        "binary_pattern": "60 | XT | 0 | XB | 441",
        "hex_opcode": "0xF00001B9",
        "visual_parts": [
          {
            "raw": "60",
            "clean": "60"
          },
          {
            "raw": "XT",
            "clean": "XT"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "XB",
            "clean": "XB"
          },
          {
            "raw": "441",
            "clean": "441"
          }
        ]
      },
      "operands": [
        {
          "name": "XT",
          "desc": "Target"
        },
        {
          "name": "XB",
          "desc": "Source"
        }
      ],
      "extension": "VSX",
      "slug": "xvcvsphp",
      "rel_url": "powerisa/xvcvsphp/",
      "linked_summary": "Converts four 32-<a href=\"../../armv8-a/bit/\">bit</a> floats to four 16-<a href=\"../../armv8-a/bit/\">bit</a> floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sync",
      "architecture": "PowerISA",
      "full_name": "Synchronize",
      "summary": "The master memory barrier. Ensures all previous instructions appear to complete before any subsequent instructions start. (L=0: Heavyweight, L=1: Lightweight/LWSYNC).",
      "syntax": "sync L",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | / | L | 598 | /",
        "hex_opcode": "0x7C0004AC",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "L",
            "clean": "L"
          },
          {
            "raw": "598",
            "clean": "598"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "L",
          "desc": "Level (0=Heavy, 1=Light)"
        }
      ],
      "pseudocode": "MemoryBarrier(L)",
      "example": "sync 0",
      "example_note": "Full hardware fence.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">MemoryBarrier(L)</code></pre>",
      "slug": "sync",
      "rel_url": "powerisa/sync/",
      "linked_summary": "The master memory barrier. Ensures all previous instructions appear to complete before any subsequent instructions start. (L=0: Heavyweight, L=1: Lightweight/LWSYNC).",
      "linked_pseudocode": "MemoryBarrier(L)"
    },
    {
      "mnemonic": "lwsync",
      "architecture": "PowerISA",
      "full_name": "Lightweight Synchronize (Pseudo)",
      "summary": "Orders loads with loads, stores with stores, and loads with stores. Does NOT order stores with loads. (Encoded as sync 1).",
      "syntax": "lwsync",
      "encoding": {
        "format": "Pseudo",
        "binary_pattern": "sync 1",
        "hex_opcode": "0x7C2004AC",
        "visual_parts": [
          {
            "raw": "sync 1",
            "clean": "sync 1"
          }
        ]
      },
      "operands": [],
      "pseudocode": "MemoryBarrier(Light)",
      "example": "lwsync",
      "example_note": "Standard multicore barrier.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">MemoryBarrier(Light)</code></pre>",
      "slug": "lwsync",
      "rel_url": "powerisa/lwsync/",
      "linked_summary": "Orders loads with loads, stores with stores, <a href=\"../../armv8-a/and_6/\">and</a> loads with stores. Does <a href=\"../../risc-v/not/\">NOT</a> order stores with loads. (Encoded as <a href=\"../../powerisa/sync/\">sync</a> 1).",
      "linked_pseudocode": "MemoryBarrier(Light)"
    },
    {
      "mnemonic": "rfid",
      "architecture": "PowerISA",
      "full_name": "Return From Interrupt Doubleword",
      "summary": "Returns from an interrupt handler. Restores PC from SRR0 and MSR from SRR1.",
      "syntax": "rfid",
      "encoding": {
        "format": "XL-form",
        "binary_pattern": "19 | / | / | / | 18 | /",
        "hex_opcode": "0x4C000024",
        "visual_parts": [
          {
            "raw": "19",
            "clean": "19"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "18",
            "clean": "18"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [],
      "pseudocode": "PC <- SRR0; MSR <- SRR1",
      "example": "rfid",
      "example_note": "Exit Kernel Mode.",
      "extension": "Privileged",
      "pseudocode_html": "<pre><code class=\"language-clike\">PC &lt;- SRR0; MSR &lt;- SRR1</code></pre>",
      "slug": "rfid",
      "rel_url": "powerisa/rfid/",
      "linked_summary": "Returns from an interrupt handler. Restores PC from SRR0 <a href=\"../../armv8-a/and_6/\">and</a> MSR from SRR1.",
      "linked_pseudocode": "PC <- SRR0; MSR <- SRR1"
    },
    {
      "mnemonic": "tlbie",
      "architecture": "PowerISA",
      "full_name": "Translation Lookaside Buffer Invalidate Entry",
      "summary": "Invalidates a TLB entry corresponding to the address in RB.",
      "syntax": "tlbie RB, RS",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | RS | / | RB | 306 | /",
        "hex_opcode": "0x7C000264",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "RS",
            "clean": "RS"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "306",
            "clean": "306"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RB",
          "desc": "Effective Address"
        },
        {
          "name": "RS",
          "desc": "Process ID (PID)"
        }
      ],
      "pseudocode": "InvalidateTLB(RB, RS)",
      "example": "tlbie r3, r4",
      "example_note": "Flush page translation.",
      "extension": "Privileged",
      "pseudocode_html": "<pre><code class=\"language-clike\">InvalidateTLB(RB, RS)</code></pre>",
      "slug": "tlbie",
      "rel_url": "powerisa/tlbie/",
      "linked_summary": "Invalidates a TLB entry corresponding to the address <a href=\"../../x86/in/\">in</a> RB.",
      "linked_pseudocode": "InvalidateTLB(RB, RS)"
    },
    {
      "mnemonic": "slbie",
      "architecture": "PowerISA",
      "full_name": "Segment Lookaside Buffer Invalidate Entry",
      "summary": "Invalidates an SLB entry. Critical for memory management on Power systems.",
      "syntax": "slbie RB",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | / | RB | 434 | /",
        "hex_opcode": "0x7C000364",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RB",
            "clean": "RB"
          },
          {
            "raw": "434",
            "clean": "434"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "RB",
          "desc": "Effective Address"
        }
      ],
      "pseudocode": "InvalidateSLB(RB)",
      "example": "slbie r3",
      "example_note": "Flush segment translation.",
      "extension": "Privileged",
      "pseudocode_html": "<pre><code class=\"language-clike\">InvalidateSLB(RB)</code></pre>",
      "slug": "slbie",
      "rel_url": "powerisa/slbie/",
      "linked_summary": "Invalidates an SLB entry. Critical for memory management on Power systems.",
      "linked_pseudocode": "InvalidateSLB(RB)"
    },
    {
      "mnemonic": "wait",
      "architecture": "PowerISA",
      "full_name": "Wait for Interrupt",
      "summary": "Stops instruction execution and places the processor in a lower power state until an interrupt occurs.",
      "syntax": "wait WC",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | WC | / | 62 | /",
        "hex_opcode": "0x7C00007C",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "WC",
            "clean": "WC"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "62",
            "clean": "62"
          },
          {
            "raw": "/",
            "clean": "/"
          }
        ]
      },
      "operands": [
        {
          "name": "WC",
          "desc": "Wait Condition (0=Interrupt, 1=Resume)"
        }
      ],
      "pseudocode": "EnterLowPowerState()",
      "example": "wait 0",
      "example_note": "Idle CPU.",
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">EnterLowPowerState()</code></pre>",
      "slug": "wait_1",
      "rel_url": "powerisa/wait_1/",
      "linked_summary": "Stops instruction execution <a href=\"../../armv8-a/and_6/\">and</a> places the processor <a href=\"../../x86/in/\">in</a> a lower power state until an interrupt occurs.",
      "linked_pseudocode": "EnterLowPowerState()"
    },
    {
      "mnemonic": "tbegin.",
      "architecture": "PowerISA",
      "full_name": "Transaction Begin",
      "summary": "Initiates a hardware transaction. If the transaction fails, execution rolls back to this point. Sets CR0 based on success/failure.",
      "syntax": "tbegin. R",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | R | / | 654 | 1",
        "hex_opcode": "0x7C00051D",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "R",
            "clean": "R"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "654",
            "clean": "654"
          },
          {
            "raw": "1",
            "clean": "1"
          }
        ]
      },
      "operands": [
        {
          "name": "R",
          "desc": "Rollback Handler (0=External, 1=Internal)"
        }
      ],
      "pseudocode": "StartTransaction(); CR0 <- Status",
      "example": "tbegin. 0",
      "example_note": "Start atomic hardware transaction.",
      "extension": "TM (Transactional Memory)",
      "pseudocode_html": "<pre><code class=\"language-clike\">StartTransaction(); CR0 &lt;- Status</code></pre>",
      "slug": "tbegin_",
      "rel_url": "powerisa/tbegin_/",
      "linked_summary": "Initiates a hardware transaction. If the transaction fails, execution rolls back to this point. Sets CR0 based on success/failure.",
      "linked_pseudocode": "StartTransaction(); CR0 <- Status"
    },
    {
      "mnemonic": "tend.",
      "architecture": "PowerISA",
      "full_name": "Transaction End",
      "summary": "Commits the current hardware transaction. If successful, memory changes become visible atomically.",
      "syntax": "tend. A",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | A | / | 686 | 1",
        "hex_opcode": "0x7C00055D",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "A",
            "clean": "A"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "686",
            "clean": "686"
          },
          {
            "raw": "1",
            "clean": "1"
          }
        ]
      },
      "operands": [
        {
          "name": "A",
          "desc": "Abort Control"
        }
      ],
      "pseudocode": "CommitTransaction()",
      "example": "tend. 0",
      "example_note": "Commit transaction.",
      "extension": "TM (Transactional Memory)",
      "pseudocode_html": "<pre><code class=\"language-clike\">CommitTransaction()</code></pre>",
      "slug": "tend_",
      "rel_url": "powerisa/tend_/",
      "linked_summary": "Commits the current hardware transaction. If successful, memory changes become visible atomically.",
      "linked_pseudocode": "CommitTransaction()"
    },
    {
      "mnemonic": "tabort.",
      "architecture": "PowerISA",
      "full_name": "Transaction Abort",
      "summary": "Forces a transaction failure and rollback.",
      "syntax": "tabort. RA",
      "encoding": {
        "format": "X-form",
        "binary_pattern": "31 | / | RA | / | 910 | 1",
        "hex_opcode": "0x7C00071D",
        "visual_parts": [
          {
            "raw": "31",
            "clean": "31"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "RA",
            "clean": "RA"
          },
          {
            "raw": "/",
            "clean": "/"
          },
          {
            "raw": "910",
            "clean": "910"
          },
          {
            "raw": "1",
            "clean": "1"
          }
        ]
      },
      "operands": [
        {
          "name": "RA",
          "desc": "Abort Code"
        }
      ],
      "pseudocode": "AbortTransaction(RA)",
      "example": "tabort. r3",
      "example_note": "Force rollback.",
      "extension": "TM (Transactional Memory)",
      "pseudocode_html": "<pre><code class=\"language-clike\">AbortTransaction(RA)</code></pre>",
      "slug": "tabort_",
      "rel_url": "powerisa/tabort_/",
      "linked_summary": "Forces a transaction failure <a href=\"../../armv8-a/and_6/\">and</a> rollback.",
      "linked_pseudocode": "AbortTransaction(RA)"
    },
    {
      "mnemonic": "vcipher",
      "architecture": "PowerISA",
      "full_name": "Vector Cipher (AES)",
      "summary": "Performs one round of AES encryption (SubBytes, ShiftRows, MixColumns, AddRoundKey).",
      "syntax": "vcipher vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1288",
        "hex_opcode": "0x10000508",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1288",
            "clean": "1288"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target State"
        },
        {
          "name": "vA",
          "desc": "Current State"
        },
        {
          "name": "vB",
          "desc": "Round Key"
        }
      ],
      "pseudocode": "AES_Encrypt_Round(vA, vB)",
      "example": "vcipher v1, v2, v3",
      "example_note": "Hardware AES Encrypt.",
      "extension": "Vector Crypto",
      "pseudocode_html": "<pre><code class=\"language-clike\">AES_Encrypt_Round(vA, vB)</code></pre>",
      "slug": "vcipher",
      "rel_url": "powerisa/vcipher/",
      "linked_summary": "Performs one round of AES encryption (SubBytes, ShiftRows, MixColumns, AddRoundKey).",
      "linked_pseudocode": "AES_Encrypt_Round(vA, vB)"
    },
    {
      "mnemonic": "vncipher",
      "architecture": "PowerISA",
      "full_name": "Vector Inverse Cipher (AES)",
      "summary": "Performs one round of AES decryption.",
      "syntax": "vncipher vD, vA, vB",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | vB | 1352",
        "hex_opcode": "0x10000548",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "vB",
            "clean": "vB"
          },
          {
            "raw": "1352",
            "clean": "1352"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target State"
        },
        {
          "name": "vA",
          "desc": "Current State"
        },
        {
          "name": "vB",
          "desc": "Round Key"
        }
      ],
      "pseudocode": "AES_Decrypt_Round(vA, vB)",
      "example": "vncipher v1, v2, v3",
      "example_note": "Hardware AES Decrypt.",
      "extension": "Vector Crypto",
      "pseudocode_html": "<pre><code class=\"language-clike\">AES_Decrypt_Round(vA, vB)</code></pre>",
      "slug": "vncipher",
      "rel_url": "powerisa/vncipher/",
      "linked_summary": "Performs one round of AES decryption.",
      "linked_pseudocode": "AES_Decrypt_Round(vA, vB)"
    },
    {
      "mnemonic": "vshasigmaw",
      "architecture": "PowerISA",
      "full_name": "Vector SHA-256 Sigma Word",
      "summary": "Performs the Sigma0/Sigma1/sigma0/sigma1 functions for SHA-256.",
      "syntax": "vshasigmaw vD, vA, ST, SIX",
      "encoding": {
        "format": "VX-form",
        "binary_pattern": "4 | vD | vA | ST | 1666",
        "hex_opcode": "0x10000682",
        "visual_parts": [
          {
            "raw": "4",
            "clean": "4"
          },
          {
            "raw": "vD",
            "clean": "vD"
          },
          {
            "raw": "vA",
            "clean": "vA"
          },
          {
            "raw": "ST",
            "clean": "ST"
          },
          {
            "raw": "1666",
            "clean": "1666"
          }
        ]
      },
      "operands": [
        {
          "name": "vD",
          "desc": "Target"
        },
        {
          "name": "vA",
          "desc": "Source"
        },
        {
          "name": "ST",
          "desc": "Sigma Type (0/1)"
        },
        {
          "name": "SIX",
          "desc": "Shift Index (Immediate)"
        }
      ],
      "pseudocode": "SHA256_Sigma(vA, ST)",
      "example": "vshasigmaw v1, v2, 0, 0",
      "example_note": "SHA-256 Acceleration.",
      "extension": "Vector Crypto",
      "pseudocode_html": "<pre><code class=\"language-clike\">SHA256_Sigma(vA, ST)</code></pre>",
      "slug": "vshasigmaw",
      "rel_url": "powerisa/vshasigmaw/",
      "linked_summary": "Performs the Sigma0/Sigma1/sigma0/sigma1 functions for SHA-256.",
      "linked_pseudocode": "SHA256_Sigma(vA, ST)"
    }
  ]
}