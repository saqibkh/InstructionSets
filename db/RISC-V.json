[
  {
    "mnemonic": "CSRRC",
    "architecture": "RISC-V",
    "extension": "Zicsr",
    "full_name": "Control Status Register Read and Clear",
    "summary": "Reads the old value of the CSR, then clears bits in the CSR based on the mask in rs1.",
    "syntax": "CSRRC rd, csr, rs1",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "csr | rs1 | 011 | rd | 1110011",
      "hex_opcode": "0x73",
      "visual_parts": [
        {
          "raw": "csr",
          "clean": "csr"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "011",
          "clean": "011"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1110011",
          "clean": "1110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "csr",
        "desc": "CSR Address"
      },
      {
        "name": "rs1",
        "desc": "Bit Mask"
      }
    ],
    "pseudocode": "t = CSRs[csr]; CSRs[csr] = t & ~R[rs1]; R[rd] = t;",
    "example": "CSRRC x10, sstatus, x5",
    "example_note": "Clears bits in 'sstatus' where x5 is 1.",
    "linked_summary": "Reads the old value of the CSR, then clears bits <a href=\"../../x86/in/\">in</a> the CSR based on the mask <a href=\"../../x86/in/\">in</a> rs1.",
    "linked_pseudocode": "t = CSRs[csr]; CSRs[csr] = t & ~R[rs1]; R[rd] = t;"
  },
  {
    "mnemonic": "CSRRWI",
    "architecture": "RISC-V",
    "extension": "Zicsr",
    "full_name": "CSR Read/Write Immediate",
    "summary": "Updates a CSR using a 5-bit unsigned immediate (zimm) instead of a register.",
    "syntax": "CSRRWI rd, csr, uimm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "csr | uimm | 101 | rd | 1110011",
      "hex_opcode": "0x73",
      "visual_parts": [
        {
          "raw": "csr",
          "clean": "csr"
        },
        {
          "raw": "uimm",
          "clean": "uimm"
        },
        {
          "raw": "101",
          "clean": "101"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1110011",
          "clean": "1110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "csr",
        "desc": "CSR Address"
      },
      {
        "name": "uimm",
        "desc": "5-bit Unsigned Imm"
      }
    ],
    "pseudocode": "t = CSRs[csr]; CSRs[csr] = zext(uimm); R[rd] = t;",
    "example": "CSRRWI x0, 0x001, 0",
    "example_note": "Writes 0 to CSR 0x001.",
    "linked_summary": "Updates a CSR using a 5-<a href=\"../../armv8-a/bit/\">bit</a> unsigned immediate (zimm) instead of a register.",
    "linked_pseudocode": "t = CSRs[csr]; CSRs[csr] = zext(uimm); R[rd] = t;"
  },
  {
    "mnemonic": "CSRRSI",
    "architecture": "RISC-V",
    "extension": "Zicsr",
    "full_name": "CSR Read and Set Immediate",
    "summary": "Sets bits in a CSR using a 5-bit unsigned immediate.",
    "syntax": "CSRRSI rd, csr, uimm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "csr | uimm | 110 | rd | 1110011",
      "hex_opcode": "0x73",
      "visual_parts": [
        {
          "raw": "csr",
          "clean": "csr"
        },
        {
          "raw": "uimm",
          "clean": "uimm"
        },
        {
          "raw": "110",
          "clean": "110"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1110011",
          "clean": "1110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "csr",
        "desc": "CSR Address"
      },
      {
        "name": "uimm",
        "desc": "Bit Mask"
      }
    ],
    "pseudocode": "t = CSRs[csr]; CSRs[csr] = t | zext(uimm); R[rd] = t;",
    "example": "CSRRSI x0, sstatus, 1",
    "example_note": "Sets bit 0 of sstatus.",
    "linked_summary": "Sets bits <a href=\"../../x86/in/\">in</a> a CSR using a 5-<a href=\"../../armv8-a/bit/\">bit</a> unsigned immediate.",
    "linked_pseudocode": "t = CSRs[csr]; CSRs[csr] = t | zext(uimm); R[rd] = t;"
  },
  {
    "mnemonic": "CSRRCI",
    "architecture": "RISC-V",
    "extension": "Zicsr",
    "full_name": "CSR Read and Clear Immediate",
    "summary": "Clears bits in a CSR using a 5-bit unsigned immediate.",
    "syntax": "CSRRCI rd, csr, uimm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "csr | uimm | 111 | rd | 1110011",
      "hex_opcode": "0x73",
      "visual_parts": [
        {
          "raw": "csr",
          "clean": "csr"
        },
        {
          "raw": "uimm",
          "clean": "uimm"
        },
        {
          "raw": "111",
          "clean": "111"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1110011",
          "clean": "1110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "csr",
        "desc": "CSR Address"
      },
      {
        "name": "uimm",
        "desc": "Bit Mask"
      }
    ],
    "pseudocode": "t = CSRs[csr]; CSRs[csr] = t & ~zext(uimm); R[rd] = t;",
    "example": "CSRRCI x0, sstatus, 2",
    "example_note": "Clears bit 1 of sstatus.",
    "linked_summary": "Clears bits <a href=\"../../x86/in/\">in</a> a CSR using a 5-<a href=\"../../armv8-a/bit/\">bit</a> unsigned immediate.",
    "linked_pseudocode": "t = CSRs[csr]; CSRs[csr] = t & ~zext(uimm); R[rd] = t;"
  },
  {
    "mnemonic": "FLD",
    "architecture": "RISC-V",
    "extension": "D (Double)",
    "full_name": "Float Load Double",
    "summary": "Loads a 64-bit double-precision floating-point value from memory.",
    "syntax": "FLD rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "offset | rs1 | 011 | rd | 0000111",
      "hex_opcode": "0x07",
      "visual_parts": [
        {
          "raw": "offset",
          "clean": "offset"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "011",
          "clean": "011"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0000111",
          "clean": "0000111"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Float Reg)"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "F[rd] = M[R[rs1] + sext(offset)][63:0];",
    "example": "FLD f1, 8(x10)",
    "example_note": "Loads double from address x10+8.",
    "linked_summary": "Loads a 64-<a href=\"../../armv8-a/bit/\">bit</a> double-precision floating-point value from memory.",
    "linked_pseudocode": "F[rd] = M[R[rs1] + sext(offset)][63:0];"
  },
  {
    "mnemonic": "FSD",
    "architecture": "RISC-V",
    "extension": "D (Double)",
    "full_name": "Float Store Double",
    "summary": "Stores a 64-bit double-precision floating-point value to memory.",
    "syntax": "FSD rs2, offset(rs1)",
    "encoding": {
      "format": "S-Type",
      "binary_pattern": "imm[11:5] | rs2 | rs1 | 011 | imm[4:0] | 0100111",
      "hex_opcode": "0x27",
      "visual_parts": [
        {
          "raw": "imm[11:5]",
          "clean": "imm"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "011",
          "clean": "011"
        },
        {
          "raw": "imm[4:0]",
          "clean": "imm"
        },
        {
          "raw": "0100111",
          "clean": "0100111"
        }
      ]
    },
    "operands": [
      {
        "name": "rs2",
        "desc": "Src (Float Reg)"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "M[R[rs1] + sext(offset)][63:0] = F[rs2];",
    "example": "FSD f1, 16(x2)",
    "example_note": "Stores f1 to stack+16.",
    "linked_summary": "Stores a 64-<a href=\"../../armv8-a/bit/\">bit</a> double-precision floating-point value to memory.",
    "linked_pseudocode": "M[R[rs1] + sext(offset)][63:0] = F[rs2];"
  },
  {
    "mnemonic": "FADD.D",
    "architecture": "RISC-V",
    "extension": "D (Double)",
    "full_name": "Float Add Double",
    "summary": "Performs double-precision floating-point addition.",
    "syntax": "FADD.D rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000001 | rs2 | rs1 | 000 | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "0000001",
          "clean": "0000001"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Src 1"
      },
      {
        "name": "rs2",
        "desc": "Src 2"
      }
    ],
    "pseudocode": "F[rd] = F[rs1] + F[rs2];",
    "example": "FADD.D f0, f1, f2",
    "example_note": "64-bit float addition.",
    "linked_summary": "Performs double-precision floating-point addition.",
    "linked_pseudocode": "F[rd] = F[rs1] + F[rs2];"
  },
  {
    "mnemonic": "FSUB.D",
    "architecture": "RISC-V",
    "extension": "D (Double)",
    "full_name": "Float Subtract Double",
    "summary": "Performs double-precision floating-point subtraction.",
    "syntax": "FSUB.D rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000101 | rs2 | rs1 | 000 | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "0000101",
          "clean": "0000101"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Src 1"
      },
      {
        "name": "rs2",
        "desc": "Src 2"
      }
    ],
    "pseudocode": "F[rd] = F[rs1] - F[rs2];",
    "example": "FSUB.D f0, f1, f2",
    "example_note": "64-bit float subtraction.",
    "linked_summary": "Performs double-precision floating-point subtraction.",
    "linked_pseudocode": "F[rd] = F[rs1] - F[rs2];"
  },
  {
    "mnemonic": "FMUL.D",
    "architecture": "RISC-V",
    "extension": "D (Double)",
    "full_name": "Float Multiply Double",
    "summary": "Performs double-precision floating-point multiplication.",
    "syntax": "FMUL.D rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0001001 | rs2 | rs1 | 000 | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "0001001",
          "clean": "0001001"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Src 1"
      },
      {
        "name": "rs2",
        "desc": "Src 2"
      }
    ],
    "pseudocode": "F[rd] = F[rs1] * F[rs2];",
    "example": "FMUL.D f0, f1, f2",
    "example_note": "64-bit float multiplication.",
    "linked_summary": "Performs double-precision floating-point multiplication.",
    "linked_pseudocode": "F[rd] = F[rs1] * F[rs2];"
  },
  {
    "mnemonic": "FDIV.D",
    "architecture": "RISC-V",
    "extension": "D (Double)",
    "full_name": "Float Divide Double",
    "summary": "Performs double-precision floating-point division.",
    "syntax": "FDIV.D rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0001101 | rs2 | rs1 | 000 | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "0001101",
          "clean": "0001101"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Dividend"
      },
      {
        "name": "rs2",
        "desc": "Divisor"
      }
    ],
    "pseudocode": "F[rd] = F[rs1] / F[rs2];",
    "example": "FDIV.D f0, f1, f2",
    "example_note": "64-bit float division.",
    "linked_summary": "Performs double-precision floating-point division.",
    "linked_pseudocode": "F[rd] = F[rs1] / F[rs2];"
  },
  {
    "mnemonic": "AMOOR.W",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic OR Word",
    "summary": "Atomically performs bitwise OR on a word in memory.",
    "syntax": "AMOOR.W rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "01000 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
      "hex_opcode": "0x2F",
      "visual_parts": [
        {
          "raw": "01000",
          "clean": "01000"
        },
        {
          "raw": "aq",
          "clean": "aq"
        },
        {
          "raw": "rl",
          "clean": "rl"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "010",
          "clean": "010"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0101111",
          "clean": "0101111"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Operand"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp | R[rs2]; R[rd] = temp;",
    "example": "AMOOR.W x10, x11, (x12)",
    "example_note": "Atomic OR.",
    "linked_summary": "Atomically performs bitwise <a href=\"../../risc-v/or/\">OR</a> on a word <a href=\"../../x86/in/\">in</a> memory.",
    "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp | R[rs2]; R[rd] = temp;"
  },
  {
    "mnemonic": "AMOXOR.W",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic XOR Word",
    "summary": "Atomically performs bitwise XOR on a word in memory.",
    "syntax": "AMOXOR.W rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "00100 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
      "hex_opcode": "0x2F",
      "visual_parts": [
        {
          "raw": "00100",
          "clean": "00100"
        },
        {
          "raw": "aq",
          "clean": "aq"
        },
        {
          "raw": "rl",
          "clean": "rl"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "010",
          "clean": "010"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0101111",
          "clean": "0101111"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Operand"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp ^ R[rs2]; R[rd] = temp;",
    "example": "AMOXOR.W x10, x11, (x12)",
    "example_note": "Atomic XOR.",
    "linked_summary": "Atomically performs bitwise <a href=\"../../risc-v/xor/\">XOR</a> on a word <a href=\"../../x86/in/\">in</a> memory.",
    "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp ^ R[rs2]; R[rd] = temp;"
  },
  {
    "mnemonic": "AMOMAX.W",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic Max Word",
    "summary": "Atomically updates memory with the maximum of the memory value and register value (Signed).",
    "syntax": "AMOMAX.W rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "10100 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
      "hex_opcode": "0x2F",
      "visual_parts": [
        {
          "raw": "10100",
          "clean": "10100"
        },
        {
          "raw": "aq",
          "clean": "aq"
        },
        {
          "raw": "rl",
          "clean": "rl"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "010",
          "clean": "010"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0101111",
          "clean": "0101111"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Operand"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = max(temp, R[rs2]); R[rd] = temp;",
    "example": "AMOMAX.W x10, x11, (x12)",
    "example_note": "Atomic Signed Max.",
    "linked_summary": "Atomically updates memory with the maximum of the memory value <a href=\"../../armv8-a/and/\">and</a> register value (Signed).",
    "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = max(temp, R[rs2]); R[rd] = temp;"
  },
  {
    "mnemonic": "AMOMIN.W",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic Min Word",
    "summary": "Atomically updates memory with the minimum of the memory value and register value (Signed).",
    "syntax": "AMOMIN.W rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "10000 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
      "hex_opcode": "0x2F",
      "visual_parts": [
        {
          "raw": "10000",
          "clean": "10000"
        },
        {
          "raw": "aq",
          "clean": "aq"
        },
        {
          "raw": "rl",
          "clean": "rl"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "010",
          "clean": "010"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0101111",
          "clean": "0101111"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Operand"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = min(temp, R[rs2]); R[rd] = temp;",
    "example": "AMOMIN.W x10, x11, (x12)",
    "example_note": "Atomic Signed Min.",
    "linked_summary": "Atomically updates memory with the minimum of the memory value <a href=\"../../armv8-a/and/\">and</a> register value (Signed).",
    "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = min(temp, R[rs2]); R[rd] = temp;"
  },
  {
    "mnemonic": "URET",
    "architecture": "RISC-V",
    "extension": "Privileged",
    "full_name": "User Return",
    "summary": "Returns from a user-mode trap handler (requires N extension).",
    "syntax": "URET",
    "encoding": {
      "format": "R-Type (System)",
      "binary_pattern": "0000000 | 00010 | 00000 | 000 | 00000 | 1110011",
      "hex_opcode": "0x73",
      "visual_parts": [
        {
          "raw": "0000000",
          "clean": "0000000"
        },
        {
          "raw": "00010",
          "clean": "00010"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "1110011",
          "clean": "1110011"
        }
      ]
    },
    "operands": [],
    "pseudocode": "PC = UEPC; Priv = U; UIE = UPIE;",
    "example": "URET",
    "example_note": "Return from User-mode exception.",
    "linked_summary": "Returns from a user-mode <a href=\"../../powerisa/trap/\">trap</a> handler (requires N extension).",
    "linked_pseudocode": "PC = UEPC; Priv = U; UIE = UPIE;"
  },
  {
    "mnemonic": "AMOADD.D",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic Add Doubleword",
    "summary": "Atomically adds a value to a 64-bit doubleword in memory.",
    "syntax": "AMOADD.D rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "00000 | aq | rl | rs2 | rs1 | 011 | rd | 0101111",
      "hex_opcode": "0x2F",
      "visual_parts": [
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "aq",
          "clean": "aq"
        },
        {
          "raw": "rl",
          "clean": "rl"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "011",
          "clean": "011"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0101111",
          "clean": "0101111"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Value to Add"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp + R[rs2]; R[rd] = temp;",
    "example": "AMOADD.D x10, x11, (x12)",
    "example_note": "64-bit atomic add.",
    "linked_summary": "Atomically <a href=\"../../armv8-a/adds/\">adds</a> a value to a 64-<a href=\"../../armv8-a/bit/\">bit</a> doubleword <a href=\"../../x86/in/\">in</a> memory.",
    "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp + R[rs2]; R[rd] = temp;"
  },
  {
    "mnemonic": "AMOSWAP.D",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic Swap Doubleword",
    "summary": "Atomically swaps a 64-bit value in memory with a register.",
    "syntax": "AMOSWAP.D rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "00001 | aq | rl | rs2 | rs1 | 011 | rd | 0101111",
      "hex_opcode": "0x2F",
      "visual_parts": [
        {
          "raw": "00001",
          "clean": "00001"
        },
        {
          "raw": "aq",
          "clean": "aq"
        },
        {
          "raw": "rl",
          "clean": "rl"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "011",
          "clean": "011"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0101111",
          "clean": "0101111"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "New Value"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = R[rs2]; R[rd] = temp;",
    "example": "AMOSWAP.D x10, x11, (x12)",
    "example_note": "64-bit atomic swap.",
    "linked_summary": "Atomically swaps a 64-<a href=\"../../armv8-a/bit/\">bit</a> value <a href=\"../../x86/in/\">in</a> memory with a register.",
    "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = R[rs2]; R[rd] = temp;"
  },
  {
    "mnemonic": "AMOAND.D",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic AND Doubleword",
    "summary": "Atomically performs bitwise AND on a 64-bit doubleword in memory.",
    "syntax": "AMOAND.D rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "01100 | aq | rl | rs2 | rs1 | 011 | rd | 0101111",
      "hex_opcode": "0x2F",
      "visual_parts": [
        {
          "raw": "01100",
          "clean": "01100"
        },
        {
          "raw": "aq",
          "clean": "aq"
        },
        {
          "raw": "rl",
          "clean": "rl"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "011",
          "clean": "011"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0101111",
          "clean": "0101111"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Operand"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp & R[rs2]; R[rd] = temp;",
    "example": "AMOAND.D x5, x6, (x7)",
    "example_note": "64-bit atomic AND.",
    "linked_summary": "Atomically performs bitwise <a href=\"../../risc-v/and/\">AND</a> on a 64-<a href=\"../../armv8-a/bit/\">bit</a> doubleword <a href=\"../../x86/in/\">in</a> memory.",
    "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp & R[rs2]; R[rd] = temp;"
  },
  {
    "mnemonic": "AMOOR.D",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic OR Doubleword",
    "summary": "Atomically performs bitwise OR on a 64-bit doubleword in memory.",
    "syntax": "AMOOR.D rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "01000 | aq | rl | rs2 | rs1 | 011 | rd | 0101111",
      "hex_opcode": "0x2F",
      "visual_parts": [
        {
          "raw": "01000",
          "clean": "01000"
        },
        {
          "raw": "aq",
          "clean": "aq"
        },
        {
          "raw": "rl",
          "clean": "rl"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "011",
          "clean": "011"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0101111",
          "clean": "0101111"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Operand"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp | R[rs2]; R[rd] = temp;",
    "example": "AMOOR.D x10, x11, (x12)",
    "example_note": "64-bit atomic OR.",
    "linked_summary": "Atomically performs bitwise <a href=\"../../risc-v/or/\">OR</a> on a 64-<a href=\"../../armv8-a/bit/\">bit</a> doubleword <a href=\"../../x86/in/\">in</a> memory.",
    "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp | R[rs2]; R[rd] = temp;"
  },
  {
    "mnemonic": "AMOXOR.D",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic XOR Doubleword",
    "summary": "Atomically performs bitwise XOR on a 64-bit doubleword in memory.",
    "syntax": "AMOXOR.D rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "00100 | aq | rl | rs2 | rs1 | 011 | rd | 0101111",
      "hex_opcode": "0x2F",
      "visual_parts": [
        {
          "raw": "00100",
          "clean": "00100"
        },
        {
          "raw": "aq",
          "clean": "aq"
        },
        {
          "raw": "rl",
          "clean": "rl"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "011",
          "clean": "011"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0101111",
          "clean": "0101111"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Operand"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp ^ R[rs2]; R[rd] = temp;",
    "example": "AMOXOR.D x10, x11, (x12)",
    "example_note": "64-bit atomic XOR.",
    "linked_summary": "Atomically performs bitwise <a href=\"../../risc-v/xor/\">XOR</a> on a 64-<a href=\"../../armv8-a/bit/\">bit</a> doubleword <a href=\"../../x86/in/\">in</a> memory.",
    "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp ^ R[rs2]; R[rd] = temp;"
  },
  {
    "mnemonic": "AMOMAX.D",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic Max Doubleword",
    "summary": "Atomically updates memory with the maximum of the memory value and register value (64-bit Signed).",
    "syntax": "AMOMAX.D rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "10100 | aq | rl | rs2 | rs1 | 011 | rd | 0101111",
      "hex_opcode": "0x2F",
      "visual_parts": [
        {
          "raw": "10100",
          "clean": "10100"
        },
        {
          "raw": "aq",
          "clean": "aq"
        },
        {
          "raw": "rl",
          "clean": "rl"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "011",
          "clean": "011"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0101111",
          "clean": "0101111"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Operand"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = max(temp, R[rs2]); R[rd] = temp;",
    "example": "AMOMAX.D x10, x11, (x12)",
    "example_note": "64-bit atomic max.",
    "linked_summary": "Atomically updates memory with the maximum of the memory value <a href=\"../../armv8-a/and/\">and</a> register value (64-<a href=\"../../armv8-a/bit/\">bit</a> Signed).",
    "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = max(temp, R[rs2]); R[rd] = temp;"
  },
  {
    "mnemonic": "AMOMIN.D",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic Min Doubleword",
    "summary": "Atomically updates memory with the minimum of the memory value and register value (64-bit Signed).",
    "syntax": "AMOMIN.D rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "10000 | aq | rl | rs2 | rs1 | 011 | rd | 0101111",
      "hex_opcode": "0x2F",
      "visual_parts": [
        {
          "raw": "10000",
          "clean": "10000"
        },
        {
          "raw": "aq",
          "clean": "aq"
        },
        {
          "raw": "rl",
          "clean": "rl"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "011",
          "clean": "011"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0101111",
          "clean": "0101111"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Operand"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = min(temp, R[rs2]); R[rd] = temp;",
    "example": "AMOMIN.D x10, x11, (x12)",
    "example_note": "64-bit atomic min.",
    "linked_summary": "Atomically updates memory with the minimum of the memory value <a href=\"../../armv8-a/and/\">and</a> register value (64-<a href=\"../../armv8-a/bit/\">bit</a> Signed).",
    "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = min(temp, R[rs2]); R[rd] = temp;"
  },
  {
    "mnemonic": "SC.D",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Store Conditional Doubleword",
    "summary": "Conditionally stores a 64-bit value to memory if the reservation is valid.",
    "syntax": "SC.D rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "00011 | aq | rl | rs2 | rs1 | 011 | rd | 0101111",
      "hex_opcode": "0x2F",
      "visual_parts": [
        {
          "raw": "00011",
          "clean": "00011"
        },
        {
          "raw": "aq",
          "clean": "aq"
        },
        {
          "raw": "rl",
          "clean": "rl"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "011",
          "clean": "011"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0101111",
          "clean": "0101111"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (0=Success)"
      },
      {
        "name": "rs2",
        "desc": "Source Value"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "if (ReservationValid) { M[R[rs1]] = R[rs2]; R[rd] = 0; } else { R[rd] = 1; }",
    "example": "SC.D x10, x11, (x12)",
    "example_note": "64-bit conditional store.",
    "linked_summary": "Conditionally stores a 64-<a href=\"../../armv8-a/bit/\">bit</a> value to memory if the reservation is valid.",
    "linked_pseudocode": "if (ReservationValid) { M[R[rs1]] = R[rs2]; R[rd] = 0; } else { R[rd] = 1; }"
  },
  {
    "mnemonic": "FMADD.S",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Float Fused Multiply-Add (Single)",
    "summary": "Computes (rs1 * rs2) + rs3 with a single rounding.",
    "syntax": "FMADD.S rd, rs1, rs2, rs3",
    "encoding": {
      "format": "R4-Type",
      "binary_pattern": "rs3 | 00 | rs2 | rs1 | rm | rd | 1000011",
      "hex_opcode": "0x43",
      "visual_parts": [
        {
          "raw": "rs3",
          "clean": "rs3"
        },
        {
          "raw": "00",
          "clean": "00"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "rm",
          "clean": "rm"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1000011",
          "clean": "1000011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Src 1"
      },
      {
        "name": "rs2",
        "desc": "Src 2"
      },
      {
        "name": "rs3",
        "desc": "Src 3"
      }
    ],
    "pseudocode": "F[rd] = (F[rs1] * F[rs2]) + F[rs3];",
    "example": "FMADD.S f0, f1, f2, f3",
    "example_note": "f0 = (f1 * f2) + f3",
    "linked_summary": "Computes (rs1 * rs2) + rs3 with a single rounding.",
    "linked_pseudocode": "F[rd] = (F[rs1] * F[rs2]) + F[rs3];"
  },
  {
    "mnemonic": "FMADD.D",
    "architecture": "RISC-V",
    "extension": "D (Double)",
    "full_name": "Float Fused Multiply-Add (Double)",
    "summary": "Computes (rs1 * rs2) + rs3 with a single rounding (64-bit).",
    "syntax": "FMADD.D rd, rs1, rs2, rs3",
    "encoding": {
      "format": "R4-Type",
      "binary_pattern": "rs3 | 01 | rs2 | rs1 | rm | rd | 1000011",
      "hex_opcode": "0x43",
      "visual_parts": [
        {
          "raw": "rs3",
          "clean": "rs3"
        },
        {
          "raw": "01",
          "clean": "01"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "rm",
          "clean": "rm"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1000011",
          "clean": "1000011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Src 1"
      },
      {
        "name": "rs2",
        "desc": "Src 2"
      },
      {
        "name": "rs3",
        "desc": "Src 3"
      }
    ],
    "pseudocode": "F[rd] = (F[rs1] * F[rs2]) + F[rs3];",
    "example": "FMADD.D f0, f1, f2, f3",
    "example_note": "64-bit fused multiply-add.",
    "linked_summary": "Computes (rs1 * rs2) + rs3 with a single rounding (64-<a href=\"../../armv8-a/bit/\">bit</a>).",
    "linked_pseudocode": "F[rd] = (F[rs1] * F[rs2]) + F[rs3];"
  },
  {
    "mnemonic": "CSRR",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Control Status Register Read",
    "summary": "Reads the value of a CSR into a register.",
    "syntax": "CSRR rd, csr",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "CSRRS rd, csr, x0",
      "hex_opcode": "See CSRRS",
      "visual_parts": [
        {
          "raw": "CSRRS rd, csr, x0",
          "clean": "CSRRS rd, csr, x0"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "csr",
        "desc": "CSR Address"
      }
    ],
    "pseudocode": "R[rd] = CSRs[csr];",
    "example": "CSRR x10, mstatus",
    "example_note": "Read mstatus.",
    "linked_summary": "Reads the value of a CSR into a register.",
    "linked_pseudocode": "R[rd] = CSRs[csr];"
  },
  {
    "mnemonic": "CSRW",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Control Status Register Write",
    "summary": "Writes a register value to a CSR.",
    "syntax": "CSRW csr, rs",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "CSRRW x0, csr, rs",
      "hex_opcode": "See CSRRW",
      "visual_parts": [
        {
          "raw": "CSRRW x0, csr, rs",
          "clean": "CSRRW x0, csr, rs"
        }
      ]
    },
    "operands": [
      {
        "name": "csr",
        "desc": "CSR Address"
      },
      {
        "name": "rs",
        "desc": "Source"
      }
    ],
    "pseudocode": "CSRs[csr] = R[rs];",
    "example": "CSRW mepc, x10",
    "example_note": "Write address in x10 to mepc.",
    "linked_summary": "Writes a register value to a CSR.",
    "linked_pseudocode": "CSRs[csr] = R[rs];"
  },
  {
    "mnemonic": "CSRS",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Control Status Register Set",
    "summary": "Sets bits in a CSR (bitwise OR).",
    "syntax": "CSRS csr, rs",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "CSRRS x0, csr, rs",
      "hex_opcode": "See CSRRS",
      "visual_parts": [
        {
          "raw": "CSRRS x0, csr, rs",
          "clean": "CSRRS x0, csr, rs"
        }
      ]
    },
    "operands": [
      {
        "name": "csr",
        "desc": "CSR Address"
      },
      {
        "name": "rs",
        "desc": "Bit Mask"
      }
    ],
    "pseudocode": "CSRs[csr] |= R[rs];",
    "example": "CSRS sstatus, x5",
    "example_note": "Set bits in sstatus.",
    "linked_summary": "Sets bits <a href=\"../../x86/in/\">in</a> a CSR (bitwise <a href=\"../../risc-v/or/\">OR</a>).",
    "linked_pseudocode": "CSRs[csr] |= R[rs];"
  },
  {
    "mnemonic": "CSRC",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Control Status Register Clear",
    "summary": "Clears bits in a CSR (bitwise AND NOT).",
    "syntax": "CSRC csr, rs",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "CSRRC x0, csr, rs",
      "hex_opcode": "See CSRRC",
      "visual_parts": [
        {
          "raw": "CSRRC x0, csr, rs",
          "clean": "CSRRC x0, csr, rs"
        }
      ]
    },
    "operands": [
      {
        "name": "csr",
        "desc": "CSR Address"
      },
      {
        "name": "rs",
        "desc": "Bit Mask"
      }
    ],
    "pseudocode": "CSRs[csr] &= ~R[rs];",
    "example": "CSRC sstatus, x5",
    "example_note": "Clear bits in sstatus.",
    "linked_summary": "Clears bits <a href=\"../../x86/in/\">in</a> a CSR (bitwise <a href=\"../../risc-v/and/\">AND</a> <a href=\"../../risc-v/not/\">NOT</a>).",
    "linked_pseudocode": "CSRs[csr] &= ~R[rs];"
  },
  {
    "mnemonic": "FCVT.LU.D",
    "architecture": "RISC-V",
    "extension": "D (Double)",
    "full_name": "Convert Double to Unsigned Long",
    "summary": "Converts a double-precision float to a 64-bit unsigned integer.",
    "syntax": "FCVT.LU.D rd, rs1",
    "encoding": {
      "format": "I-Type (Float)",
      "binary_pattern": "1100001 | 00011 | rs1 | rm | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "1100001",
          "clean": "1100001"
        },
        {
          "raw": "00011",
          "clean": "00011"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "rm",
          "clean": "rm"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (ULong)"
      },
      {
        "name": "rs1",
        "desc": "Source (Double)"
      }
    ],
    "pseudocode": "R[rd] = f64_to_u64(F[rs1]);",
    "example": "FCVT.LU.D x10, f0",
    "example_note": "Double -> Unsigned 64-bit Int.",
    "linked_summary": "Converts a double-precision float to a 64-<a href=\"../../armv8-a/bit/\">bit</a> unsigned integer.",
    "linked_pseudocode": "R[rd] = f64_to_u64(F[rs1]);"
  },
  {
    "mnemonic": "FLH",
    "architecture": "RISC-V",
    "extension": "Zfh (Half-Float)",
    "full_name": "Float Load Halfword",
    "summary": "Loads a 16-bit half-precision float from memory.",
    "syntax": "FLH rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "offset | rs1 | 001 | rd | 0000111",
      "hex_opcode": "0x07",
      "visual_parts": [
        {
          "raw": "offset",
          "clean": "offset"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0000111",
          "clean": "0000111"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Float)"
      },
      {
        "name": "rs1",
        "desc": "Base"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "F[rd] = M[R[rs1] + sext(offset)][15:0];",
    "example": "FLH f1, 0(x10)",
    "example_note": "Load 16-bit float.",
    "linked_summary": "Loads a 16-<a href=\"../../armv8-a/bit/\">bit</a> half-precision float from memory.",
    "linked_pseudocode": "F[rd] = M[R[rs1] + sext(offset)][15:0];"
  },
  {
    "mnemonic": "FSH",
    "architecture": "RISC-V",
    "extension": "Zfh (Half-Float)",
    "full_name": "Float Store Halfword",
    "summary": "Stores a 16-bit half-precision float to memory.",
    "syntax": "FSH rs2, offset(rs1)",
    "encoding": {
      "format": "S-Type",
      "binary_pattern": "imm | rs2 | rs1 | 001 | imm | 0100111",
      "hex_opcode": "0x27",
      "visual_parts": [
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "0100111",
          "clean": "0100111"
        }
      ]
    },
    "operands": [
      {
        "name": "rs2",
        "desc": "Source"
      },
      {
        "name": "rs1",
        "desc": "Base"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "M[R[rs1] + sext(offset)][15:0] = F[rs2];",
    "example": "FSH f1, 0(x10)",
    "example_note": "Store 16-bit float.",
    "linked_summary": "Stores a 16-<a href=\"../../armv8-a/bit/\">bit</a> half-precision float to memory.",
    "linked_pseudocode": "M[R[rs1] + sext(offset)][15:0] = F[rs2];"
  },
  {
    "mnemonic": "FADD.H",
    "architecture": "RISC-V",
    "extension": "Zfh (Half-Float)",
    "full_name": "Float Add Half",
    "summary": "Performs 16-bit floating-point addition.",
    "syntax": "FADD.H rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000100 | rs2 | rs1 | 000 | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "0000100",
          "clean": "0000100"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Src 1"
      },
      {
        "name": "rs2",
        "desc": "Src 2"
      }
    ],
    "pseudocode": "F[rd] = F[rs1] + F[rs2];",
    "example": "FADD.H f0, f1, f2",
    "example_note": "16-bit float add.",
    "linked_summary": "Performs 16-<a href=\"../../armv8-a/bit/\">bit</a> floating-point addition.",
    "linked_pseudocode": "F[rd] = F[rs1] + F[rs2];"
  },
  {
    "mnemonic": "FCVT.S.H",
    "architecture": "RISC-V",
    "extension": "Zfh (Half-Float)",
    "full_name": "Convert Half to Single",
    "summary": "Converts a 16-bit half-precision float to a 32-bit single-precision float.",
    "syntax": "FCVT.S.H rd, rs1",
    "encoding": {
      "format": "I-Type (Float)",
      "binary_pattern": "0100000 | 00010 | rs1 | rm | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "0100000",
          "clean": "0100000"
        },
        {
          "raw": "00010",
          "clean": "00010"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "rm",
          "clean": "rm"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Single)"
      },
      {
        "name": "rs1",
        "desc": "Source (Half)"
      }
    ],
    "pseudocode": "F[rd] = f16_to_f32(F[rs1]);",
    "example": "FCVT.S.H f0, f1",
    "example_note": "Promote Half to Float.",
    "linked_summary": "Converts a 16-<a href=\"../../armv8-a/bit/\">bit</a> half-precision float to a 32-<a href=\"../../armv8-a/bit/\">bit</a> single-precision float.",
    "linked_pseudocode": "F[rd] = f16_to_f32(F[rs1]);"
  },
  {
    "mnemonic": "FCVT.H.S",
    "architecture": "RISC-V",
    "extension": "Zfh (Half-Float)",
    "full_name": "Convert Single to Half",
    "summary": "Converts a 32-bit single-precision float to a 16-bit half-precision float.",
    "syntax": "FCVT.H.S rd, rs1",
    "encoding": {
      "format": "I-Type (Float)",
      "binary_pattern": "0100010 | 00000 | rs1 | rm | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "0100010",
          "clean": "0100010"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "rm",
          "clean": "rm"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Half)"
      },
      {
        "name": "rs1",
        "desc": "Source (Single)"
      }
    ],
    "pseudocode": "F[rd] = f32_to_f16(F[rs1]);",
    "example": "FCVT.H.S f0, f1",
    "example_note": "Demote Float to Half.",
    "linked_summary": "Converts a 32-<a href=\"../../armv8-a/bit/\">bit</a> single-precision float to a 16-<a href=\"../../armv8-a/bit/\">bit</a> half-precision float.",
    "linked_pseudocode": "F[rd] = f32_to_f16(F[rs1]);"
  },
  {
    "mnemonic": "SUBW",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Subtract Word",
    "summary": "Subtracts the lower 32 bits of rs2 from rs1 and sign-extends the result to 64 bits.",
    "syntax": "SUBW rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0100000 | rs2 | rs1 | 000 | rd | 0111011",
      "hex_opcode": "0x3B",
      "visual_parts": [
        {
          "raw": "0100000",
          "clean": "0100000"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0111011",
          "clean": "0111011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Minuend"
      },
      {
        "name": "rs2",
        "desc": "Subtrahend"
      }
    ],
    "pseudocode": "R[rd] = sext((R[rs1] - R[rs2])[31:0]);",
    "example": "SUBW x10, x11, x12",
    "example_note": "32-bit subtraction on 64-bit registers.",
    "linked_summary": "Subtracts the lower 32 bits of rs2 from rs1 <a href=\"../../armv8-a/and/\">and</a> sign-extends the result to 64 bits.",
    "linked_pseudocode": "R[rd] = sext((R[rs1] - R[rs2])[31:0]);"
  },
  {
    "mnemonic": "SLLW",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Shift Left Logical Word",
    "summary": "Performs a 32-bit logical left shift on rs1 by the amount in rs2 (lower 5 bits), sign-extending the result.",
    "syntax": "SLLW rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 001 | rd | 0111011",
      "hex_opcode": "0x3B",
      "visual_parts": [
        {
          "raw": "0000000",
          "clean": "0000000"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0111011",
          "clean": "0111011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "rs2",
        "desc": "Shift Amount"
      }
    ],
    "pseudocode": "R[rd] = sext((R[rs1] << (R[rs2] & 0x1F))[31:0]);",
    "example": "SLLW x5, x6, x7",
    "example_note": "32-bit shift.",
    "linked_summary": "Performs a 32-<a href=\"../../armv8-a/bit/\">bit</a> logical left shift on rs1 by the amount <a href=\"../../x86/in/\">in</a> rs2 (lower 5 bits), sign-extending the result.",
    "linked_pseudocode": "R[rd] = sext((R[rs1] << (R[rs2] & 0x1F))[31:0]);"
  },
  {
    "mnemonic": "SRLW",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Shift Right Logical Word",
    "summary": "Performs a 32-bit logical right shift on rs1 by the amount in rs2, sign-extending the result.",
    "syntax": "SRLW rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 101 | rd | 0111011",
      "hex_opcode": "0x3B",
      "visual_parts": [
        {
          "raw": "0000000",
          "clean": "0000000"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "101",
          "clean": "101"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0111011",
          "clean": "0111011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "rs2",
        "desc": "Shift Amount"
      }
    ],
    "pseudocode": "R[rd] = sext((R[rs1][31:0] >>u (R[rs2] & 0x1F)));",
    "example": "SRLW x5, x6, x7",
    "example_note": "32-bit logical right shift.",
    "linked_summary": "Performs a 32-<a href=\"../../armv8-a/bit/\">bit</a> logical right shift on rs1 by the amount <a href=\"../../x86/in/\">in</a> rs2, sign-extending the result.",
    "linked_pseudocode": "R[rd] = sext((R[rs1][31:0] >>u (R[rs2] & 0x1F)));"
  },
  {
    "mnemonic": "SRAW",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Shift Right Arithmetic Word",
    "summary": "Performs a 32-bit arithmetic right shift on rs1, sign-extending the result.",
    "syntax": "SRAW rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0100000 | rs2 | rs1 | 101 | rd | 0111011",
      "hex_opcode": "0x3B",
      "visual_parts": [
        {
          "raw": "0100000",
          "clean": "0100000"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "101",
          "clean": "101"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0111011",
          "clean": "0111011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "rs2",
        "desc": "Shift Amount"
      }
    ],
    "pseudocode": "R[rd] = sext((R[rs1][31:0] >>s (R[rs2] & 0x1F)));",
    "example": "SRAW x5, x6, x7",
    "example_note": "32-bit arithmetic right shift.",
    "linked_summary": "Performs a 32-<a href=\"../../armv8-a/bit/\">bit</a> arithmetic right shift on rs1, sign-extending the result.",
    "linked_pseudocode": "R[rd] = sext((R[rs1][31:0] >>s (R[rs2] & 0x1F)));"
  },
  {
    "mnemonic": "SLLIW",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Shift Left Logical Immediate Word",
    "summary": "Shifts the lower 32 bits of rs1 left by a constant, sign-extending the result.",
    "syntax": "SLLIW rd, rs1, shamt",
    "encoding": {
      "format": "I-Type (Shift)",
      "binary_pattern": "0000000 | shamt | rs1 | 001 | rd | 0011011",
      "hex_opcode": "0x1B",
      "visual_parts": [
        {
          "raw": "0000000",
          "clean": "0000000"
        },
        {
          "raw": "shamt",
          "clean": "shamt"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0011011",
          "clean": "0011011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "shamt",
        "desc": "Shift Amount (0-31)"
      }
    ],
    "pseudocode": "R[rd] = sext((R[rs1] << shamt)[31:0]);",
    "example": "SLLIW x10, x11, 4",
    "example_note": "Shift lower 32 bits left by 4.",
    "linked_summary": "Shifts the lower 32 bits of rs1 left by a constant, sign-extending the result.",
    "linked_pseudocode": "R[rd] = sext((R[rs1] << shamt)[31:0]);"
  },
  {
    "mnemonic": "SRLIW",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Shift Right Logical Immediate Word",
    "summary": "Logically shifts the lower 32 bits of rs1 right by a constant, sign-extending the result.",
    "syntax": "SRLIW rd, rs1, shamt",
    "encoding": {
      "format": "I-Type (Shift)",
      "binary_pattern": "0000000 | shamt | rs1 | 101 | rd | 0011011",
      "hex_opcode": "0x1B",
      "visual_parts": [
        {
          "raw": "0000000",
          "clean": "0000000"
        },
        {
          "raw": "shamt",
          "clean": "shamt"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "101",
          "clean": "101"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0011011",
          "clean": "0011011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "shamt",
        "desc": "Shift Amount"
      }
    ],
    "pseudocode": "R[rd] = sext((R[rs1][31:0] >>u shamt));",
    "example": "SRLIW x10, x11, 4",
    "example_note": "Logical right shift of lower word.",
    "linked_summary": "Logically shifts the lower 32 bits of rs1 right by a constant, sign-extending the result.",
    "linked_pseudocode": "R[rd] = sext((R[rs1][31:0] >>u shamt));"
  },
  {
    "mnemonic": "SRAIW",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Shift Right Arithmetic Immediate Word",
    "summary": "Arithmetically shifts the lower 32 bits of rs1 right by a constant, sign-extending the result.",
    "syntax": "SRAIW rd, rs1, shamt",
    "encoding": {
      "format": "I-Type (Shift)",
      "binary_pattern": "0100000 | shamt | rs1 | 101 | rd | 0011011",
      "hex_opcode": "0x1B",
      "visual_parts": [
        {
          "raw": "0100000",
          "clean": "0100000"
        },
        {
          "raw": "shamt",
          "clean": "shamt"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "101",
          "clean": "101"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0011011",
          "clean": "0011011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "shamt",
        "desc": "Shift Amount"
      }
    ],
    "pseudocode": "R[rd] = sext((R[rs1][31:0] >>s shamt));",
    "example": "SRAIW x10, x11, 4",
    "example_note": "Arithmetic right shift of lower word.",
    "linked_summary": "Arithmetically shifts the lower 32 bits of rs1 right by a constant, sign-extending the result.",
    "linked_pseudocode": "R[rd] = sext((R[rs1][31:0] >>s shamt));"
  },
  {
    "mnemonic": "MULW",
    "architecture": "RISC-V",
    "extension": "M (RV64)",
    "full_name": "Multiply Word",
    "summary": "Performs 32-bit multiplication of rs1 and rs2, sign-extending the 32-bit result to 64 bits.",
    "syntax": "MULW rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000001 | rs2 | rs1 | 000 | rd | 0111011",
      "hex_opcode": "0x3B",
      "visual_parts": [
        {
          "raw": "0000001",
          "clean": "0000001"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0111011",
          "clean": "0111011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "R[rd] = sext((R[rs1] * R[rs2])[31:0]);",
    "example": "MULW x10, x11, x12",
    "example_note": "32-bit multiplication.",
    "linked_summary": "Performs 32-<a href=\"../../armv8-a/bit/\">bit</a> multiplication of rs1 <a href=\"../../armv8-a/and/\">and</a> rs2, sign-extending the 32-<a href=\"../../armv8-a/bit/\">bit</a> result to 64 bits.",
    "linked_pseudocode": "R[rd] = sext((R[rs1] * R[rs2])[31:0]);"
  },
  {
    "mnemonic": "DIVW",
    "architecture": "RISC-V",
    "extension": "M (RV64)",
    "full_name": "Divide Word",
    "summary": "Performs 32-bit signed division of rs1 by rs2, sign-extending the result.",
    "syntax": "DIVW rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000001 | rs2 | rs1 | 100 | rd | 0111011",
      "hex_opcode": "0x3B",
      "visual_parts": [
        {
          "raw": "0000001",
          "clean": "0000001"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "100",
          "clean": "100"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0111011",
          "clean": "0111011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Quotient"
      },
      {
        "name": "rs1",
        "desc": "Dividend"
      },
      {
        "name": "rs2",
        "desc": "Divisor"
      }
    ],
    "pseudocode": "R[rd] = sext(R[rs1][31:0] /s R[rs2][31:0]);",
    "example": "DIVW x10, x11, x12",
    "example_note": "32-bit signed division.",
    "linked_summary": "Performs 32-<a href=\"../../armv8-a/bit/\">bit</a> signed division of rs1 by rs2, sign-extending the result.",
    "linked_pseudocode": "R[rd] = sext(R[rs1][31:0] /s R[rs2][31:0]);"
  },
  {
    "mnemonic": "DIVUW",
    "architecture": "RISC-V",
    "extension": "M (RV64)",
    "full_name": "Divide Unsigned Word",
    "summary": "Performs 32-bit unsigned division of rs1 by rs2, sign-extending the result.",
    "syntax": "DIVUW rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000001 | rs2 | rs1 | 101 | rd | 0111011",
      "hex_opcode": "0x3B",
      "visual_parts": [
        {
          "raw": "0000001",
          "clean": "0000001"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "101",
          "clean": "101"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0111011",
          "clean": "0111011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Quotient"
      },
      {
        "name": "rs1",
        "desc": "Dividend"
      },
      {
        "name": "rs2",
        "desc": "Divisor"
      }
    ],
    "pseudocode": "R[rd] = sext(R[rs1][31:0] /u R[rs2][31:0]);",
    "example": "DIVUW x10, x11, x12",
    "example_note": "32-bit unsigned division.",
    "linked_summary": "Performs 32-<a href=\"../../armv8-a/bit/\">bit</a> unsigned division of rs1 by rs2, sign-extending the result.",
    "linked_pseudocode": "R[rd] = sext(R[rs1][31:0] /u R[rs2][31:0]);"
  },
  {
    "mnemonic": "REMW",
    "architecture": "RISC-V",
    "extension": "M (RV64)",
    "full_name": "Remainder Word",
    "summary": "Computes the remainder of 32-bit signed division, sign-extending the result.",
    "syntax": "REMW rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000001 | rs2 | rs1 | 110 | rd | 0111011",
      "hex_opcode": "0x3B",
      "visual_parts": [
        {
          "raw": "0000001",
          "clean": "0000001"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "110",
          "clean": "110"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0111011",
          "clean": "0111011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Remainder"
      },
      {
        "name": "rs1",
        "desc": "Dividend"
      },
      {
        "name": "rs2",
        "desc": "Divisor"
      }
    ],
    "pseudocode": "R[rd] = sext(R[rs1][31:0] %s R[rs2][31:0]);",
    "example": "REMW x10, x11, x12",
    "example_note": "32-bit signed remainder.",
    "linked_summary": "Computes the remainder of 32-<a href=\"../../armv8-a/bit/\">bit</a> signed division, sign-extending the result.",
    "linked_pseudocode": "R[rd] = sext(R[rs1][31:0] %s R[rs2][31:0]);"
  },
  {
    "mnemonic": "REMUW",
    "architecture": "RISC-V",
    "extension": "M (RV64)",
    "full_name": "Remainder Unsigned Word",
    "summary": "Computes the remainder of 32-bit unsigned division, sign-extending the result.",
    "syntax": "REMUW rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000001 | rs2 | rs1 | 111 | rd | 0111011",
      "hex_opcode": "0x3B",
      "visual_parts": [
        {
          "raw": "0000001",
          "clean": "0000001"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "111",
          "clean": "111"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0111011",
          "clean": "0111011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Remainder"
      },
      {
        "name": "rs1",
        "desc": "Dividend"
      },
      {
        "name": "rs2",
        "desc": "Divisor"
      }
    ],
    "pseudocode": "R[rd] = sext(R[rs1][31:0] %u R[rs2][31:0]);",
    "example": "REMUW x10, x11, x12",
    "example_note": "32-bit unsigned remainder.",
    "linked_summary": "Computes the remainder of 32-<a href=\"../../armv8-a/bit/\">bit</a> unsigned division, sign-extending the result.",
    "linked_pseudocode": "R[rd] = sext(R[rs1][31:0] %u R[rs2][31:0]);"
  },
  {
    "mnemonic": "FENCE.I",
    "architecture": "RISC-V",
    "extension": "Zifencei",
    "full_name": "Instruction Fence",
    "summary": "Synchronizes the instruction cache with the data cache (used after self-modifying code).",
    "syntax": "FENCE.I",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "000000000000 | 00000 | 001 | 00000 | 0001111",
      "hex_opcode": "0x0F",
      "visual_parts": [
        {
          "raw": "000000000000",
          "clean": "000000000000"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "0001111",
          "clean": "0001111"
        }
      ]
    },
    "operands": [],
    "pseudocode": "Fence(Store, Fetch);",
    "example": "FENCE.I",
    "example_note": "Flushes I-Cache; ensures previous writes are visible to instruction fetch.",
    "linked_summary": "Synchronizes the instruction cache with the data cache (used after self-modifying code).",
    "linked_pseudocode": "Fence(Store, Fetch);"
  },
  {
    "mnemonic": "HLV.B",
    "architecture": "RISC-V",
    "extension": "H (Hypervisor)",
    "full_name": "Hypervisor Load Byte",
    "summary": "Loads a byte from Guest Physical Memory (VS-stage translation only).",
    "syntax": "HLV.B rd, (rs1)",
    "encoding": {
      "format": "R-Type (System)",
      "binary_pattern": "0110000 | 00000 | rs1 | 100 | rd | 1110011",
      "hex_opcode": "0x73",
      "visual_parts": [
        {
          "raw": "0110000",
          "clean": "0110000"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "100",
          "clean": "100"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1110011",
          "clean": "1110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Guest Address"
      }
    ],
    "pseudocode": "R[rd] = sext(GuestMem[R[rs1]][7:0]);",
    "example": "HLV.B x10, (x11)",
    "example_note": "Read byte from guest memory.",
    "linked_summary": "Loads a byte from Guest Physical Memory (VS-stage translation only).",
    "linked_pseudocode": "R[rd] = sext(GuestMem[R[rs1]][7:0]);"
  },
  {
    "mnemonic": "HLV.W",
    "architecture": "RISC-V",
    "extension": "H (Hypervisor)",
    "full_name": "Hypervisor Load Word",
    "summary": "Loads a word from Guest Physical Memory (VS-stage translation only).",
    "syntax": "HLV.W rd, (rs1)",
    "encoding": {
      "format": "R-Type (System)",
      "binary_pattern": "0110100 | 00000 | rs1 | 100 | rd | 1110011",
      "hex_opcode": "0x73",
      "visual_parts": [
        {
          "raw": "0110100",
          "clean": "0110100"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "100",
          "clean": "100"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1110011",
          "clean": "1110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Guest Address"
      }
    ],
    "pseudocode": "R[rd] = sext(GuestMem[R[rs1]][31:0]);",
    "example": "HLV.W x10, (x11)",
    "example_note": "Read word from guest memory.",
    "linked_summary": "Loads a word from Guest Physical Memory (VS-stage translation only).",
    "linked_pseudocode": "R[rd] = sext(GuestMem[R[rs1]][31:0]);"
  },
  {
    "mnemonic": "HSV.B",
    "architecture": "RISC-V",
    "extension": "H (Hypervisor)",
    "full_name": "Hypervisor Store Byte",
    "summary": "Stores a byte to Guest Physical Memory.",
    "syntax": "HSV.B rs2, (rs1)",
    "encoding": {
      "format": "R-Type (System)",
      "binary_pattern": "0110001 | rs2 | rs1 | 100 | 00000 | 1110011",
      "hex_opcode": "0x73",
      "visual_parts": [
        {
          "raw": "0110001",
          "clean": "0110001"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "100",
          "clean": "100"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "1110011",
          "clean": "1110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rs2",
        "desc": "Source"
      },
      {
        "name": "rs1",
        "desc": "Guest Address"
      }
    ],
    "pseudocode": "GuestMem[R[rs1]][7:0] = R[rs2][7:0];",
    "example": "HSV.B x10, (x11)",
    "example_note": "Write byte to guest memory.",
    "linked_summary": "Stores a byte to Guest Physical Memory.",
    "linked_pseudocode": "GuestMem[R[rs1]][7:0] = R[rs2][7:0];"
  },
  {
    "mnemonic": "HSV.W",
    "architecture": "RISC-V",
    "extension": "H (Hypervisor)",
    "full_name": "Hypervisor Store Word",
    "summary": "Stores a word to Guest Physical Memory.",
    "syntax": "HSV.W rs2, (rs1)",
    "encoding": {
      "format": "R-Type (System)",
      "binary_pattern": "0110101 | rs2 | rs1 | 100 | 00000 | 1110011",
      "hex_opcode": "0x73",
      "visual_parts": [
        {
          "raw": "0110101",
          "clean": "0110101"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "100",
          "clean": "100"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "1110011",
          "clean": "1110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rs2",
        "desc": "Source"
      },
      {
        "name": "rs1",
        "desc": "Guest Address"
      }
    ],
    "pseudocode": "GuestMem[R[rs1]][31:0] = R[rs2][31:0];",
    "example": "HSV.W x10, (x11)",
    "example_note": "Write word to guest memory.",
    "linked_summary": "Stores a word to Guest Physical Memory.",
    "linked_pseudocode": "GuestMem[R[rs1]][31:0] = R[rs2][31:0];"
  },
  {
    "mnemonic": "PREFETCH.I",
    "architecture": "RISC-V",
    "extension": "Zicbop (Prefetch)",
    "full_name": "Prefetch Instruction",
    "summary": "Hints to hardware to bring the cache block containing the instruction at the address into the instruction cache.",
    "syntax": "PREFETCH.I offset(rs1)",
    "encoding": {
      "format": "S-Type (Hint)",
      "binary_pattern": "00000 | 00000 | rs1 | 110 | imm | 0010011",
      "hex_opcode": "0x13",
      "visual_parts": [
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "110",
          "clean": "110"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "0010011",
          "clean": "0010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "Prefetch(I-Cache, R[rs1] + offset);",
    "example": "PREFETCH.I 0(x10)",
    "example_note": "Prepare I-Cache for upcoming jump.",
    "linked_summary": "Hints to hardware to bring the cache block containing the instruction <a href=\"../../armv8-a/at/\">at</a> the address into the instruction cache.",
    "linked_pseudocode": "Prefetch(I-Cache, R[rs1] + offset);"
  },
  {
    "mnemonic": "PREFETCH.R",
    "architecture": "RISC-V",
    "extension": "Zicbop (Prefetch)",
    "full_name": "Prefetch Read",
    "summary": "Hints to hardware to bring the cache block at the address into the data cache for reading.",
    "syntax": "PREFETCH.R offset(rs1)",
    "encoding": {
      "format": "S-Type (Hint)",
      "binary_pattern": "00000 | 00001 | rs1 | 110 | imm | 0010011",
      "hex_opcode": "0x13",
      "visual_parts": [
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "00001",
          "clean": "00001"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "110",
          "clean": "110"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "0010011",
          "clean": "0010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "Prefetch(D-Cache, Read, R[rs1] + offset);",
    "example": "PREFETCH.R 64(x10)",
    "example_note": "Prepare D-Cache for reading next cache line.",
    "linked_summary": "Hints to hardware to bring the cache block <a href=\"../../armv8-a/at/\">at</a> the address into the data cache for reading.",
    "linked_pseudocode": "Prefetch(D-Cache, Read, R[rs1] + offset);"
  },
  {
    "mnemonic": "PREFETCH.W",
    "architecture": "RISC-V",
    "extension": "Zicbop (Prefetch)",
    "full_name": "Prefetch Write",
    "summary": "Hints to hardware to bring the cache block at the address into the data cache for writing (exclusive ownership).",
    "syntax": "PREFETCH.W offset(rs1)",
    "encoding": {
      "format": "S-Type (Hint)",
      "binary_pattern": "00000 | 00011 | rs1 | 110 | imm | 0010011",
      "hex_opcode": "0x13",
      "visual_parts": [
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "00011",
          "clean": "00011"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "110",
          "clean": "110"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "0010011",
          "clean": "0010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "Prefetch(D-Cache, Write, R[rs1] + offset);",
    "example": "PREFETCH.W 0(x10)",
    "example_note": "Prepare D-Cache for writing.",
    "linked_summary": "Hints to hardware to bring the cache block <a href=\"../../armv8-a/at/\">at</a> the address into the data cache for writing (exclusive ownership).",
    "linked_pseudocode": "Prefetch(D-Cache, Write, R[rs1] + offset);"
  },
  {
    "mnemonic": "DRET",
    "architecture": "RISC-V",
    "extension": "Privileged",
    "full_name": "Debug Return",
    "summary": "Returns from Debug Mode to the mode defined in the 'dcsr' register.",
    "syntax": "DRET",
    "encoding": {
      "format": "R-Type (System)",
      "binary_pattern": "0111101 | 10010 | 00000 | 000 | 00000 | 1110011",
      "hex_opcode": "0x73",
      "visual_parts": [
        {
          "raw": "0111101",
          "clean": "0111101"
        },
        {
          "raw": "10010",
          "clean": "10010"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "1110011",
          "clean": "1110011"
        }
      ]
    },
    "operands": [],
    "pseudocode": "PC = DPC; Priv = DCSR.prv;",
    "example": "DRET",
    "example_note": "Resume execution from debug break.",
    "linked_summary": "Returns from Debug Mode to the mode defined <a href=\"../../x86/in/\">in</a> the 'dcsr' register.",
    "linked_pseudocode": "PC = DPC; Priv = DCSR.prv;"
  },
  {
    "mnemonic": "VSETVLI",
    "architecture": "RISC-V",
    "extension": "V (Vector)",
    "full_name": "Vector Set VL Immediate",
    "summary": "Configures the vector length (vl) and vector type (vtype) based on application needs.",
    "syntax": "VSETVLI rd, rs1, vtypei",
    "encoding": {
      "format": "V-Type",
      "binary_pattern": "0 | zimm[10:0] | rs1 | 111 | rd | 1010111",
      "hex_opcode": "0x57",
      "visual_parts": [
        {
          "raw": "0",
          "clean": "0"
        },
        {
          "raw": "zimm[10:0]",
          "clean": "zimm"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "111",
          "clean": "111"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010111",
          "clean": "1010111"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Actual VL)"
      },
      {
        "name": "rs1",
        "desc": "Req VL (Avail)"
      },
      {
        "name": "vtypei",
        "desc": "Config (SEW/LMUL)"
      }
    ],
    "pseudocode": "vl = set_config(rs1, vtypei); R[rd] = vl;",
    "example": "VSETVLI t0, a0, e32, m1, ta, ma",
    "example_note": "Request VL=a0, 32-bit elements, 1 register group.",
    "linked_summary": "Configures the vector length (vl) <a href=\"../../armv8-a/and/\">and</a> vector type (vtype) based on application needs.",
    "linked_pseudocode": "vl = set_config(rs1, vtypei); R[rd] = vl;"
  },
  {
    "mnemonic": "VLE32.V",
    "architecture": "RISC-V",
    "extension": "V (Vector)",
    "full_name": "Vector Load Element (32-bit)",
    "summary": "Loads a vector of 32-bit elements from memory into a vector register.",
    "syntax": "VLE32.V vd, (rs1), vm",
    "encoding": {
      "format": "V-Load",
      "binary_pattern": "000000 | mop | vm | rs1 | 110 | vd | 0000111",
      "hex_opcode": "0x07",
      "visual_parts": [
        {
          "raw": "000000",
          "clean": "000000"
        },
        {
          "raw": "mop",
          "clean": "mop"
        },
        {
          "raw": "vm",
          "clean": "vm"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "110",
          "clean": "110"
        },
        {
          "raw": "vd",
          "clean": "vd"
        },
        {
          "raw": "0000111",
          "clean": "0000111"
        }
      ]
    },
    "operands": [
      {
        "name": "vd",
        "desc": "Vector Dest"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "vm",
        "desc": "Mask"
      }
    ],
    "pseudocode": "foreach(i < vl): vd[i] = Mem[rs1 + i*4];",
    "example": "VLE32.V v8, (a0)",
    "example_note": "Load 32-bit integers from address in a0 to v8.",
    "linked_summary": "Loads a vector of 32-<a href=\"../../armv8-a/bit/\">bit</a> elements from memory into a vector register.",
    "linked_pseudocode": "foreach(i < vl): vd[i] = Mem[rs1 + i*4];"
  },
  {
    "mnemonic": "VSE32.V",
    "architecture": "RISC-V",
    "extension": "V (Vector)",
    "full_name": "Vector Store Element (32-bit)",
    "summary": "Stores a vector of 32-bit elements from a vector register to memory.",
    "syntax": "VSE32.V vs3, (rs1), vm",
    "encoding": {
      "format": "V-Store",
      "binary_pattern": "000000 | mop | vm | rs1 | 110 | vs3 | 0100111",
      "hex_opcode": "0x27",
      "visual_parts": [
        {
          "raw": "000000",
          "clean": "000000"
        },
        {
          "raw": "mop",
          "clean": "mop"
        },
        {
          "raw": "vm",
          "clean": "vm"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "110",
          "clean": "110"
        },
        {
          "raw": "vs3",
          "clean": "vs3"
        },
        {
          "raw": "0100111",
          "clean": "0100111"
        }
      ]
    },
    "operands": [
      {
        "name": "vs3",
        "desc": "Vector Source"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "vm",
        "desc": "Mask"
      }
    ],
    "pseudocode": "foreach(i < vl): Mem[rs1 + i*4] = vs3[i];",
    "example": "VSE32.V v8, (a0)",
    "example_note": "Store v8 to memory at a0.",
    "linked_summary": "Stores a vector of 32-<a href=\"../../armv8-a/bit/\">bit</a> elements from a vector register to memory.",
    "linked_pseudocode": "foreach(i < vl): Mem[rs1 + i*4] = vs3[i];"
  },
  {
    "mnemonic": "VADD.VV",
    "architecture": "RISC-V",
    "extension": "V (Vector)",
    "full_name": "Vector Integer Add",
    "summary": "Adds elements of two vector registers.",
    "syntax": "VADD.VV vd, vs2, vs1, vm",
    "encoding": {
      "format": "OPIVV",
      "binary_pattern": "000000 | vm | vs2 | vs1 | 000 | vd | 1010111",
      "hex_opcode": "0x57",
      "visual_parts": [
        {
          "raw": "000000",
          "clean": "000000"
        },
        {
          "raw": "vm",
          "clean": "vm"
        },
        {
          "raw": "vs2",
          "clean": "vs2"
        },
        {
          "raw": "vs1",
          "clean": "vs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "vd",
          "clean": "vd"
        },
        {
          "raw": "1010111",
          "clean": "1010111"
        }
      ]
    },
    "operands": [
      {
        "name": "vd",
        "desc": "Dest"
      },
      {
        "name": "vs2",
        "desc": "Src 2"
      },
      {
        "name": "vs1",
        "desc": "Src 1"
      }
    ],
    "pseudocode": "foreach(i < vl): vd[i] = vs1[i] + vs2[i];",
    "example": "VADD.VV v10, v8, v9",
    "example_note": "v10[i] = v8[i] + v9[i]",
    "linked_summary": "Adds elements of two vector registers.",
    "linked_pseudocode": "foreach(i < vl): vd[i] = vs1[i] + vs2[i];"
  },
  {
    "mnemonic": "VMUL.VV",
    "architecture": "RISC-V",
    "extension": "V (Vector)",
    "full_name": "Vector Integer Multiply",
    "summary": "Multiplies elements of two vector registers.",
    "syntax": "VMUL.VV vd, vs2, vs1, vm",
    "encoding": {
      "format": "OPIVV",
      "binary_pattern": "100101 | vm | vs2 | vs1 | 010 | vd | 1010111",
      "hex_opcode": "0x57",
      "visual_parts": [
        {
          "raw": "100101",
          "clean": "100101"
        },
        {
          "raw": "vm",
          "clean": "vm"
        },
        {
          "raw": "vs2",
          "clean": "vs2"
        },
        {
          "raw": "vs1",
          "clean": "vs1"
        },
        {
          "raw": "010",
          "clean": "010"
        },
        {
          "raw": "vd",
          "clean": "vd"
        },
        {
          "raw": "1010111",
          "clean": "1010111"
        }
      ]
    },
    "operands": [
      {
        "name": "vd",
        "desc": "Dest"
      },
      {
        "name": "vs2",
        "desc": "Src 2"
      },
      {
        "name": "vs1",
        "desc": "Src 1"
      }
    ],
    "pseudocode": "foreach(i < vl): vd[i] = vs1[i] * vs2[i];",
    "example": "VMUL.VV v10, v8, v9",
    "example_note": "v10[i] = v8[i] * v9[i]",
    "linked_summary": "Multiplies elements of two vector registers.",
    "linked_pseudocode": "foreach(i < vl): vd[i] = vs1[i] * vs2[i];"
  },
  {
    "mnemonic": "CLZ",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "Count Leading Zeros",
    "summary": "Counts the number of 0 bits at the MSB end of the register.",
    "syntax": "CLZ rd, rs1",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "0110000 | 00000 | rs1 | 001 | rd | 0010011",
      "hex_opcode": "0x13",
      "visual_parts": [
        {
          "raw": "0110000",
          "clean": "0110000"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0010011",
          "clean": "0010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      }
    ],
    "pseudocode": "int count = 0; while(rs1[XLEN-1-count] == 0) count++; R[rd] = count;",
    "example": "CLZ x10, x11",
    "example_note": "Find highest set bit index.",
    "linked_summary": "Counts the number of 0 bits <a href=\"../../armv8-a/at/\">at</a> the MSB end of the register.",
    "linked_pseudocode": "<a href=\"../../x86/int/\">int</a> count = 0; while(rs1[XLEN-1-count] == 0) count++; R[rd] = count;"
  },
  {
    "mnemonic": "CTZ",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "Count Trailing Zeros",
    "summary": "Counts the number of 0 bits at the LSB end of the register.",
    "syntax": "CTZ rd, rs1",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "0110000 | 00001 | rs1 | 001 | rd | 0010011",
      "hex_opcode": "0x13",
      "visual_parts": [
        {
          "raw": "0110000",
          "clean": "0110000"
        },
        {
          "raw": "00001",
          "clean": "00001"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0010011",
          "clean": "0010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      }
    ],
    "pseudocode": "int count = 0; while(rs1[count] == 0) count++; R[rd] = count;",
    "example": "CTZ x10, x11",
    "example_note": "Find lowest set bit index.",
    "linked_summary": "Counts the number of 0 bits <a href=\"../../armv8-a/at/\">at</a> the LSB end of the register.",
    "linked_pseudocode": "<a href=\"../../x86/int/\">int</a> count = 0; while(rs1[count] == 0) count++; R[rd] = count;"
  },
  {
    "mnemonic": "CPOP",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "Population Count",
    "summary": "Counts the number of set bits (1s) in the register.",
    "syntax": "CPOP rd, rs1",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "0110000 | 00010 | rs1 | 001 | rd | 0010011",
      "hex_opcode": "0x13",
      "visual_parts": [
        {
          "raw": "0110000",
          "clean": "0110000"
        },
        {
          "raw": "00010",
          "clean": "00010"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0010011",
          "clean": "0010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      }
    ],
    "pseudocode": "R[rd] = count_set_bits(R[rs1]);",
    "example": "CPOP x10, x11",
    "example_note": "Hamming weight calculation.",
    "linked_summary": "Counts the number of set bits (1s) <a href=\"../../x86/in/\">in</a> the register.",
    "linked_pseudocode": "R[rd] = count_set_bits(R[rs1]);"
  },
  {
    "mnemonic": "ANDN",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "AND Not",
    "summary": "Performs bitwise AND with the bitwise negation of rs2 (rs1 & ~rs2).",
    "syntax": "ANDN rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0100000 | rs2 | rs1 | 111 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0100000",
          "clean": "0100000"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "111",
          "clean": "111"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2 (Inverted)"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] & ~R[rs2];",
    "example": "ANDN x10, x11, x12",
    "example_note": "Clear bits in x11 that are set in x12.",
    "linked_summary": "Performs bitwise <a href=\"../../risc-v/and/\">AND</a> with the bitwise negation of rs2 (rs1 & ~rs2).",
    "linked_pseudocode": "R[rd] = R[rs1] & ~R[rs2];"
  },
  {
    "mnemonic": "ORN",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "OR Not",
    "summary": "Performs bitwise OR with the bitwise negation of rs2 (rs1 | ~rs2).",
    "syntax": "ORN rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0100000 | rs2 | rs1 | 110 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0100000",
          "clean": "0100000"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "110",
          "clean": "110"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2 (Inverted)"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] | ~R[rs2];",
    "example": "ORN x10, x11, x12",
    "example_note": "Set bits.",
    "linked_summary": "Performs bitwise <a href=\"../../risc-v/or/\">OR</a> with the bitwise negation of rs2 (rs1 | ~rs2).",
    "linked_pseudocode": "R[rd] = R[rs1] | ~R[rs2];"
  },
  {
    "mnemonic": "XNOR",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "Exclusive NOR",
    "summary": "Performs bitwise exclusive-NOR (rs1 ^ ~rs2).",
    "syntax": "XNOR rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0100000 | rs2 | rs1 | 100 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0100000",
          "clean": "0100000"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "100",
          "clean": "100"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "R[rd] = ~(R[rs1] ^ R[rs2]);",
    "example": "XNOR x10, x11, x12",
    "example_note": "Logical equivalence.",
    "linked_summary": "Performs bitwise exclusive-NOR (rs1 ^ ~rs2).",
    "linked_pseudocode": "R[rd] = ~(R[rs1] ^ R[rs2]);"
  },
  {
    "mnemonic": "ROL",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "Rotate Left",
    "summary": "Rotates the bits in rs1 left by the amount in rs2.",
    "syntax": "ROL rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0110000 | rs2 | rs1 | 001 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0110000",
          "clean": "0110000"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "rs2",
        "desc": "Rotate Amount"
      }
    ],
    "pseudocode": "shamt = R[rs2] & (XLEN-1); R[rd] = (R[rs1] << shamt) | (R[rs1] >> (XLEN-shamt));",
    "example": "ROL x10, x11, x12",
    "example_note": "Bitwise rotation.",
    "linked_summary": "Rotates the bits <a href=\"../../x86/in/\">in</a> rs1 left by the amount <a href=\"../../x86/in/\">in</a> rs2.",
    "linked_pseudocode": "shamt = R[rs2] & (XLEN-1); R[rd] = (R[rs1] << shamt) | (R[rs1] >> (XLEN-shamt));"
  },
  {
    "mnemonic": "ROR",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "Rotate Right",
    "summary": "Rotates the bits in rs1 right by the amount in rs2.",
    "syntax": "ROR rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0110000 | rs2 | rs1 | 101 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0110000",
          "clean": "0110000"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "101",
          "clean": "101"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "rs2",
        "desc": "Rotate Amount"
      }
    ],
    "pseudocode": "shamt = R[rs2] & (XLEN-1); R[rd] = (R[rs1] >> shamt) | (R[rs1] << (XLEN-shamt));",
    "example": "ROR x10, x11, x12",
    "example_note": "Bitwise rotation.",
    "linked_summary": "Rotates the bits <a href=\"../../x86/in/\">in</a> rs1 right by the amount <a href=\"../../x86/in/\">in</a> rs2.",
    "linked_pseudocode": "shamt = R[rs2] & (XLEN-1); R[rd] = (R[rs1] >> shamt) | (R[rs1] << (XLEN-shamt));"
  },
  {
    "mnemonic": "MAX",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "Maximum",
    "summary": "Computes the signed maximum of two registers.",
    "syntax": "MAX rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000101 | rs2 | rs1 | 110 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0000101",
          "clean": "0000101"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "110",
          "clean": "110"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "R[rd] = (R[rs1] >s R[rs2]) ? R[rs1] : R[rs2];",
    "example": "MAX x10, x11, x12",
    "example_note": "Signed Max.",
    "linked_summary": "Computes the signed maximum of two registers.",
    "linked_pseudocode": "R[rd] = (R[rs1] >s R[rs2]) ? R[rs1] : R[rs2];"
  },
  {
    "mnemonic": "MIN",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "Minimum",
    "summary": "Computes the signed minimum of two registers.",
    "syntax": "MIN rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000101 | rs2 | rs1 | 100 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0000101",
          "clean": "0000101"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "100",
          "clean": "100"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "R[rd] = (R[rs1] <s R[rs2]) ? R[rs1] : R[rs2];",
    "example": "MIN x10, x11, x12",
    "example_note": "Signed Min.",
    "linked_summary": "Computes the signed minimum of two registers.",
    "linked_pseudocode": "R[rd] = (R[rs1] <s R[rs2]) ? R[rs1] : R[rs2];"
  },
  {
    "mnemonic": "SEX.B",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "Sign Extend Byte",
    "summary": "Sign-extends the lowest byte (8 bits) to XLEN bits.",
    "syntax": "SEX.B rd, rs1",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "0110000 | 00100 | rs1 | 001 | rd | 0010011",
      "hex_opcode": "0x13",
      "visual_parts": [
        {
          "raw": "0110000",
          "clean": "0110000"
        },
        {
          "raw": "00100",
          "clean": "00100"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0010011",
          "clean": "0010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      }
    ],
    "pseudocode": "R[rd] = sext(R[rs1][7:0]);",
    "example": "SEX.B x10, x11",
    "example_note": "Sign extend 8-bit value.",
    "linked_summary": "Sign-extends the lowest byte (8 bits) to XLEN bits.",
    "linked_pseudocode": "R[rd] = sext(R[rs1][7:0]);"
  },
  {
    "mnemonic": "SEX.H",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "Sign Extend Halfword",
    "summary": "Sign-extends the lowest halfword (16 bits) to XLEN bits.",
    "syntax": "SEX.H rd, rs1",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "0110000 | 00101 | rs1 | 001 | rd | 0010011",
      "hex_opcode": "0x13",
      "visual_parts": [
        {
          "raw": "0110000",
          "clean": "0110000"
        },
        {
          "raw": "00101",
          "clean": "00101"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0010011",
          "clean": "0010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      }
    ],
    "pseudocode": "R[rd] = sext(R[rs1][15:0]);",
    "example": "SEX.H x10, x11",
    "example_note": "Sign extend 16-bit value.",
    "linked_summary": "Sign-extends the lowest halfword (16 bits) to XLEN bits.",
    "linked_pseudocode": "R[rd] = sext(R[rs1][15:0]);"
  },
  {
    "mnemonic": "ZEXT.H",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "Zero Extend Halfword",
    "summary": "Zero-extends the lowest halfword (16 bits) to XLEN bits.",
    "syntax": "ZEXT.H rd, rs1",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "0000100 | 00000 | rs1 | 100 | rd | 0111011",
      "hex_opcode": "0x3B",
      "visual_parts": [
        {
          "raw": "0000100",
          "clean": "0000100"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "100",
          "clean": "100"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0111011",
          "clean": "0111011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      }
    ],
    "pseudocode": "R[rd] = zext(R[rs1][15:0]);",
    "example": "ZEXT.H x10, x11",
    "example_note": "Zero extend 16-bit value.",
    "linked_summary": "Zero-extends the lowest halfword (16 bits) to XLEN bits.",
    "linked_pseudocode": "R[rd] = zext(R[rs1][15:0]);"
  },
  {
    "mnemonic": "ORC.B",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "Bitwise OR-Combine Byte",
    "summary": "Sets each byte of the result to 0xFF if the corresponding byte of the source is non-zero, else 0x00.",
    "syntax": "ORC.B rd, rs1",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "0010100 | 00111 | rs1 | 101 | rd | 0010011",
      "hex_opcode": "0x13",
      "visual_parts": [
        {
          "raw": "0010100",
          "clean": "0010100"
        },
        {
          "raw": "00111",
          "clean": "00111"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "101",
          "clean": "101"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0010011",
          "clean": "0010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      }
    ],
    "pseudocode": "For each byte i: R[rd].byte[i] = (R[rs1].byte[i] != 0) ? 0xFF : 0x00;",
    "example": "ORC.B x10, x11",
    "example_note": "Used for string processing (strlen, strcpy).",
    "linked_summary": "Sets each byte of the result to 0xFF if the corresponding byte of the source is non-<a href=\"../../armv9-a/zero/\">zero</a>, else 0x00.",
    "linked_pseudocode": "For each byte i: R[rd].byte[i] = (R[rs1].byte[i] != 0) ? 0xFF : 0x00;"
  },
  {
    "mnemonic": "REV8",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "Byte Reverse",
    "summary": "Reverses the order of bytes in a register (Endian swap).",
    "syntax": "REV8 rd, rs1",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "0110101 | 11000 | rs1 | 101 | rd | 0010011",
      "hex_opcode": "0x13",
      "visual_parts": [
        {
          "raw": "0110101",
          "clean": "0110101"
        },
        {
          "raw": "11000",
          "clean": "11000"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "101",
          "clean": "101"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0010011",
          "clean": "0010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      }
    ],
    "pseudocode": "R[rd] = Byteswap(R[rs1]);",
    "example": "REV8 x10, x11",
    "example_note": "Converts Big-Endian to Little-Endian.",
    "linked_summary": "Reverses the order of bytes <a href=\"../../x86/in/\">in</a> a register (Endian swap).",
    "linked_pseudocode": "R[rd] = Byteswap(R[rs1]);"
  },
  {
    "mnemonic": "FCVT.W.S",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Float Convert to Word (Single)",
    "summary": "Converts a single-precision floating-point number to a signed 32-bit integer.",
    "syntax": "FCVT.W.S rd, rs1",
    "encoding": {
      "format": "I-Type (Float)",
      "binary_pattern": "1100000 | 00000 | rs1 | rm | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "1100000",
          "clean": "1100000"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "rm",
          "clean": "rm"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Integer)"
      },
      {
        "name": "rs1",
        "desc": "Source (Float)"
      }
    ],
    "pseudocode": "R[rd] = sext(f32_to_i32(F[rs1]));",
    "example": "FCVT.W.S x10, f1",
    "example_note": "Convert float f1 to int x10.",
    "linked_summary": "Converts a single-precision floating-point number to a signed 32-<a href=\"../../armv8-a/bit/\">bit</a> integer.",
    "linked_pseudocode": "R[rd] = sext(f32_to_i32(F[rs1]));"
  },
  {
    "mnemonic": "FCVT.S.W",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Float Convert from Word (Single)",
    "summary": "Converts a signed 32-bit integer to a single-precision floating-point number.",
    "syntax": "FCVT.S.W rd, rs1",
    "encoding": {
      "format": "I-Type (Float)",
      "binary_pattern": "1101000 | 00000 | rs1 | rm | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "1101000",
          "clean": "1101000"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "rm",
          "clean": "rm"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Float)"
      },
      {
        "name": "rs1",
        "desc": "Source (Integer)"
      }
    ],
    "pseudocode": "F[rd] = i32_to_f32(R[rs1]);",
    "example": "FCVT.S.W f1, x10",
    "example_note": "Convert int x10 to float f1.",
    "linked_summary": "Converts a signed 32-<a href=\"../../armv8-a/bit/\">bit</a> integer to a single-precision floating-point number.",
    "linked_pseudocode": "F[rd] = i32_to_f32(R[rs1]);"
  },
  {
    "mnemonic": "FCVT.D.S",
    "architecture": "RISC-V",
    "extension": "D",
    "full_name": "Float Convert Single to Double",
    "summary": "Converts a single-precision float to a double-precision float.",
    "syntax": "FCVT.D.S rd, rs1",
    "encoding": {
      "format": "I-Type (Float)",
      "binary_pattern": "0100001 | 00000 | rs1 | rm | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "0100001",
          "clean": "0100001"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "rm",
          "clean": "rm"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Double)"
      },
      {
        "name": "rs1",
        "desc": "Source (Single)"
      }
    ],
    "pseudocode": "F[rd] = f32_to_f64(F[rs1]);",
    "example": "FCVT.D.S f0, f1",
    "example_note": "Promote float to double.",
    "linked_summary": "Converts a single-precision float to a double-precision float.",
    "linked_pseudocode": "F[rd] = f32_to_f64(F[rs1]);"
  },
  {
    "mnemonic": "FCVT.S.D",
    "architecture": "RISC-V",
    "extension": "D",
    "full_name": "Float Convert Double to Single",
    "summary": "Converts a double-precision float to a single-precision float.",
    "syntax": "FCVT.S.D rd, rs1",
    "encoding": {
      "format": "I-Type (Float)",
      "binary_pattern": "0100000 | 00001 | rs1 | rm | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "0100000",
          "clean": "0100000"
        },
        {
          "raw": "00001",
          "clean": "00001"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "rm",
          "clean": "rm"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Single)"
      },
      {
        "name": "rs1",
        "desc": "Source (Double)"
      }
    ],
    "pseudocode": "F[rd] = f64_to_f32(F[rs1]);",
    "example": "FCVT.S.D f1, f0",
    "example_note": "Demote double to float.",
    "linked_summary": "Converts a double-precision float to a single-precision float.",
    "linked_pseudocode": "F[rd] = f64_to_f32(F[rs1]);"
  },
  {
    "mnemonic": "FSGNJ.S",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Float Sign Injection (Single)",
    "summary": "Injects the sign of rs2 into rs1. Used to copy values or manipulate signs.",
    "syntax": "FSGNJ.S rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0010000 | rs2 | rs1 | 000 | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "0010000",
          "clean": "0010000"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source (Body)"
      },
      {
        "name": "rs2",
        "desc": "Source (Sign)"
      }
    ],
    "pseudocode": "F[rd] = {F[rs2][31], F[rs1][30:0]};",
    "example": "FSGNJ.S f1, f2, f3",
    "example_note": "f1 gets magnitude of f2 and sign of f3.",
    "linked_summary": "Injects the sign of rs2 into rs1. Used to <a href=\"../../powerisa/copy/\">copy</a> values <a href=\"../../powerisa/or/\">or</a> manipulate signs.",
    "linked_pseudocode": "F[rd] = {F[rs2][31], F[rs1][30:0]};"
  },
  {
    "mnemonic": "FSGNJN.S",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Float Sign Injection Negate (Single)",
    "summary": "Injects the *negated* sign of rs2 into rs1. Used for negation and absolute value.",
    "syntax": "FSGNJN.S rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0010000 | rs2 | rs1 | 001 | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "0010000",
          "clean": "0010000"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source (Body)"
      },
      {
        "name": "rs2",
        "desc": "Source (Sign)"
      }
    ],
    "pseudocode": "F[rd] = {~F[rs2][31], F[rs1][30:0]};",
    "example": "FSGNJN.S f1, f2, f2",
    "example_note": "Negates f2 (f1 = -f2).",
    "linked_summary": "Injects the *negated* sign of rs2 into rs1. Used for negation <a href=\"../../armv8-a/and/\">and</a> absolute value.",
    "linked_pseudocode": "F[rd] = {~F[rs2][31], F[rs1][30:0]};"
  },
  {
    "mnemonic": "FSGNJX.S",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Float Sign Injection XOR (Single)",
    "summary": "Injects the XOR of signs of rs1 and rs2. Used to copy sign.",
    "syntax": "FSGNJX.S rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0010000 | rs2 | rs1 | 010 | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "0010000",
          "clean": "0010000"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "010",
          "clean": "010"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "F[rd] = {F[rs1][31] ^ F[rs2][31], F[rs1][30:0]};",
    "example": "FSGNJX.S f1, f1, f2",
    "example_note": "Logic similar to Abs(f1) if f2 is properly set.",
    "linked_summary": "Injects the <a href=\"../../risc-v/xor/\">XOR</a> of signs of rs1 <a href=\"../../armv8-a/and/\">and</a> rs2. Used to <a href=\"../../powerisa/copy/\">copy</a> sign.",
    "linked_pseudocode": "F[rd] = {F[rs1][31] ^ F[rs2][31], F[rs1][30:0]};"
  },
  {
    "mnemonic": "FEQ.S",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Float Equal (Single)",
    "summary": "Sets integer rd to 1 if float rs1 equals float rs2, else 0.",
    "syntax": "FEQ.S rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "1010000 | rs2 | rs1 | 010 | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "1010000",
          "clean": "1010000"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "010",
          "clean": "010"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Integer)"
      },
      {
        "name": "rs1",
        "desc": "Src 1 (Float)"
      },
      {
        "name": "rs2",
        "desc": "Src 2 (Float)"
      }
    ],
    "pseudocode": "R[rd] = (F[rs1] == F[rs2]) ? 1 : 0;",
    "example": "FEQ.S x10, f1, f2",
    "example_note": "x10 = (f1 == f2)",
    "linked_summary": "Sets integer rd to 1 if float rs1 equals float rs2, else 0.",
    "linked_pseudocode": "R[rd] = (F[rs1] == F[rs2]) ? 1 : 0;"
  },
  {
    "mnemonic": "FLT.S",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Float Less Than (Single)",
    "summary": "Sets integer rd to 1 if float rs1 is less than float rs2, else 0.",
    "syntax": "FLT.S rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "1010000 | rs2 | rs1 | 001 | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "1010000",
          "clean": "1010000"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Integer)"
      },
      {
        "name": "rs1",
        "desc": "Src 1 (Float)"
      },
      {
        "name": "rs2",
        "desc": "Src 2 (Float)"
      }
    ],
    "pseudocode": "R[rd] = (F[rs1] < F[rs2]) ? 1 : 0;",
    "example": "FLT.S x10, f1, f2",
    "example_note": "x10 = (f1 < f2)",
    "linked_summary": "Sets integer rd to 1 if float rs1 is less than float rs2, else 0.",
    "linked_pseudocode": "R[rd] = (F[rs1] < F[rs2]) ? 1 : 0;"
  },
  {
    "mnemonic": "FLE.S",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Float Less or Equal (Single)",
    "summary": "Sets integer rd to 1 if float rs1 is less than or equal to float rs2, else 0.",
    "syntax": "FLE.S rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "1010000 | rs2 | rs1 | 000 | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "1010000",
          "clean": "1010000"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Integer)"
      },
      {
        "name": "rs1",
        "desc": "Src 1 (Float)"
      },
      {
        "name": "rs2",
        "desc": "Src 2 (Float)"
      }
    ],
    "pseudocode": "R[rd] = (F[rs1] <= F[rs2]) ? 1 : 0;",
    "example": "FLE.S x10, f1, f2",
    "example_note": "x10 = (f1 <= f2)",
    "linked_summary": "Sets integer rd to 1 if float rs1 is less than <a href=\"../../powerisa/or/\">or</a> equal to float rs2, else 0.",
    "linked_pseudocode": "R[rd] = (F[rs1] <= F[rs2]) ? 1 : 0;"
  },
  {
    "mnemonic": "FMV.X.W",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Move Float to Integer",
    "summary": "Moves the bit pattern of a floating-point register to an integer register.",
    "syntax": "FMV.X.W rd, rs1",
    "encoding": {
      "format": "I-Type (Float)",
      "binary_pattern": "1110000 | 00000 | rs1 | 000 | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "1110000",
          "clean": "1110000"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Integer)"
      },
      {
        "name": "rs1",
        "desc": "Source (Float)"
      }
    ],
    "pseudocode": "R[rd] = sext(F[rs1]);",
    "example": "FMV.X.W x10, f1",
    "example_note": "Copy bits from f1 to x10.",
    "linked_summary": "Moves the <a href=\"../../armv8-a/bit/\">bit</a> pattern of a floating-point register to an integer register.",
    "linked_pseudocode": "R[rd] = sext(F[rs1]);"
  },
  {
    "mnemonic": "FMV.W.X",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Move Integer to Float",
    "summary": "Moves the bit pattern of an integer register to a floating-point register.",
    "syntax": "FMV.W.X rd, rs1",
    "encoding": {
      "format": "I-Type (Float)",
      "binary_pattern": "1111000 | 00000 | rs1 | 000 | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "1111000",
          "clean": "1111000"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Float)"
      },
      {
        "name": "rs1",
        "desc": "Source (Integer)"
      }
    ],
    "pseudocode": "F[rd] = R[rs1];",
    "example": "FMV.W.X f1, x10",
    "example_note": "Copy bits from x10 to f1.",
    "linked_summary": "Moves the <a href=\"../../armv8-a/bit/\">bit</a> pattern of an integer register to a floating-point register.",
    "linked_pseudocode": "F[rd] = R[rs1];"
  },
  {
    "mnemonic": "CZERO.EQZ",
    "architecture": "RISC-V",
    "extension": "Zicond",
    "full_name": "Conditional Zero Equal to Zero",
    "summary": "Moves rs1 to rd if rs2 is non-zero, otherwise sets rd to zero.",
    "syntax": "CZERO.EQZ rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000111 | rs2 | rs1 | 101 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0000111",
          "clean": "0000111"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "101",
          "clean": "101"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "rs2",
        "desc": "Condition"
      }
    ],
    "pseudocode": "if (R[rs2] == 0) R[rd] = 0; else R[rd] = R[rs1];",
    "example": "CZERO.EQZ x10, x11, x12",
    "example_note": "If x12 is 0, x10=0. Else x10=x11.",
    "linked_summary": "Moves rs1 to rd if rs2 is non-<a href=\"../../armv9-a/zero/\">zero</a>, otherwise sets rd to <a href=\"../../armv9-a/zero/\">zero</a>.",
    "linked_pseudocode": "if (R[rs2] == 0) R[rd] = 0; else R[rd] = R[rs1];"
  },
  {
    "mnemonic": "CZERO.NEZ",
    "architecture": "RISC-V",
    "extension": "Zicond",
    "full_name": "Conditional Zero Not Equal to Zero",
    "summary": "Moves rs1 to rd if rs2 is zero, otherwise sets rd to zero.",
    "syntax": "CZERO.NEZ rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000111 | rs2 | rs1 | 111 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0000111",
          "clean": "0000111"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "111",
          "clean": "111"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "rs2",
        "desc": "Condition"
      }
    ],
    "pseudocode": "if (R[rs2] != 0) R[rd] = 0; else R[rd] = R[rs1];",
    "example": "CZERO.NEZ x10, x11, x12",
    "example_note": "If x12 != 0, x10=0. Else x10=x11.",
    "linked_summary": "Moves rs1 to rd if rs2 is <a href=\"../../armv9-a/zero/\">zero</a>, otherwise sets rd to <a href=\"../../armv9-a/zero/\">zero</a>.",
    "linked_pseudocode": "if (R[rs2] != 0) R[rd] = 0; else R[rd] = R[rs1];"
  },
  {
    "mnemonic": "PAUSE",
    "architecture": "RISC-V",
    "extension": "Zihintpause",
    "full_name": "Pause",
    "summary": "Hints that the current hart is in a spin-wait loop, allowing the hardware to reduce power consumption or yield resources.",
    "syntax": "PAUSE",
    "encoding": {
      "format": "I-Type (Hint)",
      "binary_pattern": "000000010000 | 00000 | 000 | 00000 | 0001111",
      "hex_opcode": "0x0F",
      "visual_parts": [
        {
          "raw": "000000010000",
          "clean": "000000010000"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "0001111",
          "clean": "0001111"
        }
      ]
    },
    "operands": [],
    "pseudocode": "// Implementation-defined delay/yield",
    "example": "PAUSE",
    "example_note": "Used inside spinlocks.",
    "linked_summary": "Hints that the current hart is <a href=\"../../x86/in/\">in</a> a spin-<a href=\"../../powerisa/wait/\">wait</a> <a href=\"../../x86/loop/\">loop</a>, allowing the hardware to reduce power consumption <a href=\"../../powerisa/or/\">or</a> <a href=\"../../armv8-a/yield/\">yield</a> resources.",
    "linked_pseudocode": "// Implementation-defined delay/<a href=\"../../armv8-a/yield/\">yield</a>"
  },
  {
    "mnemonic": "CBO.CLEAN",
    "architecture": "RISC-V",
    "extension": "Zicbom",
    "full_name": "Cache Block Operation: Clean",
    "summary": "Performs a clean operation on the cache block containing the effective address.",
    "syntax": "CBO.CLEAN (rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "000000000001 | rs1 | 010 | 00000 | 0001111",
      "hex_opcode": "0x0F",
      "visual_parts": [
        {
          "raw": "000000000001",
          "clean": "000000000001"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "010",
          "clean": "010"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "0001111",
          "clean": "0001111"
        }
      ]
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "CacheClean(R[rs1]);",
    "example": "CBO.CLEAN (x10)",
    "example_note": "Write back dirty data to memory.",
    "linked_summary": "Performs a clean operation on the cache block containing the effective address.",
    "linked_pseudocode": "CacheClean(R[rs1]);"
  },
  {
    "mnemonic": "CBO.FLUSH",
    "architecture": "RISC-V",
    "extension": "Zicbom",
    "full_name": "Cache Block Operation: Flush",
    "summary": "Performs a flush (clean + invalidate) operation on the cache block.",
    "syntax": "CBO.FLUSH (rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "000000000010 | rs1 | 010 | 00000 | 0001111",
      "hex_opcode": "0x0F",
      "visual_parts": [
        {
          "raw": "000000000010",
          "clean": "000000000010"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "010",
          "clean": "010"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "0001111",
          "clean": "0001111"
        }
      ]
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "CacheFlush(R[rs1]);",
    "example": "CBO.FLUSH (x10)",
    "example_note": "Write back and invalidate.",
    "linked_summary": "Performs a flush (clean + invalidate) operation on the cache block.",
    "linked_pseudocode": "CacheFlush(R[rs1]);"
  },
  {
    "mnemonic": "CBO.INVAL",
    "architecture": "RISC-V",
    "extension": "Zicbom",
    "full_name": "Cache Block Operation: Invalidate",
    "summary": "Performs an invalidate operation on the cache block.",
    "syntax": "CBO.INVAL (rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "000000000000 | rs1 | 010 | 00000 | 0001111",
      "hex_opcode": "0x0F",
      "visual_parts": [
        {
          "raw": "000000000000",
          "clean": "000000000000"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "010",
          "clean": "010"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "0001111",
          "clean": "0001111"
        }
      ]
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "CacheInvalidate(R[rs1]);",
    "example": "CBO.INVAL (x10)",
    "example_note": "Discard cache line (data lost if dirty).",
    "linked_summary": "Performs an invalidate operation on the cache block.",
    "linked_pseudocode": "CacheInvalidate(R[rs1]);"
  },
  {
    "mnemonic": "CBO.ZERO",
    "architecture": "RISC-V",
    "extension": "Zicboz",
    "full_name": "Cache Block Operation: Zero",
    "summary": "Zeros a cache block specified by the address.",
    "syntax": "CBO.ZERO (rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "000000000100 | rs1 | 010 | 00000 | 0001111",
      "hex_opcode": "0x0F",
      "visual_parts": [
        {
          "raw": "000000000100",
          "clean": "000000000100"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "010",
          "clean": "010"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "0001111",
          "clean": "0001111"
        }
      ]
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "MemSet(R[rs1], BlockSize, 0);",
    "example": "CBO.ZERO (x10)",
    "example_note": "Fast zeroing of memory blocks.",
    "linked_summary": "Zeros a cache block specified by the address.",
    "linked_pseudocode": "MemSet(R[rs1], BlockSize, 0);"
  },
  {
    "mnemonic": "RDCYCLE",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Read Cycle Counter",
    "summary": "Reads the lower 32/64 bits of the cycle counter.",
    "syntax": "RDCYCLE rd",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "CSRRS rd, cycle, x0",
      "hex_opcode": "See CSRRS",
      "visual_parts": [
        {
          "raw": "CSRRS rd, cycle, x0",
          "clean": "CSRRS rd, cycle, x0"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      }
    ],
    "pseudocode": "R[rd] = CSR[cycle];",
    "example": "RDCYCLE x10",
    "example_note": "Get cycle count for performance timing.",
    "linked_summary": "Reads the lower 32/64 bits of the cycle counter.",
    "linked_pseudocode": "R[rd] = CSR[cycle];"
  },
  {
    "mnemonic": "RDTIME",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Read Real-Time Clock",
    "summary": "Reads the lower 32/64 bits of the real-time clock.",
    "syntax": "RDTIME rd",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "CSRRS rd, time, x0",
      "hex_opcode": "See CSRRS",
      "visual_parts": [
        {
          "raw": "CSRRS rd, time, x0",
          "clean": "CSRRS rd, time, x0"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      }
    ],
    "pseudocode": "R[rd] = CSR[time];",
    "example": "RDTIME x10",
    "example_note": "Get wall-clock time.",
    "linked_summary": "Reads the lower 32/64 bits of the real-time clock.",
    "linked_pseudocode": "R[rd] = CSR[time];"
  },
  {
    "mnemonic": "RDINSTRET",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Read Instructions Retired",
    "summary": "Reads the count of instructions retired (completed).",
    "syntax": "RDINSTRET rd",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "CSRRS rd, instret, x0",
      "hex_opcode": "See CSRRS",
      "visual_parts": [
        {
          "raw": "CSRRS rd, instret, x0",
          "clean": "CSRRS rd, instret, x0"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      }
    ],
    "pseudocode": "R[rd] = CSR[instret];",
    "example": "RDINSTRET x10",
    "example_note": "Get instruction count.",
    "linked_summary": "Reads the count of instructions retired (completed).",
    "linked_pseudocode": "R[rd] = CSR[instret];"
  },
  {
    "mnemonic": "NOP",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "No Operation",
    "summary": "Performs no operation. Used for alignment or timing delays.",
    "syntax": "NOP",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "ADDI x0, x0, 0",
      "hex_opcode": "0x00000013",
      "visual_parts": [
        {
          "raw": "ADDI x0, x0, 0",
          "clean": "ADDI x0, x0, 0"
        }
      ]
    },
    "operands": [],
    "pseudocode": "R[0] = R[0] + 0;",
    "example": "NOP",
    "example_note": "Does nothing.",
    "linked_summary": "Performs no operation. Used for alignment <a href=\"../../powerisa/or/\">or</a> timing delays.",
    "linked_pseudocode": "R[0] = R[0] + 0;"
  },
  {
    "mnemonic": "MV",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Move",
    "summary": "Copies the value of one register into another.",
    "syntax": "MV rd, rs",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "ADDI rd, rs, 0",
      "hex_opcode": "See ADDI",
      "visual_parts": [
        {
          "raw": "ADDI rd, rs, 0",
          "clean": "ADDI rd, rs, 0"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination"
      },
      {
        "name": "rs",
        "desc": "Source"
      }
    ],
    "pseudocode": "R[rd] = R[rs];",
    "example": "MV x10, x11",
    "example_note": "Copies x11 to x10.",
    "linked_summary": "Copies the value of one register into another.",
    "linked_pseudocode": "R[rd] = R[rs];"
  },
  {
    "mnemonic": "LI",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Load Immediate",
    "summary": "Loads an arbitrary immediate value into a register.",
    "syntax": "LI rd, imm",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "LUI + ADDI",
      "hex_opcode": "Variable",
      "visual_parts": [
        {
          "raw": "LUI + ADDI",
          "clean": "LUI + ADDI"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination"
      },
      {
        "name": "imm",
        "desc": "Immediate Value"
      }
    ],
    "pseudocode": "R[rd] = imm;",
    "example": "LI x5, 0x12345",
    "example_note": "Expands to: LUI x5, 0x12; ADDI x5, x5, 0x345",
    "linked_summary": "Loads an arbitrary immediate value into a register.",
    "linked_pseudocode": "R[rd] = imm;"
  },
  {
    "mnemonic": "RET",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Return",
    "summary": "Returns from a subroutine call.",
    "syntax": "RET",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "JALR x0, 0(x1)",
      "hex_opcode": "0x00008067",
      "visual_parts": [
        {
          "raw": "JALR x0, 0(x1)",
          "clean": "JALR x0, 0(x1)"
        }
      ]
    },
    "operands": [],
    "pseudocode": "PC = R[1];",
    "example": "RET",
    "example_note": "Jumps to the address in the Return Address register (ra/x1).",
    "linked_summary": "Returns from a subroutine <a href=\"../../x86/call/\">call</a>.",
    "linked_pseudocode": "PC = R[1];"
  },
  {
    "mnemonic": "J",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Jump",
    "summary": "Unconditionally jumps to a target offset.",
    "syntax": "J offset",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "JAL x0, offset",
      "hex_opcode": "See JAL",
      "visual_parts": [
        {
          "raw": "JAL x0, offset",
          "clean": "JAL x0, offset"
        }
      ]
    },
    "operands": [
      {
        "name": "offset",
        "desc": "Jump Target"
      }
    ],
    "pseudocode": "PC += sext(offset);",
    "example": "J label",
    "example_note": "Unconditional jump (discarding return address).",
    "linked_summary": "Unconditionally jumps to a target offset.",
    "linked_pseudocode": "PC += sext(offset);"
  },
  {
    "mnemonic": "JR",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Jump Register",
    "summary": "Unconditionally jumps to an address held in a register.",
    "syntax": "JR rs",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "JALR x0, 0(rs)",
      "hex_opcode": "See JALR",
      "visual_parts": [
        {
          "raw": "JALR x0, 0(rs)",
          "clean": "JALR x0, 0(rs)"
        }
      ]
    },
    "operands": [
      {
        "name": "rs",
        "desc": "Address Register"
      }
    ],
    "pseudocode": "PC = R[rs];",
    "example": "JR x10",
    "example_note": "Jump to address stored in x10.",
    "linked_summary": "Unconditionally jumps to an address held <a href=\"../../x86/in/\">in</a> a register.",
    "linked_pseudocode": "PC = R[rs];"
  },
  {
    "mnemonic": "CALL",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Call Subroutine",
    "summary": "Calls a function by jumping to an address and saving the return address.",
    "syntax": "CALL symbol",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "AUIPC + JALR",
      "hex_opcode": "Variable",
      "visual_parts": [
        {
          "raw": "AUIPC + JALR",
          "clean": "AUIPC + JALR"
        }
      ]
    },
    "operands": [
      {
        "name": "symbol",
        "desc": "Function Name"
      }
    ],
    "pseudocode": "x1 = PC + 4; PC = symbol;",
    "example": "CALL printf",
    "example_note": "Sets up x1 (ra) and jumps to printf.",
    "linked_summary": "Calls a function by jumping to an address <a href=\"../../armv8-a/and/\">and</a> saving the return address.",
    "linked_pseudocode": "x1 = PC + 4; PC = symbol;"
  },
  {
    "mnemonic": "NOT",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Bitwise NOT",
    "summary": "Computes the bitwise logical negation (one's complement).",
    "syntax": "NOT rd, rs",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "XORI rd, rs, -1",
      "hex_opcode": "See XORI",
      "visual_parts": [
        {
          "raw": "XORI rd, rs, -1",
          "clean": "XORI rd, rs, -1"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination"
      },
      {
        "name": "rs",
        "desc": "Source"
      }
    ],
    "pseudocode": "R[rd] = ~R[rs];",
    "example": "NOT x10, x11",
    "example_note": "Inverts all bits of x11.",
    "linked_summary": "Computes the bitwise logical negation (one's complement).",
    "linked_pseudocode": "R[rd] = ~R[rs];"
  },
  {
    "mnemonic": "NEG",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Negate",
    "summary": "Computes the two's complement negation (arithmetic negative).",
    "syntax": "NEG rd, rs",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "SUB rd, x0, rs",
      "hex_opcode": "See SUB",
      "visual_parts": [
        {
          "raw": "SUB rd, x0, rs",
          "clean": "SUB rd, x0, rs"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination"
      },
      {
        "name": "rs",
        "desc": "Source"
      }
    ],
    "pseudocode": "R[rd] = 0 - R[rs];",
    "example": "NEG x5, x6",
    "example_note": "x5 = -x6",
    "linked_summary": "Computes the two's complement negation (arithmetic negative).",
    "linked_pseudocode": "R[rd] = 0 - R[rs];"
  },
  {
    "mnemonic": "BEQZ",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Branch if Equal to Zero",
    "summary": "Branches if the register is zero.",
    "syntax": "BEQZ rs, offset",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "BEQ rs, x0, offset",
      "hex_opcode": "See BEQ",
      "visual_parts": [
        {
          "raw": "BEQ rs, x0, offset",
          "clean": "BEQ rs, x0, offset"
        }
      ]
    },
    "operands": [
      {
        "name": "rs",
        "desc": "Source"
      },
      {
        "name": "offset",
        "desc": "Label"
      }
    ],
    "pseudocode": "if (R[rs] == 0) PC += offset;",
    "example": "BEQZ x10, exit",
    "example_note": "Jump to exit if x10 is zero.",
    "linked_summary": "Branches if the register is <a href=\"../../armv9-a/zero/\">zero</a>.",
    "linked_pseudocode": "if (R[rs] == 0) PC += offset;"
  },
  {
    "mnemonic": "BNEZ",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Branch if Not Equal to Zero",
    "summary": "Branches if the register is not zero.",
    "syntax": "BNEZ rs, offset",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "BNE rs, x0, offset",
      "hex_opcode": "See BNE",
      "visual_parts": [
        {
          "raw": "BNE rs, x0, offset",
          "clean": "BNE rs, x0, offset"
        }
      ]
    },
    "operands": [
      {
        "name": "rs",
        "desc": "Source"
      },
      {
        "name": "offset",
        "desc": "Label"
      }
    ],
    "pseudocode": "if (R[rs] != 0) PC += offset;",
    "example": "BNEZ x10, loop",
    "example_note": "Jump to loop if x10 is not zero.",
    "linked_summary": "Branches if the register is <a href=\"../../armv8-a/not/\">not</a> <a href=\"../../armv9-a/zero/\">zero</a>.",
    "linked_pseudocode": "if (R[rs] != 0) PC += offset;"
  },
  {
    "mnemonic": "SEQZ",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Set if Equal to Zero",
    "summary": "Sets rd to 1 if rs is zero, otherwise 0.",
    "syntax": "SEQZ rd, rs",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "SLTIU rd, rs, 1",
      "hex_opcode": "See SLTIU",
      "visual_parts": [
        {
          "raw": "SLTIU rd, rs, 1",
          "clean": "SLTIU rd, rs, 1"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs",
        "desc": "Source"
      }
    ],
    "pseudocode": "R[rd] = (R[rs] == 0) ? 1 : 0;",
    "example": "SEQZ x5, x10",
    "example_note": "Sets x5 to 1 if x10 is 0.",
    "linked_summary": "Sets rd to 1 if rs is <a href=\"../../armv9-a/zero/\">zero</a>, otherwise 0.",
    "linked_pseudocode": "R[rd] = (R[rs] == 0) ? 1 : 0;"
  },
  {
    "mnemonic": "SNEZ",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Set if Not Equal to Zero",
    "summary": "Sets rd to 1 if rs is not zero, otherwise 0.",
    "syntax": "SNEZ rd, rs",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "SLTU rd, x0, rs",
      "hex_opcode": "See SLTU",
      "visual_parts": [
        {
          "raw": "SLTU rd, x0, rs",
          "clean": "SLTU rd, x0, rs"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs",
        "desc": "Source"
      }
    ],
    "pseudocode": "R[rd] = (R[rs] != 0) ? 1 : 0;",
    "example": "SNEZ x5, x10",
    "example_note": "Sets x5 to 1 if x10 is non-zero.",
    "linked_summary": "Sets rd to 1 if rs is <a href=\"../../armv8-a/not/\">not</a> <a href=\"../../armv9-a/zero/\">zero</a>, otherwise 0.",
    "linked_pseudocode": "R[rd] = (R[rs] != 0) ? 1 : 0;"
  },
  {
    "mnemonic": "AES64ES",
    "architecture": "RISC-V",
    "extension": "Zk (Crypto)",
    "full_name": "AES-64 Encryption Schedule",
    "summary": "Performs one round of AES-128 encryption key schedule generation.",
    "syntax": "AES64ES rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0011001 | rs2 | rs1 | 000 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0011001",
          "clean": "0011001"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "R[rd] = aes_encrypt_schedule(R[rs1], R[rs2]);",
    "example": "AES64ES x10, x11, x12",
    "example_note": "AES Key Gen.",
    "linked_summary": "Performs one round of AES-128 encryption key schedule generation.",
    "linked_pseudocode": "R[rd] = aes_encrypt_schedule(R[rs1], R[rs2]);"
  },
  {
    "mnemonic": "AES64DS",
    "architecture": "RISC-V",
    "extension": "Zk (Crypto)",
    "full_name": "AES-64 Decryption Schedule",
    "summary": "Performs one round of AES-128 decryption key schedule generation.",
    "syntax": "AES64DS rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0011101 | rs2 | rs1 | 000 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0011101",
          "clean": "0011101"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "R[rd] = aes_decrypt_schedule(R[rs1], R[rs2]);",
    "example": "AES64DS x10, x11, x12",
    "example_note": "AES Decrypt Key Gen.",
    "linked_summary": "Performs one round of AES-128 decryption key schedule generation.",
    "linked_pseudocode": "R[rd] = aes_decrypt_schedule(R[rs1], R[rs2]);"
  },
  {
    "mnemonic": "SHA256SIG0",
    "architecture": "RISC-V",
    "extension": "Zk (Crypto)",
    "full_name": "SHA-256 Sigma0",
    "summary": "Performs the Sigma0 transformation function for SHA-256.",
    "syntax": "SHA256SIG0 rd, rs1",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "0001000 | 00010 | rs1 | 001 | rd | 0010011",
      "hex_opcode": "0x13",
      "visual_parts": [
        {
          "raw": "0001000",
          "clean": "0001000"
        },
        {
          "raw": "00010",
          "clean": "00010"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0010011",
          "clean": "0010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      }
    ],
    "pseudocode": "R[rd] = ROTR(x, 7) ^ ROTR(x, 18) ^ (x >> 3);",
    "example": "SHA256SIG0 x10, x11",
    "example_note": "SHA-256 calculation.",
    "linked_summary": "Performs the Sigma0 transformation function for SHA-256.",
    "linked_pseudocode": "R[rd] = ROTR(x, 7) ^ ROTR(x, 18) ^ (x >> 3);"
  },
  {
    "mnemonic": "SHA256SUM0",
    "architecture": "RISC-V",
    "extension": "Zk (Crypto)",
    "full_name": "SHA-256 Sum0",
    "summary": "Performs the Sum0 transformation function for SHA-256.",
    "syntax": "SHA256SUM0 rd, rs1",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "0001000 | 00000 | rs1 | 001 | rd | 0010011",
      "hex_opcode": "0x13",
      "visual_parts": [
        {
          "raw": "0001000",
          "clean": "0001000"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0010011",
          "clean": "0010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      }
    ],
    "pseudocode": "R[rd] = ROTR(x, 2) ^ ROTR(x, 13) ^ ROTR(x, 22);",
    "example": "SHA256SUM0 x10, x11",
    "example_note": "SHA-256 calculation.",
    "linked_summary": "Performs the Sum0 transformation function for SHA-256.",
    "linked_pseudocode": "R[rd] = ROTR(x, 2) ^ ROTR(x, 13) ^ ROTR(x, 22);"
  },
  {
    "mnemonic": "FCVT.WU.S",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Convert Float to Unsigned Word",
    "summary": "Converts a single-precision float to a 32-bit unsigned integer.",
    "syntax": "FCVT.WU.S rd, rs1",
    "encoding": {
      "format": "I-Type (Float)",
      "binary_pattern": "1100000 | 00001 | rs1 | rm | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "1100000",
          "clean": "1100000"
        },
        {
          "raw": "00001",
          "clean": "00001"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "rm",
          "clean": "rm"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (UInt)"
      },
      {
        "name": "rs1",
        "desc": "Source (Float)"
      }
    ],
    "pseudocode": "R[rd] = sext(f32_to_u32(F[rs1]));",
    "example": "FCVT.WU.S x10, f1",
    "example_note": "Float -> Unsigned Int.",
    "linked_summary": "Converts a single-precision float to a 32-<a href=\"../../armv8-a/bit/\">bit</a> unsigned integer.",
    "linked_pseudocode": "R[rd] = sext(f32_to_u32(F[rs1]));"
  },
  {
    "mnemonic": "FCVT.S.WU",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Convert Unsigned Word to Float",
    "summary": "Converts a 32-bit unsigned integer to a single-precision float.",
    "syntax": "FCVT.S.WU rd, rs1",
    "encoding": {
      "format": "I-Type (Float)",
      "binary_pattern": "1101000 | 00001 | rs1 | rm | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "1101000",
          "clean": "1101000"
        },
        {
          "raw": "00001",
          "clean": "00001"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "rm",
          "clean": "rm"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Float)"
      },
      {
        "name": "rs1",
        "desc": "Source (UInt)"
      }
    ],
    "pseudocode": "F[rd] = u32_to_f32(R[rs1]);",
    "example": "FCVT.S.WU f1, x10",
    "example_note": "Unsigned Int -> Float.",
    "linked_summary": "Converts a 32-<a href=\"../../armv8-a/bit/\">bit</a> unsigned integer to a single-precision float.",
    "linked_pseudocode": "F[rd] = u32_to_f32(R[rs1]);"
  },
  {
    "mnemonic": "FCVT.W.D",
    "architecture": "RISC-V",
    "extension": "D",
    "full_name": "Convert Double to Word",
    "summary": "Converts a double-precision float to a 32-bit signed integer.",
    "syntax": "FCVT.W.D rd, rs1",
    "encoding": {
      "format": "I-Type (Float)",
      "binary_pattern": "1100001 | 00000 | rs1 | rm | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "1100001",
          "clean": "1100001"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "rm",
          "clean": "rm"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Int)"
      },
      {
        "name": "rs1",
        "desc": "Source (Double)"
      }
    ],
    "pseudocode": "R[rd] = sext(f64_to_i32(F[rs1]));",
    "example": "FCVT.W.D x10, f0",
    "example_note": "Double -> Int.",
    "linked_summary": "Converts a double-precision float to a 32-<a href=\"../../armv8-a/bit/\">bit</a> signed integer.",
    "linked_pseudocode": "R[rd] = sext(f64_to_i32(F[rs1]));"
  },
  {
    "mnemonic": "FCVT.D.W",
    "architecture": "RISC-V",
    "extension": "D",
    "full_name": "Convert Word to Double",
    "summary": "Converts a 32-bit signed integer to a double-precision float.",
    "syntax": "FCVT.D.W rd, rs1",
    "encoding": {
      "format": "I-Type (Float)",
      "binary_pattern": "1101001 | 00000 | rs1 | rm | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "1101001",
          "clean": "1101001"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "rm",
          "clean": "rm"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Double)"
      },
      {
        "name": "rs1",
        "desc": "Source (Int)"
      }
    ],
    "pseudocode": "F[rd] = i32_to_f64(R[rs1]);",
    "example": "FCVT.D.W f0, x10",
    "example_note": "Int -> Double.",
    "linked_summary": "Converts a 32-<a href=\"../../armv8-a/bit/\">bit</a> signed integer to a double-precision float.",
    "linked_pseudocode": "F[rd] = i32_to_f64(R[rs1]);"
  },
  {
    "mnemonic": "SH1ADD",
    "architecture": "RISC-V",
    "extension": "Zba (Address Gen)",
    "full_name": "Shift Left 1 and Add",
    "summary": "Shifts rs1 left by 1 and adds rs2. Used for calculating addresses of 16-bit elements.",
    "syntax": "SH1ADD rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0010000 | rs2 | rs1 | 010 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0010000",
          "clean": "0010000"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "010",
          "clean": "010"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Index"
      },
      {
        "name": "rs2",
        "desc": "Base"
      }
    ],
    "pseudocode": "R[rd] = R[rs2] + (R[rs1] << 1);",
    "example": "SH1ADD x10, x11, x12",
    "example_note": "Calculate address: x12 + (x11 * 2).",
    "linked_summary": "Shifts rs1 left by 1 <a href=\"../../armv8-a/and/\">and</a> <a href=\"../../armv8-a/adds/\">adds</a> rs2. Used for calculating addresses of 16-<a href=\"../../armv8-a/bit/\">bit</a> elements.",
    "linked_pseudocode": "R[rd] = R[rs2] + (R[rs1] << 1);"
  },
  {
    "mnemonic": "SH2ADD",
    "architecture": "RISC-V",
    "extension": "Zba (Address Gen)",
    "full_name": "Shift Left 2 and Add",
    "summary": "Shifts rs1 left by 2 and adds rs2. Used for calculating addresses of 32-bit elements.",
    "syntax": "SH2ADD rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0010000 | rs2 | rs1 | 100 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0010000",
          "clean": "0010000"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "100",
          "clean": "100"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Index"
      },
      {
        "name": "rs2",
        "desc": "Base"
      }
    ],
    "pseudocode": "R[rd] = R[rs2] + (R[rs1] << 2);",
    "example": "SH2ADD x10, x11, x12",
    "example_note": "Calculate address: x12 + (x11 * 4).",
    "linked_summary": "Shifts rs1 left by 2 <a href=\"../../armv8-a/and/\">and</a> <a href=\"../../armv8-a/adds/\">adds</a> rs2. Used for calculating addresses of 32-<a href=\"../../armv8-a/bit/\">bit</a> elements.",
    "linked_pseudocode": "R[rd] = R[rs2] + (R[rs1] << 2);"
  },
  {
    "mnemonic": "SH3ADD",
    "architecture": "RISC-V",
    "extension": "Zba (Address Gen)",
    "full_name": "Shift Left 3 and Add",
    "summary": "Shifts rs1 left by 3 and adds rs2. Used for calculating addresses of 64-bit elements.",
    "syntax": "SH3ADD rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0010000 | rs2 | rs1 | 110 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0010000",
          "clean": "0010000"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "110",
          "clean": "110"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Index"
      },
      {
        "name": "rs2",
        "desc": "Base"
      }
    ],
    "pseudocode": "R[rd] = R[rs2] + (R[rs1] << 3);",
    "example": "SH3ADD x10, x11, x12",
    "example_note": "Calculate address: x12 + (x11 * 8).",
    "linked_summary": "Shifts rs1 left by 3 <a href=\"../../armv8-a/and/\">and</a> <a href=\"../../armv8-a/adds/\">adds</a> rs2. Used for calculating addresses of 64-<a href=\"../../armv8-a/bit/\">bit</a> elements.",
    "linked_pseudocode": "R[rd] = R[rs2] + (R[rs1] << 3);"
  },
  {
    "mnemonic": "ADDUW",
    "architecture": "RISC-V",
    "extension": "Zba (Address Gen)",
    "full_name": "Add Unsigned Word",
    "summary": "Zero-extends the lower 32 bits of rs1 and adds it to rs2. Useful for 64-bit address calculations with 32-bit unsigned indices.",
    "syntax": "ADDUW rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000100 | rs2 | rs1 | 000 | rd | 0111011",
      "hex_opcode": "0x3B",
      "visual_parts": [
        {
          "raw": "0000100",
          "clean": "0000100"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0111011",
          "clean": "0111011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Index (32-bit)"
      },
      {
        "name": "rs2",
        "desc": "Base"
      }
    ],
    "pseudocode": "R[rd] = R[rs2] + zext(R[rs1][31:0]);",
    "example": "ADDUW x10, x11, x12",
    "example_note": "x10 = x12 + (uint32_t)x11",
    "linked_summary": "Zero-extends the lower 32 bits of rs1 <a href=\"../../armv8-a/and/\">and</a> <a href=\"../../armv8-a/adds/\">adds</a> <a href=\"../../armv8-a/it/\">it</a> to rs2. Useful for 64-<a href=\"../../armv8-a/bit/\">bit</a> address calculations with 32-<a href=\"../../armv8-a/bit/\">bit</a> unsigned indices.",
    "linked_pseudocode": "R[rd] = R[rs2] + zext(R[rs1][31:0]);"
  },
  {
    "mnemonic": "BSET",
    "architecture": "RISC-V",
    "extension": "Zbs (Single Bit)",
    "full_name": "Bit Set",
    "summary": "Sets a single bit in rs1 at the index specified by rs2.",
    "syntax": "BSET rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0010100 | rs2 | rs1 | 001 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0010100",
          "clean": "0010100"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "rs2",
        "desc": "Index"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] | (1 << (R[rs2] & (XLEN-1)));",
    "example": "BSET x10, x11, x12",
    "example_note": "Set the bit at index x12 in x11.",
    "linked_summary": "Sets a single <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> rs1 <a href=\"../../armv8-a/at/\">at</a> the <a href=\"../../armv8-a/index/\">index</a> specified by rs2.",
    "linked_pseudocode": "R[rd] = R[rs1] | (1 << (R[rs2] & (XLEN-1)));"
  },
  {
    "mnemonic": "BSETI",
    "architecture": "RISC-V",
    "extension": "Zbs (Single Bit)",
    "full_name": "Bit Set Immediate",
    "summary": "Sets a single bit in rs1 at the index specified by an immediate.",
    "syntax": "BSETI rd, rs1, imm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "0010100 | imm | rs1 | 001 | rd | 0010011",
      "hex_opcode": "0x13",
      "visual_parts": [
        {
          "raw": "0010100",
          "clean": "0010100"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0010011",
          "clean": "0010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "imm",
        "desc": "Index"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] | (1 << imm);",
    "example": "BSETI x10, x11, 5",
    "example_note": "Set bit 5.",
    "linked_summary": "Sets a single <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> rs1 <a href=\"../../armv8-a/at/\">at</a> the <a href=\"../../armv8-a/index/\">index</a> specified by an immediate.",
    "linked_pseudocode": "R[rd] = R[rs1] | (1 << imm);"
  },
  {
    "mnemonic": "BCLR",
    "architecture": "RISC-V",
    "extension": "Zbs (Single Bit)",
    "full_name": "Bit Clear",
    "summary": "Clears a single bit in rs1 at the index specified by rs2.",
    "syntax": "BCLR rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0100100 | rs2 | rs1 | 001 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0100100",
          "clean": "0100100"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "rs2",
        "desc": "Index"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] & ~(1 << (R[rs2] & (XLEN-1)));",
    "example": "BCLR x10, x11, x12",
    "example_note": "Clear the bit at index x12.",
    "linked_summary": "Clears a single <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> rs1 <a href=\"../../armv8-a/at/\">at</a> the <a href=\"../../armv8-a/index/\">index</a> specified by rs2.",
    "linked_pseudocode": "R[rd] = R[rs1] & ~(1 << (R[rs2] & (XLEN-1)));"
  },
  {
    "mnemonic": "BCLRI",
    "architecture": "RISC-V",
    "extension": "Zbs (Single Bit)",
    "full_name": "Bit Clear Immediate",
    "summary": "Clears a single bit in rs1 at the index specified by an immediate.",
    "syntax": "BCLRI rd, rs1, imm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "0100100 | imm | rs1 | 001 | rd | 0010011",
      "hex_opcode": "0x13",
      "visual_parts": [
        {
          "raw": "0100100",
          "clean": "0100100"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0010011",
          "clean": "0010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "imm",
        "desc": "Index"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] & ~(1 << imm);",
    "example": "BCLRI x10, x11, 3",
    "example_note": "Clear bit 3.",
    "linked_summary": "Clears a single <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> rs1 <a href=\"../../armv8-a/at/\">at</a> the <a href=\"../../armv8-a/index/\">index</a> specified by an immediate.",
    "linked_pseudocode": "R[rd] = R[rs1] & ~(1 << imm);"
  },
  {
    "mnemonic": "BINV",
    "architecture": "RISC-V",
    "extension": "Zbs (Single Bit)",
    "full_name": "Bit Invert",
    "summary": "Inverts (toggles) a single bit in rs1 at the index specified by rs2.",
    "syntax": "BINV rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0110100 | rs2 | rs1 | 001 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0110100",
          "clean": "0110100"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "rs2",
        "desc": "Index"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] ^ (1 << (R[rs2] & (XLEN-1)));",
    "example": "BINV x10, x11, x12",
    "example_note": "Toggle the bit at index x12.",
    "linked_summary": "Inverts (toggles) a single <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> rs1 <a href=\"../../armv8-a/at/\">at</a> the <a href=\"../../armv8-a/index/\">index</a> specified by rs2.",
    "linked_pseudocode": "R[rd] = R[rs1] ^ (1 << (R[rs2] & (XLEN-1)));"
  },
  {
    "mnemonic": "BINVI",
    "architecture": "RISC-V",
    "extension": "Zbs (Single Bit)",
    "full_name": "Bit Invert Immediate",
    "summary": "Inverts (toggles) a single bit in rs1 at the index specified by an immediate.",
    "syntax": "BINVI rd, rs1, imm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "0110100 | imm | rs1 | 001 | rd | 0010011",
      "hex_opcode": "0x13",
      "visual_parts": [
        {
          "raw": "0110100",
          "clean": "0110100"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0010011",
          "clean": "0010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "imm",
        "desc": "Index"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] ^ (1 << imm);",
    "example": "BINVI x10, x11, 7",
    "example_note": "Toggle bit 7.",
    "linked_summary": "Inverts (toggles) a single <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> rs1 <a href=\"../../armv8-a/at/\">at</a> the <a href=\"../../armv8-a/index/\">index</a> specified by an immediate.",
    "linked_pseudocode": "R[rd] = R[rs1] ^ (1 << imm);"
  },
  {
    "mnemonic": "BEXT",
    "architecture": "RISC-V",
    "extension": "Zbs (Single Bit)",
    "full_name": "Bit Extract",
    "summary": "Extracts the value of a single bit (0 or 1) at the index specified by rs2. The result is placed in the LSB of rd.",
    "syntax": "BEXT rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0100100 | rs2 | rs1 | 101 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0100100",
          "clean": "0100100"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "101",
          "clean": "101"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (0 or 1)"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "rs2",
        "desc": "Index"
      }
    ],
    "pseudocode": "R[rd] = (R[rs1] >> (R[rs2] & (XLEN-1))) & 1;",
    "example": "BEXT x10, x11, x12",
    "example_note": "x10 = (x11 >> x12) & 1",
    "linked_summary": "Extracts the value of a single <a href=\"../../armv8-a/bit/\">bit</a> (0 <a href=\"../../powerisa/or/\">or</a> 1) <a href=\"../../armv8-a/at/\">at</a> the <a href=\"../../armv8-a/index/\">index</a> specified by rs2. The result is placed <a href=\"../../x86/in/\">in</a> the LSB of rd.",
    "linked_pseudocode": "R[rd] = (R[rs1] >> (R[rs2] & (XLEN-1))) & 1;"
  },
  {
    "mnemonic": "BEXTI",
    "architecture": "RISC-V",
    "extension": "Zbs (Single Bit)",
    "full_name": "Bit Extract Immediate",
    "summary": "Extracts the value of a single bit (0 or 1) at the index specified by an immediate.",
    "syntax": "BEXTI rd, rs1, imm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "0100100 | imm | rs1 | 101 | rd | 0010011",
      "hex_opcode": "0x13",
      "visual_parts": [
        {
          "raw": "0100100",
          "clean": "0100100"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "101",
          "clean": "101"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0010011",
          "clean": "0010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (0 or 1)"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "imm",
        "desc": "Index"
      }
    ],
    "pseudocode": "R[rd] = (R[rs1] >> imm) & 1;",
    "example": "BEXTI x10, x11, 31",
    "example_note": "Get sign bit (bit 31) of x11.",
    "linked_summary": "Extracts the value of a single <a href=\"../../armv8-a/bit/\">bit</a> (0 <a href=\"../../powerisa/or/\">or</a> 1) <a href=\"../../armv8-a/at/\">at</a> the <a href=\"../../armv8-a/index/\">index</a> specified by an immediate.",
    "linked_pseudocode": "R[rd] = (R[rs1] >> imm) & 1;"
  },
  {
    "mnemonic": "CLMUL",
    "architecture": "RISC-V",
    "extension": "Zbc (Carry-less)",
    "full_name": "Carry-less Multiply",
    "summary": "Performs carry-less multiplication of the lower bits of rs1 and rs2. Used for CRC and GCM (crypto).",
    "syntax": "CLMUL rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000101 | rs2 | rs1 | 001 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0000101",
          "clean": "0000101"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Src 1"
      },
      {
        "name": "rs2",
        "desc": "Src 2"
      }
    ],
    "pseudocode": "R[rd] = clmul(R[rs1], R[rs2]);",
    "example": "CLMUL x10, x11, x12",
    "example_note": "Carry-less multiply (GF(2^n)).",
    "linked_summary": "Performs carry-less multiplication of the lower bits of rs1 <a href=\"../../armv8-a/and/\">and</a> rs2. Used for CRC <a href=\"../../armv8-a/and/\">and</a> GCM (crypto).",
    "linked_pseudocode": "R[rd] = clmul(R[rs1], R[rs2]);"
  },
  {
    "mnemonic": "FCLASS.S",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Float Classify (Single)",
    "summary": "Examines the value in a float register and generates a 10-bit bitmask indicating its class (NaN, Inf, Zero, Normal, etc.).",
    "syntax": "FCLASS.S rd, rs1",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "1110000 | 00000 | rs1 | 001 | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "1110000",
          "clean": "1110000"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Integer Mask)"
      },
      {
        "name": "rs1",
        "desc": "Source (Float)"
      }
    ],
    "pseudocode": "R[rd] = classify_float(F[rs1]);",
    "example": "FCLASS.S x10, f1",
    "example_note": "Check if f1 is NaN, Infinity, or Zero.",
    "linked_summary": "Examines the value <a href=\"../../x86/in/\">in</a> a float register <a href=\"../../armv8-a/and/\">and</a> generates a 10-<a href=\"../../armv8-a/bit/\">bit</a> bitmask indicating its class (NaN, Inf, Zero, Normal, etc.).",
    "linked_pseudocode": "R[rd] = classify_float(F[rs1]);"
  },
  {
    "mnemonic": "FCLASS.D",
    "architecture": "RISC-V",
    "extension": "D",
    "full_name": "Float Classify (Double)",
    "summary": "Examines a double-precision register and generates a classification bitmask.",
    "syntax": "FCLASS.D rd, rs1",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "1110001 | 00000 | rs1 | 001 | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "1110001",
          "clean": "1110001"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Integer Mask)"
      },
      {
        "name": "rs1",
        "desc": "Source (Double)"
      }
    ],
    "pseudocode": "R[rd] = classify_double(F[rs1]);",
    "example": "FCLASS.D x10, f0",
    "example_note": "Check if f0 is NaN/Inf/Zero.",
    "linked_summary": "Examines a double-precision register <a href=\"../../armv8-a/and/\">and</a> generates a classification bitmask.",
    "linked_pseudocode": "R[rd] = classify_double(F[rs1]);"
  },
  {
    "mnemonic": "FCVT.S.L",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Convert Long to Float",
    "summary": "Converts a 64-bit signed integer (Long) to a single-precision float.",
    "syntax": "FCVT.S.L rd, rs1",
    "encoding": {
      "format": "I-Type (Float)",
      "binary_pattern": "1101000 | 00010 | rs1 | rm | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "1101000",
          "clean": "1101000"
        },
        {
          "raw": "00010",
          "clean": "00010"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "rm",
          "clean": "rm"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Float)"
      },
      {
        "name": "rs1",
        "desc": "Source (Long Int)"
      }
    ],
    "pseudocode": "F[rd] = i64_to_f32(R[rs1]);",
    "example": "FCVT.S.L f1, x10",
    "example_note": "64-bit int -> 32-bit float.",
    "linked_summary": "Converts a 64-<a href=\"../../armv8-a/bit/\">bit</a> signed integer (Long) to a single-precision float.",
    "linked_pseudocode": "F[rd] = i64_to_f32(R[rs1]);"
  },
  {
    "mnemonic": "FCVT.S.LU",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Convert Unsigned Long to Float",
    "summary": "Converts a 64-bit unsigned integer to a single-precision float.",
    "syntax": "FCVT.S.LU rd, rs1",
    "encoding": {
      "format": "I-Type (Float)",
      "binary_pattern": "1101000 | 00011 | rs1 | rm | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "1101000",
          "clean": "1101000"
        },
        {
          "raw": "00011",
          "clean": "00011"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "rm",
          "clean": "rm"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Float)"
      },
      {
        "name": "rs1",
        "desc": "Source (U-Long)"
      }
    ],
    "pseudocode": "F[rd] = u64_to_f32(R[rs1]);",
    "example": "FCVT.S.LU f1, x10",
    "example_note": "Unsigned 64-bit int -> float.",
    "linked_summary": "Converts a 64-<a href=\"../../armv8-a/bit/\">bit</a> unsigned integer to a single-precision float.",
    "linked_pseudocode": "F[rd] = u64_to_f32(R[rs1]);"
  },
  {
    "mnemonic": "FCVT.L.S",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Convert Float to Long",
    "summary": "Converts a single-precision float to a 64-bit signed integer.",
    "syntax": "FCVT.L.S rd, rs1",
    "encoding": {
      "format": "I-Type (Float)",
      "binary_pattern": "1100000 | 00010 | rs1 | rm | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "1100000",
          "clean": "1100000"
        },
        {
          "raw": "00010",
          "clean": "00010"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "rm",
          "clean": "rm"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Long Int)"
      },
      {
        "name": "rs1",
        "desc": "Source (Float)"
      }
    ],
    "pseudocode": "R[rd] = f32_to_i64(F[rs1]);",
    "example": "FCVT.L.S x10, f1",
    "example_note": "Float -> 64-bit signed int.",
    "linked_summary": "Converts a single-precision float to a 64-<a href=\"../../armv8-a/bit/\">bit</a> signed integer.",
    "linked_pseudocode": "R[rd] = f32_to_i64(F[rs1]);"
  },
  {
    "mnemonic": "FCVT.LU.S",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Convert Float to Unsigned Long",
    "summary": "Converts a single-precision float to a 64-bit unsigned integer.",
    "syntax": "FCVT.LU.S rd, rs1",
    "encoding": {
      "format": "I-Type (Float)",
      "binary_pattern": "1100000 | 00011 | rs1 | rm | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "1100000",
          "clean": "1100000"
        },
        {
          "raw": "00011",
          "clean": "00011"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "rm",
          "clean": "rm"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (U-Long)"
      },
      {
        "name": "rs1",
        "desc": "Source (Float)"
      }
    ],
    "pseudocode": "R[rd] = f32_to_u64(F[rs1]);",
    "example": "FCVT.LU.S x10, f1",
    "example_note": "Float -> 64-bit unsigned int.",
    "linked_summary": "Converts a single-precision float to a 64-<a href=\"../../armv8-a/bit/\">bit</a> unsigned integer.",
    "linked_pseudocode": "R[rd] = f32_to_u64(F[rs1]);"
  },
  {
    "mnemonic": "FCVT.D.L",
    "architecture": "RISC-V",
    "extension": "D",
    "full_name": "Convert Long to Double",
    "summary": "Converts a 64-bit signed integer to a double-precision float.",
    "syntax": "FCVT.D.L rd, rs1",
    "encoding": {
      "format": "I-Type (Float)",
      "binary_pattern": "1101001 | 00010 | rs1 | rm | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "1101001",
          "clean": "1101001"
        },
        {
          "raw": "00010",
          "clean": "00010"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "rm",
          "clean": "rm"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Double)"
      },
      {
        "name": "rs1",
        "desc": "Source (Long)"
      }
    ],
    "pseudocode": "F[rd] = i64_to_f64(R[rs1]);",
    "example": "FCVT.D.L f0, x10",
    "example_note": "64-bit Int -> Double.",
    "linked_summary": "Converts a 64-<a href=\"../../armv8-a/bit/\">bit</a> signed integer to a double-precision float.",
    "linked_pseudocode": "F[rd] = i64_to_f64(R[rs1]);"
  },
  {
    "mnemonic": "FCVT.D.LU",
    "architecture": "RISC-V",
    "extension": "D",
    "full_name": "Convert Unsigned Long to Double",
    "summary": "Converts a 64-bit unsigned integer to a double-precision float.",
    "syntax": "FCVT.D.LU rd, rs1",
    "encoding": {
      "format": "I-Type (Float)",
      "binary_pattern": "1101001 | 00011 | rs1 | rm | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "1101001",
          "clean": "1101001"
        },
        {
          "raw": "00011",
          "clean": "00011"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "rm",
          "clean": "rm"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Double)"
      },
      {
        "name": "rs1",
        "desc": "Source (U-Long)"
      }
    ],
    "pseudocode": "F[rd] = u64_to_f64(R[rs1]);",
    "example": "FCVT.D.LU f0, x10",
    "example_note": "Unsigned 64-bit Int -> Double.",
    "linked_summary": "Converts a 64-<a href=\"../../armv8-a/bit/\">bit</a> unsigned integer to a double-precision float.",
    "linked_pseudocode": "F[rd] = u64_to_f64(R[rs1]);"
  },
  {
    "mnemonic": "FCVT.L.D",
    "architecture": "RISC-V",
    "extension": "D",
    "full_name": "Convert Double to Long",
    "summary": "Converts a double-precision float to a 64-bit signed integer.",
    "syntax": "FCVT.L.D rd, rs1",
    "encoding": {
      "format": "I-Type (Float)",
      "binary_pattern": "1100001 | 00010 | rs1 | rm | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "1100001",
          "clean": "1100001"
        },
        {
          "raw": "00010",
          "clean": "00010"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "rm",
          "clean": "rm"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Long)"
      },
      {
        "name": "rs1",
        "desc": "Source (Double)"
      }
    ],
    "pseudocode": "R[rd] = f64_to_i64(F[rs1]);",
    "example": "FCVT.L.D x10, f0",
    "example_note": "Double -> 64-bit Int.",
    "linked_summary": "Converts a double-precision float to a 64-<a href=\"../../armv8-a/bit/\">bit</a> signed integer.",
    "linked_pseudocode": "R[rd] = f64_to_i64(F[rs1]);"
  },
  {
    "mnemonic": "FSGNJ.D",
    "architecture": "RISC-V",
    "extension": "D",
    "full_name": "Float Sign Injection (Double)",
    "summary": "Injects the sign of rs2 into rs1 (Double Precision).",
    "syntax": "FSGNJ.D rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0010001 | rs2 | rs1 | 000 | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "0010001",
          "clean": "0010001"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source (Body)"
      },
      {
        "name": "rs2",
        "desc": "Source (Sign)"
      }
    ],
    "pseudocode": "F[rd] = {F[rs2][63], F[rs1][62:0]};",
    "example": "FSGNJ.D f0, f1, f2",
    "example_note": "Copy sign of f2 to f1.",
    "linked_summary": "Injects the sign of rs2 into rs1 (Double Precision).",
    "linked_pseudocode": "F[rd] = {F[rs2][63], F[rs1][62:0]};"
  },
  {
    "mnemonic": "FSGNJN.D",
    "architecture": "RISC-V",
    "extension": "D",
    "full_name": "Float Sign Injection Negate (Double)",
    "summary": "Injects the *negated* sign of rs2 into rs1 (Double Precision).",
    "syntax": "FSGNJN.D rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0010001 | rs2 | rs1 | 001 | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "0010001",
          "clean": "0010001"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source (Body)"
      },
      {
        "name": "rs2",
        "desc": "Source (Sign)"
      }
    ],
    "pseudocode": "F[rd] = {~F[rs2][63], F[rs1][62:0]};",
    "example": "FSGNJN.D f0, f1, f1",
    "example_note": "Negate f1 (f0 = -f1).",
    "linked_summary": "Injects the *negated* sign of rs2 into rs1 (Double Precision).",
    "linked_pseudocode": "F[rd] = {~F[rs2][63], F[rs1][62:0]};"
  },
  {
    "mnemonic": "FEQ.D",
    "architecture": "RISC-V",
    "extension": "D",
    "full_name": "Float Equal (Double)",
    "summary": "Sets integer rd to 1 if double rs1 equals double rs2, else 0.",
    "syntax": "FEQ.D rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "1010001 | rs2 | rs1 | 010 | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "1010001",
          "clean": "1010001"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "010",
          "clean": "010"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Int)"
      },
      {
        "name": "rs1",
        "desc": "Src 1 (Double)"
      },
      {
        "name": "rs2",
        "desc": "Src 2 (Double)"
      }
    ],
    "pseudocode": "R[rd] = (F[rs1] == F[rs2]) ? 1 : 0;",
    "example": "FEQ.D x10, f0, f1",
    "example_note": "Compare equality.",
    "linked_summary": "Sets integer rd to 1 if double rs1 equals double rs2, else 0.",
    "linked_pseudocode": "R[rd] = (F[rs1] == F[rs2]) ? 1 : 0;"
  },
  {
    "mnemonic": "FLT.D",
    "architecture": "RISC-V",
    "extension": "D",
    "full_name": "Float Less Than (Double)",
    "summary": "Sets integer rd to 1 if double rs1 is less than double rs2, else 0.",
    "syntax": "FLT.D rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "1010001 | rs2 | rs1 | 001 | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "1010001",
          "clean": "1010001"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Int)"
      },
      {
        "name": "rs1",
        "desc": "Src 1"
      },
      {
        "name": "rs2",
        "desc": "Src 2"
      }
    ],
    "pseudocode": "R[rd] = (F[rs1] < F[rs2]) ? 1 : 0;",
    "example": "FLT.D x10, f0, f1",
    "example_note": "Less than check.",
    "linked_summary": "Sets integer rd to 1 if double rs1 is less than double rs2, else 0.",
    "linked_pseudocode": "R[rd] = (F[rs1] < F[rs2]) ? 1 : 0;"
  },
  {
    "mnemonic": "FLE.D",
    "architecture": "RISC-V",
    "extension": "D",
    "full_name": "Float Less or Equal (Double)",
    "summary": "Sets integer rd to 1 if double rs1 is less than or equal to double rs2, else 0.",
    "syntax": "FLE.D rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "1010001 | rs2 | rs1 | 000 | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "1010001",
          "clean": "1010001"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Int)"
      },
      {
        "name": "rs1",
        "desc": "Src 1"
      },
      {
        "name": "rs2",
        "desc": "Src 2"
      }
    ],
    "pseudocode": "R[rd] = (F[rs1] <= F[rs2]) ? 1 : 0;",
    "example": "FLE.D x10, f0, f1",
    "example_note": "Less equal check.",
    "linked_summary": "Sets integer rd to 1 if double rs1 is less than <a href=\"../../powerisa/or/\">or</a> equal to double rs2, else 0.",
    "linked_pseudocode": "R[rd] = (F[rs1] <= F[rs2]) ? 1 : 0;"
  },
  {
    "mnemonic": "C.ADDI4SPN",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Add Immediate to Stack Pointer (Non-zero)",
    "summary": "Adds a zero-extended non-zero immediate to the stack pointer (x2) and stores the result in a register.",
    "syntax": "C.ADDI4SPN rd', uimm",
    "encoding": {
      "format": "CIW",
      "binary_pattern": "000 | uimm | rd' | 00",
      "hex_opcode": "00",
      "visual_parts": [
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "uimm",
          "clean": "uimm"
        },
        {
          "raw": "rd'",
          "clean": "rd'"
        },
        {
          "raw": "00",
          "clean": "00"
        }
      ]
    },
    "operands": [
      {
        "name": "rd'",
        "desc": "Dest (x8-x15)"
      },
      {
        "name": "uimm",
        "desc": "Immediate"
      }
    ],
    "pseudocode": "R[rd'] = R[2] + zext(uimm);",
    "example": "C.ADDI4SPN x8, 16",
    "example_note": "Load address of stack object.",
    "linked_summary": "Adds a <a href=\"../../armv9-a/zero/\">zero</a>-extended non-<a href=\"../../armv9-a/zero/\">zero</a> immediate to the stack pointer (x2) <a href=\"../../armv8-a/and/\">and</a> stores the result <a href=\"../../x86/in/\">in</a> a register.",
    "linked_pseudocode": "R[rd'] = R[2] + zext(uimm);"
  },
  {
    "mnemonic": "C.LW",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Load Word",
    "summary": "Loads a 32-bit word from memory using a compressed encoding.",
    "syntax": "C.LW rd', offset(rs1')",
    "encoding": {
      "format": "CL",
      "binary_pattern": "010 | imm | rs1' | imm | rd' | 00",
      "hex_opcode": "00",
      "visual_parts": [
        {
          "raw": "010",
          "clean": "010"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "rs1'",
          "clean": "rs1'"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "rd'",
          "clean": "rd'"
        },
        {
          "raw": "00",
          "clean": "00"
        }
      ]
    },
    "operands": [
      {
        "name": "rd'",
        "desc": "Dest (x8-x15)"
      },
      {
        "name": "rs1'",
        "desc": "Base (x8-x15)"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "R[rd'] = M[R[rs1'] + offset][31:0];",
    "example": "C.LW x8, 4(x9)",
    "example_note": "16-bit encoding of LW.",
    "linked_summary": "Loads a 32-<a href=\"../../armv8-a/bit/\">bit</a> word from memory using a compressed encoding.",
    "linked_pseudocode": "R[rd'] = M[R[rs1'] + offset][31:0];"
  },
  {
    "mnemonic": "C.SW",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Store Word",
    "summary": "Stores a 32-bit word to memory using a compressed encoding.",
    "syntax": "C.SW rs2', offset(rs1')",
    "encoding": {
      "format": "CS",
      "binary_pattern": "110 | imm | rs1' | imm | rs2' | 00",
      "hex_opcode": "00",
      "visual_parts": [
        {
          "raw": "110",
          "clean": "110"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "rs1'",
          "clean": "rs1'"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "rs2'",
          "clean": "rs2'"
        },
        {
          "raw": "00",
          "clean": "00"
        }
      ]
    },
    "operands": [
      {
        "name": "rs2'",
        "desc": "Source (x8-x15)"
      },
      {
        "name": "rs1'",
        "desc": "Base (x8-x15)"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "M[R[rs1'] + offset][31:0] = R[rs2'];",
    "example": "C.SW x8, 4(x9)",
    "example_note": "16-bit encoding of SW.",
    "linked_summary": "Stores a 32-<a href=\"../../armv8-a/bit/\">bit</a> word to memory using a compressed encoding.",
    "linked_pseudocode": "M[R[rs1'] + offset][31:0] = R[rs2'];"
  },
  {
    "mnemonic": "C.ADDI",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Add Immediate",
    "summary": "Adds a non-zero immediate to a register.",
    "syntax": "C.ADDI rd, imm",
    "encoding": {
      "format": "CI",
      "binary_pattern": "000 | imm | rd | imm | 01",
      "hex_opcode": "01",
      "visual_parts": [
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "01",
          "clean": "01"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest/Source"
      },
      {
        "name": "imm",
        "desc": "6-bit Signed Imm"
      }
    ],
    "pseudocode": "R[rd] = R[rd] + sext(imm);",
    "example": "C.ADDI x10, 1",
    "example_note": "Increment x10.",
    "linked_summary": "Adds a non-<a href=\"../../armv9-a/zero/\">zero</a> immediate to a register.",
    "linked_pseudocode": "R[rd] = R[rd] + sext(imm);"
  },
  {
    "mnemonic": "C.JAL",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Jump and Link",
    "summary": "Performs a PC-relative jump and stores return address in x1 (ra). RV32 only.",
    "syntax": "C.JAL offset",
    "encoding": {
      "format": "CJ",
      "binary_pattern": "001 | imm | 01",
      "hex_opcode": "01",
      "visual_parts": [
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "01",
          "clean": "01"
        }
      ]
    },
    "operands": [
      {
        "name": "offset",
        "desc": "Jump Target"
      }
    ],
    "pseudocode": "R[1] = PC + 2; PC += sext(offset);",
    "example": "C.JAL func",
    "example_note": "Compressed function call.",
    "linked_summary": "Performs a PC-relative jump <a href=\"../../armv8-a/and/\">and</a> stores return address <a href=\"../../x86/in/\">in</a> x1 (ra). RV32 only.",
    "linked_pseudocode": "R[1] = PC + 2; PC += sext(offset);"
  },
  {
    "mnemonic": "C.LI",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Load Immediate",
    "summary": "Loads a 6-bit signed immediate into a register.",
    "syntax": "C.LI rd, imm",
    "encoding": {
      "format": "CI",
      "binary_pattern": "010 | imm | rd | imm | 01",
      "hex_opcode": "01",
      "visual_parts": [
        {
          "raw": "010",
          "clean": "010"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "01",
          "clean": "01"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "imm",
        "desc": "Immediate"
      }
    ],
    "pseudocode": "R[rd] = sext(imm);",
    "example": "C.LI x10, 1",
    "example_note": "Set x10 to 1.",
    "linked_summary": "Loads a 6-<a href=\"../../armv8-a/bit/\">bit</a> signed immediate into a register.",
    "linked_pseudocode": "R[rd] = sext(imm);"
  },
  {
    "mnemonic": "C.ADDI16SP",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Add Immediate to Stack Pointer",
    "summary": "Adds a signed non-zero immediate to the stack pointer (x2).",
    "syntax": "C.ADDI16SP imm",
    "encoding": {
      "format": "CI",
      "binary_pattern": "011 | imm | 00010 | imm | 01",
      "hex_opcode": "01",
      "visual_parts": [
        {
          "raw": "011",
          "clean": "011"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "00010",
          "clean": "00010"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "01",
          "clean": "01"
        }
      ]
    },
    "operands": [
      {
        "name": "imm",
        "desc": "Signed Imm * 16"
      }
    ],
    "pseudocode": "R[2] = R[2] + sext(imm);",
    "example": "C.ADDI16SP -64",
    "example_note": "Allocate 64 bytes on stack.",
    "linked_summary": "Adds a signed non-<a href=\"../../armv9-a/zero/\">zero</a> immediate to the stack pointer (x2).",
    "linked_pseudocode": "R[2] = R[2] + sext(imm);"
  },
  {
    "mnemonic": "C.LUI",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Load Upper Immediate",
    "summary": "Loads a non-zero 6-bit immediate into bits 17-12 of the destination register, clears lower 12 bits, sign-extends bit 17.",
    "syntax": "C.LUI rd, imm",
    "encoding": {
      "format": "CI",
      "binary_pattern": "011 | imm | rd | imm | 01",
      "hex_opcode": "01",
      "visual_parts": [
        {
          "raw": "011",
          "clean": "011"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "01",
          "clean": "01"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "imm",
        "desc": "Immediate"
      }
    ],
    "pseudocode": "R[rd] = sext(imm << 12);",
    "example": "C.LUI x10, 1",
    "example_note": "Loads 0x1000 into x10.",
    "linked_summary": "Loads a non-<a href=\"../../armv9-a/zero/\">zero</a> 6-<a href=\"../../armv8-a/bit/\">bit</a> immediate into bits 17-12 of the destination register, clears lower 12 bits, sign-extends <a href=\"../../armv8-a/bit/\">bit</a> 17.",
    "linked_pseudocode": "R[rd] = sext(imm << 12);"
  },
  {
    "mnemonic": "C.SRLI",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Shift Right Logical Immediate",
    "summary": "Logically shifts a register right by immediate.",
    "syntax": "C.SRLI rd', imm",
    "encoding": {
      "format": "CB",
      "binary_pattern": "100 | imm | 00 | imm | rd' | 01",
      "hex_opcode": "01",
      "visual_parts": [
        {
          "raw": "100",
          "clean": "100"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "00",
          "clean": "00"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "rd'",
          "clean": "rd'"
        },
        {
          "raw": "01",
          "clean": "01"
        }
      ]
    },
    "operands": [
      {
        "name": "rd'",
        "desc": "Dest/Source (x8-x15)"
      },
      {
        "name": "imm",
        "desc": "Shift Amount"
      }
    ],
    "pseudocode": "R[rd'] = R[rd'] >> imm;",
    "example": "C.SRLI x8, 2",
    "example_note": "x8 = x8 >> 2",
    "linked_summary": "Logically shifts a register right by immediate.",
    "linked_pseudocode": "R[rd'] = R[rd'] >> imm;"
  },
  {
    "mnemonic": "C.SRAI",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Shift Right Arithmetic Immediate",
    "summary": "Arithmetically shifts a register right by immediate.",
    "syntax": "C.SRAI rd', imm",
    "encoding": {
      "format": "CB",
      "binary_pattern": "100 | imm | 01 | imm | rd' | 01",
      "hex_opcode": "01",
      "visual_parts": [
        {
          "raw": "100",
          "clean": "100"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "01",
          "clean": "01"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "rd'",
          "clean": "rd'"
        },
        {
          "raw": "01",
          "clean": "01"
        }
      ]
    },
    "operands": [
      {
        "name": "rd'",
        "desc": "Dest/Source"
      },
      {
        "name": "imm",
        "desc": "Shift Amount"
      }
    ],
    "pseudocode": "R[rd'] = R[rd'] >>s imm;",
    "example": "C.SRAI x8, 2",
    "example_note": "x8 = x8 >>s 2",
    "linked_summary": "Arithmetically shifts a register right by immediate.",
    "linked_pseudocode": "R[rd'] = R[rd'] >>s imm;"
  },
  {
    "mnemonic": "C.ANDI",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed AND Immediate",
    "summary": "Computes bitwise AND with a signed immediate.",
    "syntax": "C.ANDI rd', imm",
    "encoding": {
      "format": "CB",
      "binary_pattern": "100 | imm | 10 | imm | rd' | 01",
      "hex_opcode": "01",
      "visual_parts": [
        {
          "raw": "100",
          "clean": "100"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "10",
          "clean": "10"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "rd'",
          "clean": "rd'"
        },
        {
          "raw": "01",
          "clean": "01"
        }
      ]
    },
    "operands": [
      {
        "name": "rd'",
        "desc": "Dest/Source"
      },
      {
        "name": "imm",
        "desc": "Signed Imm"
      }
    ],
    "pseudocode": "R[rd'] = R[rd'] & sext(imm);",
    "example": "C.ANDI x8, 15",
    "example_note": "Keep lowest 4 bits.",
    "linked_summary": "Computes bitwise <a href=\"../../risc-v/and/\">AND</a> with a signed immediate.",
    "linked_pseudocode": "R[rd'] = R[rd'] & sext(imm);"
  },
  {
    "mnemonic": "C.SUB",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Subtract",
    "summary": "Subtracts two registers.",
    "syntax": "C.SUB rd', rs2'",
    "encoding": {
      "format": "CA",
      "binary_pattern": "100011 | rd' | 00 | rs2' | 01",
      "hex_opcode": "01",
      "visual_parts": [
        {
          "raw": "100011",
          "clean": "100011"
        },
        {
          "raw": "rd'",
          "clean": "rd'"
        },
        {
          "raw": "00",
          "clean": "00"
        },
        {
          "raw": "rs2'",
          "clean": "rs2'"
        },
        {
          "raw": "01",
          "clean": "01"
        }
      ]
    },
    "operands": [
      {
        "name": "rd'",
        "desc": "Dest/Src1"
      },
      {
        "name": "rs2'",
        "desc": "Src2"
      }
    ],
    "pseudocode": "R[rd'] = R[rd'] - R[rs2'];",
    "example": "C.SUB x8, x9",
    "example_note": "x8 = x8 - x9",
    "linked_summary": "Subtracts two registers.",
    "linked_pseudocode": "R[rd'] = R[rd'] - R[rs2'];"
  },
  {
    "mnemonic": "C.XOR",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed XOR",
    "summary": "Bitwise XOR of two registers.",
    "syntax": "C.XOR rd', rs2'",
    "encoding": {
      "format": "CA",
      "binary_pattern": "100011 | rd' | 01 | rs2' | 01",
      "hex_opcode": "01",
      "visual_parts": [
        {
          "raw": "100011",
          "clean": "100011"
        },
        {
          "raw": "rd'",
          "clean": "rd'"
        },
        {
          "raw": "01",
          "clean": "01"
        },
        {
          "raw": "rs2'",
          "clean": "rs2'"
        },
        {
          "raw": "01",
          "clean": "01"
        }
      ]
    },
    "operands": [
      {
        "name": "rd'",
        "desc": "Dest/Src1"
      },
      {
        "name": "rs2'",
        "desc": "Src2"
      }
    ],
    "pseudocode": "R[rd'] = R[rd'] ^ R[rs2'];",
    "example": "C.XOR x8, x9",
    "example_note": "x8 = x8 ^ x9",
    "linked_summary": "Bitwise <a href=\"../../risc-v/xor/\">XOR</a> of two registers.",
    "linked_pseudocode": "R[rd'] = R[rd'] ^ R[rs2'];"
  },
  {
    "mnemonic": "C.OR",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed OR",
    "summary": "Bitwise OR of two registers.",
    "syntax": "C.OR rd', rs2'",
    "encoding": {
      "format": "CA",
      "binary_pattern": "100011 | rd' | 10 | rs2' | 01",
      "hex_opcode": "01",
      "visual_parts": [
        {
          "raw": "100011",
          "clean": "100011"
        },
        {
          "raw": "rd'",
          "clean": "rd'"
        },
        {
          "raw": "10",
          "clean": "10"
        },
        {
          "raw": "rs2'",
          "clean": "rs2'"
        },
        {
          "raw": "01",
          "clean": "01"
        }
      ]
    },
    "operands": [
      {
        "name": "rd'",
        "desc": "Dest/Src1"
      },
      {
        "name": "rs2'",
        "desc": "Src2"
      }
    ],
    "pseudocode": "R[rd'] = R[rd'] | R[rs2'];",
    "example": "C.OR x8, x9",
    "example_note": "x8 = x8 | x9",
    "linked_summary": "Bitwise <a href=\"../../risc-v/or/\">OR</a> of two registers.",
    "linked_pseudocode": "R[rd'] = R[rd'] | R[rs2'];"
  },
  {
    "mnemonic": "C.AND",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed AND",
    "summary": "Bitwise AND of two registers.",
    "syntax": "C.AND rd', rs2'",
    "encoding": {
      "format": "CA",
      "binary_pattern": "100011 | rd' | 11 | rs2' | 01",
      "hex_opcode": "01",
      "visual_parts": [
        {
          "raw": "100011",
          "clean": "100011"
        },
        {
          "raw": "rd'",
          "clean": "rd'"
        },
        {
          "raw": "11",
          "clean": "11"
        },
        {
          "raw": "rs2'",
          "clean": "rs2'"
        },
        {
          "raw": "01",
          "clean": "01"
        }
      ]
    },
    "operands": [
      {
        "name": "rd'",
        "desc": "Dest/Src1"
      },
      {
        "name": "rs2'",
        "desc": "Src2"
      }
    ],
    "pseudocode": "R[rd'] = R[rd'] & R[rs2'];",
    "example": "C.AND x8, x9",
    "example_note": "x8 = x8 & x9",
    "linked_summary": "Bitwise <a href=\"../../risc-v/and/\">AND</a> of two registers.",
    "linked_pseudocode": "R[rd'] = R[rd'] & R[rs2'];"
  },
  {
    "mnemonic": "C.J",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Jump",
    "summary": "Unconditional PC-relative jump.",
    "syntax": "C.J offset",
    "encoding": {
      "format": "CJ",
      "binary_pattern": "101 | imm | 01",
      "hex_opcode": "01",
      "visual_parts": [
        {
          "raw": "101",
          "clean": "101"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "01",
          "clean": "01"
        }
      ]
    },
    "operands": [
      {
        "name": "offset",
        "desc": "Target"
      }
    ],
    "pseudocode": "PC += sext(offset);",
    "example": "C.J label",
    "example_note": "Jump to label.",
    "linked_summary": "Unconditional PC-relative jump.",
    "linked_pseudocode": "PC += sext(offset);"
  },
  {
    "mnemonic": "C.BEQZ",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Branch if Equal to Zero",
    "summary": "Branches if the register is zero.",
    "syntax": "C.BEQZ rs1', offset",
    "encoding": {
      "format": "CB",
      "binary_pattern": "110 | imm | rs1' | imm | 01",
      "hex_opcode": "01",
      "visual_parts": [
        {
          "raw": "110",
          "clean": "110"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "rs1'",
          "clean": "rs1'"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "01",
          "clean": "01"
        }
      ]
    },
    "operands": [
      {
        "name": "rs1'",
        "desc": "Source"
      },
      {
        "name": "offset",
        "desc": "Target"
      }
    ],
    "pseudocode": "if (R[rs1'] == 0) PC += sext(offset);",
    "example": "C.BEQZ x8, exit",
    "example_note": "Jump if x8 is 0.",
    "linked_summary": "Branches if the register is <a href=\"../../armv9-a/zero/\">zero</a>.",
    "linked_pseudocode": "if (R[rs1'] == 0) PC += sext(offset);"
  },
  {
    "mnemonic": "C.BNEZ",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Branch if Not Equal to Zero",
    "summary": "Branches if the register is not zero.",
    "syntax": "C.BNEZ rs1', offset",
    "encoding": {
      "format": "CB",
      "binary_pattern": "111 | imm | rs1' | imm | 01",
      "hex_opcode": "01",
      "visual_parts": [
        {
          "raw": "111",
          "clean": "111"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "rs1'",
          "clean": "rs1'"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "01",
          "clean": "01"
        }
      ]
    },
    "operands": [
      {
        "name": "rs1'",
        "desc": "Source"
      },
      {
        "name": "offset",
        "desc": "Target"
      }
    ],
    "pseudocode": "if (R[rs1'] != 0) PC += sext(offset);",
    "example": "C.BNEZ x8, loop",
    "example_note": "Jump if x8 is not 0.",
    "linked_summary": "Branches if the register is <a href=\"../../armv8-a/not/\">not</a> <a href=\"../../armv9-a/zero/\">zero</a>.",
    "linked_pseudocode": "if (R[rs1'] != 0) PC += sext(offset);"
  },
  {
    "mnemonic": "C.SLLI",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Shift Left Logical Immediate",
    "summary": "Logically shifts a register left by immediate.",
    "syntax": "C.SLLI rd, imm",
    "encoding": {
      "format": "CI",
      "binary_pattern": "000 | imm | rd | imm | 10",
      "hex_opcode": "02",
      "visual_parts": [
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "10",
          "clean": "10"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest/Source"
      },
      {
        "name": "imm",
        "desc": "Shift Amount"
      }
    ],
    "pseudocode": "R[rd] = R[rd] << imm;",
    "example": "C.SLLI x10, 2",
    "example_note": "x10 = x10 << 2",
    "linked_summary": "Logically shifts a register left by immediate.",
    "linked_pseudocode": "R[rd] = R[rd] << imm;"
  },
  {
    "mnemonic": "C.LWSP",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Load Word from Stack Pointer",
    "summary": "Loads a word from the stack pointer (x2).",
    "syntax": "C.LWSP rd, offset(x2)",
    "encoding": {
      "format": "CI",
      "binary_pattern": "010 | imm | rd | imm | 10",
      "hex_opcode": "02",
      "visual_parts": [
        {
          "raw": "010",
          "clean": "010"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "10",
          "clean": "10"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "R[rd] = M[R[2] + offset][31:0];",
    "example": "C.LWSP x10, 4(x2)",
    "example_note": "Load from stack.",
    "linked_summary": "Loads a word from the stack pointer (x2).",
    "linked_pseudocode": "R[rd] = M[R[2] + offset][31:0];"
  },
  {
    "mnemonic": "C.SWSP",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Store Word to Stack Pointer",
    "summary": "Stores a word to the stack pointer (x2).",
    "syntax": "C.SWSP rs2, offset(x2)",
    "encoding": {
      "format": "CSS",
      "binary_pattern": "110 | imm | rs2 | 10",
      "hex_opcode": "02",
      "visual_parts": [
        {
          "raw": "110",
          "clean": "110"
        },
        {
          "raw": "imm",
          "clean": "imm"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "10",
          "clean": "10"
        }
      ]
    },
    "operands": [
      {
        "name": "rs2",
        "desc": "Source"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "M[R[2] + offset][31:0] = R[rs2];",
    "example": "C.SWSP x10, 8(x2)",
    "example_note": "Store to stack.",
    "linked_summary": "Stores a word to the stack pointer (x2).",
    "linked_pseudocode": "M[R[2] + offset][31:0] = R[rs2];"
  },
  {
    "mnemonic": "C.JR",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Jump Register",
    "summary": "Unconditionally jumps to address in register.",
    "syntax": "C.JR rs1",
    "encoding": {
      "format": "CR",
      "binary_pattern": "1000 | rs1 | 00000 | 10",
      "hex_opcode": "02",
      "visual_parts": [
        {
          "raw": "1000",
          "clean": "1000"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "10",
          "clean": "10"
        }
      ]
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "PC = R[rs1];",
    "example": "C.JR x1",
    "example_note": "Return (if x1 is ra).",
    "linked_summary": "Unconditionally jumps to address <a href=\"../../x86/in/\">in</a> register.",
    "linked_pseudocode": "PC = R[rs1];"
  },
  {
    "mnemonic": "C.MV",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Move",
    "summary": "Copies register rs2 to rd.",
    "syntax": "C.MV rd, rs2",
    "encoding": {
      "format": "CR",
      "binary_pattern": "1000 | rd | rs2 | 10",
      "hex_opcode": "02",
      "visual_parts": [
        {
          "raw": "1000",
          "clean": "1000"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "10",
          "clean": "10"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs2",
        "desc": "Source"
      }
    ],
    "pseudocode": "R[rd] = R[rs2];",
    "example": "C.MV x10, x11",
    "example_note": "Copy x11 to x10.",
    "linked_summary": "Copies register rs2 to rd.",
    "linked_pseudocode": "R[rd] = R[rs2];"
  },
  {
    "mnemonic": "C.EBREAK",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Environment Break",
    "summary": "Triggers a debugger breakpoint.",
    "syntax": "C.EBREAK",
    "encoding": {
      "format": "CR",
      "binary_pattern": "1001000000000010",
      "hex_opcode": "9002",
      "visual_parts": [
        {
          "raw": "1001000000000010",
          "clean": "1001000000000010"
        }
      ]
    },
    "operands": [],
    "pseudocode": "RaiseException(Breakpoint);",
    "example": "C.EBREAK",
    "example_note": "Break.",
    "linked_summary": "Triggers a debugger breakpoint.",
    "linked_pseudocode": "RaiseException(Breakpoint);"
  },
  {
    "mnemonic": "C.JALR",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Jump and Link Register",
    "summary": "Jumps to register address and links (saves PC+2 to ra).",
    "syntax": "C.JALR rs1",
    "encoding": {
      "format": "CR",
      "binary_pattern": "1001 | rs1 | 00000 | 10",
      "hex_opcode": "02",
      "visual_parts": [
        {
          "raw": "1001",
          "clean": "1001"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "10",
          "clean": "10"
        }
      ]
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "t = PC + 2; PC = R[rs1]; R[1] = t;",
    "example": "C.JALR x10",
    "example_note": "Call function pointer in x10.",
    "linked_summary": "Jumps to register address <a href=\"../../armv8-a/and/\">and</a> links (saves PC+2 to ra).",
    "linked_pseudocode": "t = PC + 2; PC = R[rs1]; R[1] = t;"
  },
  {
    "mnemonic": "C.ADD",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Add",
    "summary": "Adds two registers.",
    "syntax": "C.ADD rd, rs2",
    "encoding": {
      "format": "CR",
      "binary_pattern": "1001 | rd | rs2 | 10",
      "hex_opcode": "02",
      "visual_parts": [
        {
          "raw": "1001",
          "clean": "1001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "10",
          "clean": "10"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest/Src1"
      },
      {
        "name": "rs2",
        "desc": "Src2"
      }
    ],
    "pseudocode": "R[rd] = R[rd] + R[rs2];",
    "example": "C.ADD x10, x11",
    "example_note": "x10 = x10 + x11",
    "linked_summary": "Adds two registers.",
    "linked_pseudocode": "R[rd] = R[rd] + R[rs2];"
  },
  {
    "mnemonic": "BEQ",
    "architecture": "RISC-V",
    "full_name": "Branch if Equal",
    "summary": "Take the branch if registers rs1 and rs2 are equal.",
    "syntax": "BEQ rs1, rs2, offset",
    "encoding": {
      "format": "B-Type",
      "binary_pattern": "imm[12|10:5] | rs2 | rs1 | 000 | imm[4:1|11] | 1100011",
      "hex_opcode": "0x63",
      "visual_parts": [
        {
          "raw": "imm[12",
          "clean": "imm"
        },
        {
          "raw": "10:5]",
          "clean": "10:5]"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "imm[4:1",
          "clean": "imm"
        },
        {
          "raw": "11]",
          "clean": "11]"
        },
        {
          "raw": "1100011",
          "clean": "1100011"
        }
      ]
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      },
      {
        "name": "offset",
        "desc": "PC-relative offset"
      }
    ],
    "pseudocode": "if (R[rs1] == R[rs2]) PC += sext(offset);",
    "example": "BEQ x5, x6, 100",
    "example_note": "Jump to PC+100 if x5 == x6.",
    "linked_summary": "Take the branch if registers rs1 <a href=\"../../armv8-a/and/\">and</a> rs2 are equal.",
    "linked_pseudocode": "if (R[rs1] == R[rs2]) PC += sext(offset);"
  },
  {
    "mnemonic": "BNE",
    "architecture": "RISC-V",
    "full_name": "Branch if Not Equal",
    "summary": "Take the branch if registers rs1 and rs2 are not equal.",
    "syntax": "BNE rs1, rs2, offset",
    "encoding": {
      "format": "B-Type",
      "binary_pattern": "imm[12|10:5] | rs2 | rs1 | 001 | imm[4:1|11] | 1100011",
      "hex_opcode": "0x63",
      "visual_parts": [
        {
          "raw": "imm[12",
          "clean": "imm"
        },
        {
          "raw": "10:5]",
          "clean": "10:5]"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "imm[4:1",
          "clean": "imm"
        },
        {
          "raw": "11]",
          "clean": "11]"
        },
        {
          "raw": "1100011",
          "clean": "1100011"
        }
      ]
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      },
      {
        "name": "offset",
        "desc": "PC-relative offset"
      }
    ],
    "pseudocode": "if (R[rs1] != R[rs2]) PC += sext(offset);",
    "example": "BNE x5, x6, loop",
    "example_note": "Jump to 'loop' if x5 != x6.",
    "linked_summary": "Take the branch if registers rs1 <a href=\"../../armv8-a/and/\">and</a> rs2 are <a href=\"../../armv8-a/not/\">not</a> equal.",
    "linked_pseudocode": "if (R[rs1] != R[rs2]) PC += sext(offset);"
  },
  {
    "mnemonic": "BLT",
    "architecture": "RISC-V",
    "full_name": "Branch if Less Than",
    "summary": "Take the branch if rs1 is less than rs2 (signed).",
    "syntax": "BLT rs1, rs2, offset",
    "encoding": {
      "format": "B-Type",
      "binary_pattern": "imm[12|10:5] | rs2 | rs1 | 100 | imm[4:1|11] | 1100011",
      "hex_opcode": "0x63",
      "visual_parts": [
        {
          "raw": "imm[12",
          "clean": "imm"
        },
        {
          "raw": "10:5]",
          "clean": "10:5]"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "100",
          "clean": "100"
        },
        {
          "raw": "imm[4:1",
          "clean": "imm"
        },
        {
          "raw": "11]",
          "clean": "11]"
        },
        {
          "raw": "1100011",
          "clean": "1100011"
        }
      ]
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "if (R[rs1] <s R[rs2]) PC += sext(offset);",
    "example": "BLT x10, x11, exit",
    "example_note": "Branch to 'exit' if x10 < x11 (signed comparison).",
    "linked_summary": "Take the branch if rs1 is less than rs2 (signed).",
    "linked_pseudocode": "if (R[rs1] <s R[rs2]) PC += sext(offset);"
  },
  {
    "mnemonic": "BGE",
    "architecture": "RISC-V",
    "full_name": "Branch if Greater or Equal",
    "summary": "Take the branch if rs1 is greater than or equal to rs2 (signed).",
    "syntax": "BGE rs1, rs2, offset",
    "encoding": {
      "format": "B-Type",
      "binary_pattern": "imm[12|10:5] | rs2 | rs1 | 101 | imm[4:1|11] | 1100011",
      "hex_opcode": "0x63",
      "visual_parts": [
        {
          "raw": "imm[12",
          "clean": "imm"
        },
        {
          "raw": "10:5]",
          "clean": "10:5]"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "101",
          "clean": "101"
        },
        {
          "raw": "imm[4:1",
          "clean": "imm"
        },
        {
          "raw": "11]",
          "clean": "11]"
        },
        {
          "raw": "1100011",
          "clean": "1100011"
        }
      ]
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "if (R[rs1] >=s R[rs2]) PC += sext(offset);",
    "example": "BGE x10, x0, positive",
    "example_note": "Branch if x10 is positive or zero.",
    "linked_summary": "Take the branch if rs1 is greater than <a href=\"../../powerisa/or/\">or</a> equal to rs2 (signed).",
    "linked_pseudocode": "if (R[rs1] >=s R[rs2]) PC += sext(offset);"
  },
  {
    "mnemonic": "CSRRW",
    "architecture": "RISC-V",
    "extension": "Zicsr",
    "full_name": "Control Status Register Read/Write",
    "summary": "Atomically swaps values in the CSRs. Reads the old value of the CSR into rd, then writes rs1 to the CSR.",
    "syntax": "CSRRW rd, csr, rs1",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "csr | rs1 | 001 | rd | 1110011",
      "hex_opcode": "0x73",
      "visual_parts": [
        {
          "raw": "csr",
          "clean": "csr"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1110011",
          "clean": "1110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "csr",
        "desc": "CSR Address"
      },
      {
        "name": "rs1",
        "desc": "Src (New Value)"
      }
    ],
    "pseudocode": "t = CSRs[csr]; CSRs[csr] = R[rs1]; R[rd] = t;",
    "example": "CSRRW x10, scause, x11",
    "example_note": "Writes x11 to 'scause' CSR and reads old 'scause' into x10.",
    "linked_summary": "Atomically swaps values <a href=\"../../x86/in/\">in</a> the CSRs. Reads the old value of the CSR into rd, then writes rs1 to the CSR.",
    "linked_pseudocode": "t = CSRs[csr]; CSRs[csr] = R[rs1]; R[rd] = t;"
  },
  {
    "mnemonic": "CSRRS",
    "architecture": "RISC-V",
    "extension": "Zicsr",
    "full_name": "Control Status Register Read and Set",
    "summary": "Reads the value of the CSR into rd, then bitwise ORs the value in rs1 into the CSR (setting bits).",
    "syntax": "CSRRS rd, csr, rs1",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "csr | rs1 | 010 | rd | 1110011",
      "hex_opcode": "0x73",
      "visual_parts": [
        {
          "raw": "csr",
          "clean": "csr"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "010",
          "clean": "010"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1110011",
          "clean": "1110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "csr",
        "desc": "CSR Address"
      },
      {
        "name": "rs1",
        "desc": "Bit Mask"
      }
    ],
    "pseudocode": "t = CSRs[csr]; CSRs[csr] = t | R[rs1]; R[rd] = t;",
    "example": "CSRRS x0, sstatus, x5",
    "example_note": "Sets bits in 'sstatus' using mask in x5 (Result discarded).",
    "linked_summary": "Reads the value of the CSR into rd, then bitwise ORs the value <a href=\"../../x86/in/\">in</a> rs1 into the CSR (setting bits).",
    "linked_pseudocode": "t = CSRs[csr]; CSRs[csr] = t | R[rs1]; R[rd] = t;"
  },
  {
    "mnemonic": "DIV",
    "architecture": "RISC-V",
    "extension": "M",
    "full_name": "Divide",
    "summary": "Performs signed integer division.",
    "syntax": "DIV rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000001 | rs2 | rs1 | 100 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0000001",
          "clean": "0000001"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "100",
          "clean": "100"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Quotient)"
      },
      {
        "name": "rs1",
        "desc": "Dividend"
      },
      {
        "name": "rs2",
        "desc": "Divisor"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] / R[rs2];",
    "example": "DIV x10, x11, x12",
    "example_note": "Signed division of x11 by x12.",
    "linked_summary": "Performs signed integer division.",
    "linked_pseudocode": "R[rd] = R[rs1] / R[rs2];"
  },
  {
    "mnemonic": "DIVU",
    "architecture": "RISC-V",
    "extension": "M",
    "full_name": "Divide Unsigned",
    "summary": "Performs unsigned integer division.",
    "syntax": "DIVU rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000001 | rs2 | rs1 | 101 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0000001",
          "clean": "0000001"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "101",
          "clean": "101"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Dividend"
      },
      {
        "name": "rs2",
        "desc": "Divisor"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] /u R[rs2];",
    "example": "DIVU x5, x6, x7",
    "example_note": "Unsigned division.",
    "linked_summary": "Performs unsigned integer division.",
    "linked_pseudocode": "R[rd] = R[rs1] /u R[rs2];"
  },
  {
    "mnemonic": "EBREAK",
    "architecture": "RISC-V",
    "full_name": "Environment Break",
    "summary": "Used by debuggers to cause control to be transferred back to a debugging environment.",
    "syntax": "EBREAK",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "000000000001 | 00000 | 000 | 00000 | 1110011",
      "hex_opcode": "0x73",
      "visual_parts": [
        {
          "raw": "000000000001",
          "clean": "000000000001"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "1110011",
          "clean": "1110011"
        }
      ]
    },
    "operands": [],
    "pseudocode": "RaiseException(Breakpoint);",
    "example": "EBREAK",
    "example_note": "Triggers a debugger breakpoint.",
    "linked_summary": "Used by debuggers to cause control to be transferred back to a debugging environment.",
    "linked_pseudocode": "RaiseException(Breakpoint);"
  },
  {
    "mnemonic": "FENCE",
    "architecture": "RISC-V",
    "full_name": "Fence",
    "summary": "Orders device I/O and memory accesses.",
    "syntax": "FENCE pred, succ",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "fm | pred | succ | rs1 | 000 | rd | 0001111",
      "hex_opcode": "0x0F",
      "visual_parts": [
        {
          "raw": "fm",
          "clean": "fm"
        },
        {
          "raw": "pred",
          "clean": "pred"
        },
        {
          "raw": "succ",
          "clean": "succ"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0001111",
          "clean": "0001111"
        }
      ]
    },
    "operands": [
      {
        "name": "pred",
        "desc": "Predecessor Set"
      },
      {
        "name": "succ",
        "desc": "Successor Set"
      }
    ],
    "pseudocode": "MemoryBarrier(pred, succ);",
    "example": "FENCE rw, rw",
    "example_note": "Ensures all previous reads/writes complete before subsequent reads/writes.",
    "linked_summary": "Orders device I/O <a href=\"../../armv8-a/and/\">and</a> memory accesses.",
    "linked_pseudocode": "MemoryBarrier(pred, succ);"
  },
  {
    "mnemonic": "FLW",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Float Load Word",
    "summary": "Loads a single-precision floating-point value from memory.",
    "syntax": "FLW rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "offset | rs1 | 010 | rd | 0000111",
      "hex_opcode": "0x07",
      "visual_parts": [
        {
          "raw": "offset",
          "clean": "offset"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "010",
          "clean": "010"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0000111",
          "clean": "0000111"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Float Reg)"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "F[rd] = M[R[rs1] + sext(offset)][31:0];",
    "example": "FLW f1, 0(x10)",
    "example_note": "Loads float from address in x10 to f1.",
    "linked_summary": "Loads a single-precision floating-point value from memory.",
    "linked_pseudocode": "F[rd] = M[R[rs1] + sext(offset)][31:0];"
  },
  {
    "mnemonic": "FSW",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Float Store Word",
    "summary": "Stores a single-precision floating-point value to memory.",
    "syntax": "FSW rs2, offset(rs1)",
    "encoding": {
      "format": "S-Type",
      "binary_pattern": "imm[11:5] | rs2 | rs1 | 010 | imm[4:0] | 0100111",
      "hex_opcode": "0x27",
      "visual_parts": [
        {
          "raw": "imm[11:5]",
          "clean": "imm"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "010",
          "clean": "010"
        },
        {
          "raw": "imm[4:0]",
          "clean": "imm"
        },
        {
          "raw": "0100111",
          "clean": "0100111"
        }
      ]
    },
    "operands": [
      {
        "name": "rs2",
        "desc": "Src (Float Reg)"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "M[R[rs1] + sext(offset)] = F[rs2][31:0];",
    "example": "FSW f1, 4(x2)",
    "example_note": "Stores float in f1 to stack + 4.",
    "linked_summary": "Stores a single-precision floating-point value to memory.",
    "linked_pseudocode": "M[R[rs1] + sext(offset)] = F[rs2][31:0];"
  },
  {
    "mnemonic": "FADD.S",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Float Add (Single)",
    "summary": "Performs single-precision floating-point addition.",
    "syntax": "FADD.S rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 000 | rd | 1010011",
      "hex_opcode": "0x53",
      "visual_parts": [
        {
          "raw": "0000000",
          "clean": "0000000"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1010011",
          "clean": "1010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Src 1"
      },
      {
        "name": "rs2",
        "desc": "Src 2"
      }
    ],
    "pseudocode": "F[rd] = F[rs1] + F[rs2];",
    "example": "FADD.S f0, f1, f2",
    "example_note": "f0 = f1 + f2",
    "linked_summary": "Performs single-precision floating-point addition.",
    "linked_pseudocode": "F[rd] = F[rs1] + F[rs2];"
  },
  {
    "mnemonic": "MUL",
    "architecture": "RISC-V",
    "extension": "M",
    "full_name": "Multiply",
    "summary": "Performs a 32-bit (or 64-bit) multiplication of rs1 and rs2 and stores the lower bits in rd.",
    "syntax": "MUL rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000001 | rs2 | rs1 | 000 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0000001",
          "clean": "0000001"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Lower Bits)"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "R[rd] = (R[rs1] * R[rs2])[XLEN-1:0];",
    "example": "MUL x10, x11, x12",
    "example_note": "x10 = lower bits of x11 * x12.",
    "linked_summary": "Performs a 32-<a href=\"../../armv8-a/bit/\">bit</a> (<a href=\"../../powerisa/or/\">or</a> 64-<a href=\"../../armv8-a/bit/\">bit</a>) multiplication of rs1 <a href=\"../../armv8-a/and/\">and</a> rs2 <a href=\"../../armv8-a/and/\">and</a> stores the lower bits <a href=\"../../x86/in/\">in</a> rd.",
    "linked_pseudocode": "R[rd] = (R[rs1] * R[rs2])[XLEN-1:0];"
  },
  {
    "mnemonic": "MULH",
    "architecture": "RISC-V",
    "extension": "M",
    "full_name": "Multiply High Signed",
    "summary": "Performs a signed multiplication and stores the upper bits of the result.",
    "syntax": "MULH rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000001 | rs2 | rs1 | 001 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0000001",
          "clean": "0000001"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Upper Bits)"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "R[rd] = (sext(R[rs1]) * sext(R[rs2])) >> XLEN;",
    "example": "MULH x5, x6, x7",
    "example_note": "Get upper bits of signed multiplication.",
    "linked_summary": "Performs a signed multiplication <a href=\"../../armv8-a/and/\">and</a> stores the upper bits of the result.",
    "linked_pseudocode": "R[rd] = (sext(R[rs1]) * sext(R[rs2])) >> XLEN;"
  },
  {
    "mnemonic": "MRET",
    "architecture": "RISC-V",
    "extension": "Privileged",
    "full_name": "Machine Return",
    "summary": "Returns from a machine-mode trap handler.",
    "syntax": "MRET",
    "encoding": {
      "format": "R-Type (System)",
      "binary_pattern": "0011000 | 00010 | 00000 | 000 | 00000 | 1110011",
      "hex_opcode": "0x73",
      "visual_parts": [
        {
          "raw": "0011000",
          "clean": "0011000"
        },
        {
          "raw": "00010",
          "clean": "00010"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "1110011",
          "clean": "1110011"
        }
      ]
    },
    "operands": [],
    "pseudocode": "PC = MEPC; Priv = MPP; MIE = MPIE;",
    "example": "MRET",
    "example_note": "Return to previous privilege level defined in mstatus.",
    "linked_summary": "Returns from a machine-mode <a href=\"../../powerisa/trap/\">trap</a> handler.",
    "linked_pseudocode": "PC = MEPC; Priv = MPP; MIE = MPIE;"
  },
  {
    "mnemonic": "OR",
    "architecture": "RISC-V",
    "full_name": "Logical OR",
    "summary": "Performs a bitwise logical OR operation.",
    "syntax": "OR rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 110 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0000000",
          "clean": "0000000"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "110",
          "clean": "110"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] | R[rs2];",
    "example": "OR x10, x11, x12",
    "example_note": "Bitwise OR of x11 and x12.",
    "linked_summary": "Performs a bitwise logical <a href=\"../../risc-v/or/\">OR</a> operation.",
    "linked_pseudocode": "R[rd] = R[rs1] | R[rs2];"
  },
  {
    "mnemonic": "ORI",
    "architecture": "RISC-V",
    "full_name": "Logical OR Immediate",
    "summary": "Performs a bitwise logical OR with a sign-extended immediate.",
    "syntax": "ORI rd, rs1, imm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 110 | rd | 0010011",
      "hex_opcode": "0x13",
      "visual_parts": [
        {
          "raw": "imm[11:0]",
          "clean": "imm"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "110",
          "clean": "110"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0010011",
          "clean": "0010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "imm",
        "desc": "Immediate"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] | sext(imm);",
    "example": "ORI x10, x11, 1",
    "example_note": "Sets the lowest bit of x11.",
    "linked_summary": "Performs a bitwise logical <a href=\"../../risc-v/or/\">OR</a> with a sign-extended immediate.",
    "linked_pseudocode": "R[rd] = R[rs1] | sext(imm);"
  },
  {
    "mnemonic": "REM",
    "architecture": "RISC-V",
    "extension": "M",
    "full_name": "Remainder",
    "summary": "Computes the signed remainder of division.",
    "syntax": "REM rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000001 | rs2 | rs1 | 110 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0000001",
          "clean": "0000001"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "110",
          "clean": "110"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Remainder)"
      },
      {
        "name": "rs1",
        "desc": "Dividend"
      },
      {
        "name": "rs2",
        "desc": "Divisor"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] % R[rs2];",
    "example": "REM x5, x6, x7",
    "example_note": "Signed remainder.",
    "linked_summary": "Computes the signed remainder of division.",
    "linked_pseudocode": "R[rd] = R[rs1] % R[rs2];"
  },
  {
    "mnemonic": "SB",
    "architecture": "RISC-V",
    "full_name": "Store Byte",
    "summary": "Stores the lowest 8 bits of a register to memory.",
    "syntax": "SB rs2, offset(rs1)",
    "encoding": {
      "format": "S-Type",
      "binary_pattern": "imm[11:5] | rs2 | rs1 | 000 | imm[4:0] | 0100011",
      "hex_opcode": "0x23",
      "visual_parts": [
        {
          "raw": "imm[11:5]",
          "clean": "imm"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "imm[4:0]",
          "clean": "imm"
        },
        {
          "raw": "0100011",
          "clean": "0100011"
        }
      ]
    },
    "operands": [
      {
        "name": "rs2",
        "desc": "Source"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "M[R[rs1] + sext(offset)][7:0] = R[rs2][7:0];",
    "example": "SB x5, 0(x10)",
    "example_note": "Store low byte of x5 to address in x10.",
    "linked_summary": "Stores the lowest 8 bits of a register to memory.",
    "linked_pseudocode": "M[R[rs1] + sext(offset)][7:0] = R[rs2][7:0];"
  },
  {
    "mnemonic": "SH",
    "architecture": "RISC-V",
    "full_name": "Store Halfword",
    "summary": "Stores the lowest 16 bits of a register to memory.",
    "syntax": "SH rs2, offset(rs1)",
    "encoding": {
      "format": "S-Type",
      "binary_pattern": "imm[11:5] | rs2 | rs1 | 001 | imm[4:0] | 0100011",
      "hex_opcode": "0x23",
      "visual_parts": [
        {
          "raw": "imm[11:5]",
          "clean": "imm"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "imm[4:0]",
          "clean": "imm"
        },
        {
          "raw": "0100011",
          "clean": "0100011"
        }
      ]
    },
    "operands": [
      {
        "name": "rs2",
        "desc": "Source"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "M[R[rs1] + sext(offset)][15:0] = R[rs2][15:0];",
    "example": "SH x5, 4(x10)",
    "example_note": "Store halfword.",
    "linked_summary": "Stores the lowest 16 bits of a register to memory.",
    "linked_pseudocode": "M[R[rs1] + sext(offset)][15:0] = R[rs2][15:0];"
  },
  {
    "mnemonic": "SW",
    "architecture": "RISC-V",
    "full_name": "Store Word",
    "summary": "Stores a 32-bit word to memory.",
    "syntax": "SW rs2, offset(rs1)",
    "encoding": {
      "format": "S-Type",
      "binary_pattern": "imm[11:5] | rs2 | rs1 | 010 | imm[4:0] | 0100011",
      "hex_opcode": "0x23",
      "visual_parts": [
        {
          "raw": "imm[11:5]",
          "clean": "imm"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "010",
          "clean": "010"
        },
        {
          "raw": "imm[4:0]",
          "clean": "imm"
        },
        {
          "raw": "0100011",
          "clean": "0100011"
        }
      ]
    },
    "operands": [
      {
        "name": "rs2",
        "desc": "Source"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "M[R[rs1] + sext(offset)][31:0] = R[rs2][31:0];",
    "example": "SW x5, 8(x10)",
    "example_note": "Store word.",
    "linked_summary": "Stores a 32-<a href=\"../../armv8-a/bit/\">bit</a> word to memory.",
    "linked_pseudocode": "M[R[rs1] + sext(offset)][31:0] = R[rs2][31:0];"
  },
  {
    "mnemonic": "SD",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Store Doubleword",
    "summary": "Stores a 64-bit doubleword to memory.",
    "syntax": "SD rs2, offset(rs1)",
    "encoding": {
      "format": "S-Type",
      "binary_pattern": "imm[11:5] | rs2 | rs1 | 011 | imm[4:0] | 0100011",
      "hex_opcode": "0x23",
      "visual_parts": [
        {
          "raw": "imm[11:5]",
          "clean": "imm"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "011",
          "clean": "011"
        },
        {
          "raw": "imm[4:0]",
          "clean": "imm"
        },
        {
          "raw": "0100011",
          "clean": "0100011"
        }
      ]
    },
    "operands": [
      {
        "name": "rs2",
        "desc": "Source"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "M[R[rs1] + sext(offset)][63:0] = R[rs2][63:0];",
    "example": "SD x5, 16(x10)",
    "example_note": "Store 64-bit value.",
    "linked_summary": "Stores a 64-<a href=\"../../armv8-a/bit/\">bit</a> doubleword to memory.",
    "linked_pseudocode": "M[R[rs1] + sext(offset)][63:0] = R[rs2][63:0];"
  },
  {
    "mnemonic": "SLL",
    "architecture": "RISC-V",
    "full_name": "Shift Left Logical",
    "summary": "Shifts a register left by the number of bits specified in another register.",
    "syntax": "SLL rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 001 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0000000",
          "clean": "0000000"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "rs2",
        "desc": "Shift Amount"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] << (R[rs2] & 0x1F);",
    "example": "SLL x10, x11, x12",
    "example_note": "Shift x11 left by x12.",
    "linked_summary": "Shifts a register left by the number of bits specified <a href=\"../../x86/in/\">in</a> another register.",
    "linked_pseudocode": "R[rd] = R[rs1] << (R[rs2] & 0x1F);"
  },
  {
    "mnemonic": "SLLI",
    "architecture": "RISC-V",
    "full_name": "Shift Left Logical Immediate",
    "summary": "Shifts a register left by a constant amount.",
    "syntax": "SLLI rd, rs1, shamt",
    "encoding": {
      "format": "I-Type (Shift)",
      "binary_pattern": "0000000 | shamt | rs1 | 001 | rd | 0010011",
      "hex_opcode": "0x13",
      "visual_parts": [
        {
          "raw": "0000000",
          "clean": "0000000"
        },
        {
          "raw": "shamt",
          "clean": "shamt"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0010011",
          "clean": "0010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "shamt",
        "desc": "Shift Amount"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] << shamt;",
    "example": "SLLI x10, x11, 2",
    "example_note": "Multiply x11 by 4.",
    "linked_summary": "Shifts a register left by a constant amount.",
    "linked_pseudocode": "R[rd] = R[rs1] << shamt;"
  },
  {
    "mnemonic": "SRL",
    "architecture": "RISC-V",
    "full_name": "Shift Right Logical",
    "summary": "Shifts a register right, shifting in zeros.",
    "syntax": "SRL rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 101 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0000000",
          "clean": "0000000"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "101",
          "clean": "101"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "rs2",
        "desc": "Shift Amount"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] >> (R[rs2] & 0x1F);",
    "example": "SRL x10, x11, x12",
    "example_note": "Logical right shift.",
    "linked_summary": "Shifts a register right, shifting <a href=\"../../x86/in/\">in</a> zeros.",
    "linked_pseudocode": "R[rd] = R[rs1] >> (R[rs2] & 0x1F);"
  },
  {
    "mnemonic": "SRA",
    "architecture": "RISC-V",
    "full_name": "Shift Right Arithmetic",
    "summary": "Shifts a register right, preserving the sign bit.",
    "syntax": "SRA rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0100000 | rs2 | rs1 | 101 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0100000",
          "clean": "0100000"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "101",
          "clean": "101"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "rs2",
        "desc": "Shift Amount"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] >>s (R[rs2] & 0x1F);",
    "example": "SRA x10, x11, x12",
    "example_note": "Arithmetic right shift (sign preserved).",
    "linked_summary": "Shifts a register right, preserving the sign <a href=\"../../armv8-a/bit/\">bit</a>.",
    "linked_pseudocode": "R[rd] = R[rs1] >>s (R[rs2] & 0x1F);"
  },
  {
    "mnemonic": "SLT",
    "architecture": "RISC-V",
    "full_name": "Set Less Than",
    "summary": "Sets rd to 1 if rs1 < rs2 (signed), otherwise 0.",
    "syntax": "SLT rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 010 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0000000",
          "clean": "0000000"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "010",
          "clean": "010"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "R[rd] = (R[rs1] <s R[rs2]) ? 1 : 0;",
    "example": "SLT x5, x6, x7",
    "example_note": "Check if x6 < x7.",
    "linked_summary": "Sets rd to 1 if rs1 < rs2 (signed), otherwise 0.",
    "linked_pseudocode": "R[rd] = (R[rs1] <s R[rs2]) ? 1 : 0;"
  },
  {
    "mnemonic": "SLTI",
    "architecture": "RISC-V",
    "full_name": "Set Less Than Immediate",
    "summary": "Sets rd to 1 if rs1 < immediate (signed), otherwise 0.",
    "syntax": "SLTI rd, rs1, imm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 010 | rd | 0010011",
      "hex_opcode": "0x13",
      "visual_parts": [
        {
          "raw": "imm[11:0]",
          "clean": "imm"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "010",
          "clean": "010"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0010011",
          "clean": "0010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "imm",
        "desc": "Immediate"
      }
    ],
    "pseudocode": "R[rd] = (R[rs1] <s sext(imm)) ? 1 : 0;",
    "example": "SLTI x5, x6, 10",
    "example_note": "Check if x6 < 10.",
    "linked_summary": "Sets rd to 1 if rs1 < immediate (signed), otherwise 0.",
    "linked_pseudocode": "R[rd] = (R[rs1] <s sext(imm)) ? 1 : 0;"
  },
  {
    "mnemonic": "SC.W",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Store Conditional Word",
    "summary": "Conditionally stores a word to memory if the reservation (from LR) is still valid.",
    "syntax": "SC.W rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "00011 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
      "hex_opcode": "0x2F",
      "visual_parts": [
        {
          "raw": "00011",
          "clean": "00011"
        },
        {
          "raw": "aq",
          "clean": "aq"
        },
        {
          "raw": "rl",
          "clean": "rl"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "010",
          "clean": "010"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0101111",
          "clean": "0101111"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Success/Fail)"
      },
      {
        "name": "rs2",
        "desc": "Source Value"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "if (ReservationValid) { M[R[rs1]] = R[rs2]; R[rd] = 0; } else { R[rd] = 1; }",
    "example": "SC.W x10, x11, (x12)",
    "example_note": "Try to store x11 to x12. x10=0 on success.",
    "linked_summary": "Conditionally stores a word to memory if the reservation (from LR) is still valid.",
    "linked_pseudocode": "if (ReservationValid) { M[R[rs1]] = R[rs2]; R[rd] = 0; } else { R[rd] = 1; }"
  },
  {
    "mnemonic": "SFENCE.VMA",
    "architecture": "RISC-V",
    "extension": "Privileged",
    "full_name": "Supervisor Fence Virtual Memory",
    "summary": "Synchronizes updates to in-memory address translation data structures (TLB flush).",
    "syntax": "SFENCE.VMA rs1, rs2",
    "encoding": {
      "format": "R-Type (System)",
      "binary_pattern": "0001001 | rs2 | rs1 | 000 | 00000 | 1110011",
      "hex_opcode": "0x73",
      "visual_parts": [
        {
          "raw": "0001001",
          "clean": "0001001"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "1110011",
          "clean": "1110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Virtual Address (optional)"
      },
      {
        "name": "rs2",
        "desc": "ASID (optional)"
      }
    ],
    "pseudocode": "Fence(PageTable);",
    "example": "SFENCE.VMA x0, x0",
    "example_note": "Flush all TLB entries.",
    "linked_summary": "Synchronizes updates to <a href=\"../../x86/in/\">in</a>-memory address translation data structures (TLB flush).",
    "linked_pseudocode": "Fence(PageTable);"
  },
  {
    "mnemonic": "SRET",
    "architecture": "RISC-V",
    "extension": "Privileged",
    "full_name": "Supervisor Return",
    "summary": "Returns from a supervisor-mode trap handler.",
    "syntax": "SRET",
    "encoding": {
      "format": "R-Type (System)",
      "binary_pattern": "0001000 | 00010 | 00000 | 000 | 00000 | 1110011",
      "hex_opcode": "0x73",
      "visual_parts": [
        {
          "raw": "0001000",
          "clean": "0001000"
        },
        {
          "raw": "00010",
          "clean": "00010"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "1110011",
          "clean": "1110011"
        }
      ]
    },
    "operands": [],
    "pseudocode": "PC = SEPC; Priv = SPP; SIE = SPIE;",
    "example": "SRET",
    "example_note": "Return from exception/interrupt in supervisor mode.",
    "linked_summary": "Returns from a supervisor-mode <a href=\"../../powerisa/trap/\">trap</a> handler.",
    "linked_pseudocode": "PC = SEPC; Priv = SPP; SIE = SPIE;"
  },
  {
    "mnemonic": "WFI",
    "architecture": "RISC-V",
    "extension": "Privileged",
    "full_name": "Wait for Interrupt",
    "summary": "Provides a hint to the implementation that the current hart can be stalled until an interrupt occurs.",
    "syntax": "WFI",
    "encoding": {
      "format": "R-Type (System)",
      "binary_pattern": "0001000 | 00101 | 00000 | 000 | 00000 | 1110011",
      "hex_opcode": "0x73",
      "visual_parts": [
        {
          "raw": "0001000",
          "clean": "0001000"
        },
        {
          "raw": "00101",
          "clean": "00101"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "1110011",
          "clean": "1110011"
        }
      ]
    },
    "operands": [],
    "pseudocode": "while(!Interrupt) { /* low power state */ }",
    "example": "WFI",
    "example_note": "Pause execution until interrupt.",
    "linked_summary": "Provides a <a href=\"../../armv8-a/hint/\">hint</a> to the implementation that the current hart can be stalled until an interrupt occurs.",
    "linked_pseudocode": "while(!Interrupt) { /* low power state */ }"
  },
  {
    "mnemonic": "XOR",
    "architecture": "RISC-V",
    "full_name": "Logical XOR",
    "summary": "Performs a bitwise logical Exclusive-OR operation.",
    "syntax": "XOR rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 100 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0000000",
          "clean": "0000000"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "100",
          "clean": "100"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] ^ R[rs2];",
    "example": "XOR x10, x11, x12",
    "example_note": "x10 = x11 ^ x12",
    "linked_summary": "Performs a bitwise logical Exclusive-<a href=\"../../risc-v/or/\">OR</a> operation.",
    "linked_pseudocode": "R[rd] = R[rs1] ^ R[rs2];"
  },
  {
    "mnemonic": "XORI",
    "architecture": "RISC-V",
    "full_name": "Logical XOR Immediate",
    "summary": "Performs a bitwise logical Exclusive-OR with a sign-extended immediate.",
    "syntax": "XORI rd, rs1, imm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 100 | rd | 0010011",
      "hex_opcode": "0x13",
      "visual_parts": [
        {
          "raw": "imm[11:0]",
          "clean": "imm"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "100",
          "clean": "100"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0010011",
          "clean": "0010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "imm",
        "desc": "Immediate"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] ^ sext(imm);",
    "example": "XORI x10, x11, -1",
    "example_note": "Bitwise invert (NOT) x11.",
    "linked_summary": "Performs a bitwise logical Exclusive-<a href=\"../../risc-v/or/\">OR</a> with a sign-extended immediate.",
    "linked_pseudocode": "R[rd] = R[rs1] ^ sext(imm);"
  },
  {
    "mnemonic": "HFENCE.GVMA",
    "architecture": "RISC-V",
    "extension": "H (Hypervisor)",
    "full_name": "Hypervisor Fence Guest Virtual Memory Address",
    "summary": "Synchronizes updates to guest physical address translation data structures.",
    "syntax": "HFENCE.GVMA rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0110001 | rs2 | rs1 | 000 | 00000 | 1110011",
      "hex_opcode": "0x73",
      "visual_parts": [
        {
          "raw": "0110001",
          "clean": "0110001"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "1110011",
          "clean": "1110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Guest Virtual Address (optional)"
      },
      {
        "name": "rs2",
        "desc": "Guest ASID (optional)"
      }
    ],
    "pseudocode": "Fence(GuestPageTable);",
    "example": "HFENCE.GVMA x0, x0",
    "example_note": "Flush all guest TLB entries.",
    "linked_summary": "Synchronizes updates to guest physical address translation data structures.",
    "linked_pseudocode": "Fence(GuestPageTable);"
  },
  {
    "mnemonic": "HFENCE.VVMA",
    "architecture": "RISC-V",
    "extension": "H (Hypervisor)",
    "full_name": "Hypervisor Fence Virtual Virtual Memory Address",
    "summary": "Synchronizes updates to VS-stage address translation data structures.",
    "syntax": "HFENCE.VVMA rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0010001 | rs2 | rs1 | 000 | 00000 | 1110011",
      "hex_opcode": "0x73",
      "visual_parts": [
        {
          "raw": "0010001",
          "clean": "0010001"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "1110011",
          "clean": "1110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Virtual Address (optional)"
      },
      {
        "name": "rs2",
        "desc": "ASID (optional)"
      }
    ],
    "pseudocode": "Fence(VS-StagePageTable);",
    "example": "HFENCE.VVMA x10, x0",
    "example_note": "Flush TLB entries for address in x10.",
    "linked_summary": "Synchronizes updates to VS-stage address translation data structures.",
    "linked_pseudocode": "Fence(VS-StagePageTable);"
  },
  {
    "mnemonic": "JAL",
    "architecture": "RISC-V",
    "full_name": "Jump and Link",
    "summary": "Jumps to an offset relative to PC and saves the return address (PC+4) to rd.",
    "syntax": "JAL rd, offset",
    "encoding": {
      "format": "J-Type",
      "binary_pattern": "imm[20|10:1|11|19:12] | rd | 1101111",
      "hex_opcode": "0x6F",
      "visual_parts": [
        {
          "raw": "imm[20",
          "clean": "imm"
        },
        {
          "raw": "10:1",
          "clean": "10:1"
        },
        {
          "raw": "11",
          "clean": "11"
        },
        {
          "raw": "19:12]",
          "clean": "19:12]"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1101111",
          "clean": "1101111"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Return Address Dest"
      },
      {
        "name": "offset",
        "desc": "20-bit PC-relative Offset"
      }
    ],
    "pseudocode": "R[rd] = PC + 4; PC += sext(offset);",
    "example": "JAL x1, loop_target",
    "example_note": "Jump to 'loop_target' and save return address in x1 (ra).",
    "linked_summary": "Jumps to an offset relative to PC <a href=\"../../armv8-a/and/\">and</a> saves the return address (PC+4) to rd.",
    "linked_pseudocode": "R[rd] = PC + 4; PC += sext(offset);"
  },
  {
    "mnemonic": "JALR",
    "architecture": "RISC-V",
    "full_name": "Jump and Link Register",
    "summary": "Jumps to address in rs1 + offset, saving return address to rd.",
    "syntax": "JALR rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 000 | rd | 1100111",
      "hex_opcode": "0x67",
      "visual_parts": [
        {
          "raw": "imm[11:0]",
          "clean": "imm"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "1100111",
          "clean": "1100111"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Return Address Dest"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "12-bit Immediate"
      }
    ],
    "pseudocode": "t = PC + 4; PC = (R[rs1] + sext(offset)) & ~1; R[rd] = t;",
    "example": "JALR x0, 0(x1)",
    "example_note": "Return from function (jumps to address in x1/ra).",
    "linked_summary": "Jumps to address <a href=\"../../x86/in/\">in</a> rs1 + offset, saving return address to rd.",
    "linked_pseudocode": "t = PC + 4; PC = (R[rs1] + sext(offset)) & ~1; R[rd] = t;"
  },
  {
    "mnemonic": "LB",
    "architecture": "RISC-V",
    "full_name": "Load Byte",
    "summary": "Loads an 8-bit byte from memory and sign-extends it to the register width.",
    "syntax": "LB rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 000 | rd | 0000011",
      "hex_opcode": "0x03",
      "visual_parts": [
        {
          "raw": "imm[11:0]",
          "clean": "imm"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0000011",
          "clean": "0000011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Byte Offset"
      }
    ],
    "pseudocode": "R[rd] = sext(M[R[rs1] + sext(offset)][7:0]);",
    "example": "LB x10, 0(x2)",
    "example_note": "Load byte from stack pointer (x2) into x10.",
    "linked_summary": "Loads an 8-<a href=\"../../armv8-a/bit/\">bit</a> byte from memory <a href=\"../../armv8-a/and/\">and</a> sign-extends <a href=\"../../armv8-a/it/\">it</a> to the register width.",
    "linked_pseudocode": "R[rd] = sext(M[R[rs1] + sext(offset)][7:0]);"
  },
  {
    "mnemonic": "LH",
    "architecture": "RISC-V",
    "full_name": "Load Halfword",
    "summary": "Loads a 16-bit halfword from memory and sign-extends it.",
    "syntax": "LH rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 001 | rd | 0000011",
      "hex_opcode": "0x03",
      "visual_parts": [
        {
          "raw": "imm[11:0]",
          "clean": "imm"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "001",
          "clean": "001"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0000011",
          "clean": "0000011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Byte Offset"
      }
    ],
    "pseudocode": "R[rd] = sext(M[R[rs1] + sext(offset)][15:0]);",
    "example": "LH x5, 4(x10)",
    "example_note": "Load halfword from address x10+4.",
    "linked_summary": "Loads a 16-<a href=\"../../armv8-a/bit/\">bit</a> halfword from memory <a href=\"../../armv8-a/and/\">and</a> sign-extends <a href=\"../../armv8-a/it/\">it</a>.",
    "linked_pseudocode": "R[rd] = sext(M[R[rs1] + sext(offset)][15:0]);"
  },
  {
    "mnemonic": "LW",
    "architecture": "RISC-V",
    "full_name": "Load Word",
    "summary": "Loads a 32-bit word from memory and sign-extends it to 64 bits.",
    "syntax": "LW rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 010 | rd | 0000011",
      "hex_opcode": "0x03",
      "visual_parts": [
        {
          "raw": "imm[11:0]",
          "clean": "imm"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "010",
          "clean": "010"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0000011",
          "clean": "0000011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Byte Offset"
      }
    ],
    "pseudocode": "R[rd] = sext(M[R[rs1] + sext(offset)][31:0]);",
    "example": "LW x6, 12(x2)",
    "example_note": "Load 32-bit word from stack offset 12.",
    "linked_summary": "Loads a 32-<a href=\"../../armv8-a/bit/\">bit</a> word from memory <a href=\"../../armv8-a/and/\">and</a> sign-extends <a href=\"../../armv8-a/it/\">it</a> to 64 bits.",
    "linked_pseudocode": "R[rd] = sext(M[R[rs1] + sext(offset)][31:0]);"
  },
  {
    "mnemonic": "LBU",
    "architecture": "RISC-V",
    "full_name": "Load Byte Unsigned",
    "summary": "Loads an 8-bit byte from memory and zero-extends it.",
    "syntax": "LBU rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 100 | rd | 0000011",
      "hex_opcode": "0x03",
      "visual_parts": [
        {
          "raw": "imm[11:0]",
          "clean": "imm"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "100",
          "clean": "100"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0000011",
          "clean": "0000011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Byte Offset"
      }
    ],
    "pseudocode": "R[rd] = zext(M[R[rs1] + sext(offset)][7:0]);",
    "example": "LBU x10, 0(x2)",
    "example_note": "Load byte and zero-extend.",
    "linked_summary": "Loads an 8-<a href=\"../../armv8-a/bit/\">bit</a> byte from memory <a href=\"../../armv8-a/and/\">and</a> <a href=\"../../armv9-a/zero/\">zero</a>-extends <a href=\"../../armv8-a/it/\">it</a>.",
    "linked_pseudocode": "R[rd] = zext(M[R[rs1] + sext(offset)][7:0]);"
  },
  {
    "mnemonic": "LHU",
    "architecture": "RISC-V",
    "full_name": "Load Halfword Unsigned",
    "summary": "Loads a 16-bit halfword from memory and zero-extends it.",
    "syntax": "LHU rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 101 | rd | 0000011",
      "hex_opcode": "0x03",
      "visual_parts": [
        {
          "raw": "imm[11:0]",
          "clean": "imm"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "101",
          "clean": "101"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0000011",
          "clean": "0000011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Byte Offset"
      }
    ],
    "pseudocode": "R[rd] = zext(M[R[rs1] + sext(offset)][15:0]);",
    "example": "LHU x5, 4(x10)",
    "example_note": "Load halfword and zero-extend.",
    "linked_summary": "Loads a 16-<a href=\"../../armv8-a/bit/\">bit</a> halfword from memory <a href=\"../../armv8-a/and/\">and</a> <a href=\"../../armv9-a/zero/\">zero</a>-extends <a href=\"../../armv8-a/it/\">it</a>.",
    "linked_pseudocode": "R[rd] = zext(M[R[rs1] + sext(offset)][15:0]);"
  },
  {
    "mnemonic": "LD",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Load Doubleword",
    "summary": "Loads a 64-bit doubleword from memory.",
    "syntax": "LD rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 011 | rd | 0000011",
      "hex_opcode": "0x03",
      "visual_parts": [
        {
          "raw": "imm[11:0]",
          "clean": "imm"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "011",
          "clean": "011"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0000011",
          "clean": "0000011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Byte Offset"
      }
    ],
    "pseudocode": "R[rd] = M[R[rs1] + sext(offset)][63:0];",
    "example": "LD x1, 0(x2)",
    "example_note": "Load 64-bit value from stack.",
    "linked_summary": "Loads a 64-<a href=\"../../armv8-a/bit/\">bit</a> doubleword from memory.",
    "linked_pseudocode": "R[rd] = M[R[rs1] + sext(offset)][63:0];"
  },
  {
    "mnemonic": "LWU",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Load Word Unsigned",
    "summary": "Loads a 32-bit word from memory and zero-extends it to 64 bits.",
    "syntax": "LWU rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 110 | rd | 0000011",
      "hex_opcode": "0x03",
      "visual_parts": [
        {
          "raw": "imm[11:0]",
          "clean": "imm"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "110",
          "clean": "110"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0000011",
          "clean": "0000011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Byte Offset"
      }
    ],
    "pseudocode": "R[rd] = zext(M[R[rs1] + sext(offset)][31:0]);",
    "example": "LWU x6, 12(x2)",
    "example_note": "Load 32-bit word and zero-extend to 64-bit.",
    "linked_summary": "Loads a 32-<a href=\"../../armv8-a/bit/\">bit</a> word from memory <a href=\"../../armv8-a/and/\">and</a> <a href=\"../../armv9-a/zero/\">zero</a>-extends <a href=\"../../armv8-a/it/\">it</a> to 64 bits.",
    "linked_pseudocode": "R[rd] = zext(M[R[rs1] + sext(offset)][31:0]);"
  },
  {
    "mnemonic": "LUI",
    "architecture": "RISC-V",
    "full_name": "Load Upper Immediate",
    "summary": "Loads the 20-bit immediate into the upper 20 bits of the register (lower 12 bits are zero).",
    "syntax": "LUI rd, imm",
    "encoding": {
      "format": "U-Type",
      "binary_pattern": "imm[31:12] | rd | 0110111",
      "hex_opcode": "0x37",
      "visual_parts": [
        {
          "raw": "imm[31:12]",
          "clean": "imm"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110111",
          "clean": "0110111"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "imm",
        "desc": "20-bit Upper Immediate"
      }
    ],
    "pseudocode": "R[rd] = imm << 12;",
    "example": "LUI x10, 0x12345",
    "example_note": "Puts 0x12345000 into x10.",
    "linked_summary": "Loads the 20-<a href=\"../../armv8-a/bit/\">bit</a> immediate into the upper 20 bits of the register (lower 12 bits are <a href=\"../../armv9-a/zero/\">zero</a>).",
    "linked_pseudocode": "R[rd] = imm << 12;"
  },
  {
    "mnemonic": "LR.W",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Load Reserved Word",
    "summary": "Loads a word from memory and registers a reservation set for the address.",
    "syntax": "LR.W rd, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "00010 | aq | rl | 00000 | rs1 | 010 | rd | 0101111",
      "hex_opcode": "0x2F",
      "visual_parts": [
        {
          "raw": "00010",
          "clean": "00010"
        },
        {
          "raw": "aq",
          "clean": "aq"
        },
        {
          "raw": "rl",
          "clean": "rl"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "010",
          "clean": "010"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0101111",
          "clean": "0101111"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "R[rd] = LoadReserved32(M[R[rs1]]);",
    "example": "LR.W x10, (x11)",
    "example_note": "Start atomic read-modify-write sequence.",
    "linked_summary": "Loads a word from memory <a href=\"../../armv8-a/and/\">and</a> registers a reservation set for the address.",
    "linked_pseudocode": "R[rd] = LoadReserved32(M[R[rs1]]);"
  },
  {
    "mnemonic": "LR.D",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Load Reserved Doubleword",
    "summary": "Loads a doubleword from memory and registers a reservation set.",
    "syntax": "LR.D rd, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "00010 | aq | rl | 00000 | rs1 | 011 | rd | 0101111",
      "hex_opcode": "0x2F",
      "visual_parts": [
        {
          "raw": "00010",
          "clean": "00010"
        },
        {
          "raw": "aq",
          "clean": "aq"
        },
        {
          "raw": "rl",
          "clean": "rl"
        },
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "011",
          "clean": "011"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0101111",
          "clean": "0101111"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "R[rd] = LoadReserved64(M[R[rs1]]);",
    "example": "LR.D x10, (x11)",
    "example_note": "64-bit atomic load reserved.",
    "linked_summary": "Loads a doubleword from memory <a href=\"../../armv8-a/and/\">and</a> registers a reservation set.",
    "linked_pseudocode": "R[rd] = LoadReserved64(M[R[rs1]]);"
  },
  {
    "mnemonic": "ADD",
    "architecture": "RISC-V",
    "full_name": "Add",
    "summary": "Adds the contents of two registers.",
    "syntax": "ADD rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 000 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0000000",
          "clean": "0000000"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Source Register 1"
      },
      {
        "name": "rs2",
        "desc": "Source Register 2"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] + R[rs2];",
    "example": "ADD x10, x11, x12",
    "example_note": "Computes x11 + x12 and stores the result in x10.",
    "linked_summary": "Adds the contents of two registers.",
    "linked_pseudocode": "R[rd] = R[rs1] + R[rs2];"
  },
  {
    "mnemonic": "ADDI",
    "architecture": "RISC-V",
    "full_name": "Add Immediate",
    "summary": "Adds a register and a sign-extended 12-bit immediate value.",
    "syntax": "ADDI rd, rs1, imm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 000 | rd | 0010011",
      "hex_opcode": "0x13",
      "visual_parts": [
        {
          "raw": "imm[11:0]",
          "clean": "imm"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0010011",
          "clean": "0010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Source Register"
      },
      {
        "name": "imm",
        "desc": "12-bit Signed Immediate"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] + sext(imm);",
    "example": "ADDI x5, x6, 10",
    "example_note": "Adds 10 to the value in x6 and stores it in x5.",
    "linked_summary": "Adds a register <a href=\"../../armv8-a/and/\">and</a> a sign-extended 12-<a href=\"../../armv8-a/bit/\">bit</a> immediate value.",
    "linked_pseudocode": "R[rd] = R[rs1] + sext(imm);"
  },
  {
    "mnemonic": "ADDW",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Add Word",
    "summary": "Adds two 32-bit registers and sign-extends the result to 64 bits.",
    "syntax": "ADDW rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 000 | rd | 0111011",
      "hex_opcode": "0x3B",
      "visual_parts": [
        {
          "raw": "0000000",
          "clean": "0000000"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0111011",
          "clean": "0111011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Source Register 1"
      },
      {
        "name": "rs2",
        "desc": "Source Register 2"
      }
    ],
    "pseudocode": "R[rd] = sext((R[rs1] + R[rs2])[31:0]);",
    "example": "ADDW x10, x11, x12",
    "example_note": "Performs 32-bit addition of x11 and x12, result is sign-extended to 64 bits.",
    "linked_summary": "Adds two 32-<a href=\"../../armv8-a/bit/\">bit</a> registers <a href=\"../../armv8-a/and/\">and</a> sign-extends the result to 64 bits.",
    "linked_pseudocode": "R[rd] = sext((R[rs1] + R[rs2])[31:0]);"
  },
  {
    "mnemonic": "ADDIW",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Add Immediate Word",
    "summary": "Adds a 12-bit immediate to a register (32-bit arithmetic) and sign-extends to 64 bits.",
    "syntax": "ADDIW rd, rs1, imm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 000 | rd | 0011011",
      "hex_opcode": "0x1B",
      "visual_parts": [
        {
          "raw": "imm[11:0]",
          "clean": "imm"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "000",
          "clean": "000"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0011011",
          "clean": "0011011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Source Register"
      },
      {
        "name": "imm",
        "desc": "12-bit Signed Immediate"
      }
    ],
    "pseudocode": "R[rd] = sext((R[rs1] + sext(imm))[31:0]);",
    "example": "ADDIW x5, x6, 5",
    "example_note": "Adds 5 to lower 32 bits of x6, sign-extends result to x5.",
    "linked_summary": "Adds a 12-<a href=\"../../armv8-a/bit/\">bit</a> immediate to a register (32-<a href=\"../../armv8-a/bit/\">bit</a> arithmetic) <a href=\"../../armv8-a/and/\">and</a> sign-extends to 64 bits.",
    "linked_pseudocode": "R[rd] = sext((R[rs1] + sext(imm))[31:0]);"
  },
  {
    "mnemonic": "AND",
    "architecture": "RISC-V",
    "full_name": "Logical AND",
    "summary": "Performs a bitwise logical AND operation between two registers.",
    "syntax": "AND rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 111 | rd | 0110011",
      "hex_opcode": "0x33",
      "visual_parts": [
        {
          "raw": "0000000",
          "clean": "0000000"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "111",
          "clean": "111"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0110011",
          "clean": "0110011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Source Register 1"
      },
      {
        "name": "rs2",
        "desc": "Source Register 2"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] & R[rs2];",
    "example": "AND x10, x11, x12",
    "example_note": "Bitwise AND of x11 and x12.",
    "linked_summary": "Performs a bitwise logical <a href=\"../../risc-v/and/\">AND</a> operation between two registers.",
    "linked_pseudocode": "R[rd] = R[rs1] & R[rs2];"
  },
  {
    "mnemonic": "ANDI",
    "architecture": "RISC-V",
    "full_name": "Logical AND Immediate",
    "summary": "Performs a bitwise logical AND between a register and a sign-extended 12-bit immediate.",
    "syntax": "ANDI rd, rs1, imm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 111 | rd | 0010011",
      "hex_opcode": "0x13",
      "visual_parts": [
        {
          "raw": "imm[11:0]",
          "clean": "imm"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "111",
          "clean": "111"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0010011",
          "clean": "0010011"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Source Register"
      },
      {
        "name": "imm",
        "desc": "12-bit Signed Immediate"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] & sext(imm);",
    "example": "ANDI x10, x11, 15",
    "example_note": "Keeps only the lowest 4 bits of x11 (mask 0xF).",
    "linked_summary": "Performs a bitwise logical <a href=\"../../risc-v/and/\">AND</a> between a register <a href=\"../../armv8-a/and/\">and</a> a sign-extended 12-<a href=\"../../armv8-a/bit/\">bit</a> immediate.",
    "linked_pseudocode": "R[rd] = R[rs1] & sext(imm);"
  },
  {
    "mnemonic": "AUIPC",
    "architecture": "RISC-V",
    "full_name": "Add Upper Immediate to PC",
    "summary": "Adds a 20-bit upper immediate to the Program Counter, used for PC-relative addressing.",
    "syntax": "AUIPC rd, imm",
    "encoding": {
      "format": "U-Type",
      "binary_pattern": "imm[31:12] | rd | 0010111",
      "hex_opcode": "0x17",
      "visual_parts": [
        {
          "raw": "imm[31:12]",
          "clean": "imm"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0010111",
          "clean": "0010111"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "imm",
        "desc": "20-bit Upper Immediate"
      }
    ],
    "pseudocode": "R[rd] = PC + (imm << 12);",
    "example": "AUIPC x10, 0x1000",
    "example_note": "Adds 0x1000000 to the current PC and stores in x10.",
    "linked_summary": "Adds a 20-<a href=\"../../armv8-a/bit/\">bit</a> upper immediate to the Program Counter, used for PC-relative addressing.",
    "linked_pseudocode": "R[rd] = PC + (imm << 12);"
  },
  {
    "mnemonic": "AMOADD.W",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic Add Word",
    "summary": "Atomically adds a value to a word in memory.",
    "syntax": "AMOADD.W rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "00000 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
      "hex_opcode": "0x2F",
      "visual_parts": [
        {
          "raw": "00000",
          "clean": "00000"
        },
        {
          "raw": "aq",
          "clean": "aq"
        },
        {
          "raw": "rl",
          "clean": "rl"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "010",
          "clean": "010"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0101111",
          "clean": "0101111"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Value to Add"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp + R[rs2]; R[rd] = temp;",
    "example": "AMOADD.W x10, x11, (x12)",
    "example_note": "Atomically adds x11 to memory at x12. Old value stored in x10.",
    "linked_summary": "Atomically <a href=\"../../armv8-a/adds/\">adds</a> a value to a word <a href=\"../../x86/in/\">in</a> memory.",
    "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp + R[rs2]; R[rd] = temp;"
  },
  {
    "mnemonic": "AMOSWAP.W",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic Swap Word",
    "summary": "Atomically swaps a value in memory with a register.",
    "syntax": "AMOSWAP.W rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "00001 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
      "hex_opcode": "0x2F",
      "visual_parts": [
        {
          "raw": "00001",
          "clean": "00001"
        },
        {
          "raw": "aq",
          "clean": "aq"
        },
        {
          "raw": "rl",
          "clean": "rl"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "010",
          "clean": "010"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0101111",
          "clean": "0101111"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "New Value"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = R[rs2]; R[rd] = temp;",
    "example": "AMOSWAP.W x10, x11, (x12)",
    "example_note": "Writes x11 to memory at x12, loads old memory value into x10.",
    "linked_summary": "Atomically swaps a value <a href=\"../../x86/in/\">in</a> memory with a register.",
    "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = R[rs2]; R[rd] = temp;"
  },
  {
    "mnemonic": "AMOAND.W",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic AND Word",
    "summary": "Atomically performs bitwise AND on a word in memory.",
    "syntax": "AMOAND.W rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "01100 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
      "hex_opcode": "0x2F",
      "visual_parts": [
        {
          "raw": "01100",
          "clean": "01100"
        },
        {
          "raw": "aq",
          "clean": "aq"
        },
        {
          "raw": "rl",
          "clean": "rl"
        },
        {
          "raw": "rs2",
          "clean": "rs2"
        },
        {
          "raw": "rs1",
          "clean": "rs1"
        },
        {
          "raw": "010",
          "clean": "010"
        },
        {
          "raw": "rd",
          "clean": "rd"
        },
        {
          "raw": "0101111",
          "clean": "0101111"
        }
      ]
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Operand"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp & R[rs2]; R[rd] = temp;",
    "example": "AMOAND.W x5, x6, (x7)",
    "example_note": "Atomically ANDs memory at x7 with x6.",
    "linked_summary": "Atomically performs bitwise <a href=\"../../risc-v/and/\">AND</a> on a word <a href=\"../../x86/in/\">in</a> memory.",
    "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp & R[rs2]; R[rd] = temp;"
  }
]