{
  "instructions": [
    {
      "mnemonic": "VANDN.VV",
      "architecture": "RISC-V",
      "extension": "Zvbb (Vector BitManip)",
      "full_name": "Vector Bitwise AND-NOT",
      "summary": "Computes vd = vs2 & ~vs1 (bitwise AND with inverted source).",
      "syntax": "VANDN.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "000001 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "000001",
            "clean": "000001"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs2[i] & ~vs1[i];",
      "slug": "vandn_vv",
      "rel_url": "risc-v/vandn_vv/",
      "linked_summary": "Computes vd = vs2 & ~vs1 (bitwise <a href=\"../../risc-v/and/\">AND</a> with inverted source).",
      "linked_pseudocode": "foreach(i < vl): vd[i] = vs2[i] & ~vs1[i];"
    },
    {
      "mnemonic": "VORN.VV",
      "architecture": "RISC-V",
      "extension": "Zvbb (Vector BitManip)",
      "full_name": "Vector Bitwise OR-NOT",
      "summary": "Computes vd = vs2 | ~vs1 (bitwise OR with inverted source).",
      "syntax": "VORN.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "000101 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "000101",
            "clean": "000101"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs2[i] | ~vs1[i];",
      "slug": "vorn_vv",
      "rel_url": "risc-v/vorn_vv/",
      "linked_summary": "Computes vd = vs2 | ~vs1 (bitwise <a href=\"../../risc-v/or/\">OR</a> with inverted source).",
      "linked_pseudocode": "foreach(i < vl): vd[i] = vs2[i] | ~vs1[i];"
    },
    {
      "mnemonic": "VXNOR.VV",
      "architecture": "RISC-V",
      "extension": "Zvbb (Vector BitManip)",
      "full_name": "Vector Bitwise XNOR",
      "summary": "Computes vd = ~(vs2 ^ vs1) (bitwise Exclusive-NOR).",
      "syntax": "VXNOR.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "000111 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "000111",
            "clean": "000111"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = ~(vs2[i] ^ vs1[i]);",
      "slug": "vxnor_vv",
      "rel_url": "risc-v/vxnor_vv/",
      "linked_summary": "Computes vd = ~(vs2 ^ vs1) (bitwise Exclusive-NOR).",
      "linked_pseudocode": "foreach(i < vl): vd[i] = ~(vs2[i] ^ vs1[i]);"
    },
    {
      "mnemonic": "VROL.VV",
      "architecture": "RISC-V",
      "extension": "Zvbb (Vector BitManip)",
      "full_name": "Vector Rotate Left",
      "summary": "Rotates bits in elements of vs2 left by amounts in vs1.",
      "syntax": "VROL.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "010101 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010101",
            "clean": "010101"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src"
        },
        {
          "name": "vs1",
          "desc": "Shift"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = (vs2[i] << vs1[i]) | (vs2[i] >> (SEW - vs1[i]));",
      "slug": "vrol_vv",
      "rel_url": "risc-v/vrol_vv/",
      "linked_summary": "Rotates bits <a href=\"../../x86/in/\">in</a> elements of vs2 left by amounts <a href=\"../../x86/in/\">in</a> vs1.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = (vs2[i] << vs1[i]) | (vs2[i] >> (SEW - vs1[i]));"
    },
    {
      "mnemonic": "VROR.VV",
      "architecture": "RISC-V",
      "extension": "Zvbb (Vector BitManip)",
      "full_name": "Vector Rotate Right",
      "summary": "Rotates bits in elements of vs2 right by amounts in vs1.",
      "syntax": "VROR.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "010100 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010100",
            "clean": "010100"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src"
        },
        {
          "name": "vs1",
          "desc": "Shift"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = (vs2[i] >> vs1[i]) | (vs2[i] << (SEW - vs1[i]));",
      "slug": "vror_vv",
      "rel_url": "risc-v/vror_vv/",
      "linked_summary": "Rotates bits <a href=\"../../x86/in/\">in</a> elements of vs2 right by amounts <a href=\"../../x86/in/\">in</a> vs1.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = (vs2[i] >> vs1[i]) | (vs2[i] << (SEW - vs1[i]));"
    },
    {
      "mnemonic": "VROL.VX",
      "architecture": "RISC-V",
      "extension": "Zvbb (Vector BitManip)",
      "full_name": "Vector Rotate Left Scalar",
      "summary": "Rotates bits in elements of vs2 left by scalar rs1.",
      "syntax": "VROL.VX vd, vs2, rs1, vm",
      "encoding": {
        "format": "OPIVX",
        "binary_pattern": "010101 | vm | vs2 | rs1 | 100 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010101",
            "clean": "010101"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src"
        },
        {
          "name": "rs1",
          "desc": "Shift"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = rotate_left(vs2[i], rs1);",
      "slug": "vrol_vx",
      "rel_url": "risc-v/vrol_vx/",
      "linked_summary": "Rotates bits <a href=\"../../x86/in/\">in</a> elements of vs2 left by scalar rs1.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = rotate_left(vs2[i], rs1);"
    },
    {
      "mnemonic": "VROR.VX",
      "architecture": "RISC-V",
      "extension": "Zvbb (Vector BitManip)",
      "full_name": "Vector Rotate Right Scalar",
      "summary": "Rotates bits in elements of vs2 right by scalar rs1.",
      "syntax": "VROR.VX vd, vs2, rs1, vm",
      "encoding": {
        "format": "OPIVX",
        "binary_pattern": "010100 | vm | vs2 | rs1 | 100 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010100",
            "clean": "010100"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src"
        },
        {
          "name": "rs1",
          "desc": "Shift"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = rotate_right(vs2[i], rs1);",
      "slug": "vror_vx",
      "rel_url": "risc-v/vror_vx/",
      "linked_summary": "Rotates bits <a href=\"../../x86/in/\">in</a> elements of vs2 right by scalar rs1.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = rotate_right(vs2[i], rs1);"
    },
    {
      "mnemonic": "VBREV8.V",
      "architecture": "RISC-V",
      "extension": "Zvbb (Vector BitManip)",
      "full_name": "Vector Byte Reverse",
      "summary": "Reverses the bits within each byte of the source elements.",
      "syntax": "VBREV8.V vd, vs2, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "010010 | vm | vs2 | 01000 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010010",
            "clean": "010010"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "01000",
            "clean": "01000"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = reverse_bits_in_bytes(vs2[i]);",
      "slug": "vbrev8_v",
      "rel_url": "risc-v/vbrev8_v/",
      "linked_summary": "Reverses the bits within each byte of the source elements.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = reverse_bits_in_bytes(vs2[i]);"
    },
    {
      "mnemonic": "VREV8.V",
      "architecture": "RISC-V",
      "extension": "Zvbb (Vector BitManip)",
      "full_name": "Vector Reverse 8",
      "summary": "Reverses the order of bytes within each element (Endian swap).",
      "syntax": "VREV8.V vd, vs2, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "010010 | vm | vs2 | 01001 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010010",
            "clean": "010010"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "01001",
            "clean": "01001"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = bswap(vs2[i]);",
      "slug": "vrev8_v",
      "rel_url": "risc-v/vrev8_v/",
      "linked_summary": "Reverses the order of bytes within each element (Endian swap).",
      "linked_pseudocode": "foreach(i < vl): vd[i] = <a href=\"../../x86/bswap_1/\">bswap</a>(vs2[i]);"
    },
    {
      "mnemonic": "VCLZ.V",
      "architecture": "RISC-V",
      "extension": "Zvbb (Vector BitManip)",
      "full_name": "Vector Count Leading Zeros",
      "summary": "Counts the number of leading zero bits in each element.",
      "syntax": "VCLZ.V vd, vs2, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "010010 | vm | vs2 | 01100 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010010",
            "clean": "010010"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "01100",
            "clean": "01100"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = count_leading_zeros(vs2[i]);",
      "slug": "vclz_v",
      "rel_url": "risc-v/vclz_v/",
      "linked_summary": "Counts the number of leading <a href=\"../../armv9-a/zero_1/\">zero</a> bits <a href=\"../../x86/in/\">in</a> each element.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = count_leading_zeros(vs2[i]);"
    },
    {
      "mnemonic": "VCTZ.V",
      "architecture": "RISC-V",
      "extension": "Zvbb (Vector BitManip)",
      "full_name": "Vector Count Trailing Zeros",
      "summary": "Counts the number of trailing zero bits in each element.",
      "syntax": "VCTZ.V vd, vs2, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "010010 | vm | vs2 | 01101 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010010",
            "clean": "010010"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "01101",
            "clean": "01101"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = count_trailing_zeros(vs2[i]);",
      "slug": "vctz_v",
      "rel_url": "risc-v/vctz_v/",
      "linked_summary": "Counts the number of trailing <a href=\"../../armv9-a/zero_1/\">zero</a> bits <a href=\"../../x86/in/\">in</a> each element.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = count_trailing_zeros(vs2[i]);"
    },
    {
      "mnemonic": "VCPOP.V",
      "architecture": "RISC-V",
      "extension": "Zvbb (Vector BitManip)",
      "full_name": "Vector Population Count",
      "summary": "Counts the number of set bits (1s) in each element.",
      "syntax": "VCPOP.V vd, vs2, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "010010 | vm | vs2 | 01110 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010010",
            "clean": "010010"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "01110",
            "clean": "01110"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = count_set_bits(vs2[i]);",
      "slug": "vcpop_v",
      "rel_url": "risc-v/vcpop_v/",
      "linked_summary": "Counts the number of set bits (1s) <a href=\"../../x86/in/\">in</a> each element.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = count_set_bits(vs2[i]);"
    },
    {
      "mnemonic": "VWSLL.VV",
      "architecture": "RISC-V",
      "extension": "Zvbb (Vector BitManip)",
      "full_name": "Vector Widening Shift Left Logical",
      "summary": "Shifts N-bit elements left to produce 2*N-bit results.",
      "syntax": "VWSLL.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "110101 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "110101",
            "clean": "110101"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (Wide)"
        },
        {
          "name": "vs2",
          "desc": "Src (Narrow)"
        },
        {
          "name": "vs1",
          "desc": "Shift"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = zext(vs2[i]) << vs1[i];",
      "slug": "vwsll_vv",
      "rel_url": "risc-v/vwsll_vv/",
      "linked_summary": "Shifts N-<a href=\"../../armv8-a/bit/\">bit</a> elements left to produce 2*N-<a href=\"../../armv8-a/bit/\">bit</a> results.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = zext(vs2[i]) << vs1[i];"
    },
    {
      "mnemonic": "VAESDF.VV",
      "architecture": "RISC-V",
      "extension": "Zvkned (Vector Crypto)",
      "full_name": "Vector AES Decryption Final Round",
      "summary": "Performs the final AES decryption round.",
      "syntax": "VAESDF.VV vd, vs2, vs1",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "101001 | 1 | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "101001",
            "clean": "101001"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "State"
        },
        {
          "name": "vs2",
          "desc": "Round Key"
        },
        {
          "name": "vs1",
          "desc": "Undef"
        }
      ],
      "pseudocode": "vd = AES_Decrypt_Final(vd, vs2);",
      "slug": "vaesdf_vv",
      "rel_url": "risc-v/vaesdf_vv/",
      "linked_summary": "Performs the final AES decryption round.",
      "linked_pseudocode": "vd = AES_Decrypt_Final(vd, vs2);"
    },
    {
      "mnemonic": "VAESDM.VV",
      "architecture": "RISC-V",
      "extension": "Zvkned (Vector Crypto)",
      "full_name": "Vector AES Decryption Middle Round",
      "summary": "Performs a middle AES decryption round.",
      "syntax": "VAESDM.VV vd, vs2, vs1",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "101000 | 1 | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "101000",
            "clean": "101000"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "State"
        },
        {
          "name": "vs2",
          "desc": "Round Key"
        },
        {
          "name": "vs1",
          "desc": "Undef"
        }
      ],
      "pseudocode": "vd = AES_Decrypt_Middle(vd, vs2);",
      "slug": "vaesdm_vv",
      "rel_url": "risc-v/vaesdm_vv/",
      "linked_summary": "Performs a middle AES decryption round.",
      "linked_pseudocode": "vd = AES_Decrypt_Middle(vd, vs2);"
    },
    {
      "mnemonic": "VAESEF.VV",
      "architecture": "RISC-V",
      "extension": "Zvkned (Vector Crypto)",
      "full_name": "Vector AES Encryption Final Round",
      "summary": "Performs the final AES encryption round.",
      "syntax": "VAESEF.VV vd, vs2, vs1",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "101011 | 1 | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "101011",
            "clean": "101011"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "State"
        },
        {
          "name": "vs2",
          "desc": "Round Key"
        },
        {
          "name": "vs1",
          "desc": "Undef"
        }
      ],
      "pseudocode": "vd = AES_Encrypt_Final(vd, vs2);",
      "slug": "vaesef_vv",
      "rel_url": "risc-v/vaesef_vv/",
      "linked_summary": "Performs the final AES encryption round.",
      "linked_pseudocode": "vd = AES_Encrypt_Final(vd, vs2);"
    },
    {
      "mnemonic": "VAESEM.VV",
      "architecture": "RISC-V",
      "extension": "Zvkned (Vector Crypto)",
      "full_name": "Vector AES Encryption Middle Round",
      "summary": "Performs a middle AES encryption round.",
      "syntax": "VAESEM.VV vd, vs2, vs1",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "101010 | 1 | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "101010",
            "clean": "101010"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "State"
        },
        {
          "name": "vs2",
          "desc": "Round Key"
        },
        {
          "name": "vs1",
          "desc": "Undef"
        }
      ],
      "pseudocode": "vd = AES_Encrypt_Middle(vd, vs2);",
      "slug": "vaesem_vv",
      "rel_url": "risc-v/vaesem_vv/",
      "linked_summary": "Performs a middle AES encryption round.",
      "linked_pseudocode": "vd = AES_Encrypt_Middle(vd, vs2);"
    },
    {
      "mnemonic": "VAESKF1.VI",
      "architecture": "RISC-V",
      "extension": "Zvkned (Vector Crypto)",
      "full_name": "Vector AES Key Expansion 1",
      "summary": "Generates the next round key for AES (Step 1).",
      "syntax": "VAESKF1.VI vd, vs2, uimm",
      "encoding": {
        "format": "OPIVI",
        "binary_pattern": "100010 | 1 | vs2 | uimm | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "100010",
            "clean": "100010"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "uimm",
            "clean": "uimm"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src"
        },
        {
          "name": "uimm",
          "desc": "RCON"
        }
      ],
      "pseudocode": "vd = AES_KeyGen_1(vs2, uimm);",
      "slug": "vaeskf1_vi",
      "rel_url": "risc-v/vaeskf1_vi/",
      "linked_summary": "Generates the next round key for AES (Step 1).",
      "linked_pseudocode": "vd = AES_KeyGen_1(vs2, uimm);"
    },
    {
      "mnemonic": "VAESKF2.VI",
      "architecture": "RISC-V",
      "extension": "Zvkned (Vector Crypto)",
      "full_name": "Vector AES Key Expansion 2",
      "summary": "Generates the next round key for AES (Step 2).",
      "syntax": "VAESKF2.VI vd, vs2, uimm",
      "encoding": {
        "format": "OPIVI",
        "binary_pattern": "101010 | 1 | vs2 | uimm | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "101010",
            "clean": "101010"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "uimm",
            "clean": "uimm"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src"
        },
        {
          "name": "uimm",
          "desc": "Round"
        }
      ],
      "pseudocode": "vd = AES_KeyGen_2(vs2, uimm);",
      "slug": "vaeskf2_vi",
      "rel_url": "risc-v/vaeskf2_vi/",
      "linked_summary": "Generates the next round key for AES (Step 2).",
      "linked_pseudocode": "vd = AES_KeyGen_2(vs2, uimm);"
    },
    {
      "mnemonic": "VSHA2CH.VV",
      "architecture": "RISC-V",
      "extension": "Zvknha (Vector Crypto)",
      "full_name": "Vector SHA-2 Compress High",
      "summary": "Performs SHA-256 compression (high 128 bits).",
      "syntax": "VSHA2CH.VV vd, vs2, vs1",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "101110 | 1 | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "101110",
            "clean": "101110"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "State"
        },
        {
          "name": "vs2",
          "desc": "Message"
        },
        {
          "name": "vs1",
          "desc": "State B"
        }
      ],
      "pseudocode": "vd = SHA256_Compress_High(vd, vs1, vs2);",
      "slug": "vsha2ch_vv",
      "rel_url": "risc-v/vsha2ch_vv/",
      "linked_summary": "Performs SHA-256 compression (high 128 bits).",
      "linked_pseudocode": "vd = SHA256_Compress_High(vd, vs1, vs2);"
    },
    {
      "mnemonic": "VSHA2CL.VV",
      "architecture": "RISC-V",
      "extension": "Zvknha (Vector Crypto)",
      "full_name": "Vector SHA-2 Compress Low",
      "summary": "Performs SHA-256 compression (low 128 bits).",
      "syntax": "VSHA2CL.VV vd, vs2, vs1",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "101111 | 1 | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "101111",
            "clean": "101111"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "State"
        },
        {
          "name": "vs2",
          "desc": "Message"
        },
        {
          "name": "vs1",
          "desc": "State B"
        }
      ],
      "pseudocode": "vd = SHA256_Compress_Low(vd, vs1, vs2);",
      "slug": "vsha2cl_vv",
      "rel_url": "risc-v/vsha2cl_vv/",
      "linked_summary": "Performs SHA-256 compression (low 128 bits).",
      "linked_pseudocode": "vd = SHA256_Compress_Low(vd, vs1, vs2);"
    },
    {
      "mnemonic": "VSHA2MS.VV",
      "architecture": "RISC-V",
      "extension": "Zvknha (Vector Crypto)",
      "full_name": "Vector SHA-2 Message Schedule",
      "summary": "Generates SHA-256 message schedule words.",
      "syntax": "VSHA2MS.VV vd, vs2, vs1",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "101100 | 1 | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "101100",
            "clean": "101100"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "vd = SHA256_MsgSched(vd, vs1, vs2);",
      "slug": "vsha2ms_vv",
      "rel_url": "risc-v/vsha2ms_vv/",
      "linked_summary": "Generates SHA-256 message schedule words.",
      "linked_pseudocode": "vd = SHA256_MsgSched(vd, vs1, vs2);"
    },
    {
      "mnemonic": "VGHSH.VV",
      "architecture": "RISC-V",
      "extension": "Zvkg (Vector Crypto)",
      "full_name": "Vector GCM Hash",
      "summary": "Performs GHASH multiply-add for AES-GCM.",
      "syntax": "VGHSH.VV vd, vs2, vs1",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "101100 | 1 | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "101100",
            "clean": "101100"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Accumulator"
        },
        {
          "name": "vs2",
          "desc": "Hash Key"
        },
        {
          "name": "vs1",
          "desc": "Data"
        }
      ],
      "pseudocode": "vd = GHASH_MulAdd(vd, vs1, vs2);",
      "slug": "vghsh_vv",
      "rel_url": "risc-v/vghsh_vv/",
      "linked_summary": "Performs GHASH multiply-<a href=\"../../armv8-a/add_8/\">add</a> for AES-GCM.",
      "linked_pseudocode": "vd = GHASH_MulAdd(vd, vs1, vs2);"
    },
    {
      "mnemonic": "VGSHA.VV",
      "architecture": "RISC-V",
      "extension": "Zvkg (Vector Crypto)",
      "full_name": "Vector GCM Hash Accumulate",
      "summary": "Used in GCM GHASH loop.",
      "syntax": "VGSHA.VV vd, vs2, vs1",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "101101 | 1 | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "101101",
            "clean": "101101"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "vd = GHASH_Step(vd, vs1, vs2);",
      "slug": "vgsha_vv",
      "rel_url": "risc-v/vgsha_vv/",
      "linked_summary": "Used <a href=\"../../x86/in/\">in</a> GCM GHASH <a href=\"../../x86/loop/\">loop</a>.",
      "linked_pseudocode": "vd = GHASH_Step(vd, vs1, vs2);"
    },
    {
      "mnemonic": "VCLMUL.VV",
      "architecture": "RISC-V",
      "extension": "Zvbc (Vector Crypto)",
      "full_name": "Vector Carry-less Multiply",
      "summary": "Performs carry-less multiplication on vector elements (GF(2^n)).",
      "syntax": "VCLMUL.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "001100 | vm | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "001100",
            "clean": "001100"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = clmul(vs1[i], vs2[i]);",
      "slug": "vclmul_vv",
      "rel_url": "risc-v/vclmul_vv/",
      "linked_summary": "Performs carry-less multiplication on vector elements (GF(2^n)).",
      "linked_pseudocode": "foreach(i < vl): vd[i] = clmul(vs1[i], vs2[i]);"
    },
    {
      "mnemonic": "VCLMULH.VV",
      "architecture": "RISC-V",
      "extension": "Zvbc (Vector Crypto)",
      "full_name": "Vector Carry-less Multiply High",
      "summary": "Performs carry-less multiplication, keeping the high half.",
      "syntax": "VCLMULH.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "001101 | vm | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "001101",
            "clean": "001101"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = clmulh(vs1[i], vs2[i]);",
      "slug": "vclmulh_vv",
      "rel_url": "risc-v/vclmulh_vv/",
      "linked_summary": "Performs carry-less multiplication, keeping the high half.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = clmulh(vs1[i], vs2[i]);"
    },
    {
      "mnemonic": "VCPOP.M",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Mask Population Count",
      "summary": "Counts set bits in the source mask register.",
      "syntax": "VCPOP.M rd, vs2, vm",
      "encoding": {
        "format": "OPMVX",
        "binary_pattern": "010000 | vm | vs2 | 10000 | 010 | rd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010000",
            "clean": "010000"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "10000",
            "clean": "10000"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Scalar)"
        },
        {
          "name": "vs2",
          "desc": "Src Mask"
        }
      ],
      "pseudocode": "rd = count_set_bits(vs2 & vm);",
      "slug": "vcpop_m",
      "rel_url": "risc-v/vcpop_m/",
      "linked_summary": "Counts set bits <a href=\"../../x86/in/\">in</a> the source mask register.",
      "linked_pseudocode": "rd = count_set_bits(vs2 & vm);"
    },
    {
      "mnemonic": "VFIRST.M",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Find First Set Mask Bit",
      "summary": "Finds the index of the first set bit in the mask.",
      "syntax": "VFIRST.M rd, vs2, vm",
      "encoding": {
        "format": "OPMVX",
        "binary_pattern": "010000 | vm | vs2 | 10001 | 010 | rd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010000",
            "clean": "010000"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "10001",
            "clean": "10001"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Index)"
        },
        {
          "name": "vs2",
          "desc": "Src Mask"
        }
      ],
      "pseudocode": "rd = find_first_set(vs2 & vm);",
      "slug": "vfirst_m",
      "rel_url": "risc-v/vfirst_m/",
      "linked_summary": "Finds the <a href=\"../../armv8-a/index/\">index</a> of the first set <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> the mask.",
      "linked_pseudocode": "rd = find_first_set(vs2 & vm);"
    },
    {
      "mnemonic": "VMSBF.M",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Mask Set Before First",
      "summary": "Sets mask bits before the first set bit in the source mask.",
      "syntax": "VMSBF.M vd, vs2, vm",
      "encoding": {
        "format": "OPMVV",
        "binary_pattern": "010100 | vm | vs2 | 00001 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010100",
            "clean": "010100"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "00001",
            "clean": "00001"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest Mask"
        },
        {
          "name": "vs2",
          "desc": "Src Mask"
        }
      ],
      "pseudocode": "Set 1s up to the first 1 in vs2.",
      "slug": "vmsbf_m",
      "rel_url": "risc-v/vmsbf_m/",
      "linked_summary": "Sets mask bits before the first set <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> the source mask.",
      "linked_pseudocode": "Set 1s up to the first 1 <a href=\"../../x86/in/\">in</a> vs2."
    },
    {
      "mnemonic": "VMSIF.M",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Mask Set Including First",
      "summary": "Sets mask bits up to and including the first set bit in the source.",
      "syntax": "VMSIF.M vd, vs2, vm",
      "encoding": {
        "format": "OPMVV",
        "binary_pattern": "010100 | vm | vs2 | 00011 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010100",
            "clean": "010100"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "00011",
            "clean": "00011"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest Mask"
        },
        {
          "name": "vs2",
          "desc": "Src Mask"
        }
      ],
      "pseudocode": "Set 1s up to and including the first 1 in vs2.",
      "slug": "vmsif_m",
      "rel_url": "risc-v/vmsif_m/",
      "linked_summary": "Sets mask bits up to <a href=\"../../armv8-a/and_6/\">and</a> including the first set <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> the source.",
      "linked_pseudocode": "Set 1s up to <a href=\"../../armv8-a/and_6/\">and</a> including the first 1 <a href=\"../../x86/in/\">in</a> vs2."
    },
    {
      "mnemonic": "VMSOF.M",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Mask Set Only First",
      "summary": "Sets only the first set bit from the source mask.",
      "syntax": "VMSOF.M vd, vs2, vm",
      "encoding": {
        "format": "OPMVV",
        "binary_pattern": "010100 | vm | vs2 | 00010 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010100",
            "clean": "010100"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "00010",
            "clean": "00010"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest Mask"
        },
        {
          "name": "vs2",
          "desc": "Src Mask"
        }
      ],
      "pseudocode": "vd = (1 << first_set_index(vs2)) & vm;",
      "slug": "vmsof_m",
      "rel_url": "risc-v/vmsof_m/",
      "linked_summary": "Sets only the first set <a href=\"../../armv8-a/bit/\">bit</a> from the source mask.",
      "linked_pseudocode": "vd = (1 << first_set_index(vs2)) & vm;"
    },
    {
      "mnemonic": "VANDN.VX",
      "architecture": "RISC-V",
      "extension": "Zvbb",
      "full_name": "Vector Bitwise AND-NOT Scalar",
      "summary": "Computes vd = vs2 & ~rs1.",
      "syntax": "VANDN.VX vd, vs2, rs1, vm",
      "encoding": {
        "format": "OPIVX",
        "binary_pattern": "000001 | vm | vs2 | rs1 | 100 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "000001",
            "clean": "000001"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src"
        },
        {
          "name": "rs1",
          "desc": "Scalar"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs2[i] & ~rs1;",
      "slug": "vandn_vx",
      "rel_url": "risc-v/vandn_vx/",
      "linked_summary": "Computes vd = vs2 & ~rs1.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = vs2[i] & ~rs1;"
    },
    {
      "mnemonic": "VORN.VX",
      "architecture": "RISC-V",
      "extension": "Zvbb",
      "full_name": "Vector Bitwise OR-NOT Scalar",
      "summary": "Computes vd = vs2 | ~rs1.",
      "syntax": "VORN.VX vd, vs2, rs1, vm",
      "encoding": {
        "format": "OPIVX",
        "binary_pattern": "000101 | vm | vs2 | rs1 | 100 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "000101",
            "clean": "000101"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src"
        },
        {
          "name": "rs1",
          "desc": "Scalar"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs2[i] | ~rs1;",
      "slug": "vorn_vx",
      "rel_url": "risc-v/vorn_vx/",
      "linked_summary": "Computes vd = vs2 | ~rs1.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = vs2[i] | ~rs1;"
    },
    {
      "mnemonic": "VXNOR.VX",
      "architecture": "RISC-V",
      "extension": "Zvbb",
      "full_name": "Vector Bitwise XNOR Scalar",
      "summary": "Computes vd = ~(vs2 ^ rs1).",
      "syntax": "VXNOR.VX vd, vs2, rs1, vm",
      "encoding": {
        "format": "OPIVX",
        "binary_pattern": "000111 | vm | vs2 | rs1 | 100 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "000111",
            "clean": "000111"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src"
        },
        {
          "name": "rs1",
          "desc": "Scalar"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = ~(vs2[i] ^ rs1);",
      "slug": "vxnor_vx",
      "rel_url": "risc-v/vxnor_vx/",
      "linked_summary": "Computes vd = ~(vs2 ^ rs1).",
      "linked_pseudocode": "foreach(i < vl): vd[i] = ~(vs2[i] ^ rs1);"
    },
    {
      "mnemonic": "VWSLL.VX",
      "architecture": "RISC-V",
      "extension": "Zvbb",
      "full_name": "Vector Widening Shift Left Logical Scalar",
      "summary": "Shifts elements left by scalar rs1, widening the result.",
      "syntax": "VWSLL.VX vd, vs2, rs1, vm",
      "encoding": {
        "format": "OPIVX",
        "binary_pattern": "110101 | vm | vs2 | rs1 | 100 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "110101",
            "clean": "110101"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (Wide)"
        },
        {
          "name": "vs2",
          "desc": "Src (Narrow)"
        },
        {
          "name": "rs1",
          "desc": "Shift"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = zext(vs2[i]) << rs1;",
      "slug": "vwsll_vx",
      "rel_url": "risc-v/vwsll_vx/",
      "linked_summary": "Shifts elements left by scalar rs1, widening the result.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = zext(vs2[i]) << rs1;"
    },
    {
      "mnemonic": "VWSLL.VI",
      "architecture": "RISC-V",
      "extension": "Zvbb",
      "full_name": "Vector Widening Shift Left Logical Immediate",
      "summary": "Shifts elements left by immediate, widening the result.",
      "syntax": "VWSLL.VI vd, vs2, imm, vm",
      "encoding": {
        "format": "OPIVI",
        "binary_pattern": "110101 | vm | vs2 | imm | 011 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "110101",
            "clean": "110101"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (Wide)"
        },
        {
          "name": "vs2",
          "desc": "Src (Narrow)"
        },
        {
          "name": "imm",
          "desc": "Shift"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = zext(vs2[i]) << imm;",
      "slug": "vwsll_vi",
      "rel_url": "risc-v/vwsll_vi/",
      "linked_summary": "Shifts elements left by immediate, widening the result.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = zext(vs2[i]) << imm;"
    },
    {
      "mnemonic": "BLTU",
      "architecture": "RISC-V",
      "extension": "Base",
      "full_name": "Branch if Less Than Unsigned",
      "summary": "Take the branch if rs1 is less than rs2 (unsigned comparison).",
      "syntax": "BLTU rs1, rs2, offset",
      "encoding": {
        "format": "B-Type",
        "binary_pattern": "imm | rs2 | rs1 | 110 | imm | 1100011",
        "hex_opcode": "0x63",
        "visual_parts": [
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "110",
            "clean": "110"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "1100011",
            "clean": "1100011"
          }
        ]
      },
      "operands": [
        {
          "name": "rs1",
          "desc": "Source 1"
        },
        {
          "name": "rs2",
          "desc": "Source 2"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "if (R[rs1] <u R[rs2]) PC += sext(offset);",
      "slug": "bltu",
      "rel_url": "risc-v/bltu/",
      "linked_summary": "Take the branch if rs1 is less than rs2 (unsigned comparison).",
      "linked_pseudocode": "if (R[rs1] <u R[rs2]) PC += sext(offset);"
    },
    {
      "mnemonic": "BGEU",
      "architecture": "RISC-V",
      "extension": "Base",
      "full_name": "Branch if Greater or Equal Unsigned",
      "summary": "Take the branch if rs1 is greater than or equal to rs2 (unsigned comparison).",
      "syntax": "BGEU rs1, rs2, offset",
      "encoding": {
        "format": "B-Type",
        "binary_pattern": "imm | rs2 | rs1 | 111 | imm | 1100011",
        "hex_opcode": "0x63",
        "visual_parts": [
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "111",
            "clean": "111"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "1100011",
            "clean": "1100011"
          }
        ]
      },
      "operands": [
        {
          "name": "rs1",
          "desc": "Source 1"
        },
        {
          "name": "rs2",
          "desc": "Source 2"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "if (R[rs1] >=u R[rs2]) PC += sext(offset);",
      "slug": "bgeu",
      "rel_url": "risc-v/bgeu/",
      "linked_summary": "Take the branch if rs1 is greater than <a href=\"../../powerisa/or/\">or</a> equal to rs2 (unsigned comparison).",
      "linked_pseudocode": "if (R[rs1] >=u R[rs2]) PC += sext(offset);"
    },
    {
      "mnemonic": "FMV.X.D",
      "architecture": "RISC-V",
      "extension": "D (Double)",
      "full_name": "Move Double to Integer",
      "summary": "Moves the bit pattern of a 64-bit floating-point register to an integer register (RV64).",
      "syntax": "FMV.X.D rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "1110001 | 00000 | rs1 | 000 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1110001",
            "clean": "1110001"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Int64)"
        },
        {
          "name": "rs1",
          "desc": "Source (Double)"
        }
      ],
      "pseudocode": "R[rd] = F[rs1];",
      "slug": "fmv_x_d",
      "rel_url": "risc-v/fmv_x_d/",
      "linked_summary": "Moves the <a href=\"../../armv8-a/bit/\">bit</a> pattern of a 64-<a href=\"../../armv8-a/bit/\">bit</a> floating-point register to an integer register (RV64).",
      "linked_pseudocode": "R[rd] = F[rs1];"
    },
    {
      "mnemonic": "FMV.D.X",
      "architecture": "RISC-V",
      "extension": "D (Double)",
      "full_name": "Move Integer to Double",
      "summary": "Moves the bit pattern of a 64-bit integer register to a floating-point register (RV64).",
      "syntax": "FMV.D.X rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "1111001 | 00000 | rs1 | 000 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1111001",
            "clean": "1111001"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Double)"
        },
        {
          "name": "rs1",
          "desc": "Source (Int64)"
        }
      ],
      "pseudocode": "F[rd] = R[rs1];",
      "slug": "fmv_d_x",
      "rel_url": "risc-v/fmv_d_x/",
      "linked_summary": "Moves the <a href=\"../../armv8-a/bit/\">bit</a> pattern of a 64-<a href=\"../../armv8-a/bit/\">bit</a> integer register to a floating-point register (RV64).",
      "linked_pseudocode": "F[rd] = R[rs1];"
    },
    {
      "mnemonic": "FSGNJX.D",
      "architecture": "RISC-V",
      "extension": "D (Double)",
      "full_name": "Float Sign Injection XOR (Double)",
      "summary": "Injects the XOR of signs of rs1 and rs2 (Double Precision).",
      "syntax": "FSGNJX.D rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0010001 | rs2 | rs1 | 010 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0010001",
            "clean": "0010001"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source 1"
        },
        {
          "name": "rs2",
          "desc": "Source 2"
        }
      ],
      "pseudocode": "F[rd] = {F[rs1][63] ^ F[rs2][63], F[rs1][62:0]};",
      "slug": "fsgnjx_d",
      "rel_url": "risc-v/fsgnjx_d/",
      "linked_summary": "Injects the <a href=\"../../risc-v/xor/\">XOR</a> of signs of rs1 <a href=\"../../armv8-a/and_6/\">and</a> rs2 (Double Precision).",
      "linked_pseudocode": "F[rd] = {F[rs1][63] ^ F[rs2][63], F[rs1][62:0]};"
    },
    {
      "mnemonic": "C.NOP",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed No Operation",
      "summary": "Performs no operation (Compressed encoding).",
      "syntax": "C.NOP",
      "encoding": {
        "format": "CI",
        "binary_pattern": "000 | 0 | 00000 | 0 | 01",
        "hex_opcode": "01",
        "visual_parts": [
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "01",
            "clean": "01"
          }
        ]
      },
      "operands": [],
      "pseudocode": "R[0] = R[0] + 0;",
      "slug": "c_nop",
      "rel_url": "risc-v/c_nop/",
      "linked_summary": "Performs no operation (Compressed encoding).",
      "linked_pseudocode": "R[0] = R[0] + 0;"
    },
    {
      "mnemonic": "C.ADDIW",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Add Immediate Word",
      "summary": "Adds a signed immediate to a register (32-bit result sign-extended, RV64).",
      "syntax": "C.ADDIW rd, imm",
      "encoding": {
        "format": "CI",
        "binary_pattern": "001 | imm | rd | imm | 01",
        "hex_opcode": "01",
        "visual_parts": [
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "01",
            "clean": "01"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest/Src"
        },
        {
          "name": "imm",
          "desc": "Immediate"
        }
      ],
      "pseudocode": "R[rd] = sext((R[rd] + sext(imm))[31:0]);",
      "slug": "c_addiw",
      "rel_url": "risc-v/c_addiw/",
      "linked_summary": "Adds a signed immediate to a register (32-<a href=\"../../armv8-a/bit/\">bit</a> result sign-extended, RV64).",
      "linked_pseudocode": "R[rd] = sext((R[rd] + sext(imm))[31:0]);"
    },
    {
      "mnemonic": "C.ADDW",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Add Word",
      "summary": "Adds two registers (32-bit result sign-extended, RV64).",
      "syntax": "C.ADDW rd&#x27;, rs2&#x27;",
      "encoding": {
        "format": "CA",
        "binary_pattern": "100111 | rd' | 10 | rs2' | 01",
        "hex_opcode": "01",
        "visual_parts": [
          {
            "raw": "100111",
            "clean": "100111"
          },
          {
            "raw": "rd'",
            "clean": "rd'"
          },
          {
            "raw": "10",
            "clean": "10"
          },
          {
            "raw": "rs2'",
            "clean": "rs2'"
          },
          {
            "raw": "01",
            "clean": "01"
          }
        ]
      },
      "operands": [
        {
          "name": "rd'",
          "desc": "Dest/Src1"
        },
        {
          "name": "rs2'",
          "desc": "Src2"
        }
      ],
      "pseudocode": "R[rd'] = sext((R[rd'] + R[rs2'])[31:0]);",
      "slug": "c_addw",
      "rel_url": "risc-v/c_addw/",
      "linked_summary": "Adds two registers (32-<a href=\"../../armv8-a/bit/\">bit</a> result sign-extended, RV64).",
      "linked_pseudocode": "R[rd'] = sext((R[rd'] + R[rs2'])[31:0]);"
    },
    {
      "mnemonic": "C.SUBW",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Subtract Word",
      "summary": "Subtracts two registers (32-bit result sign-extended, RV64).",
      "syntax": "C.SUBW rd&#x27;, rs2&#x27;",
      "encoding": {
        "format": "CA",
        "binary_pattern": "100111 | rd' | 00 | rs2' | 01",
        "hex_opcode": "01",
        "visual_parts": [
          {
            "raw": "100111",
            "clean": "100111"
          },
          {
            "raw": "rd'",
            "clean": "rd'"
          },
          {
            "raw": "00",
            "clean": "00"
          },
          {
            "raw": "rs2'",
            "clean": "rs2'"
          },
          {
            "raw": "01",
            "clean": "01"
          }
        ]
      },
      "operands": [
        {
          "name": "rd'",
          "desc": "Dest/Src1"
        },
        {
          "name": "rs2'",
          "desc": "Src2"
        }
      ],
      "pseudocode": "R[rd'] = sext((R[rd'] - R[rs2'])[31:0]);",
      "slug": "c_subw",
      "rel_url": "risc-v/c_subw/",
      "linked_summary": "Subtracts two registers (32-<a href=\"../../armv8-a/bit/\">bit</a> result sign-extended, RV64).",
      "linked_pseudocode": "R[rd'] = sext((R[rd'] - R[rs2'])[31:0]);"
    },
    {
      "mnemonic": "C.LDSP",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Load Doubleword from Stack Pointer",
      "summary": "Loads a 64-bit value from the stack pointer (RV64).",
      "syntax": "C.LDSP rd, offset(x2)",
      "encoding": {
        "format": "CI",
        "binary_pattern": "011 | imm | rd | imm | 10",
        "hex_opcode": "02",
        "visual_parts": [
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "10",
            "clean": "10"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "R[rd] = M[R[2] + offset][63:0];",
      "slug": "c_ldsp",
      "rel_url": "risc-v/c_ldsp/",
      "linked_summary": "Loads a 64-<a href=\"../../armv8-a/bit/\">bit</a> value from the stack pointer (RV64).",
      "linked_pseudocode": "R[rd] = M[R[2] + offset][63:0];"
    },
    {
      "mnemonic": "C.SDSP",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Store Doubleword to Stack Pointer",
      "summary": "Stores a 64-bit value to the stack pointer (RV64).",
      "syntax": "C.SDSP rs2, offset(x2)",
      "encoding": {
        "format": "CSS",
        "binary_pattern": "111 | imm | rs2 | 10",
        "hex_opcode": "02",
        "visual_parts": [
          {
            "raw": "111",
            "clean": "111"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "10",
            "clean": "10"
          }
        ]
      },
      "operands": [
        {
          "name": "rs2",
          "desc": "Source"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "M[R[2] + offset][63:0] = R[rs2];",
      "slug": "c_sdsp",
      "rel_url": "risc-v/c_sdsp/",
      "linked_summary": "Stores a 64-<a href=\"../../armv8-a/bit/\">bit</a> value to the stack pointer (RV64).",
      "linked_pseudocode": "M[R[2] + offset][63:0] = R[rs2];"
    },
    {
      "mnemonic": "C.FLWSP",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Float Load Word from Stack Pointer",
      "summary": "Loads a single-precision float from the stack pointer.",
      "syntax": "C.FLWSP rd, offset(x2)",
      "encoding": {
        "format": "CI",
        "binary_pattern": "011 | imm | rd | imm | 10",
        "hex_opcode": "02",
        "visual_parts": [
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "10",
            "clean": "10"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "F[rd] = M[R[2] + offset][31:0];",
      "slug": "c_flwsp",
      "rel_url": "risc-v/c_flwsp/",
      "linked_summary": "Loads a single-precision float from the stack pointer.",
      "linked_pseudocode": "F[rd] = M[R[2] + offset][31:0];"
    },
    {
      "mnemonic": "C.FSWSP",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Float Store Word to Stack Pointer",
      "summary": "Stores a single-precision float to the stack pointer.",
      "syntax": "C.FSWSP rs2, offset(x2)",
      "encoding": {
        "format": "CSS",
        "binary_pattern": "111 | imm | rs2 | 10",
        "hex_opcode": "02",
        "visual_parts": [
          {
            "raw": "111",
            "clean": "111"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "10",
            "clean": "10"
          }
        ]
      },
      "operands": [
        {
          "name": "rs2",
          "desc": "Source"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "M[R[2] + offset][31:0] = F[rs2];",
      "slug": "c_fswsp",
      "rel_url": "risc-v/c_fswsp/",
      "linked_summary": "Stores a single-precision float to the stack pointer.",
      "linked_pseudocode": "M[R[2] + offset][31:0] = F[rs2];"
    },
    {
      "mnemonic": "C.FLDSP",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Float Load Double from Stack Pointer",
      "summary": "Loads a double-precision float from the stack pointer.",
      "syntax": "C.FLDSP rd, offset(x2)",
      "encoding": {
        "format": "CI",
        "binary_pattern": "001 | imm | rd | imm | 10",
        "hex_opcode": "02",
        "visual_parts": [
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "10",
            "clean": "10"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "F[rd] = M[R[2] + offset][63:0];",
      "slug": "c_fldsp",
      "rel_url": "risc-v/c_fldsp/",
      "linked_summary": "Loads a double-precision float from the stack pointer.",
      "linked_pseudocode": "F[rd] = M[R[2] + offset][63:0];"
    },
    {
      "mnemonic": "C.FSDSP",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Float Store Double to Stack Pointer",
      "summary": "Stores a double-precision float to the stack pointer.",
      "syntax": "C.FSDSP rs2, offset(x2)",
      "encoding": {
        "format": "CSS",
        "binary_pattern": "101 | imm | rs2 | 10",
        "hex_opcode": "02",
        "visual_parts": [
          {
            "raw": "101",
            "clean": "101"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "10",
            "clean": "10"
          }
        ]
      },
      "operands": [
        {
          "name": "rs2",
          "desc": "Source"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "M[R[2] + offset][63:0] = F[rs2];",
      "slug": "c_fsdsp",
      "rel_url": "risc-v/c_fsdsp/",
      "linked_summary": "Stores a double-precision float to the stack pointer.",
      "linked_pseudocode": "M[R[2] + offset][63:0] = F[rs2];"
    },
    {
      "mnemonic": "VSUB.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Integer Subtract",
      "summary": "Subtracts elements of two vector registers.",
      "syntax": "VSUB.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "000010 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "000010",
            "clean": "000010"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2 (Subtrahend)"
        },
        {
          "name": "vs1",
          "desc": "Src 1 (Minuend)"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs1[i] - vs2[i];",
      "slug": "vsub_vv",
      "rel_url": "risc-v/vsub_vv/",
      "linked_summary": "Subtracts elements of two vector registers.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = vs1[i] - vs2[i];"
    },
    {
      "mnemonic": "VRSUB.VX",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Integer Reverse Subtract Scalar",
      "summary": "Subtracts vector elements from a scalar value (scalar - vector).",
      "syntax": "VRSUB.VX vd, vs2, rs1, vm",
      "encoding": {
        "format": "OPIVX",
        "binary_pattern": "000011 | vm | vs2 | rs1 | 100 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "000011",
            "clean": "000011"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Vector Src"
        },
        {
          "name": "rs1",
          "desc": "Scalar Src"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = rs1 - vs2[i];",
      "slug": "vrsub_vx",
      "rel_url": "risc-v/vrsub_vx/",
      "linked_summary": "Subtracts vector elements from a scalar value (scalar - vector).",
      "linked_pseudocode": "foreach(i < vl): vd[i] = rs1 - vs2[i];"
    },
    {
      "mnemonic": "VMIN.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Minimum (Signed)",
      "summary": "Computes the signed minimum of elements in two vectors.",
      "syntax": "VMIN.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "000101 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "000101",
            "clean": "000101"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = min(vs1[i], vs2[i]);",
      "slug": "vmin_vv",
      "rel_url": "risc-v/vmin_vv/",
      "linked_summary": "Computes the signed minimum of elements <a href=\"../../x86/in/\">in</a> two vectors.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = min(vs1[i], vs2[i]);"
    },
    {
      "mnemonic": "VMAX.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Maximum (Signed)",
      "summary": "Computes the signed maximum of elements in two vectors.",
      "syntax": "VMAX.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "000111 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "000111",
            "clean": "000111"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = max(vs1[i], vs2[i]);",
      "slug": "vmax_vv",
      "rel_url": "risc-v/vmax_vv/",
      "linked_summary": "Computes the signed maximum of elements <a href=\"../../x86/in/\">in</a> two vectors.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = max(vs1[i], vs2[i]);"
    },
    {
      "mnemonic": "VMINU.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Minimum (Unsigned)",
      "summary": "Computes the unsigned minimum of elements in two vectors.",
      "syntax": "VMINU.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "000100 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "000100",
            "clean": "000100"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = min_u(vs1[i], vs2[i]);",
      "slug": "vminu_vv",
      "rel_url": "risc-v/vminu_vv/",
      "linked_summary": "Computes the unsigned minimum of elements <a href=\"../../x86/in/\">in</a> two vectors.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = min_u(vs1[i], vs2[i]);"
    },
    {
      "mnemonic": "VMAXU.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Maximum (Unsigned)",
      "summary": "Computes the unsigned maximum of elements in two vectors.",
      "syntax": "VMAXU.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "000110 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "000110",
            "clean": "000110"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = max_u(vs1[i], vs2[i]);",
      "slug": "vmaxu_vv",
      "rel_url": "risc-v/vmaxu_vv/",
      "linked_summary": "Computes the unsigned maximum of elements <a href=\"../../x86/in/\">in</a> two vectors.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = max_u(vs1[i], vs2[i]);"
    },
    {
      "mnemonic": "VOR.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Bitwise OR",
      "summary": "Performs bitwise OR on elements of two vectors.",
      "syntax": "VOR.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "001010 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "001010",
            "clean": "001010"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs1[i] | vs2[i];",
      "slug": "vor_vv",
      "rel_url": "risc-v/vor_vv/",
      "linked_summary": "Performs bitwise <a href=\"../../risc-v/or/\">OR</a> on elements of two vectors.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = vs1[i] | vs2[i];"
    },
    {
      "mnemonic": "VXOR.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Bitwise XOR",
      "summary": "Performs bitwise XOR on elements of two vectors.",
      "syntax": "VXOR.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "001011 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "001011",
            "clean": "001011"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs1[i] ^ vs2[i];",
      "slug": "vxor_vv",
      "rel_url": "risc-v/vxor_vv/",
      "linked_summary": "Performs bitwise <a href=\"../../risc-v/xor/\">XOR</a> on elements of two vectors.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = vs1[i] ^ vs2[i];"
    },
    {
      "mnemonic": "VSLL.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Shift Left Logical",
      "summary": "Shifts elements of vector vs2 left by amounts in vs1.",
      "syntax": "VSLL.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "100101 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "100101",
            "clean": "100101"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Source"
        },
        {
          "name": "vs1",
          "desc": "Shift Amount"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs2[i] << (vs1[i] & Mask);",
      "slug": "vsll_vv",
      "rel_url": "risc-v/vsll_vv/",
      "linked_summary": "Shifts elements of vector vs2 left by amounts <a href=\"../../x86/in/\">in</a> vs1.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = vs2[i] << (vs1[i] & Mask);"
    },
    {
      "mnemonic": "VSRL.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Shift Right Logical",
      "summary": "Shifts elements of vector vs2 right (logical) by amounts in vs1.",
      "syntax": "VSRL.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "101000 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "101000",
            "clean": "101000"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Source"
        },
        {
          "name": "vs1",
          "desc": "Shift Amount"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs2[i] >> (vs1[i] & Mask);",
      "slug": "vsrl_vv",
      "rel_url": "risc-v/vsrl_vv/",
      "linked_summary": "Shifts elements of vector vs2 right (logical) by amounts <a href=\"../../x86/in/\">in</a> vs1.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = vs2[i] >> (vs1[i] & Mask);"
    },
    {
      "mnemonic": "VSRA.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Shift Right Arithmetic",
      "summary": "Shifts elements of vector vs2 right (arithmetic) by amounts in vs1.",
      "syntax": "VSRA.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "101001 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "101001",
            "clean": "101001"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Source"
        },
        {
          "name": "vs1",
          "desc": "Shift Amount"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs2[i] >>s (vs1[i] & Mask);",
      "slug": "vsra_vv",
      "rel_url": "risc-v/vsra_vv/",
      "linked_summary": "Shifts elements of vector vs2 right (arithmetic) by amounts <a href=\"../../x86/in/\">in</a> vs1.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = vs2[i] >>s (vs1[i] & Mask);"
    },
    {
      "mnemonic": "VMSEQ.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Mask Set Equal",
      "summary": "Sets destination mask bit if elements are equal.",
      "syntax": "VMSEQ.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "011000 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "011000",
            "clean": "011000"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest Mask"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = (vs2[i] == vs1[i]) ? 1 : 0;",
      "slug": "vmseq_vv",
      "rel_url": "risc-v/vmseq_vv/",
      "linked_summary": "Sets destination mask <a href=\"../../armv8-a/bit/\">bit</a> if elements are equal.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = (vs2[i] == vs1[i]) ? 1 : 0;"
    },
    {
      "mnemonic": "VMSLT.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Mask Set Less Than (Signed)",
      "summary": "Sets destination mask bit if vs2 < vs1 (signed).",
      "syntax": "VMSLT.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "011011 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "011011",
            "clean": "011011"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest Mask"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = (vs2[i] <s vs1[i]) ? 1 : 0;",
      "slug": "vmslt_vv",
      "rel_url": "risc-v/vmslt_vv/",
      "linked_summary": "Sets destination mask <a href=\"../../armv8-a/bit/\">bit</a> if vs2 < vs1 (signed).",
      "linked_pseudocode": "foreach(i < vl): vd[i] = (vs2[i] <s vs1[i]) ? 1 : 0;"
    },
    {
      "mnemonic": "VMSLTU.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Mask Set Less Than (Unsigned)",
      "summary": "Sets destination mask bit if vs2 < vs1 (unsigned).",
      "syntax": "VMSLTU.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "011100 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "011100",
            "clean": "011100"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest Mask"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = (vs2[i] <u vs1[i]) ? 1 : 0;",
      "slug": "vmsltu_vv",
      "rel_url": "risc-v/vmsltu_vv/",
      "linked_summary": "Sets destination mask <a href=\"../../armv8-a/bit/\">bit</a> if vs2 < vs1 (unsigned).",
      "linked_pseudocode": "foreach(i < vl): vd[i] = (vs2[i] <u vs1[i]) ? 1 : 0;"
    },
    {
      "mnemonic": "VREDSUM.VS",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Reduction Sum",
      "summary": "Reduces a vector to a scalar by summing all elements.",
      "syntax": "VREDSUM.VS vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPMVV",
        "binary_pattern": "000000 | vm | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "000000",
            "clean": "000000"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest Scalar"
        },
        {
          "name": "vs2",
          "desc": "Source Vector"
        },
        {
          "name": "vs1",
          "desc": "Start Scalar"
        }
      ],
      "pseudocode": "vd[0] = vs1[0] + sum(vs2[*]);",
      "slug": "vredsum_vs",
      "rel_url": "risc-v/vredsum_vs/",
      "linked_summary": "Reduces a vector to a scalar by summing all elements.",
      "linked_pseudocode": "vd[0] = vs1[0] + sum(vs2[*]);"
    },
    {
      "mnemonic": "VLSE32.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Load Strided Element (32-bit)",
      "summary": "Loads elements from memory with a fixed stride.",
      "syntax": "VLSE32.V vd, (rs1), rs2, vm",
      "encoding": {
        "format": "VL-Type",
        "binary_pattern": "000110 | mop | vm | rs1 | 110 | vd | 0000111",
        "hex_opcode": "0x07",
        "visual_parts": [
          {
            "raw": "000110",
            "clean": "000110"
          },
          {
            "raw": "mop",
            "clean": "mop"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "110",
            "clean": "110"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "0000111",
            "clean": "0000111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Vector Dest"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        },
        {
          "name": "rs2",
          "desc": "Stride"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = M[rs1 + i * rs2];",
      "slug": "vlse32_v",
      "rel_url": "risc-v/vlse32_v/",
      "linked_summary": "Loads elements from memory with a fixed stride.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = M[rs1 + i * rs2];"
    },
    {
      "mnemonic": "VSSE32.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Store Strided Element (32-bit)",
      "summary": "Stores elements to memory with a fixed stride.",
      "syntax": "VSSE32.V vs3, (rs1), rs2, vm",
      "encoding": {
        "format": "VS-Type",
        "binary_pattern": "000110 | mop | vm | rs1 | 110 | vs3 | 0100111",
        "hex_opcode": "0x27",
        "visual_parts": [
          {
            "raw": "000110",
            "clean": "000110"
          },
          {
            "raw": "mop",
            "clean": "mop"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "110",
            "clean": "110"
          },
          {
            "raw": "vs3",
            "clean": "vs3"
          },
          {
            "raw": "0100111",
            "clean": "0100111"
          }
        ]
      },
      "operands": [
        {
          "name": "vs3",
          "desc": "Vector Source"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        },
        {
          "name": "rs2",
          "desc": "Stride"
        }
      ],
      "pseudocode": "foreach(i < vl): M[rs1 + i * rs2] = vs3[i];",
      "slug": "vsse32_v",
      "rel_url": "risc-v/vsse32_v/",
      "linked_summary": "Stores elements to memory with a fixed stride.",
      "linked_pseudocode": "foreach(i < vl): M[rs1 + i * rs2] = vs3[i];"
    },
    {
      "mnemonic": "VLUXEI32.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Load Unordered Indexed (32-bit indices)",
      "summary": "Loads elements from memory using a vector of indices (Gather).",
      "syntax": "VLUXEI32.V vd, (rs1), vs2, vm",
      "encoding": {
        "format": "VL-Type",
        "binary_pattern": "000111 | mop | vm | rs1 | 110 | vd | 0000111",
        "hex_opcode": "0x07",
        "visual_parts": [
          {
            "raw": "000111",
            "clean": "000111"
          },
          {
            "raw": "mop",
            "clean": "mop"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "110",
            "clean": "110"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "0000111",
            "clean": "0000111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Vector Dest"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        },
        {
          "name": "vs2",
          "desc": "Vector Indices"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = M[rs1 + vs2[i]];",
      "slug": "vluxei32_v",
      "rel_url": "risc-v/vluxei32_v/",
      "linked_summary": "Loads elements from memory using a vector of indices (Gather).",
      "linked_pseudocode": "foreach(i < vl): vd[i] = M[rs1 + vs2[i]];"
    },
    {
      "mnemonic": "VSUXEI32.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Store Unordered Indexed (32-bit indices)",
      "summary": "Stores elements to memory using a vector of indices (Scatter).",
      "syntax": "VSUXEI32.V vs3, (rs1), vs2, vm",
      "encoding": {
        "format": "VS-Type",
        "binary_pattern": "000111 | mop | vm | rs1 | 110 | vs3 | 0100111",
        "hex_opcode": "0x27",
        "visual_parts": [
          {
            "raw": "000111",
            "clean": "000111"
          },
          {
            "raw": "mop",
            "clean": "mop"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "110",
            "clean": "110"
          },
          {
            "raw": "vs3",
            "clean": "vs3"
          },
          {
            "raw": "0100111",
            "clean": "0100111"
          }
        ]
      },
      "operands": [
        {
          "name": "vs3",
          "desc": "Vector Source"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        },
        {
          "name": "vs2",
          "desc": "Vector Indices"
        }
      ],
      "pseudocode": "foreach(i < vl): M[rs1 + vs2[i]] = vs3[i];",
      "slug": "vsuxei32_v",
      "rel_url": "risc-v/vsuxei32_v/",
      "linked_summary": "Stores elements to memory using a vector of indices (Scatter).",
      "linked_pseudocode": "foreach(i < vl): M[rs1 + vs2[i]] = vs3[i];"
    },
    {
      "mnemonic": "VSLIDEUP.VX",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Slide Up",
      "summary": "Moves elements up by a scalar amount (vd[i] = vs2[i - rs1]).",
      "syntax": "VSLIDEUP.VX vd, vs2, rs1, vm",
      "encoding": {
        "format": "OPIVX",
        "binary_pattern": "001110 | vm | vs2 | rs1 | 100 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "001110",
            "clean": "001110"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Source Vector"
        },
        {
          "name": "rs1",
          "desc": "Shift Amount"
        }
      ],
      "pseudocode": "foreach(i): if i < rs1: vd[i] = vd[i] (unchanged); else: vd[i] = vs2[i - rs1];",
      "slug": "vslideup_vx",
      "rel_url": "risc-v/vslideup_vx/",
      "linked_summary": "Moves elements up by a scalar amount (vd[i] = vs2[i - rs1]).",
      "linked_pseudocode": "foreach(i): if i < rs1: vd[i] = vd[i] (unchanged); else: vd[i] = vs2[i - rs1];"
    },
    {
      "mnemonic": "VSLIDEDOWN.VX",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Slide Down",
      "summary": "Moves elements down by a scalar amount (vd[i] = vs2[i + rs1]).",
      "syntax": "VSLIDEDOWN.VX vd, vs2, rs1, vm",
      "encoding": {
        "format": "OPIVX",
        "binary_pattern": "001111 | vm | vs2 | rs1 | 100 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "001111",
            "clean": "001111"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Source Vector"
        },
        {
          "name": "rs1",
          "desc": "Shift Amount"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs2[i + rs1];",
      "slug": "vslidedown_vx",
      "rel_url": "risc-v/vslidedown_vx/",
      "linked_summary": "Moves elements down by a scalar amount (vd[i] = vs2[i + rs1]).",
      "linked_pseudocode": "foreach(i < vl): vd[i] = vs2[i + rs1];"
    },
    {
      "mnemonic": "VMNAND.MM",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Mask NAND",
      "summary": "Performs bitwise NAND on vector mask registers. Used to invert masks (NOT).",
      "syntax": "VMNAND.MM vd, vs2, vs1",
      "encoding": {
        "format": "OPMVV",
        "binary_pattern": "011101 | 1 | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "011101",
            "clean": "011101"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest Mask"
        },
        {
          "name": "vs2",
          "desc": "Src 2 Mask"
        },
        {
          "name": "vs1",
          "desc": "Src 1 Mask"
        }
      ],
      "pseudocode": "vd = ~(vs1 & vs2);",
      "slug": "vmnand_mm",
      "rel_url": "risc-v/vmnand_mm/",
      "linked_summary": "Performs bitwise NAND on vector mask registers. Used to invert masks (<a href=\"../../risc-v/not/\">NOT</a>).",
      "linked_pseudocode": "vd = ~(vs1 & vs2);"
    },
    {
      "mnemonic": "CSRRC",
      "architecture": "RISC-V",
      "extension": "Zicsr",
      "full_name": "Control Status Register Read and Clear",
      "summary": "Reads the old value of the CSR, then clears bits in the CSR based on the mask in rs1.",
      "syntax": "CSRRC rd, csr, rs1",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "csr | rs1 | 011 | rd | 1110011",
        "hex_opcode": "0x73",
        "visual_parts": [
          {
            "raw": "csr",
            "clean": "csr"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1110011",
            "clean": "1110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Old Value)"
        },
        {
          "name": "csr",
          "desc": "CSR Address"
        },
        {
          "name": "rs1",
          "desc": "Bit Mask"
        }
      ],
      "pseudocode": "t = CSRs[csr]; CSRs[csr] = t & ~R[rs1]; R[rd] = t;",
      "example": "CSRRC x10, sstatus, x5",
      "example_note": "Clears bits in 'sstatus' where x5 is 1.",
      "slug": "csrrc",
      "rel_url": "risc-v/csrrc/",
      "linked_summary": "Reads the old value of the CSR, then clears bits <a href=\"../../x86/in/\">in</a> the CSR based on the mask <a href=\"../../x86/in/\">in</a> rs1.",
      "linked_pseudocode": "t = CSRs[csr]; CSRs[csr] = t & ~R[rs1]; R[rd] = t;"
    },
    {
      "mnemonic": "CSRRWI",
      "architecture": "RISC-V",
      "extension": "Zicsr",
      "full_name": "CSR Read/Write Immediate",
      "summary": "Updates a CSR using a 5-bit unsigned immediate (zimm) instead of a register.",
      "syntax": "CSRRWI rd, csr, uimm",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "csr | uimm | 101 | rd | 1110011",
        "hex_opcode": "0x73",
        "visual_parts": [
          {
            "raw": "csr",
            "clean": "csr"
          },
          {
            "raw": "uimm",
            "clean": "uimm"
          },
          {
            "raw": "101",
            "clean": "101"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1110011",
            "clean": "1110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "csr",
          "desc": "CSR Address"
        },
        {
          "name": "uimm",
          "desc": "5-bit Unsigned Imm"
        }
      ],
      "pseudocode": "t = CSRs[csr]; CSRs[csr] = zext(uimm); R[rd] = t;",
      "example": "CSRRWI x0, 0x001, 0",
      "example_note": "Writes 0 to CSR 0x001.",
      "slug": "csrrwi",
      "rel_url": "risc-v/csrrwi/",
      "linked_summary": "Updates a CSR using a 5-<a href=\"../../armv8-a/bit/\">bit</a> unsigned immediate (zimm) instead of a register.",
      "linked_pseudocode": "t = CSRs[csr]; CSRs[csr] = zext(uimm); R[rd] = t;"
    },
    {
      "mnemonic": "CSRRSI",
      "architecture": "RISC-V",
      "extension": "Zicsr",
      "full_name": "CSR Read and Set Immediate",
      "summary": "Sets bits in a CSR using a 5-bit unsigned immediate.",
      "syntax": "CSRRSI rd, csr, uimm",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "csr | uimm | 110 | rd | 1110011",
        "hex_opcode": "0x73",
        "visual_parts": [
          {
            "raw": "csr",
            "clean": "csr"
          },
          {
            "raw": "uimm",
            "clean": "uimm"
          },
          {
            "raw": "110",
            "clean": "110"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1110011",
            "clean": "1110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "csr",
          "desc": "CSR Address"
        },
        {
          "name": "uimm",
          "desc": "Bit Mask"
        }
      ],
      "pseudocode": "t = CSRs[csr]; CSRs[csr] = t | zext(uimm); R[rd] = t;",
      "example": "CSRRSI x0, sstatus, 1",
      "example_note": "Sets bit 0 of sstatus.",
      "slug": "csrrsi",
      "rel_url": "risc-v/csrrsi/",
      "linked_summary": "Sets bits <a href=\"../../x86/in/\">in</a> a CSR using a 5-<a href=\"../../armv8-a/bit/\">bit</a> unsigned immediate.",
      "linked_pseudocode": "t = CSRs[csr]; CSRs[csr] = t | zext(uimm); R[rd] = t;"
    },
    {
      "mnemonic": "CSRRCI",
      "architecture": "RISC-V",
      "extension": "Zicsr",
      "full_name": "CSR Read and Clear Immediate",
      "summary": "Clears bits in a CSR using a 5-bit unsigned immediate.",
      "syntax": "CSRRCI rd, csr, uimm",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "csr | uimm | 111 | rd | 1110011",
        "hex_opcode": "0x73",
        "visual_parts": [
          {
            "raw": "csr",
            "clean": "csr"
          },
          {
            "raw": "uimm",
            "clean": "uimm"
          },
          {
            "raw": "111",
            "clean": "111"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1110011",
            "clean": "1110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "csr",
          "desc": "CSR Address"
        },
        {
          "name": "uimm",
          "desc": "Bit Mask"
        }
      ],
      "pseudocode": "t = CSRs[csr]; CSRs[csr] = t & ~zext(uimm); R[rd] = t;",
      "example": "CSRRCI x0, sstatus, 2",
      "example_note": "Clears bit 1 of sstatus.",
      "slug": "csrrci",
      "rel_url": "risc-v/csrrci/",
      "linked_summary": "Clears bits <a href=\"../../x86/in/\">in</a> a CSR using a 5-<a href=\"../../armv8-a/bit/\">bit</a> unsigned immediate.",
      "linked_pseudocode": "t = CSRs[csr]; CSRs[csr] = t & ~zext(uimm); R[rd] = t;"
    },
    {
      "mnemonic": "FLD",
      "architecture": "RISC-V",
      "extension": "D (Double)",
      "full_name": "Float Load Double",
      "summary": "Loads a 64-bit double-precision floating-point value from memory.",
      "syntax": "FLD rd, offset(rs1)",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "offset | rs1 | 011 | rd | 0000111",
        "hex_opcode": "0x07",
        "visual_parts": [
          {
            "raw": "offset",
            "clean": "offset"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0000111",
            "clean": "0000111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Float Reg)"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "F[rd] = M[R[rs1] + sext(offset)][63:0];",
      "example": "FLD f1, 8(x10)",
      "example_note": "Loads double from address x10+8.",
      "slug": "fld",
      "rel_url": "risc-v/fld/",
      "linked_summary": "Loads a 64-<a href=\"../../armv8-a/bit/\">bit</a> double-precision floating-point value from memory.",
      "linked_pseudocode": "F[rd] = M[R[rs1] + sext(offset)][63:0];"
    },
    {
      "mnemonic": "FSD",
      "architecture": "RISC-V",
      "extension": "D (Double)",
      "full_name": "Float Store Double",
      "summary": "Stores a 64-bit double-precision floating-point value to memory.",
      "syntax": "FSD rs2, offset(rs1)",
      "encoding": {
        "format": "S-Type",
        "binary_pattern": "imm[11:5] | rs2 | rs1 | 011 | imm[4:0] | 0100111",
        "hex_opcode": "0x27",
        "visual_parts": [
          {
            "raw": "imm[11:5]",
            "clean": "imm"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "imm[4:0]",
            "clean": "imm"
          },
          {
            "raw": "0100111",
            "clean": "0100111"
          }
        ]
      },
      "operands": [
        {
          "name": "rs2",
          "desc": "Src (Float Reg)"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "M[R[rs1] + sext(offset)][63:0] = F[rs2];",
      "example": "FSD f1, 16(x2)",
      "example_note": "Stores f1 to stack+16.",
      "slug": "fsd",
      "rel_url": "risc-v/fsd/",
      "linked_summary": "Stores a 64-<a href=\"../../armv8-a/bit/\">bit</a> double-precision floating-point value to memory.",
      "linked_pseudocode": "M[R[rs1] + sext(offset)][63:0] = F[rs2];"
    },
    {
      "mnemonic": "FADD.D",
      "architecture": "RISC-V",
      "extension": "D (Double)",
      "full_name": "Float Add Double",
      "summary": "Performs double-precision floating-point addition.",
      "syntax": "FADD.D rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000001 | rs2 | rs1 | 000 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0000001",
            "clean": "0000001"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        }
      ],
      "pseudocode": "F[rd] = F[rs1] + F[rs2];",
      "example": "FADD.D f0, f1, f2",
      "example_note": "64-bit float addition.",
      "slug": "fadd_d",
      "rel_url": "risc-v/fadd_d/",
      "linked_summary": "Performs double-precision floating-point addition.",
      "linked_pseudocode": "F[rd] = F[rs1] + F[rs2];"
    },
    {
      "mnemonic": "FSUB.D",
      "architecture": "RISC-V",
      "extension": "D (Double)",
      "full_name": "Float Subtract Double",
      "summary": "Performs double-precision floating-point subtraction.",
      "syntax": "FSUB.D rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000101 | rs2 | rs1 | 000 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0000101",
            "clean": "0000101"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        }
      ],
      "pseudocode": "F[rd] = F[rs1] - F[rs2];",
      "example": "FSUB.D f0, f1, f2",
      "example_note": "64-bit float subtraction.",
      "slug": "fsub_d",
      "rel_url": "risc-v/fsub_d/",
      "linked_summary": "Performs double-precision floating-point subtraction.",
      "linked_pseudocode": "F[rd] = F[rs1] - F[rs2];"
    },
    {
      "mnemonic": "FMUL.D",
      "architecture": "RISC-V",
      "extension": "D (Double)",
      "full_name": "Float Multiply Double",
      "summary": "Performs double-precision floating-point multiplication.",
      "syntax": "FMUL.D rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0001001 | rs2 | rs1 | 000 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0001001",
            "clean": "0001001"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        }
      ],
      "pseudocode": "F[rd] = F[rs1] * F[rs2];",
      "example": "FMUL.D f0, f1, f2",
      "example_note": "64-bit float multiplication.",
      "slug": "fmul_d",
      "rel_url": "risc-v/fmul_d/",
      "linked_summary": "Performs double-precision floating-point multiplication.",
      "linked_pseudocode": "F[rd] = F[rs1] * F[rs2];"
    },
    {
      "mnemonic": "FDIV.D",
      "architecture": "RISC-V",
      "extension": "D (Double)",
      "full_name": "Float Divide Double",
      "summary": "Performs double-precision floating-point division.",
      "syntax": "FDIV.D rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0001101 | rs2 | rs1 | 000 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0001101",
            "clean": "0001101"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Dividend"
        },
        {
          "name": "rs2",
          "desc": "Divisor"
        }
      ],
      "pseudocode": "F[rd] = F[rs1] / F[rs2];",
      "example": "FDIV.D f0, f1, f2",
      "example_note": "64-bit float division.",
      "slug": "fdiv_d",
      "rel_url": "risc-v/fdiv_d/",
      "linked_summary": "Performs double-precision floating-point division.",
      "linked_pseudocode": "F[rd] = F[rs1] / F[rs2];"
    },
    {
      "mnemonic": "AMOOR.W",
      "architecture": "RISC-V",
      "extension": "A (Atomic)",
      "full_name": "Atomic OR Word",
      "summary": "Atomically performs bitwise OR on a word in memory.",
      "syntax": "AMOOR.W rd, rs2, (rs1)",
      "encoding": {
        "format": "R-Type (Atomic)",
        "binary_pattern": "01000 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
        "hex_opcode": "0x2F",
        "visual_parts": [
          {
            "raw": "01000",
            "clean": "01000"
          },
          {
            "raw": "aq",
            "clean": "aq"
          },
          {
            "raw": "rl",
            "clean": "rl"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0101111",
            "clean": "0101111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Old Value)"
        },
        {
          "name": "rs2",
          "desc": "Operand"
        },
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp | R[rs2]; R[rd] = temp;",
      "example": "AMOOR.W x10, x11, (x12)",
      "example_note": "Atomic OR.",
      "slug": "amoor_w",
      "rel_url": "risc-v/amoor_w/",
      "linked_summary": "Atomically performs bitwise <a href=\"../../risc-v/or/\">OR</a> on a word <a href=\"../../x86/in/\">in</a> memory.",
      "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp | R[rs2]; R[rd] = temp;"
    },
    {
      "mnemonic": "AMOXOR.W",
      "architecture": "RISC-V",
      "extension": "A (Atomic)",
      "full_name": "Atomic XOR Word",
      "summary": "Atomically performs bitwise XOR on a word in memory.",
      "syntax": "AMOXOR.W rd, rs2, (rs1)",
      "encoding": {
        "format": "R-Type (Atomic)",
        "binary_pattern": "00100 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
        "hex_opcode": "0x2F",
        "visual_parts": [
          {
            "raw": "00100",
            "clean": "00100"
          },
          {
            "raw": "aq",
            "clean": "aq"
          },
          {
            "raw": "rl",
            "clean": "rl"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0101111",
            "clean": "0101111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Old Value)"
        },
        {
          "name": "rs2",
          "desc": "Operand"
        },
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp ^ R[rs2]; R[rd] = temp;",
      "example": "AMOXOR.W x10, x11, (x12)",
      "example_note": "Atomic XOR.",
      "slug": "amoxor_w",
      "rel_url": "risc-v/amoxor_w/",
      "linked_summary": "Atomically performs bitwise <a href=\"../../risc-v/xor/\">XOR</a> on a word <a href=\"../../x86/in/\">in</a> memory.",
      "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp ^ R[rs2]; R[rd] = temp;"
    },
    {
      "mnemonic": "AMOMAX.W",
      "architecture": "RISC-V",
      "extension": "A (Atomic)",
      "full_name": "Atomic Max Word",
      "summary": "Atomically updates memory with the maximum of the memory value and register value (Signed).",
      "syntax": "AMOMAX.W rd, rs2, (rs1)",
      "encoding": {
        "format": "R-Type (Atomic)",
        "binary_pattern": "10100 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
        "hex_opcode": "0x2F",
        "visual_parts": [
          {
            "raw": "10100",
            "clean": "10100"
          },
          {
            "raw": "aq",
            "clean": "aq"
          },
          {
            "raw": "rl",
            "clean": "rl"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0101111",
            "clean": "0101111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Old Value)"
        },
        {
          "name": "rs2",
          "desc": "Operand"
        },
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = max(temp, R[rs2]); R[rd] = temp;",
      "example": "AMOMAX.W x10, x11, (x12)",
      "example_note": "Atomic Signed Max.",
      "slug": "amomax_w",
      "rel_url": "risc-v/amomax_w/",
      "linked_summary": "Atomically updates memory with the maximum of the memory value <a href=\"../../armv8-a/and_6/\">and</a> register value (Signed).",
      "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = max(temp, R[rs2]); R[rd] = temp;"
    },
    {
      "mnemonic": "AMOMIN.W",
      "architecture": "RISC-V",
      "extension": "A (Atomic)",
      "full_name": "Atomic Min Word",
      "summary": "Atomically updates memory with the minimum of the memory value and register value (Signed).",
      "syntax": "AMOMIN.W rd, rs2, (rs1)",
      "encoding": {
        "format": "R-Type (Atomic)",
        "binary_pattern": "10000 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
        "hex_opcode": "0x2F",
        "visual_parts": [
          {
            "raw": "10000",
            "clean": "10000"
          },
          {
            "raw": "aq",
            "clean": "aq"
          },
          {
            "raw": "rl",
            "clean": "rl"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0101111",
            "clean": "0101111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Old Value)"
        },
        {
          "name": "rs2",
          "desc": "Operand"
        },
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = min(temp, R[rs2]); R[rd] = temp;",
      "example": "AMOMIN.W x10, x11, (x12)",
      "example_note": "Atomic Signed Min.",
      "slug": "amomin_w",
      "rel_url": "risc-v/amomin_w/",
      "linked_summary": "Atomically updates memory with the minimum of the memory value <a href=\"../../armv8-a/and_6/\">and</a> register value (Signed).",
      "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = min(temp, R[rs2]); R[rd] = temp;"
    },
    {
      "mnemonic": "URET",
      "architecture": "RISC-V",
      "extension": "Privileged",
      "full_name": "User Return",
      "summary": "Returns from a user-mode trap handler (requires N extension).",
      "syntax": "URET",
      "encoding": {
        "format": "R-Type (System)",
        "binary_pattern": "0000000 | 00010 | 00000 | 000 | 00000 | 1110011",
        "hex_opcode": "0x73",
        "visual_parts": [
          {
            "raw": "0000000",
            "clean": "0000000"
          },
          {
            "raw": "00010",
            "clean": "00010"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "1110011",
            "clean": "1110011"
          }
        ]
      },
      "operands": [],
      "pseudocode": "PC = UEPC; Priv = U; UIE = UPIE;",
      "example": "URET",
      "example_note": "Return from User-mode exception.",
      "slug": "uret",
      "rel_url": "risc-v/uret/",
      "linked_summary": "Returns from a user-mode <a href=\"../../powerisa/trap/\">trap</a> handler (requires N extension).",
      "linked_pseudocode": "PC = UEPC; Priv = U; UIE = UPIE;"
    },
    {
      "mnemonic": "VLE8.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Load Element (8-bit)",
      "summary": "Loads a vector of 8-bit elements from memory.",
      "syntax": "VLE8.V vd, (rs1), vm",
      "encoding": {
        "format": "VL-Type",
        "binary_pattern": "000000 | mop | vm | rs1 | 000 | vd | 0000111",
        "hex_opcode": "0x07",
        "visual_parts": [
          {
            "raw": "000000",
            "clean": "000000"
          },
          {
            "raw": "mop",
            "clean": "mop"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "0000111",
            "clean": "0000111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = M[rs1 + i];",
      "slug": "vle8_v",
      "rel_url": "risc-v/vle8_v/",
      "linked_summary": "Loads a vector of 8-<a href=\"../../armv8-a/bit/\">bit</a> elements from memory.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = M[rs1 + i];"
    },
    {
      "mnemonic": "VLE16.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Load Element (16-bit)",
      "summary": "Loads a vector of 16-bit elements from memory.",
      "syntax": "VLE16.V vd, (rs1), vm",
      "encoding": {
        "format": "VL-Type",
        "binary_pattern": "000000 | mop | vm | rs1 | 101 | vd | 0000111",
        "hex_opcode": "0x07",
        "visual_parts": [
          {
            "raw": "000000",
            "clean": "000000"
          },
          {
            "raw": "mop",
            "clean": "mop"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "101",
            "clean": "101"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "0000111",
            "clean": "0000111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = M[rs1 + i*2];",
      "slug": "vle16_v",
      "rel_url": "risc-v/vle16_v/",
      "linked_summary": "Loads a vector of 16-<a href=\"../../armv8-a/bit/\">bit</a> elements from memory.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = M[rs1 + i*2];"
    },
    {
      "mnemonic": "VLE64.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Load Element (64-bit)",
      "summary": "Loads a vector of 64-bit elements from memory.",
      "syntax": "VLE64.V vd, (rs1), vm",
      "encoding": {
        "format": "VL-Type",
        "binary_pattern": "000000 | mop | vm | rs1 | 111 | vd | 0000111",
        "hex_opcode": "0x07",
        "visual_parts": [
          {
            "raw": "000000",
            "clean": "000000"
          },
          {
            "raw": "mop",
            "clean": "mop"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "111",
            "clean": "111"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "0000111",
            "clean": "0000111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = M[rs1 + i*8];",
      "slug": "vle64_v",
      "rel_url": "risc-v/vle64_v/",
      "linked_summary": "Loads a vector of 64-<a href=\"../../armv8-a/bit/\">bit</a> elements from memory.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = M[rs1 + i*8];"
    },
    {
      "mnemonic": "VSE8.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Store Element (8-bit)",
      "summary": "Stores a vector of 8-bit elements to memory.",
      "syntax": "VSE8.V vs3, (rs1), vm",
      "encoding": {
        "format": "VS-Type",
        "binary_pattern": "000000 | mop | vm | rs1 | 000 | vs3 | 0100111",
        "hex_opcode": "0x27",
        "visual_parts": [
          {
            "raw": "000000",
            "clean": "000000"
          },
          {
            "raw": "mop",
            "clean": "mop"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vs3",
            "clean": "vs3"
          },
          {
            "raw": "0100111",
            "clean": "0100111"
          }
        ]
      },
      "operands": [
        {
          "name": "vs3",
          "desc": "Source"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        }
      ],
      "pseudocode": "foreach(i < vl): M[rs1 + i] = vs3[i];",
      "slug": "vse8_v",
      "rel_url": "risc-v/vse8_v/",
      "linked_summary": "Stores a vector of 8-<a href=\"../../armv8-a/bit/\">bit</a> elements to memory.",
      "linked_pseudocode": "foreach(i < vl): M[rs1 + i] = vs3[i];"
    },
    {
      "mnemonic": "VSE16.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Store Element (16-bit)",
      "summary": "Stores a vector of 16-bit elements to memory.",
      "syntax": "VSE16.V vs3, (rs1), vm",
      "encoding": {
        "format": "VS-Type",
        "binary_pattern": "000000 | mop | vm | rs1 | 101 | vs3 | 0100111",
        "hex_opcode": "0x27",
        "visual_parts": [
          {
            "raw": "000000",
            "clean": "000000"
          },
          {
            "raw": "mop",
            "clean": "mop"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "101",
            "clean": "101"
          },
          {
            "raw": "vs3",
            "clean": "vs3"
          },
          {
            "raw": "0100111",
            "clean": "0100111"
          }
        ]
      },
      "operands": [
        {
          "name": "vs3",
          "desc": "Source"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        }
      ],
      "pseudocode": "foreach(i < vl): M[rs1 + i*2] = vs3[i];",
      "slug": "vse16_v",
      "rel_url": "risc-v/vse16_v/",
      "linked_summary": "Stores a vector of 16-<a href=\"../../armv8-a/bit/\">bit</a> elements to memory.",
      "linked_pseudocode": "foreach(i < vl): M[rs1 + i*2] = vs3[i];"
    },
    {
      "mnemonic": "VSE64.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Store Element (64-bit)",
      "summary": "Stores a vector of 64-bit elements to memory.",
      "syntax": "VSE64.V vs3, (rs1), vm",
      "encoding": {
        "format": "VS-Type",
        "binary_pattern": "000000 | mop | vm | rs1 | 111 | vs3 | 0100111",
        "hex_opcode": "0x27",
        "visual_parts": [
          {
            "raw": "000000",
            "clean": "000000"
          },
          {
            "raw": "mop",
            "clean": "mop"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "111",
            "clean": "111"
          },
          {
            "raw": "vs3",
            "clean": "vs3"
          },
          {
            "raw": "0100111",
            "clean": "0100111"
          }
        ]
      },
      "operands": [
        {
          "name": "vs3",
          "desc": "Source"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        }
      ],
      "pseudocode": "foreach(i < vl): M[rs1 + i*8] = vs3[i];",
      "slug": "vse64_v",
      "rel_url": "risc-v/vse64_v/",
      "linked_summary": "Stores a vector of 64-<a href=\"../../armv8-a/bit/\">bit</a> elements to memory.",
      "linked_pseudocode": "foreach(i < vl): M[rs1 + i*8] = vs3[i];"
    },
    {
      "mnemonic": "VMV1R.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Move 1 Register (Whole)",
      "summary": "Moves a single vector register to another, ignoring VL and VTYPE (used for spilling).",
      "syntax": "VMV1R.V vd, vs2",
      "encoding": {
        "format": "OPVI",
        "binary_pattern": "100111 | 1 | vs2 | 00000 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "100111",
            "clean": "100111"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Source"
        }
      ],
      "pseudocode": "vd = vs2; // Copies entire register content",
      "slug": "vmv1r_v",
      "rel_url": "risc-v/vmv1r_v/",
      "linked_summary": "Moves a single vector register to another, ignoring VL <a href=\"../../armv8-a/and_6/\">and</a> VTYPE (used for spilling).",
      "linked_pseudocode": "vd = vs2; // Copies entire register content"
    },
    {
      "mnemonic": "VMV2R.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Move 2 Registers (Whole)",
      "summary": "Moves 2 consecutive vector registers, ignoring VL and VTYPE.",
      "syntax": "VMV2R.V vd, vs2",
      "encoding": {
        "format": "OPVI",
        "binary_pattern": "100111 | 1 | vs2 | 00001 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "100111",
            "clean": "100111"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "00001",
            "clean": "00001"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest Group"
        },
        {
          "name": "vs2",
          "desc": "Source Group"
        }
      ],
      "pseudocode": "vd[0:1] = vs2[0:1];",
      "slug": "vmv2r_v",
      "rel_url": "risc-v/vmv2r_v/",
      "linked_summary": "Moves 2 consecutive vector registers, ignoring VL <a href=\"../../armv8-a/and_6/\">and</a> VTYPE.",
      "linked_pseudocode": "vd[0:1] = vs2[0:1];"
    },
    {
      "mnemonic": "VMV4R.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Move 4 Registers (Whole)",
      "summary": "Moves 4 consecutive vector registers, ignoring VL and VTYPE.",
      "syntax": "VMV4R.V vd, vs2",
      "encoding": {
        "format": "OPVI",
        "binary_pattern": "100111 | 1 | vs2 | 00011 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "100111",
            "clean": "100111"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "00011",
            "clean": "00011"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest Group"
        },
        {
          "name": "vs2",
          "desc": "Source Group"
        }
      ],
      "pseudocode": "vd[0:3] = vs2[0:3];",
      "slug": "vmv4r_v",
      "rel_url": "risc-v/vmv4r_v/",
      "linked_summary": "Moves 4 consecutive vector registers, ignoring VL <a href=\"../../armv8-a/and_6/\">and</a> VTYPE.",
      "linked_pseudocode": "vd[0:3] = vs2[0:3];"
    },
    {
      "mnemonic": "VMV8R.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Move 8 Registers (Whole)",
      "summary": "Moves 8 consecutive vector registers, ignoring VL and VTYPE.",
      "syntax": "VMV8R.V vd, vs2",
      "encoding": {
        "format": "OPVI",
        "binary_pattern": "100111 | 1 | vs2 | 00111 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "100111",
            "clean": "100111"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "00111",
            "clean": "00111"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest Group"
        },
        {
          "name": "vs2",
          "desc": "Source Group"
        }
      ],
      "pseudocode": "vd[0:7] = vs2[0:7];",
      "slug": "vmv8r_v",
      "rel_url": "risc-v/vmv8r_v/",
      "linked_summary": "Moves 8 consecutive vector registers, ignoring VL <a href=\"../../armv8-a/and_6/\">and</a> VTYPE.",
      "linked_pseudocode": "vd[0:7] = vs2[0:7];"
    },
    {
      "mnemonic": "VSETIVLI",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Set VL Immediate",
      "summary": "Sets vector length (VL) and type (VTYPE) using a 5-bit immediate for the requested length.",
      "syntax": "VSETIVLI rd, uimm, vtypei",
      "encoding": {
        "format": "V-Type",
        "binary_pattern": "11 | zimm[10:0] | uimm | 111 | rd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "11",
            "clean": "11"
          },
          {
            "raw": "zimm[10:0]",
            "clean": "zimm"
          },
          {
            "raw": "uimm",
            "clean": "uimm"
          },
          {
            "raw": "111",
            "clean": "111"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (New VL)"
        },
        {
          "name": "uimm",
          "desc": "Req VL (Imm)"
        },
        {
          "name": "vtypei",
          "desc": "Config"
        }
      ],
      "pseudocode": "vl = set_config(uimm, vtypei); R[rd] = vl;",
      "slug": "vsetivli",
      "rel_url": "risc-v/vsetivli/",
      "linked_summary": "Sets vector length (VL) <a href=\"../../armv8-a/and_6/\">and</a> type (VTYPE) using a 5-<a href=\"../../armv8-a/bit/\">bit</a> immediate for the requested length.",
      "linked_pseudocode": "vl = set_config(uimm, vtypei); R[rd] = vl;"
    },
    {
      "mnemonic": "VLM.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Load Mask",
      "summary": "Loads a vector mask register from memory.",
      "syntax": "VLM.V vd, (rs1)",
      "encoding": {
        "format": "VL-Type",
        "binary_pattern": "000000 | 01011 | 1 | rs1 | 000 | vd | 0000111",
        "hex_opcode": "0x07",
        "visual_parts": [
          {
            "raw": "000000",
            "clean": "000000"
          },
          {
            "raw": "01011",
            "clean": "01011"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "0000111",
            "clean": "0000111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest Mask"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        }
      ],
      "pseudocode": "vd = LoadMask(rs1);",
      "slug": "vlm_v",
      "rel_url": "risc-v/vlm_v/",
      "linked_summary": "Loads a vector mask register from memory.",
      "linked_pseudocode": "vd = LoadMask(rs1);"
    },
    {
      "mnemonic": "VSM.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Store Mask",
      "summary": "Stores a vector mask register to memory.",
      "syntax": "VSM.V vs3, (rs1)",
      "encoding": {
        "format": "VS-Type",
        "binary_pattern": "000000 | 01011 | 1 | rs1 | 000 | vs3 | 0100111",
        "hex_opcode": "0x27",
        "visual_parts": [
          {
            "raw": "000000",
            "clean": "000000"
          },
          {
            "raw": "01011",
            "clean": "01011"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vs3",
            "clean": "vs3"
          },
          {
            "raw": "0100111",
            "clean": "0100111"
          }
        ]
      },
      "operands": [
        {
          "name": "vs3",
          "desc": "Src Mask"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        }
      ],
      "pseudocode": "StoreMask(rs1, vs3);",
      "slug": "vsm_v",
      "rel_url": "risc-v/vsm_v/",
      "linked_summary": "Stores a vector mask register to memory.",
      "linked_pseudocode": "StoreMask(rs1, vs3);"
    },
    {
      "mnemonic": "AMOMINU.D",
      "architecture": "RISC-V",
      "extension": "A (Atomic)",
      "full_name": "Atomic Min Unsigned Doubleword",
      "summary": "Atomically updates memory with the minimum of the memory value and register value (Unsigned 64-bit).",
      "syntax": "AMOMINU.D rd, rs2, (rs1)",
      "encoding": {
        "format": "R-Type (Atomic)",
        "binary_pattern": "11000 | aq | rl | rs2 | rs1 | 011 | rd | 0101111",
        "hex_opcode": "0x2F",
        "visual_parts": [
          {
            "raw": "11000",
            "clean": "11000"
          },
          {
            "raw": "aq",
            "clean": "aq"
          },
          {
            "raw": "rl",
            "clean": "rl"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0101111",
            "clean": "0101111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Old Value)"
        },
        {
          "name": "rs2",
          "desc": "Operand"
        },
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = min_u(temp, R[rs2]); R[rd] = temp;",
      "slug": "amominu_d",
      "rel_url": "risc-v/amominu_d/",
      "linked_summary": "Atomically updates memory with the minimum of the memory value <a href=\"../../armv8-a/and_6/\">and</a> register value (Unsigned 64-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = min_u(temp, R[rs2]); R[rd] = temp;"
    },
    {
      "mnemonic": "AMOMAXU.D",
      "architecture": "RISC-V",
      "extension": "A (Atomic)",
      "full_name": "Atomic Max Unsigned Doubleword",
      "summary": "Atomically updates memory with the maximum of the memory value and register value (Unsigned 64-bit).",
      "syntax": "AMOMAXU.D rd, rs2, (rs1)",
      "encoding": {
        "format": "R-Type (Atomic)",
        "binary_pattern": "11100 | aq | rl | rs2 | rs1 | 011 | rd | 0101111",
        "hex_opcode": "0x2F",
        "visual_parts": [
          {
            "raw": "11100",
            "clean": "11100"
          },
          {
            "raw": "aq",
            "clean": "aq"
          },
          {
            "raw": "rl",
            "clean": "rl"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0101111",
            "clean": "0101111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Old Value)"
        },
        {
          "name": "rs2",
          "desc": "Operand"
        },
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = max_u(temp, R[rs2]); R[rd] = temp;",
      "slug": "amomaxu_d",
      "rel_url": "risc-v/amomaxu_d/",
      "linked_summary": "Atomically updates memory with the maximum of the memory value <a href=\"../../armv8-a/and_6/\">and</a> register value (Unsigned 64-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = max_u(temp, R[rs2]); R[rd] = temp;"
    },
    {
      "mnemonic": "FMSUB.S",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Float Fused Multiply-Subtract (Single)",
      "summary": "Computes (rs1 * rs2) - rs3 with a single rounding.",
      "syntax": "FMSUB.S rd, rs1, rs2, rs3",
      "encoding": {
        "format": "R4-Type",
        "binary_pattern": "rs3 | 00 | rs2 | rs1 | rm | rd | 1000111",
        "hex_opcode": "0x47",
        "visual_parts": [
          {
            "raw": "rs3",
            "clean": "rs3"
          },
          {
            "raw": "00",
            "clean": "00"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1000111",
            "clean": "1000111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        },
        {
          "name": "rs3",
          "desc": "Src 3"
        }
      ],
      "pseudocode": "F[rd] = (F[rs1] * F[rs2]) - F[rs3];",
      "slug": "fmsub_s",
      "rel_url": "risc-v/fmsub_s/",
      "linked_summary": "Computes (rs1 * rs2) - rs3 with a single rounding.",
      "linked_pseudocode": "F[rd] = (F[rs1] * F[rs2]) - F[rs3];"
    },
    {
      "mnemonic": "FNMADD.S",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Float Negated Fused Multiply-Add (Single)",
      "summary": "Computes -(rs1 * rs2) - rs3 with a single rounding.",
      "syntax": "FNMADD.S rd, rs1, rs2, rs3",
      "encoding": {
        "format": "R4-Type",
        "binary_pattern": "rs3 | 00 | rs2 | rs1 | rm | rd | 1001111",
        "hex_opcode": "0x4F",
        "visual_parts": [
          {
            "raw": "rs3",
            "clean": "rs3"
          },
          {
            "raw": "00",
            "clean": "00"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1001111",
            "clean": "1001111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        },
        {
          "name": "rs3",
          "desc": "Src 3"
        }
      ],
      "pseudocode": "F[rd] = -((F[rs1] * F[rs2]) + F[rs3]);",
      "slug": "fnmadd_s",
      "rel_url": "risc-v/fnmadd_s/",
      "linked_summary": "Computes -(rs1 * rs2) - rs3 with a single rounding.",
      "linked_pseudocode": "F[rd] = -((F[rs1] * F[rs2]) + F[rs3]);"
    },
    {
      "mnemonic": "FNMSUB.S",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Float Negated Fused Multiply-Subtract (Single)",
      "summary": "Computes -(rs1 * rs2) + rs3 with a single rounding.",
      "syntax": "FNMSUB.S rd, rs1, rs2, rs3",
      "encoding": {
        "format": "R4-Type",
        "binary_pattern": "rs3 | 00 | rs2 | rs1 | rm | rd | 1001011",
        "hex_opcode": "0x4B",
        "visual_parts": [
          {
            "raw": "rs3",
            "clean": "rs3"
          },
          {
            "raw": "00",
            "clean": "00"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1001011",
            "clean": "1001011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        },
        {
          "name": "rs3",
          "desc": "Src 3"
        }
      ],
      "pseudocode": "F[rd] = -((F[rs1] * F[rs2]) - F[rs3]);",
      "slug": "fnmsub_s",
      "rel_url": "risc-v/fnmsub_s/",
      "linked_summary": "Computes -(rs1 * rs2) + rs3 with a single rounding.",
      "linked_pseudocode": "F[rd] = -((F[rs1] * F[rs2]) - F[rs3]);"
    },
    {
      "mnemonic": "FSQRT.D",
      "architecture": "RISC-V",
      "extension": "D",
      "full_name": "Float Square Root (Double)",
      "summary": "Computes the square root of a double-precision floating-point number.",
      "syntax": "FSQRT.D rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "0101101 | 00000 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0101101",
            "clean": "0101101"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        }
      ],
      "pseudocode": "F[rd] = sqrt(F[rs1]);",
      "slug": "fsqrt_d",
      "rel_url": "risc-v/fsqrt_d/",
      "linked_summary": "Computes the square root of a double-precision floating-point number.",
      "linked_pseudocode": "F[rd] = sqrt(F[rs1]);"
    },
    {
      "mnemonic": "FMIN.D",
      "architecture": "RISC-V",
      "extension": "D",
      "full_name": "Float Minimum (Double)",
      "summary": "Writes the smaller of two double-precision floating-point values to rd.",
      "syntax": "FMIN.D rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0010101 | rs2 | rs1 | 000 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0010101",
            "clean": "0010101"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        }
      ],
      "pseudocode": "F[rd] = min(F[rs1], F[rs2]);",
      "slug": "fmin_d",
      "rel_url": "risc-v/fmin_d/",
      "linked_summary": "Writes the smaller of two double-precision floating-point values to rd.",
      "linked_pseudocode": "F[rd] = min(F[rs1], F[rs2]);"
    },
    {
      "mnemonic": "FMAX.D",
      "architecture": "RISC-V",
      "extension": "D",
      "full_name": "Float Maximum (Double)",
      "summary": "Writes the larger of two double-precision floating-point values to rd.",
      "syntax": "FMAX.D rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0010101 | rs2 | rs1 | 001 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0010101",
            "clean": "0010101"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        }
      ],
      "pseudocode": "F[rd] = max(F[rs1], F[rs2]);",
      "slug": "fmax_d",
      "rel_url": "risc-v/fmax_d/",
      "linked_summary": "Writes the larger of two double-precision floating-point values to rd.",
      "linked_pseudocode": "F[rd] = max(F[rs1], F[rs2]);"
    },
    {
      "mnemonic": "FMSUB.D",
      "architecture": "RISC-V",
      "extension": "D",
      "full_name": "Float Fused Multiply-Subtract (Double)",
      "summary": "Computes (rs1 * rs2) - rs3 with a single rounding (Double).",
      "syntax": "FMSUB.D rd, rs1, rs2, rs3",
      "encoding": {
        "format": "R4-Type",
        "binary_pattern": "rs3 | 01 | rs2 | rs1 | rm | rd | 1000111",
        "hex_opcode": "0x47",
        "visual_parts": [
          {
            "raw": "rs3",
            "clean": "rs3"
          },
          {
            "raw": "01",
            "clean": "01"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1000111",
            "clean": "1000111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        },
        {
          "name": "rs3",
          "desc": "Src 3"
        }
      ],
      "pseudocode": "F[rd] = (F[rs1] * F[rs2]) - F[rs3];",
      "slug": "fmsub_d",
      "rel_url": "risc-v/fmsub_d/",
      "linked_summary": "Computes (rs1 * rs2) - rs3 with a single rounding (Double).",
      "linked_pseudocode": "F[rd] = (F[rs1] * F[rs2]) - F[rs3];"
    },
    {
      "mnemonic": "FNMADD.D",
      "architecture": "RISC-V",
      "extension": "D",
      "full_name": "Float Negated Fused Multiply-Add (Double)",
      "summary": "Computes -(rs1 * rs2) - rs3 with a single rounding (Double).",
      "syntax": "FNMADD.D rd, rs1, rs2, rs3",
      "encoding": {
        "format": "R4-Type",
        "binary_pattern": "rs3 | 01 | rs2 | rs1 | rm | rd | 1001111",
        "hex_opcode": "0x4F",
        "visual_parts": [
          {
            "raw": "rs3",
            "clean": "rs3"
          },
          {
            "raw": "01",
            "clean": "01"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1001111",
            "clean": "1001111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        },
        {
          "name": "rs3",
          "desc": "Src 3"
        }
      ],
      "pseudocode": "F[rd] = -((F[rs1] * F[rs2]) + F[rs3]);",
      "slug": "fnmadd_d",
      "rel_url": "risc-v/fnmadd_d/",
      "linked_summary": "Computes -(rs1 * rs2) - rs3 with a single rounding (Double).",
      "linked_pseudocode": "F[rd] = -((F[rs1] * F[rs2]) + F[rs3]);"
    },
    {
      "mnemonic": "FNMSUB.D",
      "architecture": "RISC-V",
      "extension": "D",
      "full_name": "Float Negated Fused Multiply-Subtract (Double)",
      "summary": "Computes -(rs1 * rs2) + rs3 with a single rounding (Double).",
      "syntax": "FNMSUB.D rd, rs1, rs2, rs3",
      "encoding": {
        "format": "R4-Type",
        "binary_pattern": "rs3 | 01 | rs2 | rs1 | rm | rd | 1001011",
        "hex_opcode": "0x4B",
        "visual_parts": [
          {
            "raw": "rs3",
            "clean": "rs3"
          },
          {
            "raw": "01",
            "clean": "01"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1001011",
            "clean": "1001011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        },
        {
          "name": "rs3",
          "desc": "Src 3"
        }
      ],
      "pseudocode": "F[rd] = -((F[rs1] * F[rs2]) - F[rs3]);",
      "slug": "fnmsub_d",
      "rel_url": "risc-v/fnmsub_d/",
      "linked_summary": "Computes -(rs1 * rs2) + rs3 with a single rounding (Double).",
      "linked_pseudocode": "F[rd] = -((F[rs1] * F[rs2]) - F[rs3]);"
    },
    {
      "mnemonic": "FCVT.WU.D",
      "architecture": "RISC-V",
      "extension": "D",
      "full_name": "Convert Double to Unsigned Word",
      "summary": "Converts a double-precision float to a 32-bit unsigned integer.",
      "syntax": "FCVT.WU.D rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "1100001 | 00001 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1100001",
            "clean": "1100001"
          },
          {
            "raw": "00001",
            "clean": "00001"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (UInt)"
        },
        {
          "name": "rs1",
          "desc": "Source (Double)"
        }
      ],
      "pseudocode": "R[rd] = sext(f64_to_u32(F[rs1]));",
      "slug": "fcvt_wu_d",
      "rel_url": "risc-v/fcvt_wu_d/",
      "linked_summary": "Converts a double-precision float to a 32-<a href=\"../../armv8-a/bit/\">bit</a> unsigned integer.",
      "linked_pseudocode": "R[rd] = sext(f64_to_u32(F[rs1]));"
    },
    {
      "mnemonic": "FCVT.D.WU",
      "architecture": "RISC-V",
      "extension": "D",
      "full_name": "Convert Unsigned Word to Double",
      "summary": "Converts a 32-bit unsigned integer to a double-precision float.",
      "syntax": "FCVT.D.WU rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "1101001 | 00001 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1101001",
            "clean": "1101001"
          },
          {
            "raw": "00001",
            "clean": "00001"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Double)"
        },
        {
          "name": "rs1",
          "desc": "Source (UInt)"
        }
      ],
      "pseudocode": "F[rd] = u32_to_f64(R[rs1]);",
      "slug": "fcvt_d_wu",
      "rel_url": "risc-v/fcvt_d_wu/",
      "linked_summary": "Converts a 32-<a href=\"../../armv8-a/bit/\">bit</a> unsigned integer to a double-precision float.",
      "linked_pseudocode": "F[rd] = u32_to_f64(R[rs1]);"
    },
    {
      "mnemonic": "C.FLW",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Float Load Word",
      "summary": "Loads a single-precision float from memory (Compressed).",
      "syntax": "C.FLW rd&#x27;, offset(rs1&#x27;)",
      "encoding": {
        "format": "CL",
        "binary_pattern": "011 | imm | rs1' | imm | rd' | 00",
        "hex_opcode": "00",
        "visual_parts": [
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rs1'",
            "clean": "rs1'"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rd'",
            "clean": "rd'"
          },
          {
            "raw": "00",
            "clean": "00"
          }
        ]
      },
      "operands": [
        {
          "name": "rd'",
          "desc": "Dest (f8-f15)"
        },
        {
          "name": "rs1'",
          "desc": "Base (x8-x15)"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "F[rd'] = M[R[rs1'] + offset][31:0];",
      "slug": "c_flw",
      "rel_url": "risc-v/c_flw/",
      "linked_summary": "Loads a single-precision float from memory (Compressed).",
      "linked_pseudocode": "F[rd'] = M[R[rs1'] + offset][31:0];"
    },
    {
      "mnemonic": "C.FSW",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Float Store Word",
      "summary": "Stores a single-precision float to memory (Compressed).",
      "syntax": "C.FSW rs2&#x27;, offset(rs1&#x27;)",
      "encoding": {
        "format": "CS",
        "binary_pattern": "111 | imm | rs1' | imm | rs2' | 00",
        "hex_opcode": "00",
        "visual_parts": [
          {
            "raw": "111",
            "clean": "111"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rs1'",
            "clean": "rs1'"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rs2'",
            "clean": "rs2'"
          },
          {
            "raw": "00",
            "clean": "00"
          }
        ]
      },
      "operands": [
        {
          "name": "rs2'",
          "desc": "Source (f8-f15)"
        },
        {
          "name": "rs1'",
          "desc": "Base (x8-x15)"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "M[R[rs1'] + offset][31:0] = F[rs2'];",
      "slug": "c_fsw",
      "rel_url": "risc-v/c_fsw/",
      "linked_summary": "Stores a single-precision float to memory (Compressed).",
      "linked_pseudocode": "M[R[rs1'] + offset][31:0] = F[rs2'];"
    },
    {
      "mnemonic": "C.LD",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Load Doubleword",
      "summary": "Loads a 64-bit value from memory (Compressed, RV64).",
      "syntax": "C.LD rd&#x27;, offset(rs1&#x27;)",
      "encoding": {
        "format": "CL",
        "binary_pattern": "011 | imm | rs1' | imm | rd' | 00",
        "hex_opcode": "00",
        "visual_parts": [
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rs1'",
            "clean": "rs1'"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rd'",
            "clean": "rd'"
          },
          {
            "raw": "00",
            "clean": "00"
          }
        ]
      },
      "operands": [
        {
          "name": "rd'",
          "desc": "Dest (x8-x15)"
        },
        {
          "name": "rs1'",
          "desc": "Base (x8-x15)"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "R[rd'] = M[R[rs1'] + offset][63:0];",
      "slug": "c_ld",
      "rel_url": "risc-v/c_ld/",
      "linked_summary": "Loads a 64-<a href=\"../../armv8-a/bit/\">bit</a> value from memory (Compressed, RV64).",
      "linked_pseudocode": "R[rd'] = M[R[rs1'] + offset][63:0];"
    },
    {
      "mnemonic": "C.SD",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Store Doubleword",
      "summary": "Stores a 64-bit value to memory (Compressed, RV64).",
      "syntax": "C.SD rs2&#x27;, offset(rs1&#x27;)",
      "encoding": {
        "format": "CS",
        "binary_pattern": "111 | imm | rs1' | imm | rs2' | 00",
        "hex_opcode": "00",
        "visual_parts": [
          {
            "raw": "111",
            "clean": "111"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rs1'",
            "clean": "rs1'"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rs2'",
            "clean": "rs2'"
          },
          {
            "raw": "00",
            "clean": "00"
          }
        ]
      },
      "operands": [
        {
          "name": "rs2'",
          "desc": "Source (x8-x15)"
        },
        {
          "name": "rs1'",
          "desc": "Base (x8-x15)"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "M[R[rs1'] + offset][63:0] = R[rs2'];",
      "slug": "c_sd",
      "rel_url": "risc-v/c_sd/",
      "linked_summary": "Stores a 64-<a href=\"../../armv8-a/bit/\">bit</a> value to memory (Compressed, RV64).",
      "linked_pseudocode": "M[R[rs1'] + offset][63:0] = R[rs2'];"
    },
    {
      "mnemonic": "VFADD.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Float Add",
      "summary": "Adds elements of two vector registers (Floating Point).",
      "syntax": "VFADD.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPFVV",
        "binary_pattern": "000000 | vm | vs2 | vs1 | 001 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "000000",
            "clean": "000000"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs1[i] + vs2[i];",
      "slug": "vfadd_vv",
      "rel_url": "risc-v/vfadd_vv/",
      "linked_summary": "Adds elements of two vector registers (Floating Point).",
      "linked_pseudocode": "foreach(i < vl): vd[i] = vs1[i] + vs2[i];"
    },
    {
      "mnemonic": "VRGATHER.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Register Gather",
      "summary": "Gathers elements from a vector register using indices from another vector register.",
      "syntax": "VRGATHER.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "001100 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "001100",
            "clean": "001100"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Source Table"
        },
        {
          "name": "vs1",
          "desc": "Indices"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = (vs1[i] >= vlmax) ? 0 : vs2[vs1[i]];",
      "slug": "vrgather_vv",
      "rel_url": "risc-v/vrgather_vv/",
      "linked_summary": "Gathers elements from a vector register using indices from another vector register.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = (vs1[i] >= vlmax) ? 0 : vs2[vs1[i]];"
    },
    {
      "mnemonic": "VMAND.MM",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Mask AND",
      "summary": "Performs bitwise AND on vector mask registers.",
      "syntax": "VMAND.MM vd, vs2, vs1",
      "encoding": {
        "format": "OPMVV",
        "binary_pattern": "011001 | 1 | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "011001",
            "clean": "011001"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest Mask"
        },
        {
          "name": "vs2",
          "desc": "Src 2 Mask"
        },
        {
          "name": "vs1",
          "desc": "Src 1 Mask"
        }
      ],
      "pseudocode": "vd = vs1 & vs2;",
      "slug": "vmand_mm",
      "rel_url": "risc-v/vmand_mm/",
      "linked_summary": "Performs bitwise <a href=\"../../risc-v/and/\">AND</a> on vector mask registers.",
      "linked_pseudocode": "vd = vs1 & vs2;"
    },
    {
      "mnemonic": "AMOADD.D",
      "architecture": "RISC-V",
      "extension": "A (Atomic)",
      "full_name": "Atomic Add Doubleword",
      "summary": "Atomically adds a value to a 64-bit doubleword in memory.",
      "syntax": "AMOADD.D rd, rs2, (rs1)",
      "encoding": {
        "format": "R-Type (Atomic)",
        "binary_pattern": "00000 | aq | rl | rs2 | rs1 | 011 | rd | 0101111",
        "hex_opcode": "0x2F",
        "visual_parts": [
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "aq",
            "clean": "aq"
          },
          {
            "raw": "rl",
            "clean": "rl"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0101111",
            "clean": "0101111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Old Value)"
        },
        {
          "name": "rs2",
          "desc": "Value to Add"
        },
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp + R[rs2]; R[rd] = temp;",
      "example": "AMOADD.D x10, x11, (x12)",
      "example_note": "64-bit atomic add.",
      "slug": "amoadd_d",
      "rel_url": "risc-v/amoadd_d/",
      "linked_summary": "Atomically <a href=\"../../armv8-a/adds_5/\">adds</a> a value to a 64-<a href=\"../../armv8-a/bit/\">bit</a> doubleword <a href=\"../../x86/in/\">in</a> memory.",
      "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp + R[rs2]; R[rd] = temp;"
    },
    {
      "mnemonic": "AMOSWAP.D",
      "architecture": "RISC-V",
      "extension": "A (Atomic)",
      "full_name": "Atomic Swap Doubleword",
      "summary": "Atomically swaps a 64-bit value in memory with a register.",
      "syntax": "AMOSWAP.D rd, rs2, (rs1)",
      "encoding": {
        "format": "R-Type (Atomic)",
        "binary_pattern": "00001 | aq | rl | rs2 | rs1 | 011 | rd | 0101111",
        "hex_opcode": "0x2F",
        "visual_parts": [
          {
            "raw": "00001",
            "clean": "00001"
          },
          {
            "raw": "aq",
            "clean": "aq"
          },
          {
            "raw": "rl",
            "clean": "rl"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0101111",
            "clean": "0101111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Old Value)"
        },
        {
          "name": "rs2",
          "desc": "New Value"
        },
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = R[rs2]; R[rd] = temp;",
      "example": "AMOSWAP.D x10, x11, (x12)",
      "example_note": "64-bit atomic swap.",
      "slug": "amoswap_d",
      "rel_url": "risc-v/amoswap_d/",
      "linked_summary": "Atomically swaps a 64-<a href=\"../../armv8-a/bit/\">bit</a> value <a href=\"../../x86/in/\">in</a> memory with a register.",
      "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = R[rs2]; R[rd] = temp;"
    },
    {
      "mnemonic": "AMOAND.D",
      "architecture": "RISC-V",
      "extension": "A (Atomic)",
      "full_name": "Atomic AND Doubleword",
      "summary": "Atomically performs bitwise AND on a 64-bit doubleword in memory.",
      "syntax": "AMOAND.D rd, rs2, (rs1)",
      "encoding": {
        "format": "R-Type (Atomic)",
        "binary_pattern": "01100 | aq | rl | rs2 | rs1 | 011 | rd | 0101111",
        "hex_opcode": "0x2F",
        "visual_parts": [
          {
            "raw": "01100",
            "clean": "01100"
          },
          {
            "raw": "aq",
            "clean": "aq"
          },
          {
            "raw": "rl",
            "clean": "rl"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0101111",
            "clean": "0101111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Old Value)"
        },
        {
          "name": "rs2",
          "desc": "Operand"
        },
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp & R[rs2]; R[rd] = temp;",
      "example": "AMOAND.D x5, x6, (x7)",
      "example_note": "64-bit atomic AND.",
      "slug": "amoand_d",
      "rel_url": "risc-v/amoand_d/",
      "linked_summary": "Atomically performs bitwise <a href=\"../../risc-v/and/\">AND</a> on a 64-<a href=\"../../armv8-a/bit/\">bit</a> doubleword <a href=\"../../x86/in/\">in</a> memory.",
      "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp & R[rs2]; R[rd] = temp;"
    },
    {
      "mnemonic": "AMOOR.D",
      "architecture": "RISC-V",
      "extension": "A (Atomic)",
      "full_name": "Atomic OR Doubleword",
      "summary": "Atomically performs bitwise OR on a 64-bit doubleword in memory.",
      "syntax": "AMOOR.D rd, rs2, (rs1)",
      "encoding": {
        "format": "R-Type (Atomic)",
        "binary_pattern": "01000 | aq | rl | rs2 | rs1 | 011 | rd | 0101111",
        "hex_opcode": "0x2F",
        "visual_parts": [
          {
            "raw": "01000",
            "clean": "01000"
          },
          {
            "raw": "aq",
            "clean": "aq"
          },
          {
            "raw": "rl",
            "clean": "rl"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0101111",
            "clean": "0101111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Old Value)"
        },
        {
          "name": "rs2",
          "desc": "Operand"
        },
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp | R[rs2]; R[rd] = temp;",
      "example": "AMOOR.D x10, x11, (x12)",
      "example_note": "64-bit atomic OR.",
      "slug": "amoor_d",
      "rel_url": "risc-v/amoor_d/",
      "linked_summary": "Atomically performs bitwise <a href=\"../../risc-v/or/\">OR</a> on a 64-<a href=\"../../armv8-a/bit/\">bit</a> doubleword <a href=\"../../x86/in/\">in</a> memory.",
      "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp | R[rs2]; R[rd] = temp;"
    },
    {
      "mnemonic": "AMOXOR.D",
      "architecture": "RISC-V",
      "extension": "A (Atomic)",
      "full_name": "Atomic XOR Doubleword",
      "summary": "Atomically performs bitwise XOR on a 64-bit doubleword in memory.",
      "syntax": "AMOXOR.D rd, rs2, (rs1)",
      "encoding": {
        "format": "R-Type (Atomic)",
        "binary_pattern": "00100 | aq | rl | rs2 | rs1 | 011 | rd | 0101111",
        "hex_opcode": "0x2F",
        "visual_parts": [
          {
            "raw": "00100",
            "clean": "00100"
          },
          {
            "raw": "aq",
            "clean": "aq"
          },
          {
            "raw": "rl",
            "clean": "rl"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0101111",
            "clean": "0101111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Old Value)"
        },
        {
          "name": "rs2",
          "desc": "Operand"
        },
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp ^ R[rs2]; R[rd] = temp;",
      "example": "AMOXOR.D x10, x11, (x12)",
      "example_note": "64-bit atomic XOR.",
      "slug": "amoxor_d",
      "rel_url": "risc-v/amoxor_d/",
      "linked_summary": "Atomically performs bitwise <a href=\"../../risc-v/xor/\">XOR</a> on a 64-<a href=\"../../armv8-a/bit/\">bit</a> doubleword <a href=\"../../x86/in/\">in</a> memory.",
      "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp ^ R[rs2]; R[rd] = temp;"
    },
    {
      "mnemonic": "AMOMAX.D",
      "architecture": "RISC-V",
      "extension": "A (Atomic)",
      "full_name": "Atomic Max Doubleword",
      "summary": "Atomically updates memory with the maximum of the memory value and register value (64-bit Signed).",
      "syntax": "AMOMAX.D rd, rs2, (rs1)",
      "encoding": {
        "format": "R-Type (Atomic)",
        "binary_pattern": "10100 | aq | rl | rs2 | rs1 | 011 | rd | 0101111",
        "hex_opcode": "0x2F",
        "visual_parts": [
          {
            "raw": "10100",
            "clean": "10100"
          },
          {
            "raw": "aq",
            "clean": "aq"
          },
          {
            "raw": "rl",
            "clean": "rl"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0101111",
            "clean": "0101111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Old Value)"
        },
        {
          "name": "rs2",
          "desc": "Operand"
        },
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = max(temp, R[rs2]); R[rd] = temp;",
      "example": "AMOMAX.D x10, x11, (x12)",
      "example_note": "64-bit atomic max.",
      "slug": "amomax_d",
      "rel_url": "risc-v/amomax_d/",
      "linked_summary": "Atomically updates memory with the maximum of the memory value <a href=\"../../armv8-a/and_6/\">and</a> register value (64-<a href=\"../../armv8-a/bit/\">bit</a> Signed).",
      "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = max(temp, R[rs2]); R[rd] = temp;"
    },
    {
      "mnemonic": "AMOMIN.D",
      "architecture": "RISC-V",
      "extension": "A (Atomic)",
      "full_name": "Atomic Min Doubleword",
      "summary": "Atomically updates memory with the minimum of the memory value and register value (64-bit Signed).",
      "syntax": "AMOMIN.D rd, rs2, (rs1)",
      "encoding": {
        "format": "R-Type (Atomic)",
        "binary_pattern": "10000 | aq | rl | rs2 | rs1 | 011 | rd | 0101111",
        "hex_opcode": "0x2F",
        "visual_parts": [
          {
            "raw": "10000",
            "clean": "10000"
          },
          {
            "raw": "aq",
            "clean": "aq"
          },
          {
            "raw": "rl",
            "clean": "rl"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0101111",
            "clean": "0101111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Old Value)"
        },
        {
          "name": "rs2",
          "desc": "Operand"
        },
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = min(temp, R[rs2]); R[rd] = temp;",
      "example": "AMOMIN.D x10, x11, (x12)",
      "example_note": "64-bit atomic min.",
      "slug": "amomin_d",
      "rel_url": "risc-v/amomin_d/",
      "linked_summary": "Atomically updates memory with the minimum of the memory value <a href=\"../../armv8-a/and_6/\">and</a> register value (64-<a href=\"../../armv8-a/bit/\">bit</a> Signed).",
      "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = min(temp, R[rs2]); R[rd] = temp;"
    },
    {
      "mnemonic": "SC.D",
      "architecture": "RISC-V",
      "extension": "A (Atomic)",
      "full_name": "Store Conditional Doubleword",
      "summary": "Conditionally stores a 64-bit value to memory if the reservation is valid.",
      "syntax": "SC.D rd, rs2, (rs1)",
      "encoding": {
        "format": "R-Type (Atomic)",
        "binary_pattern": "00011 | aq | rl | rs2 | rs1 | 011 | rd | 0101111",
        "hex_opcode": "0x2F",
        "visual_parts": [
          {
            "raw": "00011",
            "clean": "00011"
          },
          {
            "raw": "aq",
            "clean": "aq"
          },
          {
            "raw": "rl",
            "clean": "rl"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0101111",
            "clean": "0101111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (0=Success)"
        },
        {
          "name": "rs2",
          "desc": "Source Value"
        },
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "if (ReservationValid) { M[R[rs1]] = R[rs2]; R[rd] = 0; } else { R[rd] = 1; }",
      "example": "SC.D x10, x11, (x12)",
      "example_note": "64-bit conditional store.",
      "slug": "sc_d",
      "rel_url": "risc-v/sc_d/",
      "linked_summary": "Conditionally stores a 64-<a href=\"../../armv8-a/bit/\">bit</a> value to memory if the reservation is valid.",
      "linked_pseudocode": "if (ReservationValid) { M[R[rs1]] = R[rs2]; R[rd] = 0; } else { R[rd] = 1; }"
    },
    {
      "mnemonic": "FMADD.S",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Float Fused Multiply-Add (Single)",
      "summary": "Computes (rs1 * rs2) + rs3 with a single rounding.",
      "syntax": "FMADD.S rd, rs1, rs2, rs3",
      "encoding": {
        "format": "R4-Type",
        "binary_pattern": "rs3 | 00 | rs2 | rs1 | rm | rd | 1000011",
        "hex_opcode": "0x43",
        "visual_parts": [
          {
            "raw": "rs3",
            "clean": "rs3"
          },
          {
            "raw": "00",
            "clean": "00"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1000011",
            "clean": "1000011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        },
        {
          "name": "rs3",
          "desc": "Src 3"
        }
      ],
      "pseudocode": "F[rd] = (F[rs1] * F[rs2]) + F[rs3];",
      "example": "FMADD.S f0, f1, f2, f3",
      "example_note": "f0 = (f1 * f2) + f3",
      "slug": "fmadd_s",
      "rel_url": "risc-v/fmadd_s/",
      "linked_summary": "Computes (rs1 * rs2) + rs3 with a single rounding.",
      "linked_pseudocode": "F[rd] = (F[rs1] * F[rs2]) + F[rs3];"
    },
    {
      "mnemonic": "FMADD.D",
      "architecture": "RISC-V",
      "extension": "D (Double)",
      "full_name": "Float Fused Multiply-Add (Double)",
      "summary": "Computes (rs1 * rs2) + rs3 with a single rounding (64-bit).",
      "syntax": "FMADD.D rd, rs1, rs2, rs3",
      "encoding": {
        "format": "R4-Type",
        "binary_pattern": "rs3 | 01 | rs2 | rs1 | rm | rd | 1000011",
        "hex_opcode": "0x43",
        "visual_parts": [
          {
            "raw": "rs3",
            "clean": "rs3"
          },
          {
            "raw": "01",
            "clean": "01"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1000011",
            "clean": "1000011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        },
        {
          "name": "rs3",
          "desc": "Src 3"
        }
      ],
      "pseudocode": "F[rd] = (F[rs1] * F[rs2]) + F[rs3];",
      "example": "FMADD.D f0, f1, f2, f3",
      "example_note": "64-bit fused multiply-add.",
      "slug": "fmadd_d",
      "rel_url": "risc-v/fmadd_d/",
      "linked_summary": "Computes (rs1 * rs2) + rs3 with a single rounding (64-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": "F[rd] = (F[rs1] * F[rs2]) + F[rs3];"
    },
    {
      "mnemonic": "SUB",
      "architecture": "RISC-V",
      "extension": "Base",
      "full_name": "Subtract",
      "summary": "Subtracts rs2 from rs1.",
      "syntax": "SUB rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0100000 | rs2 | rs1 | 000 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0100000",
            "clean": "0100000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Minuend"
        },
        {
          "name": "rs2",
          "desc": "Subtrahend"
        }
      ],
      "pseudocode": "R[rd] = R[rs1] - R[rs2];",
      "slug": "sub",
      "rel_url": "risc-v/sub/",
      "linked_summary": "Subtracts rs2 from rs1.",
      "linked_pseudocode": "R[rd] = R[rs1] - R[rs2];"
    },
    {
      "mnemonic": "SLTU",
      "architecture": "RISC-V",
      "extension": "Base",
      "full_name": "Set Less Than Unsigned",
      "summary": "Sets rd to 1 if rs1 < rs2 (unsigned comparison), otherwise 0.",
      "syntax": "SLTU rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000000 | rs2 | rs1 | 011 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0000000",
            "clean": "0000000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source 1"
        },
        {
          "name": "rs2",
          "desc": "Source 2"
        }
      ],
      "pseudocode": "R[rd] = (R[rs1] <u R[rs2]) ? 1 : 0;",
      "slug": "sltu",
      "rel_url": "risc-v/sltu/",
      "linked_summary": "Sets rd to 1 if rs1 < rs2 (unsigned comparison), otherwise 0.",
      "linked_pseudocode": "R[rd] = (R[rs1] <u R[rs2]) ? 1 : 0;"
    },
    {
      "mnemonic": "SLTIU",
      "architecture": "RISC-V",
      "extension": "Base",
      "full_name": "Set Less Than Immediate Unsigned",
      "summary": "Sets rd to 1 if rs1 < immediate (unsigned comparison), otherwise 0.",
      "syntax": "SLTIU rd, rs1, imm",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "imm[11:0] | rs1 | 011 | rd | 0010011",
        "hex_opcode": "0x13",
        "visual_parts": [
          {
            "raw": "imm[11:0]",
            "clean": "imm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0010011",
            "clean": "0010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        },
        {
          "name": "imm",
          "desc": "Immediate"
        }
      ],
      "pseudocode": "R[rd] = (R[rs1] <u sext(imm)) ? 1 : 0;",
      "slug": "sltiu",
      "rel_url": "risc-v/sltiu/",
      "linked_summary": "Sets rd to 1 if rs1 < immediate (unsigned comparison), otherwise 0.",
      "linked_pseudocode": "R[rd] = (R[rs1] <u sext(imm)) ? 1 : 0;"
    },
    {
      "mnemonic": "ECALL",
      "architecture": "RISC-V",
      "extension": "Base",
      "full_name": "Environment Call",
      "summary": "Generates an environment call exception (system call).",
      "syntax": "ECALL",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "000000000000 | 00000 | 000 | 00000 | 1110011",
        "hex_opcode": "0x73",
        "visual_parts": [
          {
            "raw": "000000000000",
            "clean": "000000000000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "1110011",
            "clean": "1110011"
          }
        ]
      },
      "operands": [],
      "pseudocode": "RaiseException(EnvironmentCall);",
      "slug": "ecall",
      "rel_url": "risc-v/ecall/",
      "linked_summary": "Generates an environment <a href=\"../../x86/call/\">call</a> exception (system <a href=\"../../x86/call/\">call</a>).",
      "linked_pseudocode": "RaiseException(EnvironmentCall);"
    },
    {
      "mnemonic": "MULHU",
      "architecture": "RISC-V",
      "extension": "M",
      "full_name": "Multiply High Unsigned",
      "summary": "Performs unsigned multiplication and returns the upper XLEN bits.",
      "syntax": "MULHU rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000001 | rs2 | rs1 | 011 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0000001",
            "clean": "0000001"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Upper Bits)"
        },
        {
          "name": "rs1",
          "desc": "Source 1"
        },
        {
          "name": "rs2",
          "desc": "Source 2"
        }
      ],
      "pseudocode": "R[rd] = (R[rs1] *u R[rs2]) >> XLEN;",
      "slug": "mulhu",
      "rel_url": "risc-v/mulhu/",
      "linked_summary": "Performs unsigned multiplication <a href=\"../../armv8-a/and_6/\">and</a> returns the upper XLEN bits.",
      "linked_pseudocode": "R[rd] = (R[rs1] *u R[rs2]) >> XLEN;"
    },
    {
      "mnemonic": "MULHSU",
      "architecture": "RISC-V",
      "extension": "M",
      "full_name": "Multiply High Signed-Unsigned",
      "summary": "Multiplies signed rs1 by unsigned rs2 and returns the upper XLEN bits.",
      "syntax": "MULHSU rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000001 | rs2 | rs1 | 010 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0000001",
            "clean": "0000001"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Upper Bits)"
        },
        {
          "name": "rs1",
          "desc": "Signed Source"
        },
        {
          "name": "rs2",
          "desc": "Unsigned Source"
        }
      ],
      "pseudocode": "R[rd] = (sext(R[rs1]) * zext(R[rs2])) >> XLEN;",
      "slug": "mulhsu",
      "rel_url": "risc-v/mulhsu/",
      "linked_summary": "Multiplies signed rs1 by unsigned rs2 <a href=\"../../armv8-a/and_6/\">and</a> returns the upper XLEN bits.",
      "linked_pseudocode": "R[rd] = (sext(R[rs1]) * zext(R[rs2])) >> XLEN;"
    },
    {
      "mnemonic": "REMU",
      "architecture": "RISC-V",
      "extension": "M",
      "full_name": "Remainder Unsigned",
      "summary": "Computes the unsigned remainder of division.",
      "syntax": "REMU rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000001 | rs2 | rs1 | 111 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0000001",
            "clean": "0000001"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "111",
            "clean": "111"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Remainder)"
        },
        {
          "name": "rs1",
          "desc": "Dividend"
        },
        {
          "name": "rs2",
          "desc": "Divisor"
        }
      ],
      "pseudocode": "R[rd] = R[rs1] %u R[rs2];",
      "slug": "remu",
      "rel_url": "risc-v/remu/",
      "linked_summary": "Computes the unsigned remainder of division.",
      "linked_pseudocode": "R[rd] = R[rs1] %u R[rs2];"
    },
    {
      "mnemonic": "AMOMINU.W",
      "architecture": "RISC-V",
      "extension": "A (Atomic)",
      "full_name": "Atomic Min Unsigned Word",
      "summary": "Atomically updates memory with the minimum of the memory value and register value (Unsigned).",
      "syntax": "AMOMINU.W rd, rs2, (rs1)",
      "encoding": {
        "format": "R-Type (Atomic)",
        "binary_pattern": "11000 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
        "hex_opcode": "0x2F",
        "visual_parts": [
          {
            "raw": "11000",
            "clean": "11000"
          },
          {
            "raw": "aq",
            "clean": "aq"
          },
          {
            "raw": "rl",
            "clean": "rl"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0101111",
            "clean": "0101111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Old Value)"
        },
        {
          "name": "rs2",
          "desc": "Operand"
        },
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = min_u(temp, R[rs2]); R[rd] = temp;",
      "slug": "amominu_w",
      "rel_url": "risc-v/amominu_w/",
      "linked_summary": "Atomically updates memory with the minimum of the memory value <a href=\"../../armv8-a/and_6/\">and</a> register value (Unsigned).",
      "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = min_u(temp, R[rs2]); R[rd] = temp;"
    },
    {
      "mnemonic": "AMOMAXU.W",
      "architecture": "RISC-V",
      "extension": "A (Atomic)",
      "full_name": "Atomic Max Unsigned Word",
      "summary": "Atomically updates memory with the maximum of the memory value and register value (Unsigned).",
      "syntax": "AMOMAXU.W rd, rs2, (rs1)",
      "encoding": {
        "format": "R-Type (Atomic)",
        "binary_pattern": "11100 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
        "hex_opcode": "0x2F",
        "visual_parts": [
          {
            "raw": "11100",
            "clean": "11100"
          },
          {
            "raw": "aq",
            "clean": "aq"
          },
          {
            "raw": "rl",
            "clean": "rl"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0101111",
            "clean": "0101111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Old Value)"
        },
        {
          "name": "rs2",
          "desc": "Operand"
        },
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = max_u(temp, R[rs2]); R[rd] = temp;",
      "slug": "amomaxu_w",
      "rel_url": "risc-v/amomaxu_w/",
      "linked_summary": "Atomically updates memory with the maximum of the memory value <a href=\"../../armv8-a/and_6/\">and</a> register value (Unsigned).",
      "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = max_u(temp, R[rs2]); R[rd] = temp;"
    },
    {
      "mnemonic": "FSUB.S",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Float Subtract (Single)",
      "summary": "Performs single-precision floating-point subtraction.",
      "syntax": "FSUB.S rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000100 | rs2 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0000100",
            "clean": "0000100"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        }
      ],
      "pseudocode": "F[rd] = F[rs1] - F[rs2];",
      "slug": "fsub_s",
      "rel_url": "risc-v/fsub_s/",
      "linked_summary": "Performs single-precision floating-point subtraction.",
      "linked_pseudocode": "F[rd] = F[rs1] - F[rs2];"
    },
    {
      "mnemonic": "FMUL.S",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Float Multiply (Single)",
      "summary": "Performs single-precision floating-point multiplication.",
      "syntax": "FMUL.S rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0001000 | rs2 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0001000",
            "clean": "0001000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        }
      ],
      "pseudocode": "F[rd] = F[rs1] * F[rs2];",
      "slug": "fmul_s",
      "rel_url": "risc-v/fmul_s/",
      "linked_summary": "Performs single-precision floating-point multiplication.",
      "linked_pseudocode": "F[rd] = F[rs1] * F[rs2];"
    },
    {
      "mnemonic": "FDIV.S",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Float Divide (Single)",
      "summary": "Performs single-precision floating-point division.",
      "syntax": "FDIV.S rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0001100 | rs2 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0001100",
            "clean": "0001100"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Dividend"
        },
        {
          "name": "rs2",
          "desc": "Divisor"
        }
      ],
      "pseudocode": "F[rd] = F[rs1] / F[rs2];",
      "slug": "fdiv_s",
      "rel_url": "risc-v/fdiv_s/",
      "linked_summary": "Performs single-precision floating-point division.",
      "linked_pseudocode": "F[rd] = F[rs1] / F[rs2];"
    },
    {
      "mnemonic": "FSQRT.S",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Float Square Root (Single)",
      "summary": "Computes the square root of a single-precision floating-point number.",
      "syntax": "FSQRT.S rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "0101100 | 00000 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0101100",
            "clean": "0101100"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        }
      ],
      "pseudocode": "F[rd] = sqrt(F[rs1]);",
      "slug": "fsqrt_s",
      "rel_url": "risc-v/fsqrt_s/",
      "linked_summary": "Computes the square root of a single-precision floating-point number.",
      "linked_pseudocode": "F[rd] = sqrt(F[rs1]);"
    },
    {
      "mnemonic": "FMIN.S",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Float Minimum (Single)",
      "summary": "Writes the smaller of two single-precision floating-point values to rd.",
      "syntax": "FMIN.S rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0010100 | rs2 | rs1 | 000 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0010100",
            "clean": "0010100"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        }
      ],
      "pseudocode": "F[rd] = min(F[rs1], F[rs2]);",
      "slug": "fmin_s",
      "rel_url": "risc-v/fmin_s/",
      "linked_summary": "Writes the smaller of two single-precision floating-point values to rd.",
      "linked_pseudocode": "F[rd] = min(F[rs1], F[rs2]);"
    },
    {
      "mnemonic": "FMAX.S",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Float Maximum (Single)",
      "summary": "Writes the larger of two single-precision floating-point values to rd.",
      "syntax": "FMAX.S rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0010100 | rs2 | rs1 | 001 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0010100",
            "clean": "0010100"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        }
      ],
      "pseudocode": "F[rd] = max(F[rs1], F[rs2]);",
      "slug": "fmax_s",
      "rel_url": "risc-v/fmax_s/",
      "linked_summary": "Writes the larger of two single-precision floating-point values to rd.",
      "linked_pseudocode": "F[rd] = max(F[rs1], F[rs2]);"
    },
    {
      "mnemonic": "CSRR",
      "architecture": "RISC-V",
      "extension": "Pseudo",
      "full_name": "Control Status Register Read",
      "summary": "Reads the value of a CSR into a register.",
      "syntax": "CSRR rd, csr",
      "encoding": {
        "format": "Pseudo",
        "binary_pattern": "CSRRS rd, csr, x0",
        "hex_opcode": "See CSRRS",
        "visual_parts": [
          {
            "raw": "CSRRS rd, csr, x0",
            "clean": "CSRRS rd, csr, x0"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "csr",
          "desc": "CSR Address"
        }
      ],
      "pseudocode": "R[rd] = CSRs[csr];",
      "example": "CSRR x10, mstatus",
      "example_note": "Read mstatus.",
      "slug": "csrr",
      "rel_url": "risc-v/csrr/",
      "linked_summary": "Reads the value of a CSR into a register.",
      "linked_pseudocode": "R[rd] = CSRs[csr];"
    },
    {
      "mnemonic": "CSRW",
      "architecture": "RISC-V",
      "extension": "Pseudo",
      "full_name": "Control Status Register Write",
      "summary": "Writes a register value to a CSR.",
      "syntax": "CSRW csr, rs",
      "encoding": {
        "format": "Pseudo",
        "binary_pattern": "CSRRW x0, csr, rs",
        "hex_opcode": "See CSRRW",
        "visual_parts": [
          {
            "raw": "CSRRW x0, csr, rs",
            "clean": "CSRRW x0, csr, rs"
          }
        ]
      },
      "operands": [
        {
          "name": "csr",
          "desc": "CSR Address"
        },
        {
          "name": "rs",
          "desc": "Source"
        }
      ],
      "pseudocode": "CSRs[csr] = R[rs];",
      "example": "CSRW mepc, x10",
      "example_note": "Write address in x10 to mepc.",
      "slug": "csrw",
      "rel_url": "risc-v/csrw/",
      "linked_summary": "Writes a register value to a CSR.",
      "linked_pseudocode": "CSRs[csr] = R[rs];"
    },
    {
      "mnemonic": "CSRS",
      "architecture": "RISC-V",
      "extension": "Pseudo",
      "full_name": "Control Status Register Set",
      "summary": "Sets bits in a CSR (bitwise OR).",
      "syntax": "CSRS csr, rs",
      "encoding": {
        "format": "Pseudo",
        "binary_pattern": "CSRRS x0, csr, rs",
        "hex_opcode": "See CSRRS",
        "visual_parts": [
          {
            "raw": "CSRRS x0, csr, rs",
            "clean": "CSRRS x0, csr, rs"
          }
        ]
      },
      "operands": [
        {
          "name": "csr",
          "desc": "CSR Address"
        },
        {
          "name": "rs",
          "desc": "Bit Mask"
        }
      ],
      "pseudocode": "CSRs[csr] |= R[rs];",
      "example": "CSRS sstatus, x5",
      "example_note": "Set bits in sstatus.",
      "slug": "csrs",
      "rel_url": "risc-v/csrs/",
      "linked_summary": "Sets bits <a href=\"../../x86/in/\">in</a> a CSR (bitwise <a href=\"../../risc-v/or/\">OR</a>).",
      "linked_pseudocode": "CSRs[csr] |= R[rs];"
    },
    {
      "mnemonic": "CSRC",
      "architecture": "RISC-V",
      "extension": "Pseudo",
      "full_name": "Control Status Register Clear",
      "summary": "Clears bits in a CSR (bitwise AND NOT).",
      "syntax": "CSRC csr, rs",
      "encoding": {
        "format": "Pseudo",
        "binary_pattern": "CSRRC x0, csr, rs",
        "hex_opcode": "See CSRRC",
        "visual_parts": [
          {
            "raw": "CSRRC x0, csr, rs",
            "clean": "CSRRC x0, csr, rs"
          }
        ]
      },
      "operands": [
        {
          "name": "csr",
          "desc": "CSR Address"
        },
        {
          "name": "rs",
          "desc": "Bit Mask"
        }
      ],
      "pseudocode": "CSRs[csr] &= ~R[rs];",
      "example": "CSRC sstatus, x5",
      "example_note": "Clear bits in sstatus.",
      "slug": "csrc",
      "rel_url": "risc-v/csrc/",
      "linked_summary": "Clears bits <a href=\"../../x86/in/\">in</a> a CSR (bitwise <a href=\"../../risc-v/and/\">AND</a> <a href=\"../../risc-v/not/\">NOT</a>).",
      "linked_pseudocode": "CSRs[csr] &= ~R[rs];"
    },
    {
      "mnemonic": "FCVT.LU.D",
      "architecture": "RISC-V",
      "extension": "D (Double)",
      "full_name": "Convert Double to Unsigned Long",
      "summary": "Converts a double-precision float to a 64-bit unsigned integer.",
      "syntax": "FCVT.LU.D rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "1100001 | 00011 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1100001",
            "clean": "1100001"
          },
          {
            "raw": "00011",
            "clean": "00011"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (ULong)"
        },
        {
          "name": "rs1",
          "desc": "Source (Double)"
        }
      ],
      "pseudocode": "R[rd] = f64_to_u64(F[rs1]);",
      "example": "FCVT.LU.D x10, f0",
      "example_note": "Double -> Unsigned 64-bit Int.",
      "slug": "fcvt_lu_d",
      "rel_url": "risc-v/fcvt_lu_d/",
      "linked_summary": "Converts a double-precision float to a 64-<a href=\"../../armv8-a/bit/\">bit</a> unsigned integer.",
      "linked_pseudocode": "R[rd] = f64_to_u64(F[rs1]);"
    },
    {
      "mnemonic": "FLH",
      "architecture": "RISC-V",
      "extension": "Zfh (Half-Float)",
      "full_name": "Float Load Halfword",
      "summary": "Loads a 16-bit half-precision float from memory.",
      "syntax": "FLH rd, offset(rs1)",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "offset | rs1 | 001 | rd | 0000111",
        "hex_opcode": "0x07",
        "visual_parts": [
          {
            "raw": "offset",
            "clean": "offset"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0000111",
            "clean": "0000111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Float)"
        },
        {
          "name": "rs1",
          "desc": "Base"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "F[rd] = M[R[rs1] + sext(offset)][15:0];",
      "example": "FLH f1, 0(x10)",
      "example_note": "Load 16-bit float.",
      "slug": "flh",
      "rel_url": "risc-v/flh/",
      "linked_summary": "Loads a 16-<a href=\"../../armv8-a/bit/\">bit</a> half-precision float from memory.",
      "linked_pseudocode": "F[rd] = M[R[rs1] + sext(offset)][15:0];"
    },
    {
      "mnemonic": "FSH",
      "architecture": "RISC-V",
      "extension": "Zfh (Half-Float)",
      "full_name": "Float Store Halfword",
      "summary": "Stores a 16-bit half-precision float to memory.",
      "syntax": "FSH rs2, offset(rs1)",
      "encoding": {
        "format": "S-Type",
        "binary_pattern": "imm | rs2 | rs1 | 001 | imm | 0100111",
        "hex_opcode": "0x27",
        "visual_parts": [
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "0100111",
            "clean": "0100111"
          }
        ]
      },
      "operands": [
        {
          "name": "rs2",
          "desc": "Source"
        },
        {
          "name": "rs1",
          "desc": "Base"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "M[R[rs1] + sext(offset)][15:0] = F[rs2];",
      "example": "FSH f1, 0(x10)",
      "example_note": "Store 16-bit float.",
      "slug": "fsh",
      "rel_url": "risc-v/fsh/",
      "linked_summary": "Stores a 16-<a href=\"../../armv8-a/bit/\">bit</a> half-precision float to memory.",
      "linked_pseudocode": "M[R[rs1] + sext(offset)][15:0] = F[rs2];"
    },
    {
      "mnemonic": "FADD.H",
      "architecture": "RISC-V",
      "extension": "Zfh (Half-Float)",
      "full_name": "Float Add Half",
      "summary": "Performs 16-bit floating-point addition.",
      "syntax": "FADD.H rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000100 | rs2 | rs1 | 000 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0000100",
            "clean": "0000100"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        }
      ],
      "pseudocode": "F[rd] = F[rs1] + F[rs2];",
      "example": "FADD.H f0, f1, f2",
      "example_note": "16-bit float add.",
      "slug": "fadd_h",
      "rel_url": "risc-v/fadd_h/",
      "linked_summary": "Performs 16-<a href=\"../../armv8-a/bit/\">bit</a> floating-point addition.",
      "linked_pseudocode": "F[rd] = F[rs1] + F[rs2];"
    },
    {
      "mnemonic": "FCVT.S.H",
      "architecture": "RISC-V",
      "extension": "Zfh (Half-Float)",
      "full_name": "Convert Half to Single",
      "summary": "Converts a 16-bit half-precision float to a 32-bit single-precision float.",
      "syntax": "FCVT.S.H rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "0100000 | 00010 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0100000",
            "clean": "0100000"
          },
          {
            "raw": "00010",
            "clean": "00010"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Single)"
        },
        {
          "name": "rs1",
          "desc": "Source (Half)"
        }
      ],
      "pseudocode": "F[rd] = f16_to_f32(F[rs1]);",
      "example": "FCVT.S.H f0, f1",
      "example_note": "Promote Half to Float.",
      "slug": "fcvt_s_h",
      "rel_url": "risc-v/fcvt_s_h/",
      "linked_summary": "Converts a 16-<a href=\"../../armv8-a/bit/\">bit</a> half-precision float to a 32-<a href=\"../../armv8-a/bit/\">bit</a> single-precision float.",
      "linked_pseudocode": "F[rd] = f16_to_f32(F[rs1]);"
    },
    {
      "mnemonic": "FCVT.H.S",
      "architecture": "RISC-V",
      "extension": "Zfh (Half-Float)",
      "full_name": "Convert Single to Half",
      "summary": "Converts a 32-bit single-precision float to a 16-bit half-precision float.",
      "syntax": "FCVT.H.S rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "0100010 | 00000 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0100010",
            "clean": "0100010"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Half)"
        },
        {
          "name": "rs1",
          "desc": "Source (Single)"
        }
      ],
      "pseudocode": "F[rd] = f32_to_f16(F[rs1]);",
      "example": "FCVT.H.S f0, f1",
      "example_note": "Demote Float to Half.",
      "slug": "fcvt_h_s",
      "rel_url": "risc-v/fcvt_h_s/",
      "linked_summary": "Converts a 32-<a href=\"../../armv8-a/bit/\">bit</a> single-precision float to a 16-<a href=\"../../armv8-a/bit/\">bit</a> half-precision float.",
      "linked_pseudocode": "F[rd] = f32_to_f16(F[rs1]);"
    },
    {
      "mnemonic": "SUBW",
      "architecture": "RISC-V",
      "extension": "RV64",
      "full_name": "Subtract Word",
      "summary": "Subtracts the lower 32 bits of rs2 from rs1 and sign-extends the result to 64 bits.",
      "syntax": "SUBW rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0100000 | rs2 | rs1 | 000 | rd | 0111011",
        "hex_opcode": "0x3B",
        "visual_parts": [
          {
            "raw": "0100000",
            "clean": "0100000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0111011",
            "clean": "0111011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Minuend"
        },
        {
          "name": "rs2",
          "desc": "Subtrahend"
        }
      ],
      "pseudocode": "R[rd] = sext((R[rs1] - R[rs2])[31:0]);",
      "example": "SUBW x10, x11, x12",
      "example_note": "32-bit subtraction on 64-bit registers.",
      "slug": "subw",
      "rel_url": "risc-v/subw/",
      "linked_summary": "Subtracts the lower 32 bits of rs2 from rs1 <a href=\"../../armv8-a/and_6/\">and</a> sign-extends the result to 64 bits.",
      "linked_pseudocode": "R[rd] = sext((R[rs1] - R[rs2])[31:0]);"
    },
    {
      "mnemonic": "SLLW",
      "architecture": "RISC-V",
      "extension": "RV64",
      "full_name": "Shift Left Logical Word",
      "summary": "Performs a 32-bit logical left shift on rs1 by the amount in rs2 (lower 5 bits), sign-extending the result.",
      "syntax": "SLLW rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000000 | rs2 | rs1 | 001 | rd | 0111011",
        "hex_opcode": "0x3B",
        "visual_parts": [
          {
            "raw": "0000000",
            "clean": "0000000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0111011",
            "clean": "0111011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        },
        {
          "name": "rs2",
          "desc": "Shift Amount"
        }
      ],
      "pseudocode": "R[rd] = sext((R[rs1] << (R[rs2] & 0x1F))[31:0]);",
      "example": "SLLW x5, x6, x7",
      "example_note": "32-bit shift.",
      "slug": "sllw",
      "rel_url": "risc-v/sllw/",
      "linked_summary": "Performs a 32-<a href=\"../../armv8-a/bit/\">bit</a> logical left shift on rs1 by the amount <a href=\"../../x86/in/\">in</a> rs2 (lower 5 bits), sign-extending the result.",
      "linked_pseudocode": "R[rd] = sext((R[rs1] << (R[rs2] & 0x1F))[31:0]);"
    },
    {
      "mnemonic": "SRLW",
      "architecture": "RISC-V",
      "extension": "RV64",
      "full_name": "Shift Right Logical Word",
      "summary": "Performs a 32-bit logical right shift on rs1 by the amount in rs2, sign-extending the result.",
      "syntax": "SRLW rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000000 | rs2 | rs1 | 101 | rd | 0111011",
        "hex_opcode": "0x3B",
        "visual_parts": [
          {
            "raw": "0000000",
            "clean": "0000000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "101",
            "clean": "101"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0111011",
            "clean": "0111011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        },
        {
          "name": "rs2",
          "desc": "Shift Amount"
        }
      ],
      "pseudocode": "R[rd] = sext((R[rs1][31:0] >>u (R[rs2] & 0x1F)));",
      "example": "SRLW x5, x6, x7",
      "example_note": "32-bit logical right shift.",
      "slug": "srlw",
      "rel_url": "risc-v/srlw/",
      "linked_summary": "Performs a 32-<a href=\"../../armv8-a/bit/\">bit</a> logical right shift on rs1 by the amount <a href=\"../../x86/in/\">in</a> rs2, sign-extending the result.",
      "linked_pseudocode": "R[rd] = sext((R[rs1][31:0] >>u (R[rs2] & 0x1F)));"
    },
    {
      "mnemonic": "SRAW",
      "architecture": "RISC-V",
      "extension": "RV64",
      "full_name": "Shift Right Arithmetic Word",
      "summary": "Performs a 32-bit arithmetic right shift on rs1, sign-extending the result.",
      "syntax": "SRAW rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0100000 | rs2 | rs1 | 101 | rd | 0111011",
        "hex_opcode": "0x3B",
        "visual_parts": [
          {
            "raw": "0100000",
            "clean": "0100000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "101",
            "clean": "101"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0111011",
            "clean": "0111011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        },
        {
          "name": "rs2",
          "desc": "Shift Amount"
        }
      ],
      "pseudocode": "R[rd] = sext((R[rs1][31:0] >>s (R[rs2] & 0x1F)));",
      "example": "SRAW x5, x6, x7",
      "example_note": "32-bit arithmetic right shift.",
      "slug": "sraw",
      "rel_url": "risc-v/sraw/",
      "linked_summary": "Performs a 32-<a href=\"../../armv8-a/bit/\">bit</a> arithmetic right shift on rs1, sign-extending the result.",
      "linked_pseudocode": "R[rd] = sext((R[rs1][31:0] >>s (R[rs2] & 0x1F)));"
    },
    {
      "mnemonic": "SLLIW",
      "architecture": "RISC-V",
      "extension": "RV64",
      "full_name": "Shift Left Logical Immediate Word",
      "summary": "Shifts the lower 32 bits of rs1 left by a constant, sign-extending the result.",
      "syntax": "SLLIW rd, rs1, shamt",
      "encoding": {
        "format": "I-Type (Shift)",
        "binary_pattern": "0000000 | shamt | rs1 | 001 | rd | 0011011",
        "hex_opcode": "0x1B",
        "visual_parts": [
          {
            "raw": "0000000",
            "clean": "0000000"
          },
          {
            "raw": "shamt",
            "clean": "shamt"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0011011",
            "clean": "0011011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        },
        {
          "name": "shamt",
          "desc": "Shift Amount (0-31)"
        }
      ],
      "pseudocode": "R[rd] = sext((R[rs1] << shamt)[31:0]);",
      "example": "SLLIW x10, x11, 4",
      "example_note": "Shift lower 32 bits left by 4.",
      "slug": "slliw",
      "rel_url": "risc-v/slliw/",
      "linked_summary": "Shifts the lower 32 bits of rs1 left by a constant, sign-extending the result.",
      "linked_pseudocode": "R[rd] = sext((R[rs1] << shamt)[31:0]);"
    },
    {
      "mnemonic": "SRLIW",
      "architecture": "RISC-V",
      "extension": "RV64",
      "full_name": "Shift Right Logical Immediate Word",
      "summary": "Logically shifts the lower 32 bits of rs1 right by a constant, sign-extending the result.",
      "syntax": "SRLIW rd, rs1, shamt",
      "encoding": {
        "format": "I-Type (Shift)",
        "binary_pattern": "0000000 | shamt | rs1 | 101 | rd | 0011011",
        "hex_opcode": "0x1B",
        "visual_parts": [
          {
            "raw": "0000000",
            "clean": "0000000"
          },
          {
            "raw": "shamt",
            "clean": "shamt"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "101",
            "clean": "101"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0011011",
            "clean": "0011011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        },
        {
          "name": "shamt",
          "desc": "Shift Amount"
        }
      ],
      "pseudocode": "R[rd] = sext((R[rs1][31:0] >>u shamt));",
      "example": "SRLIW x10, x11, 4",
      "example_note": "Logical right shift of lower word.",
      "slug": "srliw",
      "rel_url": "risc-v/srliw/",
      "linked_summary": "Logically shifts the lower 32 bits of rs1 right by a constant, sign-extending the result.",
      "linked_pseudocode": "R[rd] = sext((R[rs1][31:0] >>u shamt));"
    },
    {
      "mnemonic": "SRAIW",
      "architecture": "RISC-V",
      "extension": "RV64",
      "full_name": "Shift Right Arithmetic Immediate Word",
      "summary": "Arithmetically shifts the lower 32 bits of rs1 right by a constant, sign-extending the result.",
      "syntax": "SRAIW rd, rs1, shamt",
      "encoding": {
        "format": "I-Type (Shift)",
        "binary_pattern": "0100000 | shamt | rs1 | 101 | rd | 0011011",
        "hex_opcode": "0x1B",
        "visual_parts": [
          {
            "raw": "0100000",
            "clean": "0100000"
          },
          {
            "raw": "shamt",
            "clean": "shamt"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "101",
            "clean": "101"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0011011",
            "clean": "0011011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        },
        {
          "name": "shamt",
          "desc": "Shift Amount"
        }
      ],
      "pseudocode": "R[rd] = sext((R[rs1][31:0] >>s shamt));",
      "example": "SRAIW x10, x11, 4",
      "example_note": "Arithmetic right shift of lower word.",
      "slug": "sraiw",
      "rel_url": "risc-v/sraiw/",
      "linked_summary": "Arithmetically shifts the lower 32 bits of rs1 right by a constant, sign-extending the result.",
      "linked_pseudocode": "R[rd] = sext((R[rs1][31:0] >>s shamt));"
    },
    {
      "mnemonic": "MULW",
      "architecture": "RISC-V",
      "extension": "M (RV64)",
      "full_name": "Multiply Word",
      "summary": "Performs 32-bit multiplication of rs1 and rs2, sign-extending the 32-bit result to 64 bits.",
      "syntax": "MULW rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000001 | rs2 | rs1 | 000 | rd | 0111011",
        "hex_opcode": "0x3B",
        "visual_parts": [
          {
            "raw": "0000001",
            "clean": "0000001"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0111011",
            "clean": "0111011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source 1"
        },
        {
          "name": "rs2",
          "desc": "Source 2"
        }
      ],
      "pseudocode": "R[rd] = sext((R[rs1] * R[rs2])[31:0]);",
      "example": "MULW x10, x11, x12",
      "example_note": "32-bit multiplication.",
      "slug": "mulw",
      "rel_url": "risc-v/mulw/",
      "linked_summary": "Performs 32-<a href=\"../../armv8-a/bit/\">bit</a> multiplication of rs1 <a href=\"../../armv8-a/and_6/\">and</a> rs2, sign-extending the 32-<a href=\"../../armv8-a/bit/\">bit</a> result to 64 bits.",
      "linked_pseudocode": "R[rd] = sext((R[rs1] * R[rs2])[31:0]);"
    },
    {
      "mnemonic": "DIVW",
      "architecture": "RISC-V",
      "extension": "M (RV64)",
      "full_name": "Divide Word",
      "summary": "Performs 32-bit signed division of rs1 by rs2, sign-extending the result.",
      "syntax": "DIVW rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000001 | rs2 | rs1 | 100 | rd | 0111011",
        "hex_opcode": "0x3B",
        "visual_parts": [
          {
            "raw": "0000001",
            "clean": "0000001"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0111011",
            "clean": "0111011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Quotient"
        },
        {
          "name": "rs1",
          "desc": "Dividend"
        },
        {
          "name": "rs2",
          "desc": "Divisor"
        }
      ],
      "pseudocode": "R[rd] = sext(R[rs1][31:0] /s R[rs2][31:0]);",
      "example": "DIVW x10, x11, x12",
      "example_note": "32-bit signed division.",
      "slug": "divw",
      "rel_url": "risc-v/divw/",
      "linked_summary": "Performs 32-<a href=\"../../armv8-a/bit/\">bit</a> signed division of rs1 by rs2, sign-extending the result.",
      "linked_pseudocode": "R[rd] = sext(R[rs1][31:0] /s R[rs2][31:0]);"
    },
    {
      "mnemonic": "DIVUW",
      "architecture": "RISC-V",
      "extension": "M (RV64)",
      "full_name": "Divide Unsigned Word",
      "summary": "Performs 32-bit unsigned division of rs1 by rs2, sign-extending the result.",
      "syntax": "DIVUW rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000001 | rs2 | rs1 | 101 | rd | 0111011",
        "hex_opcode": "0x3B",
        "visual_parts": [
          {
            "raw": "0000001",
            "clean": "0000001"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "101",
            "clean": "101"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0111011",
            "clean": "0111011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Quotient"
        },
        {
          "name": "rs1",
          "desc": "Dividend"
        },
        {
          "name": "rs2",
          "desc": "Divisor"
        }
      ],
      "pseudocode": "R[rd] = sext(R[rs1][31:0] /u R[rs2][31:0]);",
      "example": "DIVUW x10, x11, x12",
      "example_note": "32-bit unsigned division.",
      "slug": "divuw",
      "rel_url": "risc-v/divuw/",
      "linked_summary": "Performs 32-<a href=\"../../armv8-a/bit/\">bit</a> unsigned division of rs1 by rs2, sign-extending the result.",
      "linked_pseudocode": "R[rd] = sext(R[rs1][31:0] /u R[rs2][31:0]);"
    },
    {
      "mnemonic": "REMW",
      "architecture": "RISC-V",
      "extension": "M (RV64)",
      "full_name": "Remainder Word",
      "summary": "Computes the remainder of 32-bit signed division, sign-extending the result.",
      "syntax": "REMW rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000001 | rs2 | rs1 | 110 | rd | 0111011",
        "hex_opcode": "0x3B",
        "visual_parts": [
          {
            "raw": "0000001",
            "clean": "0000001"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "110",
            "clean": "110"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0111011",
            "clean": "0111011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Remainder"
        },
        {
          "name": "rs1",
          "desc": "Dividend"
        },
        {
          "name": "rs2",
          "desc": "Divisor"
        }
      ],
      "pseudocode": "R[rd] = sext(R[rs1][31:0] %s R[rs2][31:0]);",
      "example": "REMW x10, x11, x12",
      "example_note": "32-bit signed remainder.",
      "slug": "remw",
      "rel_url": "risc-v/remw/",
      "linked_summary": "Computes the remainder of 32-<a href=\"../../armv8-a/bit/\">bit</a> signed division, sign-extending the result.",
      "linked_pseudocode": "R[rd] = sext(R[rs1][31:0] %s R[rs2][31:0]);"
    },
    {
      "mnemonic": "REMUW",
      "architecture": "RISC-V",
      "extension": "M (RV64)",
      "full_name": "Remainder Unsigned Word",
      "summary": "Computes the remainder of 32-bit unsigned division, sign-extending the result.",
      "syntax": "REMUW rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000001 | rs2 | rs1 | 111 | rd | 0111011",
        "hex_opcode": "0x3B",
        "visual_parts": [
          {
            "raw": "0000001",
            "clean": "0000001"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "111",
            "clean": "111"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0111011",
            "clean": "0111011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Remainder"
        },
        {
          "name": "rs1",
          "desc": "Dividend"
        },
        {
          "name": "rs2",
          "desc": "Divisor"
        }
      ],
      "pseudocode": "R[rd] = sext(R[rs1][31:0] %u R[rs2][31:0]);",
      "example": "REMUW x10, x11, x12",
      "example_note": "32-bit unsigned remainder.",
      "slug": "remuw",
      "rel_url": "risc-v/remuw/",
      "linked_summary": "Computes the remainder of 32-<a href=\"../../armv8-a/bit/\">bit</a> unsigned division, sign-extending the result.",
      "linked_pseudocode": "R[rd] = sext(R[rs1][31:0] %u R[rs2][31:0]);"
    },
    {
      "mnemonic": "FENCE.I",
      "architecture": "RISC-V",
      "extension": "Zifencei",
      "full_name": "Instruction Fence",
      "summary": "Synchronizes the instruction cache with the data cache (used after self-modifying code).",
      "syntax": "FENCE.I",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "000000000000 | 00000 | 001 | 00000 | 0001111",
        "hex_opcode": "0x0F",
        "visual_parts": [
          {
            "raw": "000000000000",
            "clean": "000000000000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "0001111",
            "clean": "0001111"
          }
        ]
      },
      "operands": [],
      "pseudocode": "Fence(Store, Fetch);",
      "example": "FENCE.I",
      "example_note": "Flushes I-Cache; ensures previous writes are visible to instruction fetch.",
      "slug": "fence_i",
      "rel_url": "risc-v/fence_i/",
      "linked_summary": "Synchronizes the instruction cache with the data cache (used after self-modifying code).",
      "linked_pseudocode": "Fence(Store, Fetch);"
    },
    {
      "mnemonic": "HLV.B",
      "architecture": "RISC-V",
      "extension": "H (Hypervisor)",
      "full_name": "Hypervisor Load Byte",
      "summary": "Loads a byte from Guest Physical Memory (VS-stage translation only).",
      "syntax": "HLV.B rd, (rs1)",
      "encoding": {
        "format": "R-Type (System)",
        "binary_pattern": "0110000 | 00000 | rs1 | 100 | rd | 1110011",
        "hex_opcode": "0x73",
        "visual_parts": [
          {
            "raw": "0110000",
            "clean": "0110000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1110011",
            "clean": "1110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Guest Address"
        }
      ],
      "pseudocode": "R[rd] = sext(GuestMem[R[rs1]][7:0]);",
      "example": "HLV.B x10, (x11)",
      "example_note": "Read byte from guest memory.",
      "slug": "hlv_b",
      "rel_url": "risc-v/hlv_b/",
      "linked_summary": "Loads a byte from Guest Physical Memory (VS-stage translation only).",
      "linked_pseudocode": "R[rd] = sext(GuestMem[R[rs1]][7:0]);"
    },
    {
      "mnemonic": "HLV.W",
      "architecture": "RISC-V",
      "extension": "H (Hypervisor)",
      "full_name": "Hypervisor Load Word",
      "summary": "Loads a word from Guest Physical Memory (VS-stage translation only).",
      "syntax": "HLV.W rd, (rs1)",
      "encoding": {
        "format": "R-Type (System)",
        "binary_pattern": "0110100 | 00000 | rs1 | 100 | rd | 1110011",
        "hex_opcode": "0x73",
        "visual_parts": [
          {
            "raw": "0110100",
            "clean": "0110100"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1110011",
            "clean": "1110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Guest Address"
        }
      ],
      "pseudocode": "R[rd] = sext(GuestMem[R[rs1]][31:0]);",
      "example": "HLV.W x10, (x11)",
      "example_note": "Read word from guest memory.",
      "slug": "hlv_w",
      "rel_url": "risc-v/hlv_w/",
      "linked_summary": "Loads a word from Guest Physical Memory (VS-stage translation only).",
      "linked_pseudocode": "R[rd] = sext(GuestMem[R[rs1]][31:0]);"
    },
    {
      "mnemonic": "HSV.B",
      "architecture": "RISC-V",
      "extension": "H (Hypervisor)",
      "full_name": "Hypervisor Store Byte",
      "summary": "Stores a byte to Guest Physical Memory.",
      "syntax": "HSV.B rs2, (rs1)",
      "encoding": {
        "format": "R-Type (System)",
        "binary_pattern": "0110001 | rs2 | rs1 | 100 | 00000 | 1110011",
        "hex_opcode": "0x73",
        "visual_parts": [
          {
            "raw": "0110001",
            "clean": "0110001"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "1110011",
            "clean": "1110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rs2",
          "desc": "Source"
        },
        {
          "name": "rs1",
          "desc": "Guest Address"
        }
      ],
      "pseudocode": "GuestMem[R[rs1]][7:0] = R[rs2][7:0];",
      "example": "HSV.B x10, (x11)",
      "example_note": "Write byte to guest memory.",
      "slug": "hsv_b",
      "rel_url": "risc-v/hsv_b/",
      "linked_summary": "Stores a byte to Guest Physical Memory.",
      "linked_pseudocode": "GuestMem[R[rs1]][7:0] = R[rs2][7:0];"
    },
    {
      "mnemonic": "HSV.W",
      "architecture": "RISC-V",
      "extension": "H (Hypervisor)",
      "full_name": "Hypervisor Store Word",
      "summary": "Stores a word to Guest Physical Memory.",
      "syntax": "HSV.W rs2, (rs1)",
      "encoding": {
        "format": "R-Type (System)",
        "binary_pattern": "0110101 | rs2 | rs1 | 100 | 00000 | 1110011",
        "hex_opcode": "0x73",
        "visual_parts": [
          {
            "raw": "0110101",
            "clean": "0110101"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "1110011",
            "clean": "1110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rs2",
          "desc": "Source"
        },
        {
          "name": "rs1",
          "desc": "Guest Address"
        }
      ],
      "pseudocode": "GuestMem[R[rs1]][31:0] = R[rs2][31:0];",
      "example": "HSV.W x10, (x11)",
      "example_note": "Write word to guest memory.",
      "slug": "hsv_w",
      "rel_url": "risc-v/hsv_w/",
      "linked_summary": "Stores a word to Guest Physical Memory.",
      "linked_pseudocode": "GuestMem[R[rs1]][31:0] = R[rs2][31:0];"
    },
    {
      "mnemonic": "PREFETCH.I",
      "architecture": "RISC-V",
      "extension": "Zicbop (Prefetch)",
      "full_name": "Prefetch Instruction",
      "summary": "Hints to hardware to bring the cache block containing the instruction at the address into the instruction cache.",
      "syntax": "PREFETCH.I offset(rs1)",
      "encoding": {
        "format": "S-Type (Hint)",
        "binary_pattern": "00000 | 00000 | rs1 | 110 | imm | 0010011",
        "hex_opcode": "0x13",
        "visual_parts": [
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "110",
            "clean": "110"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "0010011",
            "clean": "0010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rs1",
          "desc": "Base Address"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "Prefetch(I-Cache, R[rs1] + offset);",
      "example": "PREFETCH.I 0(x10)",
      "example_note": "Prepare I-Cache for upcoming jump.",
      "slug": "prefetch_i",
      "rel_url": "risc-v/prefetch_i/",
      "linked_summary": "Hints to hardware to bring the cache block containing the instruction <a href=\"../../armv8-a/at_2/\">at</a> the address into the instruction cache.",
      "linked_pseudocode": "Prefetch(I-Cache, R[rs1] + offset);"
    },
    {
      "mnemonic": "PREFETCH.R",
      "architecture": "RISC-V",
      "extension": "Zicbop (Prefetch)",
      "full_name": "Prefetch Read",
      "summary": "Hints to hardware to bring the cache block at the address into the data cache for reading.",
      "syntax": "PREFETCH.R offset(rs1)",
      "encoding": {
        "format": "S-Type (Hint)",
        "binary_pattern": "00000 | 00001 | rs1 | 110 | imm | 0010011",
        "hex_opcode": "0x13",
        "visual_parts": [
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "00001",
            "clean": "00001"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "110",
            "clean": "110"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "0010011",
            "clean": "0010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rs1",
          "desc": "Base Address"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "Prefetch(D-Cache, Read, R[rs1] + offset);",
      "example": "PREFETCH.R 64(x10)",
      "example_note": "Prepare D-Cache for reading next cache line.",
      "slug": "prefetch_r",
      "rel_url": "risc-v/prefetch_r/",
      "linked_summary": "Hints to hardware to bring the cache block <a href=\"../../armv8-a/at_2/\">at</a> the address into the data cache for reading.",
      "linked_pseudocode": "Prefetch(D-Cache, Read, R[rs1] + offset);"
    },
    {
      "mnemonic": "PREFETCH.W",
      "architecture": "RISC-V",
      "extension": "Zicbop (Prefetch)",
      "full_name": "Prefetch Write",
      "summary": "Hints to hardware to bring the cache block at the address into the data cache for writing (exclusive ownership).",
      "syntax": "PREFETCH.W offset(rs1)",
      "encoding": {
        "format": "S-Type (Hint)",
        "binary_pattern": "00000 | 00011 | rs1 | 110 | imm | 0010011",
        "hex_opcode": "0x13",
        "visual_parts": [
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "00011",
            "clean": "00011"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "110",
            "clean": "110"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "0010011",
            "clean": "0010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rs1",
          "desc": "Base Address"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "Prefetch(D-Cache, Write, R[rs1] + offset);",
      "example": "PREFETCH.W 0(x10)",
      "example_note": "Prepare D-Cache for writing.",
      "slug": "prefetch_w",
      "rel_url": "risc-v/prefetch_w/",
      "linked_summary": "Hints to hardware to bring the cache block <a href=\"../../armv8-a/at_2/\">at</a> the address into the data cache for writing (exclusive ownership).",
      "linked_pseudocode": "Prefetch(D-Cache, Write, R[rs1] + offset);"
    },
    {
      "mnemonic": "DRET",
      "architecture": "RISC-V",
      "extension": "Privileged",
      "full_name": "Debug Return",
      "summary": "Returns from Debug Mode to the mode defined in the 'dcsr' register.",
      "syntax": "DRET",
      "encoding": {
        "format": "R-Type (System)",
        "binary_pattern": "0111101 | 10010 | 00000 | 000 | 00000 | 1110011",
        "hex_opcode": "0x73",
        "visual_parts": [
          {
            "raw": "0111101",
            "clean": "0111101"
          },
          {
            "raw": "10010",
            "clean": "10010"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "1110011",
            "clean": "1110011"
          }
        ]
      },
      "operands": [],
      "pseudocode": "PC = DPC; Priv = DCSR.prv;",
      "example": "DRET",
      "example_note": "Resume execution from debug break.",
      "slug": "dret",
      "rel_url": "risc-v/dret/",
      "linked_summary": "Returns from Debug Mode to the mode defined <a href=\"../../x86/in/\">in</a> the 'dcsr' register.",
      "linked_pseudocode": "PC = DPC; Priv = DCSR.prv;"
    },
    {
      "mnemonic": "VSETVLI",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Set VL Immediate",
      "summary": "Configures the vector length (vl) and vector type (vtype) based on application needs.",
      "syntax": "VSETVLI rd, rs1, vtypei",
      "encoding": {
        "format": "V-Type",
        "binary_pattern": "0 | zimm[10:0] | rs1 | 111 | rd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "zimm[10:0]",
            "clean": "zimm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "111",
            "clean": "111"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Actual VL)"
        },
        {
          "name": "rs1",
          "desc": "Req VL (Avail)"
        },
        {
          "name": "vtypei",
          "desc": "Config (SEW/LMUL)"
        }
      ],
      "pseudocode": "vl = set_config(rs1, vtypei); R[rd] = vl;",
      "example": "VSETVLI t0, a0, e32, m1, ta, ma",
      "example_note": "Request VL=a0, 32-bit elements, 1 register group.",
      "slug": "vsetvli",
      "rel_url": "risc-v/vsetvli/",
      "linked_summary": "Configures the vector length (vl) <a href=\"../../armv8-a/and_6/\">and</a> vector type (vtype) based on application needs.",
      "linked_pseudocode": "vl = set_config(rs1, vtypei); R[rd] = vl;"
    },
    {
      "mnemonic": "VLE32.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Load Element (32-bit)",
      "summary": "Loads a vector of 32-bit elements from memory into a vector register.",
      "syntax": "VLE32.V vd, (rs1), vm",
      "encoding": {
        "format": "V-Load",
        "binary_pattern": "000000 | mop | vm | rs1 | 110 | vd | 0000111",
        "hex_opcode": "0x07",
        "visual_parts": [
          {
            "raw": "000000",
            "clean": "000000"
          },
          {
            "raw": "mop",
            "clean": "mop"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "110",
            "clean": "110"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "0000111",
            "clean": "0000111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Vector Dest"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        },
        {
          "name": "vm",
          "desc": "Mask"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = Mem[rs1 + i*4];",
      "example": "VLE32.V v8, (a0)",
      "example_note": "Load 32-bit integers from address in a0 to v8.",
      "slug": "vle32_v",
      "rel_url": "risc-v/vle32_v/",
      "linked_summary": "Loads a vector of 32-<a href=\"../../armv8-a/bit/\">bit</a> elements from memory into a vector register.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = Mem[rs1 + i*4];"
    },
    {
      "mnemonic": "VSE32.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Store Element (32-bit)",
      "summary": "Stores a vector of 32-bit elements from a vector register to memory.",
      "syntax": "VSE32.V vs3, (rs1), vm",
      "encoding": {
        "format": "V-Store",
        "binary_pattern": "000000 | mop | vm | rs1 | 110 | vs3 | 0100111",
        "hex_opcode": "0x27",
        "visual_parts": [
          {
            "raw": "000000",
            "clean": "000000"
          },
          {
            "raw": "mop",
            "clean": "mop"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "110",
            "clean": "110"
          },
          {
            "raw": "vs3",
            "clean": "vs3"
          },
          {
            "raw": "0100111",
            "clean": "0100111"
          }
        ]
      },
      "operands": [
        {
          "name": "vs3",
          "desc": "Vector Source"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        },
        {
          "name": "vm",
          "desc": "Mask"
        }
      ],
      "pseudocode": "foreach(i < vl): Mem[rs1 + i*4] = vs3[i];",
      "example": "VSE32.V v8, (a0)",
      "example_note": "Store v8 to memory at a0.",
      "slug": "vse32_v",
      "rel_url": "risc-v/vse32_v/",
      "linked_summary": "Stores a vector of 32-<a href=\"../../armv8-a/bit/\">bit</a> elements from a vector register to memory.",
      "linked_pseudocode": "foreach(i < vl): Mem[rs1 + i*4] = vs3[i];"
    },
    {
      "mnemonic": "VADD.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Integer Add",
      "summary": "Adds elements of two vector registers.",
      "syntax": "VADD.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "000000 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "000000",
            "clean": "000000"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs1[i] + vs2[i];",
      "example": "VADD.VV v10, v8, v9",
      "example_note": "v10[i] = v8[i] + v9[i]",
      "slug": "vadd_vv",
      "rel_url": "risc-v/vadd_vv/",
      "linked_summary": "Adds elements of two vector registers.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = vs1[i] + vs2[i];"
    },
    {
      "mnemonic": "VMUL.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Integer Multiply",
      "summary": "Multiplies elements of two vector registers.",
      "syntax": "VMUL.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "100101 | vm | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "100101",
            "clean": "100101"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs1[i] * vs2[i];",
      "example": "VMUL.VV v10, v8, v9",
      "example_note": "v10[i] = v8[i] * v9[i]",
      "slug": "vmul_vv",
      "rel_url": "risc-v/vmul_vv/",
      "linked_summary": "Multiplies elements of two vector registers.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = vs1[i] * vs2[i];"
    },
    {
      "mnemonic": "CLZ",
      "architecture": "RISC-V",
      "extension": "Zbb (BitManip)",
      "full_name": "Count Leading Zeros",
      "summary": "Counts the number of 0 bits at the MSB end of the register.",
      "syntax": "CLZ rd, rs1",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "0110000 | 00000 | rs1 | 001 | rd | 0010011",
        "hex_opcode": "0x13",
        "visual_parts": [
          {
            "raw": "0110000",
            "clean": "0110000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0010011",
            "clean": "0010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        }
      ],
      "pseudocode": "int count = 0; while(rs1[XLEN-1-count] == 0) count++; R[rd] = count;",
      "example": "CLZ x10, x11",
      "example_note": "Find highest set bit index.",
      "slug": "clz",
      "rel_url": "risc-v/clz/",
      "linked_summary": "Counts the number of 0 bits <a href=\"../../armv8-a/at_2/\">at</a> the MSB end of the register.",
      "linked_pseudocode": "<a href=\"../../x86/int/\">int</a> count = 0; while(rs1[XLEN-1-count] == 0) count++; R[rd] = count;"
    },
    {
      "mnemonic": "CTZ",
      "architecture": "RISC-V",
      "extension": "Zbb (BitManip)",
      "full_name": "Count Trailing Zeros",
      "summary": "Counts the number of 0 bits at the LSB end of the register.",
      "syntax": "CTZ rd, rs1",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "0110000 | 00001 | rs1 | 001 | rd | 0010011",
        "hex_opcode": "0x13",
        "visual_parts": [
          {
            "raw": "0110000",
            "clean": "0110000"
          },
          {
            "raw": "00001",
            "clean": "00001"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0010011",
            "clean": "0010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        }
      ],
      "pseudocode": "int count = 0; while(rs1[count] == 0) count++; R[rd] = count;",
      "example": "CTZ x10, x11",
      "example_note": "Find lowest set bit index.",
      "slug": "ctz",
      "rel_url": "risc-v/ctz/",
      "linked_summary": "Counts the number of 0 bits <a href=\"../../armv8-a/at_2/\">at</a> the LSB end of the register.",
      "linked_pseudocode": "<a href=\"../../x86/int/\">int</a> count = 0; while(rs1[count] == 0) count++; R[rd] = count;"
    },
    {
      "mnemonic": "CPOP",
      "architecture": "RISC-V",
      "extension": "Zbb (BitManip)",
      "full_name": "Population Count",
      "summary": "Counts the number of set bits (1s) in the register.",
      "syntax": "CPOP rd, rs1",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "0110000 | 00010 | rs1 | 001 | rd | 0010011",
        "hex_opcode": "0x13",
        "visual_parts": [
          {
            "raw": "0110000",
            "clean": "0110000"
          },
          {
            "raw": "00010",
            "clean": "00010"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0010011",
            "clean": "0010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        }
      ],
      "pseudocode": "R[rd] = count_set_bits(R[rs1]);",
      "example": "CPOP x10, x11",
      "example_note": "Hamming weight calculation.",
      "slug": "cpop",
      "rel_url": "risc-v/cpop/",
      "linked_summary": "Counts the number of set bits (1s) <a href=\"../../x86/in/\">in</a> the register.",
      "linked_pseudocode": "R[rd] = count_set_bits(R[rs1]);"
    },
    {
      "mnemonic": "ANDN",
      "architecture": "RISC-V",
      "extension": "Zbb (BitManip)",
      "full_name": "AND Not",
      "summary": "Performs bitwise AND with the bitwise negation of rs2 (rs1 & ~rs2).",
      "syntax": "ANDN rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0100000 | rs2 | rs1 | 111 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0100000",
            "clean": "0100000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "111",
            "clean": "111"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source 1"
        },
        {
          "name": "rs2",
          "desc": "Source 2 (Inverted)"
        }
      ],
      "pseudocode": "R[rd] = R[rs1] & ~R[rs2];",
      "example": "ANDN x10, x11, x12",
      "example_note": "Clear bits in x11 that are set in x12.",
      "slug": "andn",
      "rel_url": "risc-v/andn/",
      "linked_summary": "Performs bitwise <a href=\"../../risc-v/and/\">AND</a> with the bitwise negation of rs2 (rs1 & ~rs2).",
      "linked_pseudocode": "R[rd] = R[rs1] & ~R[rs2];"
    },
    {
      "mnemonic": "ORN",
      "architecture": "RISC-V",
      "extension": "Zbb (BitManip)",
      "full_name": "OR Not",
      "summary": "Performs bitwise OR with the bitwise negation of rs2 (rs1 | ~rs2).",
      "syntax": "ORN rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0100000 | rs2 | rs1 | 110 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0100000",
            "clean": "0100000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "110",
            "clean": "110"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source 1"
        },
        {
          "name": "rs2",
          "desc": "Source 2 (Inverted)"
        }
      ],
      "pseudocode": "R[rd] = R[rs1] | ~R[rs2];",
      "example": "ORN x10, x11, x12",
      "example_note": "Set bits.",
      "slug": "orn",
      "rel_url": "risc-v/orn/",
      "linked_summary": "Performs bitwise <a href=\"../../risc-v/or/\">OR</a> with the bitwise negation of rs2 (rs1 | ~rs2).",
      "linked_pseudocode": "R[rd] = R[rs1] | ~R[rs2];"
    },
    {
      "mnemonic": "XNOR",
      "architecture": "RISC-V",
      "extension": "Zbb (BitManip)",
      "full_name": "Exclusive NOR",
      "summary": "Performs bitwise exclusive-NOR (rs1 ^ ~rs2).",
      "syntax": "XNOR rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0100000 | rs2 | rs1 | 100 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0100000",
            "clean": "0100000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source 1"
        },
        {
          "name": "rs2",
          "desc": "Source 2"
        }
      ],
      "pseudocode": "R[rd] = ~(R[rs1] ^ R[rs2]);",
      "example": "XNOR x10, x11, x12",
      "example_note": "Logical equivalence.",
      "slug": "xnor",
      "rel_url": "risc-v/xnor/",
      "linked_summary": "Performs bitwise exclusive-NOR (rs1 ^ ~rs2).",
      "linked_pseudocode": "R[rd] = ~(R[rs1] ^ R[rs2]);"
    },
    {
      "mnemonic": "ROL",
      "architecture": "RISC-V",
      "extension": "Zbb (BitManip)",
      "full_name": "Rotate Left",
      "summary": "Rotates the bits in rs1 left by the amount in rs2.",
      "syntax": "ROL rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0110000 | rs2 | rs1 | 001 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0110000",
            "clean": "0110000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        },
        {
          "name": "rs2",
          "desc": "Rotate Amount"
        }
      ],
      "pseudocode": "shamt = R[rs2] & (XLEN-1); R[rd] = (R[rs1] << shamt) | (R[rs1] >> (XLEN-shamt));",
      "example": "ROL x10, x11, x12",
      "example_note": "Bitwise rotation.",
      "slug": "rol",
      "rel_url": "risc-v/rol/",
      "linked_summary": "Rotates the bits <a href=\"../../x86/in/\">in</a> rs1 left by the amount <a href=\"../../x86/in/\">in</a> rs2.",
      "linked_pseudocode": "shamt = R[rs2] & (XLEN-1); R[rd] = (R[rs1] << shamt) | (R[rs1] >> (XLEN-shamt));"
    },
    {
      "mnemonic": "ROR",
      "architecture": "RISC-V",
      "extension": "Zbb (BitManip)",
      "full_name": "Rotate Right",
      "summary": "Rotates the bits in rs1 right by the amount in rs2.",
      "syntax": "ROR rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0110000 | rs2 | rs1 | 101 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0110000",
            "clean": "0110000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "101",
            "clean": "101"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        },
        {
          "name": "rs2",
          "desc": "Rotate Amount"
        }
      ],
      "pseudocode": "shamt = R[rs2] & (XLEN-1); R[rd] = (R[rs1] >> shamt) | (R[rs1] << (XLEN-shamt));",
      "example": "ROR x10, x11, x12",
      "example_note": "Bitwise rotation.",
      "slug": "ror",
      "rel_url": "risc-v/ror/",
      "linked_summary": "Rotates the bits <a href=\"../../x86/in/\">in</a> rs1 right by the amount <a href=\"../../x86/in/\">in</a> rs2.",
      "linked_pseudocode": "shamt = R[rs2] & (XLEN-1); R[rd] = (R[rs1] >> shamt) | (R[rs1] << (XLEN-shamt));"
    },
    {
      "mnemonic": "MAX",
      "architecture": "RISC-V",
      "extension": "Zbb (BitManip)",
      "full_name": "Maximum",
      "summary": "Computes the signed maximum of two registers.",
      "syntax": "MAX rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000101 | rs2 | rs1 | 110 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0000101",
            "clean": "0000101"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "110",
            "clean": "110"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source 1"
        },
        {
          "name": "rs2",
          "desc": "Source 2"
        }
      ],
      "pseudocode": "R[rd] = (R[rs1] >s R[rs2]) ? R[rs1] : R[rs2];",
      "example": "MAX x10, x11, x12",
      "example_note": "Signed Max.",
      "slug": "max",
      "rel_url": "risc-v/max/",
      "linked_summary": "Computes the signed maximum of two registers.",
      "linked_pseudocode": "R[rd] = (R[rs1] >s R[rs2]) ? R[rs1] : R[rs2];"
    },
    {
      "mnemonic": "MIN",
      "architecture": "RISC-V",
      "extension": "Zbb (BitManip)",
      "full_name": "Minimum",
      "summary": "Computes the signed minimum of two registers.",
      "syntax": "MIN rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000101 | rs2 | rs1 | 100 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0000101",
            "clean": "0000101"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source 1"
        },
        {
          "name": "rs2",
          "desc": "Source 2"
        }
      ],
      "pseudocode": "R[rd] = (R[rs1] <s R[rs2]) ? R[rs1] : R[rs2];",
      "example": "MIN x10, x11, x12",
      "example_note": "Signed Min.",
      "slug": "min",
      "rel_url": "risc-v/min/",
      "linked_summary": "Computes the signed minimum of two registers.",
      "linked_pseudocode": "R[rd] = (R[rs1] <s R[rs2]) ? R[rs1] : R[rs2];"
    },
    {
      "mnemonic": "SEX.B",
      "architecture": "RISC-V",
      "extension": "Zbb (BitManip)",
      "full_name": "Sign Extend Byte",
      "summary": "Sign-extends the lowest byte (8 bits) to XLEN bits.",
      "syntax": "SEX.B rd, rs1",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "0110000 | 00100 | rs1 | 001 | rd | 0010011",
        "hex_opcode": "0x13",
        "visual_parts": [
          {
            "raw": "0110000",
            "clean": "0110000"
          },
          {
            "raw": "00100",
            "clean": "00100"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0010011",
            "clean": "0010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        }
      ],
      "pseudocode": "R[rd] = sext(R[rs1][7:0]);",
      "example": "SEX.B x10, x11",
      "example_note": "Sign extend 8-bit value.",
      "slug": "sex_b",
      "rel_url": "risc-v/sex_b/",
      "linked_summary": "Sign-extends the lowest byte (8 bits) to XLEN bits.",
      "linked_pseudocode": "R[rd] = sext(R[rs1][7:0]);"
    },
    {
      "mnemonic": "SEX.H",
      "architecture": "RISC-V",
      "extension": "Zbb (BitManip)",
      "full_name": "Sign Extend Halfword",
      "summary": "Sign-extends the lowest halfword (16 bits) to XLEN bits.",
      "syntax": "SEX.H rd, rs1",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "0110000 | 00101 | rs1 | 001 | rd | 0010011",
        "hex_opcode": "0x13",
        "visual_parts": [
          {
            "raw": "0110000",
            "clean": "0110000"
          },
          {
            "raw": "00101",
            "clean": "00101"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0010011",
            "clean": "0010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        }
      ],
      "pseudocode": "R[rd] = sext(R[rs1][15:0]);",
      "example": "SEX.H x10, x11",
      "example_note": "Sign extend 16-bit value.",
      "slug": "sex_h",
      "rel_url": "risc-v/sex_h/",
      "linked_summary": "Sign-extends the lowest halfword (16 bits) to XLEN bits.",
      "linked_pseudocode": "R[rd] = sext(R[rs1][15:0]);"
    },
    {
      "mnemonic": "ZEXT.H",
      "architecture": "RISC-V",
      "extension": "Zbb (BitManip)",
      "full_name": "Zero Extend Halfword",
      "summary": "Zero-extends the lowest halfword (16 bits) to XLEN bits.",
      "syntax": "ZEXT.H rd, rs1",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "0000100 | 00000 | rs1 | 100 | rd | 0111011",
        "hex_opcode": "0x3B",
        "visual_parts": [
          {
            "raw": "0000100",
            "clean": "0000100"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0111011",
            "clean": "0111011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        }
      ],
      "pseudocode": "R[rd] = zext(R[rs1][15:0]);",
      "example": "ZEXT.H x10, x11",
      "example_note": "Zero extend 16-bit value.",
      "slug": "zext_h",
      "rel_url": "risc-v/zext_h/",
      "linked_summary": "Zero-extends the lowest halfword (16 bits) to XLEN bits.",
      "linked_pseudocode": "R[rd] = zext(R[rs1][15:0]);"
    },
    {
      "mnemonic": "ORC.B",
      "architecture": "RISC-V",
      "extension": "Zbb (BitManip)",
      "full_name": "Bitwise OR-Combine Byte",
      "summary": "Sets each byte of the result to 0xFF if the corresponding byte of the source is non-zero, else 0x00.",
      "syntax": "ORC.B rd, rs1",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "0010100 | 00111 | rs1 | 101 | rd | 0010011",
        "hex_opcode": "0x13",
        "visual_parts": [
          {
            "raw": "0010100",
            "clean": "0010100"
          },
          {
            "raw": "00111",
            "clean": "00111"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "101",
            "clean": "101"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0010011",
            "clean": "0010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        }
      ],
      "pseudocode": "For each byte i: R[rd].byte[i] = (R[rs1].byte[i] != 0) ? 0xFF : 0x00;",
      "example": "ORC.B x10, x11",
      "example_note": "Used for string processing (strlen, strcpy).",
      "slug": "orc_b",
      "rel_url": "risc-v/orc_b/",
      "linked_summary": "Sets each byte of the result to 0xFF if the corresponding byte of the source is non-<a href=\"../../armv9-a/zero_1/\">zero</a>, else 0x00.",
      "linked_pseudocode": "For each byte i: R[rd].byte[i] = (R[rs1].byte[i] != 0) ? 0xFF : 0x00;"
    },
    {
      "mnemonic": "REV8",
      "architecture": "RISC-V",
      "extension": "Zbb (BitManip)",
      "full_name": "Byte Reverse",
      "summary": "Reverses the order of bytes in a register (Endian swap).",
      "syntax": "REV8 rd, rs1",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "0110101 | 11000 | rs1 | 101 | rd | 0010011",
        "hex_opcode": "0x13",
        "visual_parts": [
          {
            "raw": "0110101",
            "clean": "0110101"
          },
          {
            "raw": "11000",
            "clean": "11000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "101",
            "clean": "101"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0010011",
            "clean": "0010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        }
      ],
      "pseudocode": "R[rd] = Byteswap(R[rs1]);",
      "example": "REV8 x10, x11",
      "example_note": "Converts Big-Endian to Little-Endian.",
      "slug": "rev8",
      "rel_url": "risc-v/rev8/",
      "linked_summary": "Reverses the order of bytes <a href=\"../../x86/in/\">in</a> a register (Endian swap).",
      "linked_pseudocode": "R[rd] = Byteswap(R[rs1]);"
    },
    {
      "mnemonic": "VWADD.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Widening Integer Add",
      "summary": "Adds N-bit elements to produce 2*N-bit results (Widening).",
      "syntax": "VWADD.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "110001 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "110001",
            "clean": "110001"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (2*SEW)"
        },
        {
          "name": "vs2",
          "desc": "Src 2 (SEW)"
        },
        {
          "name": "vs1",
          "desc": "Src 1 (SEW)"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = sext(vs1[i]) + sext(vs2[i]);",
      "slug": "vwadd_vv",
      "rel_url": "risc-v/vwadd_vv/",
      "linked_summary": "Adds N-<a href=\"../../armv8-a/bit/\">bit</a> elements to produce 2*N-<a href=\"../../armv8-a/bit/\">bit</a> results (Widening).",
      "linked_pseudocode": "foreach(i < vl): vd[i] = sext(vs1[i]) + sext(vs2[i]);"
    },
    {
      "mnemonic": "VWADDU.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Widening Integer Add Unsigned",
      "summary": "Adds unsigned N-bit elements to produce unsigned 2*N-bit results.",
      "syntax": "VWADDU.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "110000 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "110000",
            "clean": "110000"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (2*SEW)"
        },
        {
          "name": "vs2",
          "desc": "Src 2 (SEW)"
        },
        {
          "name": "vs1",
          "desc": "Src 1 (SEW)"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = zext(vs1[i]) + zext(vs2[i]);",
      "slug": "vwaddu_vv",
      "rel_url": "risc-v/vwaddu_vv/",
      "linked_summary": "Adds unsigned N-<a href=\"../../armv8-a/bit/\">bit</a> elements to produce unsigned 2*N-<a href=\"../../armv8-a/bit/\">bit</a> results.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = zext(vs1[i]) + zext(vs2[i]);"
    },
    {
      "mnemonic": "VWSUB.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Widening Integer Subtract",
      "summary": "Subtracts N-bit elements to produce 2*N-bit results.",
      "syntax": "VWSUB.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "110011 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "110011",
            "clean": "110011"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (2*SEW)"
        },
        {
          "name": "vs2",
          "desc": "Src 2 (SEW)"
        },
        {
          "name": "vs1",
          "desc": "Src 1 (SEW)"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = sext(vs2[i]) - sext(vs1[i]);",
      "slug": "vwsub_vv",
      "rel_url": "risc-v/vwsub_vv/",
      "linked_summary": "Subtracts N-<a href=\"../../armv8-a/bit/\">bit</a> elements to produce 2*N-<a href=\"../../armv8-a/bit/\">bit</a> results.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = sext(vs2[i]) - sext(vs1[i]);"
    },
    {
      "mnemonic": "VWMUL.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Widening Integer Multiply",
      "summary": "Multiplies N-bit elements to produce 2*N-bit results.",
      "syntax": "VWMUL.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "111011 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "111011",
            "clean": "111011"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (2*SEW)"
        },
        {
          "name": "vs2",
          "desc": "Src 2 (SEW)"
        },
        {
          "name": "vs1",
          "desc": "Src 1 (SEW)"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = sext(vs2[i]) * sext(vs1[i]);",
      "slug": "vwmul_vv",
      "rel_url": "risc-v/vwmul_vv/",
      "linked_summary": "Multiplies N-<a href=\"../../armv8-a/bit/\">bit</a> elements to produce 2*N-<a href=\"../../armv8-a/bit/\">bit</a> results.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = sext(vs2[i]) * sext(vs1[i]);"
    },
    {
      "mnemonic": "VNSRL.WX",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Narrowing Shift Right Logical",
      "summary": "Shifts 2*N-bit elements right and narrows the result to N-bits.",
      "syntax": "VNSRL.WX vd, vs2, rs1, vm",
      "encoding": {
        "format": "OPIVX",
        "binary_pattern": "101100 | vm | vs2 | rs1 | 100 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "101100",
            "clean": "101100"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (SEW)"
        },
        {
          "name": "vs2",
          "desc": "Src Vector (2*SEW)"
        },
        {
          "name": "rs1",
          "desc": "Shift Amount"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = (vs2[i] >> rs1) & Mask(SEW);",
      "slug": "vnsrl_wx",
      "rel_url": "risc-v/vnsrl_wx/",
      "linked_summary": "Shifts 2*N-<a href=\"../../armv8-a/bit/\">bit</a> elements right <a href=\"../../armv8-a/and_6/\">and</a> narrows the result to N-bits.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = (vs2[i] >> rs1) & Mask(SEW);"
    },
    {
      "mnemonic": "VNSRA.WX",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Narrowing Shift Right Arithmetic",
      "summary": "Arithmetically shifts 2*N-bit elements right and narrows to N-bits.",
      "syntax": "VNSRA.WX vd, vs2, rs1, vm",
      "encoding": {
        "format": "OPIVX",
        "binary_pattern": "101101 | vm | vs2 | rs1 | 100 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "101101",
            "clean": "101101"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (SEW)"
        },
        {
          "name": "vs2",
          "desc": "Src Vector (2*SEW)"
        },
        {
          "name": "rs1",
          "desc": "Shift Amount"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = (vs2[i] >>s rs1) & Mask(SEW);",
      "slug": "vnsra_wx",
      "rel_url": "risc-v/vnsra_wx/",
      "linked_summary": "Arithmetically shifts 2*N-<a href=\"../../armv8-a/bit/\">bit</a> elements right <a href=\"../../armv8-a/and_6/\">and</a> narrows to N-bits.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = (vs2[i] >>s rs1) & Mask(SEW);"
    },
    {
      "mnemonic": "VMERGE.VVM",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Merge",
      "summary": "Merges two vectors based on the mask (if mask=0, pick vs2; if mask=1, pick vs1).",
      "syntax": "VMERGE.VVM vd, vs2, vs1, v0",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "010111 | 0 | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010111",
            "clean": "010111"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "False Src"
        },
        {
          "name": "vs1",
          "desc": "True Src"
        },
        {
          "name": "v0",
          "desc": "Mask"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = v0[i] ? vs1[i] : vs2[i];",
      "slug": "vmerge_vvm",
      "rel_url": "risc-v/vmerge_vvm/",
      "linked_summary": "Merges two vectors based on the mask (if mask=0, pick vs2; if mask=1, pick vs1).",
      "linked_pseudocode": "foreach(i < vl): vd[i] = v0[i] ? vs1[i] : vs2[i];"
    },
    {
      "mnemonic": "VMV.V.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Move",
      "summary": "Copies a vector register.",
      "syntax": "VMV.V.V vd, vs1",
      "encoding": {
        "format": "Pseudo",
        "binary_pattern": "VADDI.VI vd, vs1, 0",
        "hex_opcode": "See VADDI",
        "visual_parts": [
          {
            "raw": "VADDI.VI vd, vs1, 0",
            "clean": "VADDI.VI vd, vs1, 0"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs1",
          "desc": "Source"
        }
      ],
      "pseudocode": "vd = vs1;",
      "slug": "vmv_v_v",
      "rel_url": "risc-v/vmv_v_v/",
      "linked_summary": "Copies a vector register.",
      "linked_pseudocode": "vd = vs1;"
    },
    {
      "mnemonic": "VMV.X.S",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Move Scalar to Integer",
      "summary": "Copies element 0 of a vector to an integer register.",
      "syntax": "VMV.X.S rd, vs2",
      "encoding": {
        "format": "OPMVX",
        "binary_pattern": "010000 | 1 | vs2 | 00000 | 010 | rd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010000",
            "clean": "010000"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Int)"
        },
        {
          "name": "vs2",
          "desc": "Source (Vector)"
        }
      ],
      "pseudocode": "rd = vs2[0];",
      "slug": "vmv_x_s",
      "rel_url": "risc-v/vmv_x_s/",
      "linked_summary": "Copies element 0 of a vector to an integer register.",
      "linked_pseudocode": "rd = vs2[0];"
    },
    {
      "mnemonic": "VMV.S.X",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Move Integer to Scalar",
      "summary": "Copies an integer register to element 0 of a vector.",
      "syntax": "VMV.S.X vd, rs1",
      "encoding": {
        "format": "OPMVX",
        "binary_pattern": "010000 | 1 | 00000 | rs1 | 110 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010000",
            "clean": "010000"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "110",
            "clean": "110"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (Vector)"
        },
        {
          "name": "rs1",
          "desc": "Source (Int)"
        }
      ],
      "pseudocode": "vd[0] = rs1;",
      "slug": "vmv_s_x",
      "rel_url": "risc-v/vmv_s_x/",
      "linked_summary": "Copies an integer register to element 0 of a vector.",
      "linked_pseudocode": "vd[0] = rs1;"
    },
    {
      "mnemonic": "VMFEQ.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Float Equal",
      "summary": "Compares float vectors for equality, writing result to mask register.",
      "syntax": "VMFEQ.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPFVV",
        "binary_pattern": "011000 | vm | vs2 | vs1 | 001 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "011000",
            "clean": "011000"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest Mask"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = (vs2[i] == vs1[i]) ? 1 : 0;",
      "slug": "vmfeq_vv",
      "rel_url": "risc-v/vmfeq_vv/",
      "linked_summary": "Compares float vectors for equality, writing result to mask register.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = (vs2[i] == vs1[i]) ? 1 : 0;"
    },
    {
      "mnemonic": "VMFLE.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Float Less or Equal",
      "summary": "Compares float vectors (vs2 <= vs1), writing result to mask register.",
      "syntax": "VMFLE.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPFVV",
        "binary_pattern": "011001 | vm | vs2 | vs1 | 001 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "011001",
            "clean": "011001"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest Mask"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = (vs2[i] <= vs1[i]) ? 1 : 0;",
      "slug": "vmfle_vv",
      "rel_url": "risc-v/vmfle_vv/",
      "linked_summary": "Compares float vectors (vs2 <= vs1), writing result to mask register.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = (vs2[i] <= vs1[i]) ? 1 : 0;"
    },
    {
      "mnemonic": "VMFLT.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Float Less Than",
      "summary": "Compares float vectors (vs2 < vs1), writing result to mask register.",
      "syntax": "VMFLT.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPFVV",
        "binary_pattern": "011011 | vm | vs2 | vs1 | 001 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "011011",
            "clean": "011011"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest Mask"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = (vs2[i] < vs1[i]) ? 1 : 0;",
      "slug": "vmflt_vv",
      "rel_url": "risc-v/vmflt_vv/",
      "linked_summary": "Compares float vectors (vs2 < vs1), writing result to mask register.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = (vs2[i] < vs1[i]) ? 1 : 0;"
    },
    {
      "mnemonic": "VFCLASS.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Float Classify",
      "summary": "Classifies elements of a float vector (NaN, Inf, etc.).",
      "syntax": "VFCLASS.V vd, vs2, vm",
      "encoding": {
        "format": "OPFVV",
        "binary_pattern": "010011 | vm | vs2 | 10000 | 001 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010011",
            "clean": "010011"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "10000",
            "clean": "10000"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (Mask Bits)"
        },
        {
          "name": "vs2",
          "desc": "Src Vector"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = classify(vs2[i]);",
      "slug": "vfclass_v",
      "rel_url": "risc-v/vfclass_v/",
      "linked_summary": "Classifies elements of a float vector (NaN, Inf, etc.).",
      "linked_pseudocode": "foreach(i < vl): vd[i] = classify(vs2[i]);"
    },
    {
      "mnemonic": "VFMV.F.S",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Move Float to Scalar",
      "summary": "Moves element 0 of a float vector to a scalar float register.",
      "syntax": "VFMV.F.S fd, vs2",
      "encoding": {
        "format": "OPFVW",
        "binary_pattern": "001100 | 1 | vs2 | 00000 | 001 | fd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "001100",
            "clean": "001100"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "fd",
            "clean": "fd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "fd",
          "desc": "Dest (Float)"
        },
        {
          "name": "vs2",
          "desc": "Src Vector"
        }
      ],
      "pseudocode": "fd = vs2[0];",
      "slug": "vfmv_f_s",
      "rel_url": "risc-v/vfmv_f_s/",
      "linked_summary": "Moves element 0 of a float vector to a scalar float register.",
      "linked_pseudocode": "fd = vs2[0];"
    },
    {
      "mnemonic": "VFMV.S.F",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Move Scalar to Float",
      "summary": "Moves a scalar float register to element 0 of a vector.",
      "syntax": "VFMV.S.F vd, fs1",
      "encoding": {
        "format": "OPFVW",
        "binary_pattern": "001101 | 1 | 00000 | fs1 | 101 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "001101",
            "clean": "001101"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "fs1",
            "clean": "fs1"
          },
          {
            "raw": "101",
            "clean": "101"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest Vector"
        },
        {
          "name": "fs1",
          "desc": "Src Float"
        }
      ],
      "pseudocode": "vd[0] = fs1;",
      "slug": "vfmv_s_f",
      "rel_url": "risc-v/vfmv_s_f/",
      "linked_summary": "Moves a scalar float register to element 0 of a vector.",
      "linked_pseudocode": "vd[0] = fs1;"
    },
    {
      "mnemonic": "FLI.S",
      "architecture": "RISC-V",
      "extension": "Zfa (Float Automation)",
      "full_name": "Float Load Immediate (Single)",
      "summary": "Loads a common floating-point constant (e.g., 1.0, 0.5, PI) into a register from a small table.",
      "syntax": "FLI.S rd, rs1",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "1111000 | 00001 | rs1 | 000 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1111000",
            "clean": "1111000"
          },
          {
            "raw": "00001",
            "clean": "00001"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Constant Index"
        }
      ],
      "pseudocode": "F[rd] = FloatTable[rs1];",
      "slug": "fli_s",
      "rel_url": "risc-v/fli_s/",
      "linked_summary": "Loads a common floating-point constant (e.g., 1.0, 0.5, PI) into a register from a small table.",
      "linked_pseudocode": "F[rd] = FloatTable[rs1];"
    },
    {
      "mnemonic": "FLI.D",
      "architecture": "RISC-V",
      "extension": "Zfa (Float Automation)",
      "full_name": "Float Load Immediate (Double)",
      "summary": "Loads a common double-precision constant into a register.",
      "syntax": "FLI.D rd, rs1",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "1111001 | 00001 | rs1 | 000 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1111001",
            "clean": "1111001"
          },
          {
            "raw": "00001",
            "clean": "00001"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Constant Index"
        }
      ],
      "pseudocode": "F[rd] = DoubleTable[rs1];",
      "slug": "fli_d",
      "rel_url": "risc-v/fli_d/",
      "linked_summary": "Loads a common double-precision constant into a register.",
      "linked_pseudocode": "F[rd] = DoubleTable[rs1];"
    },
    {
      "mnemonic": "FLI.H",
      "architecture": "RISC-V",
      "extension": "Zfa (Float Automation)",
      "full_name": "Float Load Immediate (Half)",
      "summary": "Loads a common half-precision constant into a register.",
      "syntax": "FLI.H rd, rs1",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "1111000 | 00001 | rs1 | 000 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1111000",
            "clean": "1111000"
          },
          {
            "raw": "00001",
            "clean": "00001"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Constant Index"
        }
      ],
      "pseudocode": "F[rd] = HalfTable[rs1];",
      "slug": "fli_h",
      "rel_url": "risc-v/fli_h/",
      "linked_summary": "Loads a common half-precision constant into a register.",
      "linked_pseudocode": "F[rd] = HalfTable[rs1];"
    },
    {
      "mnemonic": "FMINM.S",
      "architecture": "RISC-V",
      "extension": "Zfa (Float Automation)",
      "full_name": "Float Minimum (IEEE 754-2019)",
      "summary": "Minimum of two floats, treating -0.0 as smaller than +0.0 (canonicalize NaNs).",
      "syntax": "FMINM.S rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0010100 | rs2 | rs1 | 010 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0010100",
            "clean": "0010100"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        }
      ],
      "pseudocode": "F[rd] = minNum(F[rs1], F[rs2]);",
      "slug": "fminm_s",
      "rel_url": "risc-v/fminm_s/",
      "linked_summary": "Minimum of two floats, treating -0.0 as smaller than +0.0 (canonicalize NaNs).",
      "linked_pseudocode": "F[rd] = minNum(F[rs1], F[rs2]);"
    },
    {
      "mnemonic": "FMAXM.S",
      "architecture": "RISC-V",
      "extension": "Zfa (Float Automation)",
      "full_name": "Float Maximum (IEEE 754-2019)",
      "summary": "Maximum of two floats, treating +0.0 as larger than -0.0.",
      "syntax": "FMAXM.S rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0010100 | rs2 | rs1 | 011 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0010100",
            "clean": "0010100"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        }
      ],
      "pseudocode": "F[rd] = maxNum(F[rs1], F[rs2]);",
      "slug": "fmaxm_s",
      "rel_url": "risc-v/fmaxm_s/",
      "linked_summary": "Maximum of two floats, treating +0.0 as larger than -0.0.",
      "linked_pseudocode": "F[rd] = maxNum(F[rs1], F[rs2]);"
    },
    {
      "mnemonic": "FROUND.S",
      "architecture": "RISC-V",
      "extension": "Zfa (Float Automation)",
      "full_name": "Float Round to Integer",
      "summary": "Rounds a float to the nearest integer value (returned as a float).",
      "syntax": "FROUND.S rd, rs1, rm",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "0100000 | 00100 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0100000",
            "clean": "0100000"
          },
          {
            "raw": "00100",
            "clean": "00100"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src"
        },
        {
          "name": "rm",
          "desc": "Mode"
        }
      ],
      "pseudocode": "F[rd] = round(F[rs1]);",
      "slug": "fround_s",
      "rel_url": "risc-v/fround_s/",
      "linked_summary": "Rounds a float to the nearest integer value (returned as a float).",
      "linked_pseudocode": "F[rd] = round(F[rs1]);"
    },
    {
      "mnemonic": "AMOCAS.W",
      "architecture": "RISC-V",
      "extension": "Zacas (Atomic CAS)",
      "full_name": "Atomic Compare and Swap Word",
      "summary": "Atomically compares memory at rs1 with rd; if equal, writes rs2 to memory. Returns original value in rd.",
      "syntax": "AMOCAS.W rd, rs2, (rs1)",
      "encoding": {
        "format": "R-Type (Atomic)",
        "binary_pattern": "00101 | 1 | 0 | rs2 | rs1 | 010 | rd | 0101111",
        "hex_opcode": "0x2F",
        "visual_parts": [
          {
            "raw": "00101",
            "clean": "00101"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0101111",
            "clean": "0101111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest/Compare"
        },
        {
          "name": "rs2",
          "desc": "Swap Value"
        },
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "atomic { if(M[rs1]==R[rd]) M[rs1]=R[rs2]; R[rd]=M[rs1]; }",
      "slug": "amocas_w",
      "rel_url": "risc-v/amocas_w/",
      "linked_summary": "Atomically compares memory <a href=\"../../armv8-a/at_2/\">at</a> rs1 with rd; if equal, writes rs2 to memory. Returns original value <a href=\"../../x86/in/\">in</a> rd.",
      "linked_pseudocode": "atomic { if(M[rs1]==R[rd]) M[rs1]=R[rs2]; R[rd]=M[rs1]; }"
    },
    {
      "mnemonic": "AMOCAS.D",
      "architecture": "RISC-V",
      "extension": "Zacas (Atomic CAS)",
      "full_name": "Atomic Compare and Swap Doubleword",
      "summary": "Atomically compares 64-bit memory at rs1 with rd; if equal, writes rs2 to memory.",
      "syntax": "AMOCAS.D rd, rs2, (rs1)",
      "encoding": {
        "format": "R-Type (Atomic)",
        "binary_pattern": "00101 | 1 | 0 | rs2 | rs1 | 011 | rd | 0101111",
        "hex_opcode": "0x2F",
        "visual_parts": [
          {
            "raw": "00101",
            "clean": "00101"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0101111",
            "clean": "0101111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest/Compare"
        },
        {
          "name": "rs2",
          "desc": "Swap Value"
        },
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "atomic { if(M[rs1]==R[rd]) M[rs1]=R[rs2]; R[rd]=M[rs1]; }",
      "slug": "amocas_d",
      "rel_url": "risc-v/amocas_d/",
      "linked_summary": "Atomically compares 64-<a href=\"../../armv8-a/bit/\">bit</a> memory <a href=\"../../armv8-a/at_2/\">at</a> rs1 with rd; if equal, writes rs2 to memory.",
      "linked_pseudocode": "atomic { if(M[rs1]==R[rd]) M[rs1]=R[rs2]; R[rd]=M[rs1]; }"
    },
    {
      "mnemonic": "C.MUL",
      "architecture": "RISC-V",
      "extension": "Zcb (Compressed)",
      "full_name": "Compressed Multiply",
      "summary": "Performs 32-bit multiplication (rd = rd * rs2) in 16-bit encoding.",
      "syntax": "C.MUL rd&#x27;, rs2&#x27;",
      "encoding": {
        "format": "CA",
        "binary_pattern": "100111 | rd' | 10 | rs2' | 01",
        "hex_opcode": "01",
        "visual_parts": [
          {
            "raw": "100111",
            "clean": "100111"
          },
          {
            "raw": "rd'",
            "clean": "rd'"
          },
          {
            "raw": "10",
            "clean": "10"
          },
          {
            "raw": "rs2'",
            "clean": "rs2'"
          },
          {
            "raw": "01",
            "clean": "01"
          }
        ]
      },
      "operands": [
        {
          "name": "rd'",
          "desc": "Dest/Src1"
        },
        {
          "name": "rs2'",
          "desc": "Src2"
        }
      ],
      "pseudocode": "R[rd'] = R[rd'] * R[rs2'];",
      "slug": "c_mul",
      "rel_url": "risc-v/c_mul/",
      "linked_summary": "Performs 32-<a href=\"../../armv8-a/bit/\">bit</a> multiplication (rd = rd * rs2) <a href=\"../../x86/in/\">in</a> 16-<a href=\"../../armv8-a/bit/\">bit</a> encoding.",
      "linked_pseudocode": "R[rd'] = R[rd'] * R[rs2'];"
    },
    {
      "mnemonic": "C.ZEXT.B",
      "architecture": "RISC-V",
      "extension": "Zcb (Compressed)",
      "full_name": "Compressed Zero Extend Byte",
      "summary": "Zero extends the lowest byte of rd' to XLEN.",
      "syntax": "C.ZEXT.B rd&#x27;",
      "encoding": {
        "format": "CR",
        "binary_pattern": "100111 | rd' | 11 | 000 | 01",
        "hex_opcode": "01",
        "visual_parts": [
          {
            "raw": "100111",
            "clean": "100111"
          },
          {
            "raw": "rd'",
            "clean": "rd'"
          },
          {
            "raw": "11",
            "clean": "11"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "01",
            "clean": "01"
          }
        ]
      },
      "operands": [
        {
          "name": "rd'",
          "desc": "Dest/Src"
        }
      ],
      "pseudocode": "R[rd'] = zext(R[rd'][7:0]);",
      "slug": "c_zext_b",
      "rel_url": "risc-v/c_zext_b/",
      "linked_summary": "Zero extends the lowest byte of rd' to XLEN.",
      "linked_pseudocode": "R[rd'] = zext(R[rd'][7:0]);"
    },
    {
      "mnemonic": "C.SEXT.B",
      "architecture": "RISC-V",
      "extension": "Zcb (Compressed)",
      "full_name": "Compressed Sign Extend Byte",
      "summary": "Sign extends the lowest byte of rd' to XLEN.",
      "syntax": "C.SEXT.B rd&#x27;",
      "encoding": {
        "format": "CR",
        "binary_pattern": "100111 | rd' | 11 | 001 | 01",
        "hex_opcode": "01",
        "visual_parts": [
          {
            "raw": "100111",
            "clean": "100111"
          },
          {
            "raw": "rd'",
            "clean": "rd'"
          },
          {
            "raw": "11",
            "clean": "11"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "01",
            "clean": "01"
          }
        ]
      },
      "operands": [
        {
          "name": "rd'",
          "desc": "Dest/Src"
        }
      ],
      "pseudocode": "R[rd'] = sext(R[rd'][7:0]);",
      "slug": "c_sext_b",
      "rel_url": "risc-v/c_sext_b/",
      "linked_summary": "Sign extends the lowest byte of rd' to XLEN.",
      "linked_pseudocode": "R[rd'] = sext(R[rd'][7:0]);"
    },
    {
      "mnemonic": "C.NOT",
      "architecture": "RISC-V",
      "extension": "Zcb (Compressed)",
      "full_name": "Compressed Bitwise NOT",
      "summary": "Computes bitwise logical negation.",
      "syntax": "C.NOT rd&#x27;",
      "encoding": {
        "format": "CR",
        "binary_pattern": "100111 | rd' | 11 | 101 | 01",
        "hex_opcode": "01",
        "visual_parts": [
          {
            "raw": "100111",
            "clean": "100111"
          },
          {
            "raw": "rd'",
            "clean": "rd'"
          },
          {
            "raw": "11",
            "clean": "11"
          },
          {
            "raw": "101",
            "clean": "101"
          },
          {
            "raw": "01",
            "clean": "01"
          }
        ]
      },
      "operands": [
        {
          "name": "rd'",
          "desc": "Dest/Src"
        }
      ],
      "pseudocode": "R[rd'] = ~R[rd'];",
      "slug": "c_not",
      "rel_url": "risc-v/c_not/",
      "linked_summary": "Computes bitwise logical negation.",
      "linked_pseudocode": "R[rd'] = ~R[rd'];"
    },
    {
      "mnemonic": "SM4ED",
      "architecture": "RISC-V",
      "extension": "Zks (Scalar Crypto)",
      "full_name": "SM4 Encryption/Decryption",
      "summary": "Accelerates the SM4 block cipher (encryption/decryption round).",
      "syntax": "SM4ED rd, rs1, rs2, bs",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "110000 | bs | rs2 | rs1 | 000 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "110000",
            "clean": "110000"
          },
          {
            "raw": "bs",
            "clean": "bs"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        },
        {
          "name": "bs",
          "desc": "Byte Select"
        }
      ],
      "pseudocode": "rd = SM4_Round(rs1, rs2, bs);",
      "slug": "sm4ed",
      "rel_url": "risc-v/sm4ed/",
      "linked_summary": "Accelerates the SM4 block cipher (encryption/decryption round).",
      "linked_pseudocode": "rd = SM4_Round(rs1, rs2, bs);"
    },
    {
      "mnemonic": "SM4KS",
      "architecture": "RISC-V",
      "extension": "Zks (Scalar Crypto)",
      "full_name": "SM4 Key Schedule",
      "summary": "Accelerates the SM4 key schedule generation.",
      "syntax": "SM4KS rd, rs1, rs2, bs",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "110100 | bs | rs2 | rs1 | 000 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "110100",
            "clean": "110100"
          },
          {
            "raw": "bs",
            "clean": "bs"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        },
        {
          "name": "bs",
          "desc": "Byte Select"
        }
      ],
      "pseudocode": "rd = SM4_KeyGen(rs1, rs2, bs);",
      "slug": "sm4ks",
      "rel_url": "risc-v/sm4ks/",
      "linked_summary": "Accelerates the SM4 key schedule generation.",
      "linked_pseudocode": "rd = SM4_KeyGen(rs1, rs2, bs);"
    },
    {
      "mnemonic": "SM3P0",
      "architecture": "RISC-V",
      "extension": "Zks (Scalar Crypto)",
      "full_name": "SM3 P0 Transformation",
      "summary": "Performs the P0 permutation for the SM3 hash algorithm.",
      "syntax": "SM3P0 rd, rs1",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0001000 | 01000 | rs1 | 001 | rd | 0010011",
        "hex_opcode": "0x13",
        "visual_parts": [
          {
            "raw": "0001000",
            "clean": "0001000"
          },
          {
            "raw": "01000",
            "clean": "01000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0010011",
            "clean": "0010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src"
        }
      ],
      "pseudocode": "rd = P0(rs1);",
      "slug": "sm3p0",
      "rel_url": "risc-v/sm3p0/",
      "linked_summary": "Performs the P0 permutation for the SM3 hash algorithm.",
      "linked_pseudocode": "rd = P0(rs1);"
    },
    {
      "mnemonic": "SM3P1",
      "architecture": "RISC-V",
      "extension": "Zks (Scalar Crypto)",
      "full_name": "SM3 P1 Transformation",
      "summary": "Performs the P1 permutation for the SM3 hash algorithm.",
      "syntax": "SM3P1 rd, rs1",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0001000 | 01001 | rs1 | 001 | rd | 0010011",
        "hex_opcode": "0x13",
        "visual_parts": [
          {
            "raw": "0001000",
            "clean": "0001000"
          },
          {
            "raw": "01001",
            "clean": "01001"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0010011",
            "clean": "0010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src"
        }
      ],
      "pseudocode": "rd = P1(rs1);",
      "slug": "sm3p1",
      "rel_url": "risc-v/sm3p1/",
      "linked_summary": "Performs the P1 permutation for the SM3 hash algorithm.",
      "linked_pseudocode": "rd = P1(rs1);"
    },
    {
      "mnemonic": "CM.PUSH",
      "architecture": "RISC-V",
      "extension": "Zcmp (Code Size)",
      "full_name": "Push Registers",
      "summary": "Pushes multiple registers (ra, s0-s11) to the stack and adjusts sp. Critical for small code size.",
      "syntax": "CM.PUSH {reg_list}, -stack_adj",
      "encoding": {
        "format": "Push/Pop",
        "binary_pattern": "1011100 | rlist | spimm | 10",
        "hex_opcode": "0x02",
        "visual_parts": [
          {
            "raw": "1011100",
            "clean": "1011100"
          },
          {
            "raw": "rlist",
            "clean": "rlist"
          },
          {
            "raw": "spimm",
            "clean": "spimm"
          },
          {
            "raw": "10",
            "clean": "10"
          }
        ]
      },
      "operands": [
        {
          "name": "rlist",
          "desc": "Register List"
        },
        {
          "name": "stack_adj",
          "desc": "Stack Adjustment"
        }
      ],
      "pseudocode": "SP -= adj; Mem[SP] = {regs};",
      "slug": "cm_push",
      "rel_url": "risc-v/cm_push/",
      "linked_summary": "Pushes multiple registers (ra, s0-s11) to the stack <a href=\"../../armv8-a/and_6/\">and</a> adjusts sp. Critical for small code size.",
      "linked_pseudocode": "SP -= adj; Mem[SP] = {regs};"
    },
    {
      "mnemonic": "CM.POP",
      "architecture": "RISC-V",
      "extension": "Zcmp (Code Size)",
      "full_name": "Pop Registers",
      "summary": "Pops multiple registers from the stack and restores sp.",
      "syntax": "CM.POP {reg_list}, stack_adj",
      "encoding": {
        "format": "Push/Pop",
        "binary_pattern": "1011101 | rlist | spimm | 10",
        "hex_opcode": "0x02",
        "visual_parts": [
          {
            "raw": "1011101",
            "clean": "1011101"
          },
          {
            "raw": "rlist",
            "clean": "rlist"
          },
          {
            "raw": "spimm",
            "clean": "spimm"
          },
          {
            "raw": "10",
            "clean": "10"
          }
        ]
      },
      "operands": [
        {
          "name": "rlist",
          "desc": "Register List"
        },
        {
          "name": "stack_adj",
          "desc": "Stack Adjustment"
        }
      ],
      "pseudocode": "{regs} = Mem[SP]; SP += adj;",
      "slug": "cm_pop",
      "rel_url": "risc-v/cm_pop/",
      "linked_summary": "Pops multiple registers from the stack <a href=\"../../armv8-a/and_6/\">and</a> restores sp.",
      "linked_pseudocode": "{regs} = Mem[SP]; SP += adj;"
    },
    {
      "mnemonic": "VSETVL",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Set VL",
      "summary": "Sets the vector length (VL) based on the application vector length (AVL) in rs1 and configuration in rs2.",
      "syntax": "VSETVL rd, rs1, rs2",
      "encoding": {
        "format": "V-Type",
        "binary_pattern": "1000000 | rs2 | rs1 | 111 | rd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "1000000",
            "clean": "1000000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "111",
            "clean": "111"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (New VL)"
        },
        {
          "name": "rs1",
          "desc": "AVL"
        },
        {
          "name": "rs2",
          "desc": "Config (VTYPE)"
        }
      ],
      "pseudocode": "vl = set_config(rs1, rs2); R[rd] = vl;",
      "slug": "vsetvl",
      "rel_url": "risc-v/vsetvl/",
      "linked_summary": "Sets the vector length (VL) based on the application vector length (AVL) <a href=\"../../x86/in/\">in</a> rs1 <a href=\"../../armv8-a/and_6/\">and</a> configuration <a href=\"../../x86/in/\">in</a> rs2.",
      "linked_pseudocode": "vl = set_config(rs1, rs2); R[rd] = vl;"
    },
    {
      "mnemonic": "CBO.ZERO",
      "architecture": "RISC-V",
      "extension": "Zicboz",
      "full_name": "Cache Block Zero",
      "summary": "Zeros a cache block corresponding to the address in rs1.",
      "syntax": "CBO.ZERO (rs1)",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "000000000100 | rs1 | 010 | 00000 | 0001111",
        "hex_opcode": "0x0F",
        "visual_parts": [
          {
            "raw": "000000000100",
            "clean": "000000000100"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "0001111",
            "clean": "0001111"
          }
        ]
      },
      "operands": [
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "memset(BlockAddr(rs1), 0, BlockSize);",
      "slug": "cbo_zero",
      "rel_url": "risc-v/cbo_zero/",
      "linked_summary": "Zeros a cache block corresponding to the address <a href=\"../../x86/in/\">in</a> rs1.",
      "linked_pseudocode": "memset(BlockAddr(rs1), 0, BlockSize);"
    },
    {
      "mnemonic": "FCVT.W.S",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Float Convert to Word (Single)",
      "summary": "Converts a single-precision floating-point number to a signed 32-bit integer.",
      "syntax": "FCVT.W.S rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "1100000 | 00000 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1100000",
            "clean": "1100000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Integer)"
        },
        {
          "name": "rs1",
          "desc": "Source (Float)"
        }
      ],
      "pseudocode": "R[rd] = sext(f32_to_i32(F[rs1]));",
      "example": "FCVT.W.S x10, f1",
      "example_note": "Convert float f1 to int x10.",
      "slug": "fcvt_w_s",
      "rel_url": "risc-v/fcvt_w_s/",
      "linked_summary": "Converts a single-precision floating-point number to a signed 32-<a href=\"../../armv8-a/bit/\">bit</a> integer.",
      "linked_pseudocode": "R[rd] = sext(f32_to_i32(F[rs1]));"
    },
    {
      "mnemonic": "FCVT.S.W",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Float Convert from Word (Single)",
      "summary": "Converts a signed 32-bit integer to a single-precision floating-point number.",
      "syntax": "FCVT.S.W rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "1101000 | 00000 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1101000",
            "clean": "1101000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Float)"
        },
        {
          "name": "rs1",
          "desc": "Source (Integer)"
        }
      ],
      "pseudocode": "F[rd] = i32_to_f32(R[rs1]);",
      "example": "FCVT.S.W f1, x10",
      "example_note": "Convert int x10 to float f1.",
      "slug": "fcvt_s_w",
      "rel_url": "risc-v/fcvt_s_w/",
      "linked_summary": "Converts a signed 32-<a href=\"../../armv8-a/bit/\">bit</a> integer to a single-precision floating-point number.",
      "linked_pseudocode": "F[rd] = i32_to_f32(R[rs1]);"
    },
    {
      "mnemonic": "FCVT.D.S",
      "architecture": "RISC-V",
      "extension": "D",
      "full_name": "Float Convert Single to Double",
      "summary": "Converts a single-precision float to a double-precision float.",
      "syntax": "FCVT.D.S rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "0100001 | 00000 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0100001",
            "clean": "0100001"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Double)"
        },
        {
          "name": "rs1",
          "desc": "Source (Single)"
        }
      ],
      "pseudocode": "F[rd] = f32_to_f64(F[rs1]);",
      "example": "FCVT.D.S f0, f1",
      "example_note": "Promote float to double.",
      "slug": "fcvt_d_s",
      "rel_url": "risc-v/fcvt_d_s/",
      "linked_summary": "Converts a single-precision float to a double-precision float.",
      "linked_pseudocode": "F[rd] = f32_to_f64(F[rs1]);"
    },
    {
      "mnemonic": "FCVT.S.D",
      "architecture": "RISC-V",
      "extension": "D",
      "full_name": "Float Convert Double to Single",
      "summary": "Converts a double-precision float to a single-precision float.",
      "syntax": "FCVT.S.D rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "0100000 | 00001 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0100000",
            "clean": "0100000"
          },
          {
            "raw": "00001",
            "clean": "00001"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Single)"
        },
        {
          "name": "rs1",
          "desc": "Source (Double)"
        }
      ],
      "pseudocode": "F[rd] = f64_to_f32(F[rs1]);",
      "example": "FCVT.S.D f1, f0",
      "example_note": "Demote double to float.",
      "slug": "fcvt_s_d",
      "rel_url": "risc-v/fcvt_s_d/",
      "linked_summary": "Converts a double-precision float to a single-precision float.",
      "linked_pseudocode": "F[rd] = f64_to_f32(F[rs1]);"
    },
    {
      "mnemonic": "FSGNJ.S",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Float Sign Injection (Single)",
      "summary": "Injects the sign of rs2 into rs1. Used to copy values or manipulate signs.",
      "syntax": "FSGNJ.S rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0010000 | rs2 | rs1 | 000 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0010000",
            "clean": "0010000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source (Body)"
        },
        {
          "name": "rs2",
          "desc": "Source (Sign)"
        }
      ],
      "pseudocode": "F[rd] = {F[rs2][31], F[rs1][30:0]};",
      "example": "FSGNJ.S f1, f2, f3",
      "example_note": "f1 gets magnitude of f2 and sign of f3.",
      "slug": "fsgnj_s",
      "rel_url": "risc-v/fsgnj_s/",
      "linked_summary": "Injects the sign of rs2 into rs1. Used to <a href=\"../../powerisa/copy/\">copy</a> values <a href=\"../../powerisa/or/\">or</a> manipulate signs.",
      "linked_pseudocode": "F[rd] = {F[rs2][31], F[rs1][30:0]};"
    },
    {
      "mnemonic": "FSGNJN.S",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Float Sign Injection Negate (Single)",
      "summary": "Injects the *negated* sign of rs2 into rs1. Used for negation and absolute value.",
      "syntax": "FSGNJN.S rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0010000 | rs2 | rs1 | 001 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0010000",
            "clean": "0010000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source (Body)"
        },
        {
          "name": "rs2",
          "desc": "Source (Sign)"
        }
      ],
      "pseudocode": "F[rd] = {~F[rs2][31], F[rs1][30:0]};",
      "example": "FSGNJN.S f1, f2, f2",
      "example_note": "Negates f2 (f1 = -f2).",
      "slug": "fsgnjn_s",
      "rel_url": "risc-v/fsgnjn_s/",
      "linked_summary": "Injects the *negated* sign of rs2 into rs1. Used for negation <a href=\"../../armv8-a/and_6/\">and</a> absolute value.",
      "linked_pseudocode": "F[rd] = {~F[rs2][31], F[rs1][30:0]};"
    },
    {
      "mnemonic": "FSGNJX.S",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Float Sign Injection XOR (Single)",
      "summary": "Injects the XOR of signs of rs1 and rs2. Used to copy sign.",
      "syntax": "FSGNJX.S rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0010000 | rs2 | rs1 | 010 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0010000",
            "clean": "0010000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source 1"
        },
        {
          "name": "rs2",
          "desc": "Source 2"
        }
      ],
      "pseudocode": "F[rd] = {F[rs1][31] ^ F[rs2][31], F[rs1][30:0]};",
      "example": "FSGNJX.S f1, f1, f2",
      "example_note": "Logic similar to Abs(f1) if f2 is properly set.",
      "slug": "fsgnjx_s",
      "rel_url": "risc-v/fsgnjx_s/",
      "linked_summary": "Injects the <a href=\"../../risc-v/xor/\">XOR</a> of signs of rs1 <a href=\"../../armv8-a/and_6/\">and</a> rs2. Used to <a href=\"../../powerisa/copy/\">copy</a> sign.",
      "linked_pseudocode": "F[rd] = {F[rs1][31] ^ F[rs2][31], F[rs1][30:0]};"
    },
    {
      "mnemonic": "FEQ.S",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Float Equal (Single)",
      "summary": "Sets integer rd to 1 if float rs1 equals float rs2, else 0.",
      "syntax": "FEQ.S rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "1010000 | rs2 | rs1 | 010 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1010000",
            "clean": "1010000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Integer)"
        },
        {
          "name": "rs1",
          "desc": "Src 1 (Float)"
        },
        {
          "name": "rs2",
          "desc": "Src 2 (Float)"
        }
      ],
      "pseudocode": "R[rd] = (F[rs1] == F[rs2]) ? 1 : 0;",
      "example": "FEQ.S x10, f1, f2",
      "example_note": "x10 = (f1 == f2)",
      "slug": "feq_s",
      "rel_url": "risc-v/feq_s/",
      "linked_summary": "Sets integer rd to 1 if float rs1 equals float rs2, else 0.",
      "linked_pseudocode": "R[rd] = (F[rs1] == F[rs2]) ? 1 : 0;"
    },
    {
      "mnemonic": "FLT.S",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Float Less Than (Single)",
      "summary": "Sets integer rd to 1 if float rs1 is less than float rs2, else 0.",
      "syntax": "FLT.S rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "1010000 | rs2 | rs1 | 001 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1010000",
            "clean": "1010000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Integer)"
        },
        {
          "name": "rs1",
          "desc": "Src 1 (Float)"
        },
        {
          "name": "rs2",
          "desc": "Src 2 (Float)"
        }
      ],
      "pseudocode": "R[rd] = (F[rs1] < F[rs2]) ? 1 : 0;",
      "example": "FLT.S x10, f1, f2",
      "example_note": "x10 = (f1 < f2)",
      "slug": "flt_s",
      "rel_url": "risc-v/flt_s/",
      "linked_summary": "Sets integer rd to 1 if float rs1 is less than float rs2, else 0.",
      "linked_pseudocode": "R[rd] = (F[rs1] < F[rs2]) ? 1 : 0;"
    },
    {
      "mnemonic": "FLE.S",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Float Less or Equal (Single)",
      "summary": "Sets integer rd to 1 if float rs1 is less than or equal to float rs2, else 0.",
      "syntax": "FLE.S rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "1010000 | rs2 | rs1 | 000 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1010000",
            "clean": "1010000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Integer)"
        },
        {
          "name": "rs1",
          "desc": "Src 1 (Float)"
        },
        {
          "name": "rs2",
          "desc": "Src 2 (Float)"
        }
      ],
      "pseudocode": "R[rd] = (F[rs1] <= F[rs2]) ? 1 : 0;",
      "example": "FLE.S x10, f1, f2",
      "example_note": "x10 = (f1 <= f2)",
      "slug": "fle_s",
      "rel_url": "risc-v/fle_s/",
      "linked_summary": "Sets integer rd to 1 if float rs1 is less than <a href=\"../../powerisa/or/\">or</a> equal to float rs2, else 0.",
      "linked_pseudocode": "R[rd] = (F[rs1] <= F[rs2]) ? 1 : 0;"
    },
    {
      "mnemonic": "FMV.X.W",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Move Float to Integer",
      "summary": "Moves the bit pattern of a floating-point register to an integer register.",
      "syntax": "FMV.X.W rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "1110000 | 00000 | rs1 | 000 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1110000",
            "clean": "1110000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Integer)"
        },
        {
          "name": "rs1",
          "desc": "Source (Float)"
        }
      ],
      "pseudocode": "R[rd] = sext(F[rs1]);",
      "example": "FMV.X.W x10, f1",
      "example_note": "Copy bits from f1 to x10.",
      "slug": "fmv_x_w",
      "rel_url": "risc-v/fmv_x_w/",
      "linked_summary": "Moves the <a href=\"../../armv8-a/bit/\">bit</a> pattern of a floating-point register to an integer register.",
      "linked_pseudocode": "R[rd] = sext(F[rs1]);"
    },
    {
      "mnemonic": "FMV.W.X",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Move Integer to Float",
      "summary": "Moves the bit pattern of an integer register to a floating-point register.",
      "syntax": "FMV.W.X rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "1111000 | 00000 | rs1 | 000 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1111000",
            "clean": "1111000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Float)"
        },
        {
          "name": "rs1",
          "desc": "Source (Integer)"
        }
      ],
      "pseudocode": "F[rd] = R[rs1];",
      "example": "FMV.W.X f1, x10",
      "example_note": "Copy bits from x10 to f1.",
      "slug": "fmv_w_x",
      "rel_url": "risc-v/fmv_w_x/",
      "linked_summary": "Moves the <a href=\"../../armv8-a/bit/\">bit</a> pattern of an integer register to a floating-point register.",
      "linked_pseudocode": "F[rd] = R[rs1];"
    },
    {
      "mnemonic": "VFMUL.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Float Multiply",
      "summary": "Multiplies elements of two floating-point vectors.",
      "syntax": "VFMUL.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPFVV",
        "binary_pattern": "100100 | vm | vs2 | vs1 | 001 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "100100",
            "clean": "100100"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs1[i] * vs2[i];",
      "slug": "vfmul_vv",
      "rel_url": "risc-v/vfmul_vv/",
      "linked_summary": "Multiplies elements of two floating-point vectors.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = vs1[i] * vs2[i];"
    },
    {
      "mnemonic": "VFDIV.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Float Divide",
      "summary": "Divides elements of two floating-point vectors.",
      "syntax": "VFDIV.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPFVV",
        "binary_pattern": "100000 | vm | vs2 | vs1 | 001 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "100000",
            "clean": "100000"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Divisor"
        },
        {
          "name": "vs1",
          "desc": "Dividend"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs1[i] / vs2[i];",
      "slug": "vfdiv_vv",
      "rel_url": "risc-v/vfdiv_vv/",
      "linked_summary": "Divides elements of two floating-point vectors.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = vs1[i] / vs2[i];"
    },
    {
      "mnemonic": "VFSQRT.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Float Square Root",
      "summary": "Computes the square root of elements in a floating-point vector.",
      "syntax": "VFSQRT.V vd, vs2, vm",
      "encoding": {
        "format": "OPFVV",
        "binary_pattern": "010011 | vm | vs2 | 00000 | 001 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010011",
            "clean": "010011"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Source"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = sqrt(vs2[i]);",
      "slug": "vfsqrt_v",
      "rel_url": "risc-v/vfsqrt_v/",
      "linked_summary": "Computes the square root of elements <a href=\"../../x86/in/\">in</a> a floating-point vector.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = sqrt(vs2[i]);"
    },
    {
      "mnemonic": "VFMADD.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Float Fused Multiply-Add",
      "summary": "Computes (vs1 * vs2) + vd (overwriting vd) with single rounding.",
      "syntax": "VFMADD.VV vd, vs1, vs2, vm",
      "encoding": {
        "format": "OPFVV",
        "binary_pattern": "101000 | vm | vs2 | vs1 | 001 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "101000",
            "clean": "101000"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest/Addend"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = (vs1[i] * vs2[i]) + vd[i];",
      "slug": "vfmadd_vv",
      "rel_url": "risc-v/vfmadd_vv/",
      "linked_summary": "Computes (vs1 * vs2) + vd (overwriting vd) with single rounding.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = (vs1[i] * vs2[i]) + vd[i];"
    },
    {
      "mnemonic": "VFMIN.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Float Minimum",
      "summary": "Writes the smaller of two floating-point vector elements to vd.",
      "syntax": "VFMIN.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPFVV",
        "binary_pattern": "000100 | vm | vs2 | vs1 | 001 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "000100",
            "clean": "000100"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = min(vs1[i], vs2[i]);",
      "slug": "vfmin_vv",
      "rel_url": "risc-v/vfmin_vv/",
      "linked_summary": "Writes the smaller of two floating-point vector elements to vd.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = min(vs1[i], vs2[i]);"
    },
    {
      "mnemonic": "VFMAX.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Float Maximum",
      "summary": "Writes the larger of two floating-point vector elements to vd.",
      "syntax": "VFMAX.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPFVV",
        "binary_pattern": "000110 | vm | vs2 | vs1 | 001 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "000110",
            "clean": "000110"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = max(vs1[i], vs2[i]);",
      "slug": "vfmax_vv",
      "rel_url": "risc-v/vfmax_vv/",
      "linked_summary": "Writes the larger of two floating-point vector elements to vd.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = max(vs1[i], vs2[i]);"
    },
    {
      "mnemonic": "VFSGNJ.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Float Sign Injection",
      "summary": "Injects the sign of vs2 into vs1 (Copy Sign).",
      "syntax": "VFSGNJ.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPFVV",
        "binary_pattern": "001000 | vm | vs2 | vs1 | 001 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "001000",
            "clean": "001000"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Sign Src"
        },
        {
          "name": "vs1",
          "desc": "Body Src"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = copy_sign(vs1[i], vs2[i]);",
      "slug": "vfsgnj_vv",
      "rel_url": "risc-v/vfsgnj_vv/",
      "linked_summary": "Injects the sign of vs2 into vs1 (Copy Sign).",
      "linked_pseudocode": "foreach(i < vl): vd[i] = copy_sign(vs1[i], vs2[i]);"
    },
    {
      "mnemonic": "VSADD.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Saturating Integer Add",
      "summary": "Adds elements with signed saturation (clips to Max/Min instead of wrapping).",
      "syntax": "VSADD.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "100001 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "100001",
            "clean": "100001"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = saturate_s(vs1[i] + vs2[i]);",
      "slug": "vsadd_vv",
      "rel_url": "risc-v/vsadd_vv/",
      "linked_summary": "Adds elements with signed saturation (clips to Max/Min instead of wrapping).",
      "linked_pseudocode": "foreach(i < vl): vd[i] = saturate_s(vs1[i] + vs2[i]);"
    },
    {
      "mnemonic": "VSSUB.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Saturating Integer Subtract",
      "summary": "Subtracts elements with signed saturation.",
      "syntax": "VSSUB.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "100011 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "100011",
            "clean": "100011"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = saturate_s(vs1[i] - vs2[i]);",
      "slug": "vssub_vv",
      "rel_url": "risc-v/vssub_vv/",
      "linked_summary": "Subtracts elements with signed saturation.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = saturate_s(vs1[i] - vs2[i]);"
    },
    {
      "mnemonic": "VAADD.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Averaging Add",
      "summary": "Computes (vs1 + vs2) >> 1 with rounding.",
      "syntax": "VAADD.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "100100 | vm | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "100100",
            "clean": "100100"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = (vs1[i] + vs2[i] + 1) >> 1;",
      "slug": "vaadd_vv",
      "rel_url": "risc-v/vaadd_vv/",
      "linked_summary": "Computes (vs1 + vs2) >> 1 with rounding.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = (vs1[i] + vs2[i] + 1) >> 1;"
    },
    {
      "mnemonic": "VCOMPRESS.VM",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Compress",
      "summary": "Compacts elements from source vector into contiguous elements in dest where the mask is 1.",
      "syntax": "VCOMPRESS.VM vd, vs2, vs1",
      "encoding": {
        "format": "OPMVV",
        "binary_pattern": "010111 | 1 | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010111",
            "clean": "010111"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Source"
        },
        {
          "name": "vs1",
          "desc": "Mask"
        }
      ],
      "pseudocode": "idx = 0; foreach(i < vl): if vs1[i]: vd[idx++] = vs2[i];",
      "slug": "vcompress_vm",
      "rel_url": "risc-v/vcompress_vm/",
      "linked_summary": "Compacts elements from source vector into contiguous elements <a href=\"../../x86/in/\">in</a> dest where the mask is 1.",
      "linked_pseudocode": "idx = 0; foreach(i < vl): if vs1[i]: vd[idx++] = vs2[i];"
    },
    {
      "mnemonic": "FSUB.H",
      "architecture": "RISC-V",
      "extension": "Zfh (Half-Float)",
      "full_name": "Float Subtract (Half)",
      "summary": "Performs 16-bit floating-point subtraction.",
      "syntax": "FSUB.H rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000100 | rs2 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0000100",
            "clean": "0000100"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        }
      ],
      "pseudocode": "F[rd] = F[rs1] - F[rs2];",
      "slug": "fsub_h",
      "rel_url": "risc-v/fsub_h/",
      "linked_summary": "Performs 16-<a href=\"../../armv8-a/bit/\">bit</a> floating-point subtraction.",
      "linked_pseudocode": "F[rd] = F[rs1] - F[rs2];"
    },
    {
      "mnemonic": "FMUL.H",
      "architecture": "RISC-V",
      "extension": "Zfh (Half-Float)",
      "full_name": "Float Multiply (Half)",
      "summary": "Performs 16-bit floating-point multiplication.",
      "syntax": "FMUL.H rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0001000 | rs2 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0001000",
            "clean": "0001000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        }
      ],
      "pseudocode": "F[rd] = F[rs1] * F[rs2];",
      "slug": "fmul_h",
      "rel_url": "risc-v/fmul_h/",
      "linked_summary": "Performs 16-<a href=\"../../armv8-a/bit/\">bit</a> floating-point multiplication.",
      "linked_pseudocode": "F[rd] = F[rs1] * F[rs2];"
    },
    {
      "mnemonic": "FDIV.H",
      "architecture": "RISC-V",
      "extension": "Zfh (Half-Float)",
      "full_name": "Float Divide (Half)",
      "summary": "Performs 16-bit floating-point division.",
      "syntax": "FDIV.H rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0001100 | rs2 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0001100",
            "clean": "0001100"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Dividend"
        },
        {
          "name": "rs2",
          "desc": "Divisor"
        }
      ],
      "pseudocode": "F[rd] = F[rs1] / F[rs2];",
      "slug": "fdiv_h",
      "rel_url": "risc-v/fdiv_h/",
      "linked_summary": "Performs 16-<a href=\"../../armv8-a/bit/\">bit</a> floating-point division.",
      "linked_pseudocode": "F[rd] = F[rs1] / F[rs2];"
    },
    {
      "mnemonic": "FSQRT.H",
      "architecture": "RISC-V",
      "extension": "Zfh (Half-Float)",
      "full_name": "Float Square Root (Half)",
      "summary": "Computes the square root of a 16-bit floating-point number.",
      "syntax": "FSQRT.H rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "0101100 | 00000 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0101100",
            "clean": "0101100"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        }
      ],
      "pseudocode": "F[rd] = sqrt(F[rs1]);",
      "slug": "fsqrt_h",
      "rel_url": "risc-v/fsqrt_h/",
      "linked_summary": "Computes the square root of a 16-<a href=\"../../armv8-a/bit/\">bit</a> floating-point number.",
      "linked_pseudocode": "F[rd] = sqrt(F[rs1]);"
    },
    {
      "mnemonic": "FMIN.H",
      "architecture": "RISC-V",
      "extension": "Zfh (Half-Float)",
      "full_name": "Float Minimum (Half)",
      "summary": "Writes the smaller of two 16-bit floating-point values to rd.",
      "syntax": "FMIN.H rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0010100 | rs2 | rs1 | 000 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0010100",
            "clean": "0010100"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        }
      ],
      "pseudocode": "F[rd] = min(F[rs1], F[rs2]);",
      "slug": "fmin_h",
      "rel_url": "risc-v/fmin_h/",
      "linked_summary": "Writes the smaller of two 16-<a href=\"../../armv8-a/bit/\">bit</a> floating-point values to rd.",
      "linked_pseudocode": "F[rd] = min(F[rs1], F[rs2]);"
    },
    {
      "mnemonic": "FMAX.H",
      "architecture": "RISC-V",
      "extension": "Zfh (Half-Float)",
      "full_name": "Float Maximum (Half)",
      "summary": "Writes the larger of two 16-bit floating-point values to rd.",
      "syntax": "FMAX.H rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0010100 | rs2 | rs1 | 001 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0010100",
            "clean": "0010100"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        }
      ],
      "pseudocode": "F[rd] = max(F[rs1], F[rs2]);",
      "slug": "fmax_h",
      "rel_url": "risc-v/fmax_h/",
      "linked_summary": "Writes the larger of two 16-<a href=\"../../armv8-a/bit/\">bit</a> floating-point values to rd.",
      "linked_pseudocode": "F[rd] = max(F[rs1], F[rs2]);"
    },
    {
      "mnemonic": "FMADD.H",
      "architecture": "RISC-V",
      "extension": "Zfh (Half-Float)",
      "full_name": "Float Fused Multiply-Add (Half)",
      "summary": "Computes (rs1 * rs2) + rs3 with single rounding (16-bit).",
      "syntax": "FMADD.H rd, rs1, rs2, rs3",
      "encoding": {
        "format": "R4-Type",
        "binary_pattern": "rs3 | 00 | rs2 | rs1 | rm | rd | 1000011",
        "hex_opcode": "0x43",
        "visual_parts": [
          {
            "raw": "rs3",
            "clean": "rs3"
          },
          {
            "raw": "00",
            "clean": "00"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1000011",
            "clean": "1000011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        },
        {
          "name": "rs3",
          "desc": "Src 3"
        }
      ],
      "pseudocode": "F[rd] = (F[rs1] * F[rs2]) + F[rs3];",
      "slug": "fmadd_h",
      "rel_url": "risc-v/fmadd_h/",
      "linked_summary": "Computes (rs1 * rs2) + rs3 with single rounding (16-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": "F[rd] = (F[rs1] * F[rs2]) + F[rs3];"
    },
    {
      "mnemonic": "FMSUB.H",
      "architecture": "RISC-V",
      "extension": "Zfh (Half-Float)",
      "full_name": "Float Fused Multiply-Subtract (Half)",
      "summary": "Computes (rs1 * rs2) - rs3 with single rounding (16-bit).",
      "syntax": "FMSUB.H rd, rs1, rs2, rs3",
      "encoding": {
        "format": "R4-Type",
        "binary_pattern": "rs3 | 00 | rs2 | rs1 | rm | rd | 1000111",
        "hex_opcode": "0x47",
        "visual_parts": [
          {
            "raw": "rs3",
            "clean": "rs3"
          },
          {
            "raw": "00",
            "clean": "00"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1000111",
            "clean": "1000111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        },
        {
          "name": "rs3",
          "desc": "Src 3"
        }
      ],
      "pseudocode": "F[rd] = (F[rs1] * F[rs2]) - F[rs3];",
      "slug": "fmsub_h",
      "rel_url": "risc-v/fmsub_h/",
      "linked_summary": "Computes (rs1 * rs2) - rs3 with single rounding (16-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": "F[rd] = (F[rs1] * F[rs2]) - F[rs3];"
    },
    {
      "mnemonic": "FNMADD.H",
      "architecture": "RISC-V",
      "extension": "Zfh (Half-Float)",
      "full_name": "Float Negated Fused Multiply-Add (Half)",
      "summary": "Computes -(rs1 * rs2) - rs3 with single rounding (16-bit).",
      "syntax": "FNMADD.H rd, rs1, rs2, rs3",
      "encoding": {
        "format": "R4-Type",
        "binary_pattern": "rs3 | 00 | rs2 | rs1 | rm | rd | 1001111",
        "hex_opcode": "0x4F",
        "visual_parts": [
          {
            "raw": "rs3",
            "clean": "rs3"
          },
          {
            "raw": "00",
            "clean": "00"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1001111",
            "clean": "1001111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        },
        {
          "name": "rs3",
          "desc": "Src 3"
        }
      ],
      "pseudocode": "F[rd] = -((F[rs1] * F[rs2]) + F[rs3]);",
      "slug": "fnmadd_h",
      "rel_url": "risc-v/fnmadd_h/",
      "linked_summary": "Computes -(rs1 * rs2) - rs3 with single rounding (16-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": "F[rd] = -((F[rs1] * F[rs2]) + F[rs3]);"
    },
    {
      "mnemonic": "FNMSUB.H",
      "architecture": "RISC-V",
      "extension": "Zfh (Half-Float)",
      "full_name": "Float Negated Fused Multiply-Subtract (Half)",
      "summary": "Computes -(rs1 * rs2) + rs3 with single rounding (16-bit).",
      "syntax": "FNMSUB.H rd, rs1, rs2, rs3",
      "encoding": {
        "format": "R4-Type",
        "binary_pattern": "rs3 | 00 | rs2 | rs1 | rm | rd | 1001011",
        "hex_opcode": "0x4B",
        "visual_parts": [
          {
            "raw": "rs3",
            "clean": "rs3"
          },
          {
            "raw": "00",
            "clean": "00"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1001011",
            "clean": "1001011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        },
        {
          "name": "rs3",
          "desc": "Src 3"
        }
      ],
      "pseudocode": "F[rd] = -((F[rs1] * F[rs2]) - F[rs3]);",
      "slug": "fnmsub_h",
      "rel_url": "risc-v/fnmsub_h/",
      "linked_summary": "Computes -(rs1 * rs2) + rs3 with single rounding (16-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": "F[rd] = -((F[rs1] * F[rs2]) - F[rs3]);"
    },
    {
      "mnemonic": "FEQ.H",
      "architecture": "RISC-V",
      "extension": "Zfh (Half-Float)",
      "full_name": "Float Equal (Half)",
      "summary": "Sets integer rd to 1 if half-precision rs1 equals rs2, else 0.",
      "syntax": "FEQ.H rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "1010000 | rs2 | rs1 | 010 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1010000",
            "clean": "1010000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Int)"
        },
        {
          "name": "rs1",
          "desc": "Src 1 (Half)"
        },
        {
          "name": "rs2",
          "desc": "Src 2 (Half)"
        }
      ],
      "pseudocode": "R[rd] = (F[rs1] == F[rs2]) ? 1 : 0;",
      "slug": "feq_h",
      "rel_url": "risc-v/feq_h/",
      "linked_summary": "Sets integer rd to 1 if half-precision rs1 equals rs2, else 0.",
      "linked_pseudocode": "R[rd] = (F[rs1] == F[rs2]) ? 1 : 0;"
    },
    {
      "mnemonic": "FLT.H",
      "architecture": "RISC-V",
      "extension": "Zfh (Half-Float)",
      "full_name": "Float Less Than (Half)",
      "summary": "Sets integer rd to 1 if half-precision rs1 is less than rs2, else 0.",
      "syntax": "FLT.H rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "1010000 | rs2 | rs1 | 001 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1010000",
            "clean": "1010000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Int)"
        },
        {
          "name": "rs1",
          "desc": "Src 1 (Half)"
        },
        {
          "name": "rs2",
          "desc": "Src 2 (Half)"
        }
      ],
      "pseudocode": "R[rd] = (F[rs1] < F[rs2]) ? 1 : 0;",
      "slug": "flt_h",
      "rel_url": "risc-v/flt_h/",
      "linked_summary": "Sets integer rd to 1 if half-precision rs1 is less than rs2, else 0.",
      "linked_pseudocode": "R[rd] = (F[rs1] < F[rs2]) ? 1 : 0;"
    },
    {
      "mnemonic": "FLE.H",
      "architecture": "RISC-V",
      "extension": "Zfh (Half-Float)",
      "full_name": "Float Less or Equal (Half)",
      "summary": "Sets integer rd to 1 if half-precision rs1 is less than or equal to rs2, else 0.",
      "syntax": "FLE.H rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "1010000 | rs2 | rs1 | 000 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1010000",
            "clean": "1010000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Int)"
        },
        {
          "name": "rs1",
          "desc": "Src 1 (Half)"
        },
        {
          "name": "rs2",
          "desc": "Src 2 (Half)"
        }
      ],
      "pseudocode": "R[rd] = (F[rs1] <= F[rs2]) ? 1 : 0;",
      "slug": "fle_h",
      "rel_url": "risc-v/fle_h/",
      "linked_summary": "Sets integer rd to 1 if half-precision rs1 is less than <a href=\"../../powerisa/or/\">or</a> equal to rs2, else 0.",
      "linked_pseudocode": "R[rd] = (F[rs1] <= F[rs2]) ? 1 : 0;"
    },
    {
      "mnemonic": "FCLASS.H",
      "architecture": "RISC-V",
      "extension": "Zfh (Half-Float)",
      "full_name": "Float Classify (Half)",
      "summary": "Examines a 16-bit floating-point number and generates a classification bitmask.",
      "syntax": "FCLASS.H rd, rs1",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "1110000 | 00000 | rs1 | 001 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1110000",
            "clean": "1110000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Int)"
        },
        {
          "name": "rs1",
          "desc": "Src (Half)"
        }
      ],
      "pseudocode": "R[rd] = classify_half(F[rs1]);",
      "slug": "fclass_h",
      "rel_url": "risc-v/fclass_h/",
      "linked_summary": "Examines a 16-<a href=\"../../armv8-a/bit/\">bit</a> floating-point number <a href=\"../../armv8-a/and_6/\">and</a> generates a classification bitmask.",
      "linked_pseudocode": "R[rd] = classify_half(F[rs1]);"
    },
    {
      "mnemonic": "FSGNJ.H",
      "architecture": "RISC-V",
      "extension": "Zfh (Half-Float)",
      "full_name": "Float Sign Injection (Half)",
      "summary": "Injects the sign of rs2 into rs1 (16-bit).",
      "syntax": "FSGNJ.H rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0010000 | rs2 | rs1 | 000 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0010000",
            "clean": "0010000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Sign Src"
        }
      ],
      "pseudocode": "F[rd] = {F[rs2][15], F[rs1][14:0]};",
      "slug": "fsgnj_h",
      "rel_url": "risc-v/fsgnj_h/",
      "linked_summary": "Injects the sign of rs2 into rs1 (16-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": "F[rd] = {F[rs2][15], F[rs1][14:0]};"
    },
    {
      "mnemonic": "FSGNJN.H",
      "architecture": "RISC-V",
      "extension": "Zfh (Half-Float)",
      "full_name": "Float Sign Injection Negate (Half)",
      "summary": "Injects the negated sign of rs2 into rs1 (16-bit).",
      "syntax": "FSGNJN.H rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0010000 | rs2 | rs1 | 001 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0010000",
            "clean": "0010000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Sign Src"
        }
      ],
      "pseudocode": "F[rd] = {~F[rs2][15], F[rs1][14:0]};",
      "slug": "fsgnjn_h",
      "rel_url": "risc-v/fsgnjn_h/",
      "linked_summary": "Injects the negated sign of rs2 into rs1 (16-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": "F[rd] = {~F[rs2][15], F[rs1][14:0]};"
    },
    {
      "mnemonic": "FSGNJX.H",
      "architecture": "RISC-V",
      "extension": "Zfh (Half-Float)",
      "full_name": "Float Sign Injection XOR (Half)",
      "summary": "Injects the XOR of signs of rs1 and rs2 (16-bit).",
      "syntax": "FSGNJX.H rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0010000 | rs2 | rs1 | 010 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0010000",
            "clean": "0010000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Sign Src"
        }
      ],
      "pseudocode": "F[rd] = {F[rs1][15] ^ F[rs2][15], F[rs1][14:0]};",
      "slug": "fsgnjx_h",
      "rel_url": "risc-v/fsgnjx_h/",
      "linked_summary": "Injects the <a href=\"../../risc-v/xor/\">XOR</a> of signs of rs1 <a href=\"../../armv8-a/and_6/\">and</a> rs2 (16-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": "F[rd] = {F[rs1][15] ^ F[rs2][15], F[rs1][14:0]};"
    },
    {
      "mnemonic": "FCVT.W.H",
      "architecture": "RISC-V",
      "extension": "Zfh (Half-Float)",
      "full_name": "Convert Half to Word",
      "summary": "Converts a 16-bit floating-point number to a 32-bit signed integer.",
      "syntax": "FCVT.W.H rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "1100000 | 00010 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1100000",
            "clean": "1100000"
          },
          {
            "raw": "00010",
            "clean": "00010"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Int)"
        },
        {
          "name": "rs1",
          "desc": "Src (Half)"
        }
      ],
      "pseudocode": "R[rd] = sext(f16_to_i32(F[rs1]));",
      "slug": "fcvt_w_h",
      "rel_url": "risc-v/fcvt_w_h/",
      "linked_summary": "Converts a 16-<a href=\"../../armv8-a/bit/\">bit</a> floating-point number to a 32-<a href=\"../../armv8-a/bit/\">bit</a> signed integer.",
      "linked_pseudocode": "R[rd] = sext(f16_to_i32(F[rs1]));"
    },
    {
      "mnemonic": "FCVT.WU.H",
      "architecture": "RISC-V",
      "extension": "Zfh (Half-Float)",
      "full_name": "Convert Half to Unsigned Word",
      "summary": "Converts a 16-bit floating-point number to a 32-bit unsigned integer.",
      "syntax": "FCVT.WU.H rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "1100000 | 00011 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1100000",
            "clean": "1100000"
          },
          {
            "raw": "00011",
            "clean": "00011"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (UInt)"
        },
        {
          "name": "rs1",
          "desc": "Src (Half)"
        }
      ],
      "pseudocode": "R[rd] = sext(f16_to_u32(F[rs1]));",
      "slug": "fcvt_wu_h",
      "rel_url": "risc-v/fcvt_wu_h/",
      "linked_summary": "Converts a 16-<a href=\"../../armv8-a/bit/\">bit</a> floating-point number to a 32-<a href=\"../../armv8-a/bit/\">bit</a> unsigned integer.",
      "linked_pseudocode": "R[rd] = sext(f16_to_u32(F[rs1]));"
    },
    {
      "mnemonic": "FCVT.H.W",
      "architecture": "RISC-V",
      "extension": "Zfh (Half-Float)",
      "full_name": "Convert Word to Half",
      "summary": "Converts a 32-bit signed integer to a 16-bit floating-point number.",
      "syntax": "FCVT.H.W rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "1101000 | 00010 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1101000",
            "clean": "1101000"
          },
          {
            "raw": "00010",
            "clean": "00010"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Half)"
        },
        {
          "name": "rs1",
          "desc": "Src (Int)"
        }
      ],
      "pseudocode": "F[rd] = i32_to_f16(R[rs1]);",
      "slug": "fcvt_h_w",
      "rel_url": "risc-v/fcvt_h_w/",
      "linked_summary": "Converts a 32-<a href=\"../../armv8-a/bit/\">bit</a> signed integer to a 16-<a href=\"../../armv8-a/bit/\">bit</a> floating-point number.",
      "linked_pseudocode": "F[rd] = i32_to_f16(R[rs1]);"
    },
    {
      "mnemonic": "FCVT.H.WU",
      "architecture": "RISC-V",
      "extension": "Zfh (Half-Float)",
      "full_name": "Convert Unsigned Word to Half",
      "summary": "Converts a 32-bit unsigned integer to a 16-bit floating-point number.",
      "syntax": "FCVT.H.WU rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "1101000 | 00011 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1101000",
            "clean": "1101000"
          },
          {
            "raw": "00011",
            "clean": "00011"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Half)"
        },
        {
          "name": "rs1",
          "desc": "Src (UInt)"
        }
      ],
      "pseudocode": "F[rd] = u32_to_f16(R[rs1]);",
      "slug": "fcvt_h_wu",
      "rel_url": "risc-v/fcvt_h_wu/",
      "linked_summary": "Converts a 32-<a href=\"../../armv8-a/bit/\">bit</a> unsigned integer to a 16-<a href=\"../../armv8-a/bit/\">bit</a> floating-point number.",
      "linked_pseudocode": "F[rd] = u32_to_f16(R[rs1]);"
    },
    {
      "mnemonic": "VNCLIP.WV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Narrowing Clip (Arithmetic Shift)",
      "summary": "Shifts elements right, rounds, and clips (saturates) the result to the destination width. Critical for Quantization.",
      "syntax": "VNCLIP.WV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "101111 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "101111",
            "clean": "101111"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (Narrow)"
        },
        {
          "name": "vs2",
          "desc": "Src Vector (Wide)"
        },
        {
          "name": "vs1",
          "desc": "Shift Vector"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = clip(round(vs2[i] >> vs1[i]));",
      "slug": "vnclip_wv",
      "rel_url": "risc-v/vnclip_wv/",
      "linked_summary": "Shifts elements right, rounds, <a href=\"../../armv8-a/and_6/\">and</a> clips (saturates) the result to the destination width. Critical for Quantization.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = clip(round(vs2[i] >> vs1[i]));"
    },
    {
      "mnemonic": "VNCLIPU.WI",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Narrowing Clip Unsigned (Immediate)",
      "summary": "Shifts right (logical), rounds, and clips to unsigned destination. Used for pixel packing.",
      "syntax": "VNCLIPU.WI vd, vs2, imm, vm",
      "encoding": {
        "format": "OPIVI",
        "binary_pattern": "101110 | vm | vs2 | imm | 011 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "101110",
            "clean": "101110"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (Narrow)"
        },
        {
          "name": "vs2",
          "desc": "Src Vector (Wide)"
        },
        {
          "name": "imm",
          "desc": "Shift Amount"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = clip_u(round(vs2[i] >>u imm));",
      "slug": "vnclipu_wi",
      "rel_url": "risc-v/vnclipu_wi/",
      "linked_summary": "Shifts right (logical), rounds, <a href=\"../../armv8-a/and_6/\">and</a> clips to unsigned destination. Used for pixel packing.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = clip_u(round(vs2[i] >>u imm));"
    },
    {
      "mnemonic": "VFCVT.X.F.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Float to Signed Integer Convert",
      "summary": "Converts floating-point elements to signed integers.",
      "syntax": "VFCVT.X.F.V vd, vs2, vm",
      "encoding": {
        "format": "OPFVV",
        "binary_pattern": "010010 | vm | vs2 | 00001 | 001 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010010",
            "clean": "010010"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "00001",
            "clean": "00001"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (Int)"
        },
        {
          "name": "vs2",
          "desc": "Src (Float)"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = float_to_int(vs2[i]);",
      "slug": "vfcvt_x_f_v",
      "rel_url": "risc-v/vfcvt_x_f_v/",
      "linked_summary": "Converts floating-point elements to signed integers.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = float_to_int(vs2[i]);"
    },
    {
      "mnemonic": "VFCVT.F.X.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Signed Integer to Float Convert",
      "summary": "Converts signed integer elements to floating-point.",
      "syntax": "VFCVT.F.X.V vd, vs2, vm",
      "encoding": {
        "format": "OPFVV",
        "binary_pattern": "010010 | vm | vs2 | 00011 | 001 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010010",
            "clean": "010010"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "00011",
            "clean": "00011"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (Float)"
        },
        {
          "name": "vs2",
          "desc": "Src (Int)"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = int_to_float(vs2[i]);",
      "slug": "vfcvt_f_x_v",
      "rel_url": "risc-v/vfcvt_f_x_v/",
      "linked_summary": "Converts signed integer elements to floating-point.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = int_to_float(vs2[i]);"
    },
    {
      "mnemonic": "VFWCVT.F.X.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Widening Integer to Float Convert",
      "summary": "Converts N-bit integers to 2*N-bit floats (e.g., Int16 -> FP32).",
      "syntax": "VFWCVT.F.X.V vd, vs2, vm",
      "encoding": {
        "format": "OPFVV",
        "binary_pattern": "010010 | vm | vs2 | 01011 | 001 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010010",
            "clean": "010010"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "01011",
            "clean": "01011"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (Wide Float)"
        },
        {
          "name": "vs2",
          "desc": "Src (Narrow Int)"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = int_to_wide_float(vs2[i]);",
      "slug": "vfwcvt_f_x_v",
      "rel_url": "risc-v/vfwcvt_f_x_v/",
      "linked_summary": "Converts N-<a href=\"../../armv8-a/bit/\">bit</a> integers to 2*N-<a href=\"../../armv8-a/bit/\">bit</a> floats (e.g., Int16 -> FP32).",
      "linked_pseudocode": "foreach(i < vl): vd[i] = int_to_wide_float(vs2[i]);"
    },
    {
      "mnemonic": "VFNCVT.F.F.W",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Narrowing Float Convert",
      "summary": "Converts 2*N-bit floats to N-bit floats (e.g., FP32 -> FP16).",
      "syntax": "VFNCVT.F.F.W vd, vs2, vm",
      "encoding": {
        "format": "OPFVV",
        "binary_pattern": "010010 | vm | vs2 | 10100 | 001 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010010",
            "clean": "010010"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "10100",
            "clean": "10100"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (Narrow Float)"
        },
        {
          "name": "vs2",
          "desc": "Src (Wide Float)"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = narrow_float(vs2[i]);",
      "slug": "vfncvt_f_f_w",
      "rel_url": "risc-v/vfncvt_f_f_w/",
      "linked_summary": "Converts 2*N-<a href=\"../../armv8-a/bit/\">bit</a> floats to N-<a href=\"../../armv8-a/bit/\">bit</a> floats (e.g., FP32 -> FP16).",
      "linked_pseudocode": "foreach(i < vl): vd[i] = narrow_float(vs2[i]);"
    },
    {
      "mnemonic": "VFREC7.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Float Reciprocal Estimate 7-bit",
      "summary": "Computes an estimate of 1/x (7-bit precision). Used for fast division/normalization loops.",
      "syntax": "VFREC7.V vd, vs2, vm",
      "encoding": {
        "format": "OPFVV",
        "binary_pattern": "010011 | vm | vs2 | 00101 | 001 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010011",
            "clean": "010011"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "00101",
            "clean": "00101"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Source"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = approx_reciprocal(vs2[i]);",
      "slug": "vfrec7_v",
      "rel_url": "risc-v/vfrec7_v/",
      "linked_summary": "Computes an estimate of 1/x (7-<a href=\"../../armv8-a/bit/\">bit</a> precision). Used for fast division/normalization loops.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = approx_reciprocal(vs2[i]);"
    },
    {
      "mnemonic": "VFRSQRT7.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Float Reciprocal Sqrt Estimate 7-bit",
      "summary": "Computes an estimate of 1/sqrt(x). Critical for vector normalization.",
      "syntax": "VFRSQRT7.V vd, vs2, vm",
      "encoding": {
        "format": "OPFVV",
        "binary_pattern": "010011 | vm | vs2 | 00100 | 001 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010011",
            "clean": "010011"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "00100",
            "clean": "00100"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Source"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = approx_rsqrt(vs2[i]);",
      "slug": "vfrsqrt7_v",
      "rel_url": "risc-v/vfrsqrt7_v/",
      "linked_summary": "Computes an estimate of 1/sqrt(x). Critical for vector normalization.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = approx_rsqrt(vs2[i]);"
    },
    {
      "mnemonic": "VADDC.VVM",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Add with Carry",
      "summary": "Adds two vectors plus a carry-in from the mask register (v0).",
      "syntax": "VADDC.VVM vd, vs2, vs1, v0",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "010000 | 0 | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010000",
            "clean": "010000"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        },
        {
          "name": "v0",
          "desc": "Carry-In Mask"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs1[i] + vs2[i] + v0[i];",
      "slug": "vaddc_vvm",
      "rel_url": "risc-v/vaddc_vvm/",
      "linked_summary": "Adds two vectors plus a carry-<a href=\"../../x86/in/\">in</a> from the mask register (v0).",
      "linked_pseudocode": "foreach(i < vl): vd[i] = vs1[i] + vs2[i] + v0[i];"
    },
    {
      "mnemonic": "VMADC.VVM",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Add with Carry (Produce Mask)",
      "summary": "Adds two vectors and a carry-in, producing the carry-out to the destination mask.",
      "syntax": "VMADC.VVM vd, vs2, vs1, v0",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "010001 | 0 | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010001",
            "clean": "010001"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest Mask (Carry Out)"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        },
        {
          "name": "v0",
          "desc": "Carry-In Mask"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = carry_out(vs1[i] + vs2[i] + v0[i]);",
      "slug": "vmadc_vvm",
      "rel_url": "risc-v/vmadc_vvm/",
      "linked_summary": "Adds two vectors <a href=\"../../armv8-a/and_6/\">and</a> a carry-<a href=\"../../x86/in/\">in</a>, producing the carry-<a href=\"../../x86/out/\">out</a> to the destination mask.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = carry_out(vs1[i] + vs2[i] + v0[i]);"
    },
    {
      "mnemonic": "VSBC.VVM",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Subtract with Borrow",
      "summary": "Subtracts two vectors minus a borrow-in from the mask register.",
      "syntax": "VSBC.VVM vd, vs2, vs1, v0",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "010010 | 0 | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010010",
            "clean": "010010"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        },
        {
          "name": "v0",
          "desc": "Borrow-In Mask"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs1[i] - vs2[i] - v0[i];",
      "slug": "vsbc_vvm",
      "rel_url": "risc-v/vsbc_vvm/",
      "linked_summary": "Subtracts two vectors minus a borrow-<a href=\"../../x86/in/\">in</a> from the mask register.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = vs1[i] - vs2[i] - v0[i];"
    },
    {
      "mnemonic": "VMACC.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Integer Multiply-Accumulate",
      "summary": "Computes vd = vd + (vs1 * vs2). Essential for dot products.",
      "syntax": "VMACC.VV vd, vs1, vs2, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "111001 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "111001",
            "clean": "111001"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest/Accumulator"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vd[i] + (vs1[i] * vs2[i]);",
      "slug": "vmacc_vv",
      "rel_url": "risc-v/vmacc_vv/",
      "linked_summary": "Computes vd = vd + (vs1 * vs2). Essential for dot products.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = vd[i] + (vs1[i] * vs2[i]);"
    },
    {
      "mnemonic": "VNMSUB.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Integer Negative Multiply-Subtract",
      "summary": "Computes vd = -(vd - (vs1 * vs2)).",
      "syntax": "VNMSUB.VV vd, vs1, vs2, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "111011 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "111011",
            "clean": "111011"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest/Accumulator"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = -(vd[i] - (vs1[i] * vs2[i]));",
      "slug": "vnmsub_vv",
      "rel_url": "risc-v/vnmsub_vv/",
      "linked_summary": "Computes vd = -(vd - (vs1 * vs2)).",
      "linked_pseudocode": "foreach(i < vl): vd[i] = -(vd[i] - (vs1[i] * vs2[i]));"
    },
    {
      "mnemonic": "VSMUL.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Single-Width Saturating Multiply",
      "summary": "Performs signed saturating multiplication, keeping the high half of the product (Fixed-point support).",
      "syntax": "VSMUL.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "111101 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "111101",
            "clean": "111101"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = (sext(vs1[i]) * sext(vs2[i])) >> (SEW-1);",
      "slug": "vsmul_vv",
      "rel_url": "risc-v/vsmul_vv/",
      "linked_summary": "Performs signed saturating multiplication, keeping the high half of the product (Fixed-point support).",
      "linked_pseudocode": "foreach(i < vl): vd[i] = (sext(vs1[i]) * sext(vs2[i])) >> (SEW-1);"
    },
    {
      "mnemonic": "VREDMAX.VS",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Reduction Maximum (Signed)",
      "summary": "Reduces a vector to a scalar by finding the maximum signed element.",
      "syntax": "VREDMAX.VS vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPMVV",
        "binary_pattern": "000111 | vm | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "000111",
            "clean": "000111"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (Scalar)"
        },
        {
          "name": "vs2",
          "desc": "Src Vector"
        },
        {
          "name": "vs1",
          "desc": "Start Scalar"
        }
      ],
      "pseudocode": "vd[0] = max(vs1[0], max_element(vs2));",
      "slug": "vredmax_vs",
      "rel_url": "risc-v/vredmax_vs/",
      "linked_summary": "Reduces a vector to a scalar by finding the maximum signed element.",
      "linked_pseudocode": "vd[0] = max(vs1[0], max_element(vs2));"
    },
    {
      "mnemonic": "VREDMIN.VS",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Reduction Minimum (Signed)",
      "summary": "Reduces a vector to a scalar by finding the minimum signed element.",
      "syntax": "VREDMIN.VS vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPMVV",
        "binary_pattern": "000101 | vm | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "000101",
            "clean": "000101"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (Scalar)"
        },
        {
          "name": "vs2",
          "desc": "Src Vector"
        },
        {
          "name": "vs1",
          "desc": "Start Scalar"
        }
      ],
      "pseudocode": "vd[0] = min(vs1[0], min_element(vs2));",
      "slug": "vredmin_vs",
      "rel_url": "risc-v/vredmin_vs/",
      "linked_summary": "Reduces a vector to a scalar by finding the minimum signed element.",
      "linked_pseudocode": "vd[0] = min(vs1[0], min_element(vs2));"
    },
    {
      "mnemonic": "VREDAND.VS",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Reduction AND",
      "summary": "Reduces a vector to a scalar using bitwise AND.",
      "syntax": "VREDAND.VS vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPMVV",
        "binary_pattern": "000001 | vm | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "000001",
            "clean": "000001"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (Scalar)"
        },
        {
          "name": "vs2",
          "desc": "Src Vector"
        },
        {
          "name": "vs1",
          "desc": "Start Scalar"
        }
      ],
      "pseudocode": "vd[0] = vs1[0] & reduce_and(vs2);",
      "slug": "vredand_vs",
      "rel_url": "risc-v/vredand_vs/",
      "linked_summary": "Reduces a vector to a scalar using bitwise <a href=\"../../risc-v/and/\">AND</a>.",
      "linked_pseudocode": "vd[0] = vs1[0] & reduce_and(vs2);"
    },
    {
      "mnemonic": "VREDOR.VS",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Reduction OR",
      "summary": "Reduces a vector to a scalar using bitwise OR.",
      "syntax": "VREDOR.VS vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPMVV",
        "binary_pattern": "000010 | vm | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "000010",
            "clean": "000010"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (Scalar)"
        },
        {
          "name": "vs2",
          "desc": "Src Vector"
        },
        {
          "name": "vs1",
          "desc": "Start Scalar"
        }
      ],
      "pseudocode": "vd[0] = vs1[0] | reduce_or(vs2);",
      "slug": "vredor_vs",
      "rel_url": "risc-v/vredor_vs/",
      "linked_summary": "Reduces a vector to a scalar using bitwise <a href=\"../../risc-v/or/\">OR</a>.",
      "linked_pseudocode": "vd[0] = vs1[0] | reduce_or(vs2);"
    },
    {
      "mnemonic": "VFWADD.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Widening Float Add",
      "summary": "Adds N-bit floats to produce 2*N-bit float results (e.g., FP16 + FP16 -> FP32).",
      "syntax": "VFWADD.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPFVV",
        "binary_pattern": "110000 | vm | vs2 | vs1 | 001 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "110000",
            "clean": "110000"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (2*SEW)"
        },
        {
          "name": "vs2",
          "desc": "Src 2 (SEW)"
        },
        {
          "name": "vs1",
          "desc": "Src 1 (SEW)"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = extend(vs1[i]) + extend(vs2[i]);",
      "slug": "vfwadd_vv",
      "rel_url": "risc-v/vfwadd_vv/",
      "linked_summary": "Adds N-<a href=\"../../armv8-a/bit/\">bit</a> floats to produce 2*N-<a href=\"../../armv8-a/bit/\">bit</a> float results (e.g., FP16 + FP16 -> FP32).",
      "linked_pseudocode": "foreach(i < vl): vd[i] = extend(vs1[i]) + extend(vs2[i]);"
    },
    {
      "mnemonic": "VFWMUL.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Widening Float Multiply",
      "summary": "Multiplies N-bit floats to produce 2*N-bit float results.",
      "syntax": "VFWMUL.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPFVV",
        "binary_pattern": "111000 | vm | vs2 | vs1 | 001 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "111000",
            "clean": "111000"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (2*SEW)"
        },
        {
          "name": "vs2",
          "desc": "Src 2 (SEW)"
        },
        {
          "name": "vs1",
          "desc": "Src 1 (SEW)"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = extend(vs1[i]) * extend(vs2[i]);",
      "slug": "vfwmul_vv",
      "rel_url": "risc-v/vfwmul_vv/",
      "linked_summary": "Multiplies N-<a href=\"../../armv8-a/bit/\">bit</a> floats to produce 2*N-<a href=\"../../armv8-a/bit/\">bit</a> float results.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = extend(vs1[i]) * extend(vs2[i]);"
    },
    {
      "mnemonic": "VFREDUSUM.VS",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Unordered Float Reduction Sum",
      "summary": "Reduces a float vector to a scalar by summing elements (Order not preserved, faster).",
      "syntax": "VFREDUSUM.VS vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPFVV",
        "binary_pattern": "000001 | vm | vs2 | vs1 | 001 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "000001",
            "clean": "000001"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (Scalar)"
        },
        {
          "name": "vs2",
          "desc": "Src Vector"
        },
        {
          "name": "vs1",
          "desc": "Start Scalar"
        }
      ],
      "pseudocode": "vd[0] = vs1[0] + sum(vs2[*]); // Non-deterministic order",
      "slug": "vfredusum_vs",
      "rel_url": "risc-v/vfredusum_vs/",
      "linked_summary": "Reduces a float vector to a scalar by summing elements (Order <a href=\"../../armv8-a/not_1/\">not</a> preserved, faster).",
      "linked_pseudocode": "vd[0] = vs1[0] + sum(vs2[*]); // Non-deterministic order"
    },
    {
      "mnemonic": "VFREDMAX.VS",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Float Reduction Maximum",
      "summary": "Reduces a float vector to a scalar by finding the maximum element.",
      "syntax": "VFREDMAX.VS vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPFVV",
        "binary_pattern": "000111 | vm | vs2 | vs1 | 001 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "000111",
            "clean": "000111"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (Scalar)"
        },
        {
          "name": "vs2",
          "desc": "Src Vector"
        },
        {
          "name": "vs1",
          "desc": "Start Scalar"
        }
      ],
      "pseudocode": "vd[0] = max(vs1[0], max_element(vs2));",
      "slug": "vfredmax_vs",
      "rel_url": "risc-v/vfredmax_vs/",
      "linked_summary": "Reduces a float vector to a scalar by finding the maximum element.",
      "linked_pseudocode": "vd[0] = max(vs1[0], max_element(vs2));"
    },
    {
      "mnemonic": "VMSBC.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Mask Set Before First",
      "summary": "Writes a mask where bits are 1 before the first element in vs2 that is 1.",
      "syntax": "VMSBC.VV vd, vs2, vs1",
      "encoding": {
        "format": "OPMVV",
        "binary_pattern": "011110 | 0 | vs2 | 00000 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "011110",
            "clean": "011110"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest Mask"
        },
        {
          "name": "vs2",
          "desc": "Src Mask"
        }
      ],
      "pseudocode": "Sets mask bits to 1 up to (but not including) the first set bit in vs2.",
      "slug": "vmsbc_vv",
      "rel_url": "risc-v/vmsbc_vv/",
      "linked_summary": "Writes a mask where bits are 1 before the first element <a href=\"../../x86/in/\">in</a> vs2 that is 1.",
      "linked_pseudocode": "Sets mask bits to 1 up to (but <a href=\"../../armv8-a/not_1/\">not</a> including) the first set <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> vs2."
    },
    {
      "mnemonic": "CZERO.EQZ",
      "architecture": "RISC-V",
      "extension": "Zicond",
      "full_name": "Conditional Zero Equal to Zero",
      "summary": "Moves rs1 to rd if rs2 is non-zero, otherwise sets rd to zero.",
      "syntax": "CZERO.EQZ rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000111 | rs2 | rs1 | 101 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0000111",
            "clean": "0000111"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "101",
            "clean": "101"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        },
        {
          "name": "rs2",
          "desc": "Condition"
        }
      ],
      "pseudocode": "if (R[rs2] == 0) R[rd] = 0; else R[rd] = R[rs1];",
      "example": "CZERO.EQZ x10, x11, x12",
      "example_note": "If x12 is 0, x10=0. Else x10=x11.",
      "slug": "czero_eqz",
      "rel_url": "risc-v/czero_eqz/",
      "linked_summary": "Moves rs1 to rd if rs2 is non-<a href=\"../../armv9-a/zero_1/\">zero</a>, otherwise sets rd to <a href=\"../../armv9-a/zero_1/\">zero</a>.",
      "linked_pseudocode": "if (R[rs2] == 0) R[rd] = 0; else R[rd] = R[rs1];"
    },
    {
      "mnemonic": "CZERO.NEZ",
      "architecture": "RISC-V",
      "extension": "Zicond",
      "full_name": "Conditional Zero Not Equal to Zero",
      "summary": "Moves rs1 to rd if rs2 is zero, otherwise sets rd to zero.",
      "syntax": "CZERO.NEZ rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000111 | rs2 | rs1 | 111 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0000111",
            "clean": "0000111"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "111",
            "clean": "111"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        },
        {
          "name": "rs2",
          "desc": "Condition"
        }
      ],
      "pseudocode": "if (R[rs2] != 0) R[rd] = 0; else R[rd] = R[rs1];",
      "example": "CZERO.NEZ x10, x11, x12",
      "example_note": "If x12 != 0, x10=0. Else x10=x11.",
      "slug": "czero_nez",
      "rel_url": "risc-v/czero_nez/",
      "linked_summary": "Moves rs1 to rd if rs2 is <a href=\"../../armv9-a/zero_1/\">zero</a>, otherwise sets rd to <a href=\"../../armv9-a/zero_1/\">zero</a>.",
      "linked_pseudocode": "if (R[rs2] != 0) R[rd] = 0; else R[rd] = R[rs1];"
    },
    {
      "mnemonic": "PAUSE",
      "architecture": "RISC-V",
      "extension": "Zihintpause",
      "full_name": "Pause",
      "summary": "Hints that the current hart is in a spin-wait loop, allowing the hardware to reduce power consumption or yield resources.",
      "syntax": "PAUSE",
      "encoding": {
        "format": "I-Type (Hint)",
        "binary_pattern": "000000010000 | 00000 | 000 | 00000 | 0001111",
        "hex_opcode": "0x0F",
        "visual_parts": [
          {
            "raw": "000000010000",
            "clean": "000000010000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "0001111",
            "clean": "0001111"
          }
        ]
      },
      "operands": [],
      "pseudocode": "// Implementation-defined delay/yield",
      "example": "PAUSE",
      "example_note": "Used inside spinlocks.",
      "slug": "pause",
      "rel_url": "risc-v/pause/",
      "linked_summary": "Hints that the current hart is <a href=\"../../x86/in/\">in</a> a spin-<a href=\"../../powerisa/wait_1/\">wait</a> <a href=\"../../x86/loop/\">loop</a>, allowing the hardware to reduce power consumption <a href=\"../../powerisa/or/\">or</a> <a href=\"../../armv8-a/yield_2/\">yield</a> resources.",
      "linked_pseudocode": "// Implementation-defined delay/<a href=\"../../armv8-a/yield_2/\">yield</a>"
    },
    {
      "mnemonic": "CBO.CLEAN",
      "architecture": "RISC-V",
      "extension": "Zicbom",
      "full_name": "Cache Block Operation: Clean",
      "summary": "Performs a clean operation on the cache block containing the effective address.",
      "syntax": "CBO.CLEAN (rs1)",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "000000000001 | rs1 | 010 | 00000 | 0001111",
        "hex_opcode": "0x0F",
        "visual_parts": [
          {
            "raw": "000000000001",
            "clean": "000000000001"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "0001111",
            "clean": "0001111"
          }
        ]
      },
      "operands": [
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "CacheClean(R[rs1]);",
      "example": "CBO.CLEAN (x10)",
      "example_note": "Write back dirty data to memory.",
      "slug": "cbo_clean",
      "rel_url": "risc-v/cbo_clean/",
      "linked_summary": "Performs a clean operation on the cache block containing the effective address.",
      "linked_pseudocode": "CacheClean(R[rs1]);"
    },
    {
      "mnemonic": "CBO.FLUSH",
      "architecture": "RISC-V",
      "extension": "Zicbom",
      "full_name": "Cache Block Operation: Flush",
      "summary": "Performs a flush (clean + invalidate) operation on the cache block.",
      "syntax": "CBO.FLUSH (rs1)",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "000000000010 | rs1 | 010 | 00000 | 0001111",
        "hex_opcode": "0x0F",
        "visual_parts": [
          {
            "raw": "000000000010",
            "clean": "000000000010"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "0001111",
            "clean": "0001111"
          }
        ]
      },
      "operands": [
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "CacheFlush(R[rs1]);",
      "example": "CBO.FLUSH (x10)",
      "example_note": "Write back and invalidate.",
      "slug": "cbo_flush",
      "rel_url": "risc-v/cbo_flush/",
      "linked_summary": "Performs a flush (clean + invalidate) operation on the cache block.",
      "linked_pseudocode": "CacheFlush(R[rs1]);"
    },
    {
      "mnemonic": "CBO.INVAL",
      "architecture": "RISC-V",
      "extension": "Zicbom",
      "full_name": "Cache Block Operation: Invalidate",
      "summary": "Performs an invalidate operation on the cache block.",
      "syntax": "CBO.INVAL (rs1)",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "000000000000 | rs1 | 010 | 00000 | 0001111",
        "hex_opcode": "0x0F",
        "visual_parts": [
          {
            "raw": "000000000000",
            "clean": "000000000000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "0001111",
            "clean": "0001111"
          }
        ]
      },
      "operands": [
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "CacheInvalidate(R[rs1]);",
      "example": "CBO.INVAL (x10)",
      "example_note": "Discard cache line (data lost if dirty).",
      "slug": "cbo_inval",
      "rel_url": "risc-v/cbo_inval/",
      "linked_summary": "Performs an invalidate operation on the cache block.",
      "linked_pseudocode": "CacheInvalidate(R[rs1]);"
    },
    {
      "mnemonic": "RDCYCLE",
      "architecture": "RISC-V",
      "extension": "Pseudo",
      "full_name": "Read Cycle Counter",
      "summary": "Reads the lower 32/64 bits of the cycle counter.",
      "syntax": "RDCYCLE rd",
      "encoding": {
        "format": "Pseudo",
        "binary_pattern": "CSRRS rd, cycle, x0",
        "hex_opcode": "See CSRRS",
        "visual_parts": [
          {
            "raw": "CSRRS rd, cycle, x0",
            "clean": "CSRRS rd, cycle, x0"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        }
      ],
      "pseudocode": "R[rd] = CSR[cycle];",
      "example": "RDCYCLE x10",
      "example_note": "Get cycle count for performance timing.",
      "slug": "rdcycle",
      "rel_url": "risc-v/rdcycle/",
      "linked_summary": "Reads the lower 32/64 bits of the cycle counter.",
      "linked_pseudocode": "R[rd] = CSR[cycle];"
    },
    {
      "mnemonic": "RDTIME",
      "architecture": "RISC-V",
      "extension": "Pseudo",
      "full_name": "Read Real-Time Clock",
      "summary": "Reads the lower 32/64 bits of the real-time clock.",
      "syntax": "RDTIME rd",
      "encoding": {
        "format": "Pseudo",
        "binary_pattern": "CSRRS rd, time, x0",
        "hex_opcode": "See CSRRS",
        "visual_parts": [
          {
            "raw": "CSRRS rd, time, x0",
            "clean": "CSRRS rd, time, x0"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        }
      ],
      "pseudocode": "R[rd] = CSR[time];",
      "example": "RDTIME x10",
      "example_note": "Get wall-clock time.",
      "slug": "rdtime",
      "rel_url": "risc-v/rdtime/",
      "linked_summary": "Reads the lower 32/64 bits of the real-time clock.",
      "linked_pseudocode": "R[rd] = CSR[time];"
    },
    {
      "mnemonic": "RDINSTRET",
      "architecture": "RISC-V",
      "extension": "Pseudo",
      "full_name": "Read Instructions Retired",
      "summary": "Reads the count of instructions retired (completed).",
      "syntax": "RDINSTRET rd",
      "encoding": {
        "format": "Pseudo",
        "binary_pattern": "CSRRS rd, instret, x0",
        "hex_opcode": "See CSRRS",
        "visual_parts": [
          {
            "raw": "CSRRS rd, instret, x0",
            "clean": "CSRRS rd, instret, x0"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        }
      ],
      "pseudocode": "R[rd] = CSR[instret];",
      "example": "RDINSTRET x10",
      "example_note": "Get instruction count.",
      "slug": "rdinstret",
      "rel_url": "risc-v/rdinstret/",
      "linked_summary": "Reads the count of instructions retired (completed).",
      "linked_pseudocode": "R[rd] = CSR[instret];"
    },
    {
      "mnemonic": "NOP",
      "architecture": "RISC-V",
      "extension": "Pseudo",
      "full_name": "No Operation",
      "summary": "Performs no operation. Used for alignment or timing delays.",
      "syntax": "NOP",
      "encoding": {
        "format": "Pseudo",
        "binary_pattern": "ADDI x0, x0, 0",
        "hex_opcode": "0x00000013",
        "visual_parts": [
          {
            "raw": "ADDI x0, x0, 0",
            "clean": "ADDI x0, x0, 0"
          }
        ]
      },
      "operands": [],
      "pseudocode": "R[0] = R[0] + 0;",
      "example": "NOP",
      "example_note": "Does nothing.",
      "slug": "nop",
      "rel_url": "risc-v/nop/",
      "linked_summary": "Performs no operation. Used for alignment <a href=\"../../powerisa/or/\">or</a> timing delays.",
      "linked_pseudocode": "R[0] = R[0] + 0;"
    },
    {
      "mnemonic": "MV",
      "architecture": "RISC-V",
      "extension": "Pseudo",
      "full_name": "Move",
      "summary": "Copies the value of one register into another.",
      "syntax": "MV rd, rs",
      "encoding": {
        "format": "Pseudo",
        "binary_pattern": "ADDI rd, rs, 0",
        "hex_opcode": "See ADDI",
        "visual_parts": [
          {
            "raw": "ADDI rd, rs, 0",
            "clean": "ADDI rd, rs, 0"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Destination"
        },
        {
          "name": "rs",
          "desc": "Source"
        }
      ],
      "pseudocode": "R[rd] = R[rs];",
      "example": "MV x10, x11",
      "example_note": "Copies x11 to x10.",
      "slug": "mv",
      "rel_url": "risc-v/mv/",
      "linked_summary": "Copies the value of one register into another.",
      "linked_pseudocode": "R[rd] = R[rs];"
    },
    {
      "mnemonic": "LI",
      "architecture": "RISC-V",
      "extension": "Pseudo",
      "full_name": "Load Immediate",
      "summary": "Loads an arbitrary immediate value into a register.",
      "syntax": "LI rd, imm",
      "encoding": {
        "format": "Pseudo",
        "binary_pattern": "LUI + ADDI",
        "hex_opcode": "Variable",
        "visual_parts": [
          {
            "raw": "LUI + ADDI",
            "clean": "LUI + ADDI"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Destination"
        },
        {
          "name": "imm",
          "desc": "Immediate Value"
        }
      ],
      "pseudocode": "R[rd] = imm;",
      "example": "LI x5, 0x12345",
      "example_note": "Expands to: LUI x5, 0x12; ADDI x5, x5, 0x345",
      "slug": "li",
      "rel_url": "risc-v/li/",
      "linked_summary": "Loads an arbitrary immediate value into a register.",
      "linked_pseudocode": "R[rd] = imm;"
    },
    {
      "mnemonic": "RET",
      "architecture": "RISC-V",
      "extension": "Pseudo",
      "full_name": "Return",
      "summary": "Returns from a subroutine call.",
      "syntax": "RET",
      "encoding": {
        "format": "Pseudo",
        "binary_pattern": "JALR x0, 0(x1)",
        "hex_opcode": "0x00008067",
        "visual_parts": [
          {
            "raw": "JALR x0, 0(x1)",
            "clean": "JALR x0, 0(x1)"
          }
        ]
      },
      "operands": [],
      "pseudocode": "PC = R[1];",
      "example": "RET",
      "example_note": "Jumps to the address in the Return Address register (ra/x1).",
      "slug": "ret",
      "rel_url": "risc-v/ret/",
      "linked_summary": "Returns from a subroutine <a href=\"../../x86/call/\">call</a>.",
      "linked_pseudocode": "PC = R[1];"
    },
    {
      "mnemonic": "J",
      "architecture": "RISC-V",
      "extension": "Pseudo",
      "full_name": "Jump",
      "summary": "Unconditionally jumps to a target offset.",
      "syntax": "J offset",
      "encoding": {
        "format": "Pseudo",
        "binary_pattern": "JAL x0, offset",
        "hex_opcode": "See JAL",
        "visual_parts": [
          {
            "raw": "JAL x0, offset",
            "clean": "JAL x0, offset"
          }
        ]
      },
      "operands": [
        {
          "name": "offset",
          "desc": "Jump Target"
        }
      ],
      "pseudocode": "PC += sext(offset);",
      "example": "J label",
      "example_note": "Unconditional jump (discarding return address).",
      "slug": "j",
      "rel_url": "risc-v/j/",
      "linked_summary": "Unconditionally jumps to a target offset.",
      "linked_pseudocode": "PC += sext(offset);"
    },
    {
      "mnemonic": "JR",
      "architecture": "RISC-V",
      "extension": "Pseudo",
      "full_name": "Jump Register",
      "summary": "Unconditionally jumps to an address held in a register.",
      "syntax": "JR rs",
      "encoding": {
        "format": "Pseudo",
        "binary_pattern": "JALR x0, 0(rs)",
        "hex_opcode": "See JALR",
        "visual_parts": [
          {
            "raw": "JALR x0, 0(rs)",
            "clean": "JALR x0, 0(rs)"
          }
        ]
      },
      "operands": [
        {
          "name": "rs",
          "desc": "Address Register"
        }
      ],
      "pseudocode": "PC = R[rs];",
      "example": "JR x10",
      "example_note": "Jump to address stored in x10.",
      "slug": "jr",
      "rel_url": "risc-v/jr/",
      "linked_summary": "Unconditionally jumps to an address held <a href=\"../../x86/in/\">in</a> a register.",
      "linked_pseudocode": "PC = R[rs];"
    },
    {
      "mnemonic": "CALL",
      "architecture": "RISC-V",
      "extension": "Pseudo",
      "full_name": "Call Subroutine",
      "summary": "Calls a function by jumping to an address and saving the return address.",
      "syntax": "CALL symbol",
      "encoding": {
        "format": "Pseudo",
        "binary_pattern": "AUIPC + JALR",
        "hex_opcode": "Variable",
        "visual_parts": [
          {
            "raw": "AUIPC + JALR",
            "clean": "AUIPC + JALR"
          }
        ]
      },
      "operands": [
        {
          "name": "symbol",
          "desc": "Function Name"
        }
      ],
      "pseudocode": "x1 = PC + 4; PC = symbol;",
      "example": "CALL printf",
      "example_note": "Sets up x1 (ra) and jumps to printf.",
      "slug": "call",
      "rel_url": "risc-v/call/",
      "linked_summary": "Calls a function by jumping to an address <a href=\"../../armv8-a/and_6/\">and</a> saving the return address.",
      "linked_pseudocode": "x1 = PC + 4; PC = symbol;"
    },
    {
      "mnemonic": "NOT",
      "architecture": "RISC-V",
      "extension": "Pseudo",
      "full_name": "Bitwise NOT",
      "summary": "Computes the bitwise logical negation (one's complement).",
      "syntax": "NOT rd, rs",
      "encoding": {
        "format": "Pseudo",
        "binary_pattern": "XORI rd, rs, -1",
        "hex_opcode": "See XORI",
        "visual_parts": [
          {
            "raw": "XORI rd, rs, -1",
            "clean": "XORI rd, rs, -1"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Destination"
        },
        {
          "name": "rs",
          "desc": "Source"
        }
      ],
      "pseudocode": "R[rd] = ~R[rs];",
      "example": "NOT x10, x11",
      "example_note": "Inverts all bits of x11.",
      "slug": "not",
      "rel_url": "risc-v/not/",
      "linked_summary": "Computes the bitwise logical negation (one's complement).",
      "linked_pseudocode": "R[rd] = ~R[rs];"
    },
    {
      "mnemonic": "NEG",
      "architecture": "RISC-V",
      "extension": "Pseudo",
      "full_name": "Negate",
      "summary": "Computes the two's complement negation (arithmetic negative).",
      "syntax": "NEG rd, rs",
      "encoding": {
        "format": "Pseudo",
        "binary_pattern": "SUB rd, x0, rs",
        "hex_opcode": "See SUB",
        "visual_parts": [
          {
            "raw": "SUB rd, x0, rs",
            "clean": "SUB rd, x0, rs"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Destination"
        },
        {
          "name": "rs",
          "desc": "Source"
        }
      ],
      "pseudocode": "R[rd] = 0 - R[rs];",
      "example": "NEG x5, x6",
      "example_note": "x5 = -x6",
      "slug": "neg",
      "rel_url": "risc-v/neg/",
      "linked_summary": "Computes the two's complement negation (arithmetic negative).",
      "linked_pseudocode": "R[rd] = 0 - R[rs];"
    },
    {
      "mnemonic": "BEQZ",
      "architecture": "RISC-V",
      "extension": "Pseudo",
      "full_name": "Branch if Equal to Zero",
      "summary": "Branches if the register is zero.",
      "syntax": "BEQZ rs, offset",
      "encoding": {
        "format": "Pseudo",
        "binary_pattern": "BEQ rs, x0, offset",
        "hex_opcode": "See BEQ",
        "visual_parts": [
          {
            "raw": "BEQ rs, x0, offset",
            "clean": "BEQ rs, x0, offset"
          }
        ]
      },
      "operands": [
        {
          "name": "rs",
          "desc": "Source"
        },
        {
          "name": "offset",
          "desc": "Label"
        }
      ],
      "pseudocode": "if (R[rs] == 0) PC += offset;",
      "example": "BEQZ x10, exit",
      "example_note": "Jump to exit if x10 is zero.",
      "slug": "beqz",
      "rel_url": "risc-v/beqz/",
      "linked_summary": "Branches if the register is <a href=\"../../armv9-a/zero_1/\">zero</a>.",
      "linked_pseudocode": "if (R[rs] == 0) PC += offset;"
    },
    {
      "mnemonic": "BNEZ",
      "architecture": "RISC-V",
      "extension": "Pseudo",
      "full_name": "Branch if Not Equal to Zero",
      "summary": "Branches if the register is not zero.",
      "syntax": "BNEZ rs, offset",
      "encoding": {
        "format": "Pseudo",
        "binary_pattern": "BNE rs, x0, offset",
        "hex_opcode": "See BNE",
        "visual_parts": [
          {
            "raw": "BNE rs, x0, offset",
            "clean": "BNE rs, x0, offset"
          }
        ]
      },
      "operands": [
        {
          "name": "rs",
          "desc": "Source"
        },
        {
          "name": "offset",
          "desc": "Label"
        }
      ],
      "pseudocode": "if (R[rs] != 0) PC += offset;",
      "example": "BNEZ x10, loop",
      "example_note": "Jump to loop if x10 is not zero.",
      "slug": "bnez",
      "rel_url": "risc-v/bnez/",
      "linked_summary": "Branches if the register is <a href=\"../../armv8-a/not_1/\">not</a> <a href=\"../../armv9-a/zero_1/\">zero</a>.",
      "linked_pseudocode": "if (R[rs] != 0) PC += offset;"
    },
    {
      "mnemonic": "SEQZ",
      "architecture": "RISC-V",
      "extension": "Pseudo",
      "full_name": "Set if Equal to Zero",
      "summary": "Sets rd to 1 if rs is zero, otherwise 0.",
      "syntax": "SEQZ rd, rs",
      "encoding": {
        "format": "Pseudo",
        "binary_pattern": "SLTIU rd, rs, 1",
        "hex_opcode": "See SLTIU",
        "visual_parts": [
          {
            "raw": "SLTIU rd, rs, 1",
            "clean": "SLTIU rd, rs, 1"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs",
          "desc": "Source"
        }
      ],
      "pseudocode": "R[rd] = (R[rs] == 0) ? 1 : 0;",
      "example": "SEQZ x5, x10",
      "example_note": "Sets x5 to 1 if x10 is 0.",
      "slug": "seqz",
      "rel_url": "risc-v/seqz/",
      "linked_summary": "Sets rd to 1 if rs is <a href=\"../../armv9-a/zero_1/\">zero</a>, otherwise 0.",
      "linked_pseudocode": "R[rd] = (R[rs] == 0) ? 1 : 0;"
    },
    {
      "mnemonic": "SNEZ",
      "architecture": "RISC-V",
      "extension": "Pseudo",
      "full_name": "Set if Not Equal to Zero",
      "summary": "Sets rd to 1 if rs is not zero, otherwise 0.",
      "syntax": "SNEZ rd, rs",
      "encoding": {
        "format": "Pseudo",
        "binary_pattern": "SLTU rd, x0, rs",
        "hex_opcode": "See SLTU",
        "visual_parts": [
          {
            "raw": "SLTU rd, x0, rs",
            "clean": "SLTU rd, x0, rs"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs",
          "desc": "Source"
        }
      ],
      "pseudocode": "R[rd] = (R[rs] != 0) ? 1 : 0;",
      "example": "SNEZ x5, x10",
      "example_note": "Sets x5 to 1 if x10 is non-zero.",
      "slug": "snez",
      "rel_url": "risc-v/snez/",
      "linked_summary": "Sets rd to 1 if rs is <a href=\"../../armv8-a/not_1/\">not</a> <a href=\"../../armv9-a/zero_1/\">zero</a>, otherwise 0.",
      "linked_pseudocode": "R[rd] = (R[rs] != 0) ? 1 : 0;"
    },
    {
      "mnemonic": "AES64ES",
      "architecture": "RISC-V",
      "extension": "Zk (Crypto)",
      "full_name": "AES-64 Encryption Schedule",
      "summary": "Performs one round of AES-128 encryption key schedule generation.",
      "syntax": "AES64ES rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0011001 | rs2 | rs1 | 000 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0011001",
            "clean": "0011001"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source 1"
        },
        {
          "name": "rs2",
          "desc": "Source 2"
        }
      ],
      "pseudocode": "R[rd] = aes_encrypt_schedule(R[rs1], R[rs2]);",
      "example": "AES64ES x10, x11, x12",
      "example_note": "AES Key Gen.",
      "slug": "aes64es",
      "rel_url": "risc-v/aes64es/",
      "linked_summary": "Performs one round of AES-128 encryption key schedule generation.",
      "linked_pseudocode": "R[rd] = aes_encrypt_schedule(R[rs1], R[rs2]);"
    },
    {
      "mnemonic": "AES64DS",
      "architecture": "RISC-V",
      "extension": "Zk (Crypto)",
      "full_name": "AES-64 Decryption Schedule",
      "summary": "Performs one round of AES-128 decryption key schedule generation.",
      "syntax": "AES64DS rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0011101 | rs2 | rs1 | 000 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0011101",
            "clean": "0011101"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source 1"
        },
        {
          "name": "rs2",
          "desc": "Source 2"
        }
      ],
      "pseudocode": "R[rd] = aes_decrypt_schedule(R[rs1], R[rs2]);",
      "example": "AES64DS x10, x11, x12",
      "example_note": "AES Decrypt Key Gen.",
      "slug": "aes64ds",
      "rel_url": "risc-v/aes64ds/",
      "linked_summary": "Performs one round of AES-128 decryption key schedule generation.",
      "linked_pseudocode": "R[rd] = aes_decrypt_schedule(R[rs1], R[rs2]);"
    },
    {
      "mnemonic": "SHA256SIG0",
      "architecture": "RISC-V",
      "extension": "Zk (Crypto)",
      "full_name": "SHA-256 Sigma0",
      "summary": "Performs the Sigma0 transformation function for SHA-256.",
      "syntax": "SHA256SIG0 rd, rs1",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "0001000 | 00010 | rs1 | 001 | rd | 0010011",
        "hex_opcode": "0x13",
        "visual_parts": [
          {
            "raw": "0001000",
            "clean": "0001000"
          },
          {
            "raw": "00010",
            "clean": "00010"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0010011",
            "clean": "0010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        }
      ],
      "pseudocode": "R[rd] = ROTR(x, 7) ^ ROTR(x, 18) ^ (x >> 3);",
      "example": "SHA256SIG0 x10, x11",
      "example_note": "SHA-256 calculation.",
      "slug": "sha256sig0",
      "rel_url": "risc-v/sha256sig0/",
      "linked_summary": "Performs the Sigma0 transformation function for SHA-256.",
      "linked_pseudocode": "R[rd] = ROTR(x, 7) ^ ROTR(x, 18) ^ (x >> 3);"
    },
    {
      "mnemonic": "SHA256SUM0",
      "architecture": "RISC-V",
      "extension": "Zk (Crypto)",
      "full_name": "SHA-256 Sum0",
      "summary": "Performs the Sum0 transformation function for SHA-256.",
      "syntax": "SHA256SUM0 rd, rs1",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "0001000 | 00000 | rs1 | 001 | rd | 0010011",
        "hex_opcode": "0x13",
        "visual_parts": [
          {
            "raw": "0001000",
            "clean": "0001000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0010011",
            "clean": "0010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        }
      ],
      "pseudocode": "R[rd] = ROTR(x, 2) ^ ROTR(x, 13) ^ ROTR(x, 22);",
      "example": "SHA256SUM0 x10, x11",
      "example_note": "SHA-256 calculation.",
      "slug": "sha256sum0",
      "rel_url": "risc-v/sha256sum0/",
      "linked_summary": "Performs the Sum0 transformation function for SHA-256.",
      "linked_pseudocode": "R[rd] = ROTR(x, 2) ^ ROTR(x, 13) ^ ROTR(x, 22);"
    },
    {
      "mnemonic": "FCVT.WU.S",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Convert Float to Unsigned Word",
      "summary": "Converts a single-precision float to a 32-bit unsigned integer.",
      "syntax": "FCVT.WU.S rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "1100000 | 00001 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1100000",
            "clean": "1100000"
          },
          {
            "raw": "00001",
            "clean": "00001"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (UInt)"
        },
        {
          "name": "rs1",
          "desc": "Source (Float)"
        }
      ],
      "pseudocode": "R[rd] = sext(f32_to_u32(F[rs1]));",
      "example": "FCVT.WU.S x10, f1",
      "example_note": "Float -> Unsigned Int.",
      "slug": "fcvt_wu_s",
      "rel_url": "risc-v/fcvt_wu_s/",
      "linked_summary": "Converts a single-precision float to a 32-<a href=\"../../armv8-a/bit/\">bit</a> unsigned integer.",
      "linked_pseudocode": "R[rd] = sext(f32_to_u32(F[rs1]));"
    },
    {
      "mnemonic": "FCVT.S.WU",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Convert Unsigned Word to Float",
      "summary": "Converts a 32-bit unsigned integer to a single-precision float.",
      "syntax": "FCVT.S.WU rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "1101000 | 00001 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1101000",
            "clean": "1101000"
          },
          {
            "raw": "00001",
            "clean": "00001"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Float)"
        },
        {
          "name": "rs1",
          "desc": "Source (UInt)"
        }
      ],
      "pseudocode": "F[rd] = u32_to_f32(R[rs1]);",
      "example": "FCVT.S.WU f1, x10",
      "example_note": "Unsigned Int -> Float.",
      "slug": "fcvt_s_wu",
      "rel_url": "risc-v/fcvt_s_wu/",
      "linked_summary": "Converts a 32-<a href=\"../../armv8-a/bit/\">bit</a> unsigned integer to a single-precision float.",
      "linked_pseudocode": "F[rd] = u32_to_f32(R[rs1]);"
    },
    {
      "mnemonic": "FCVT.W.D",
      "architecture": "RISC-V",
      "extension": "D",
      "full_name": "Convert Double to Word",
      "summary": "Converts a double-precision float to a 32-bit signed integer.",
      "syntax": "FCVT.W.D rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "1100001 | 00000 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1100001",
            "clean": "1100001"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Int)"
        },
        {
          "name": "rs1",
          "desc": "Source (Double)"
        }
      ],
      "pseudocode": "R[rd] = sext(f64_to_i32(F[rs1]));",
      "example": "FCVT.W.D x10, f0",
      "example_note": "Double -> Int.",
      "slug": "fcvt_w_d",
      "rel_url": "risc-v/fcvt_w_d/",
      "linked_summary": "Converts a double-precision float to a 32-<a href=\"../../armv8-a/bit/\">bit</a> signed integer.",
      "linked_pseudocode": "R[rd] = sext(f64_to_i32(F[rs1]));"
    },
    {
      "mnemonic": "FCVT.D.W",
      "architecture": "RISC-V",
      "extension": "D",
      "full_name": "Convert Word to Double",
      "summary": "Converts a 32-bit signed integer to a double-precision float.",
      "syntax": "FCVT.D.W rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "1101001 | 00000 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1101001",
            "clean": "1101001"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Double)"
        },
        {
          "name": "rs1",
          "desc": "Source (Int)"
        }
      ],
      "pseudocode": "F[rd] = i32_to_f64(R[rs1]);",
      "example": "FCVT.D.W f0, x10",
      "example_note": "Int -> Double.",
      "slug": "fcvt_d_w",
      "rel_url": "risc-v/fcvt_d_w/",
      "linked_summary": "Converts a 32-<a href=\"../../armv8-a/bit/\">bit</a> signed integer to a double-precision float.",
      "linked_pseudocode": "F[rd] = i32_to_f64(R[rs1]);"
    },
    {
      "mnemonic": "SH1ADD",
      "architecture": "RISC-V",
      "extension": "Zba (Address Gen)",
      "full_name": "Shift Left 1 and Add",
      "summary": "Shifts rs1 left by 1 and adds rs2. Used for calculating addresses of 16-bit elements.",
      "syntax": "SH1ADD rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0010000 | rs2 | rs1 | 010 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0010000",
            "clean": "0010000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Index"
        },
        {
          "name": "rs2",
          "desc": "Base"
        }
      ],
      "pseudocode": "R[rd] = R[rs2] + (R[rs1] << 1);",
      "example": "SH1ADD x10, x11, x12",
      "example_note": "Calculate address: x12 + (x11 * 2).",
      "slug": "sh1add",
      "rel_url": "risc-v/sh1add/",
      "linked_summary": "Shifts rs1 left by 1 <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../armv8-a/adds_5/\">adds</a> rs2. Used for calculating addresses of 16-<a href=\"../../armv8-a/bit/\">bit</a> elements.",
      "linked_pseudocode": "R[rd] = R[rs2] + (R[rs1] << 1);"
    },
    {
      "mnemonic": "SH2ADD",
      "architecture": "RISC-V",
      "extension": "Zba (Address Gen)",
      "full_name": "Shift Left 2 and Add",
      "summary": "Shifts rs1 left by 2 and adds rs2. Used for calculating addresses of 32-bit elements.",
      "syntax": "SH2ADD rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0010000 | rs2 | rs1 | 100 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0010000",
            "clean": "0010000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Index"
        },
        {
          "name": "rs2",
          "desc": "Base"
        }
      ],
      "pseudocode": "R[rd] = R[rs2] + (R[rs1] << 2);",
      "example": "SH2ADD x10, x11, x12",
      "example_note": "Calculate address: x12 + (x11 * 4).",
      "slug": "sh2add",
      "rel_url": "risc-v/sh2add/",
      "linked_summary": "Shifts rs1 left by 2 <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../armv8-a/adds_5/\">adds</a> rs2. Used for calculating addresses of 32-<a href=\"../../armv8-a/bit/\">bit</a> elements.",
      "linked_pseudocode": "R[rd] = R[rs2] + (R[rs1] << 2);"
    },
    {
      "mnemonic": "SH3ADD",
      "architecture": "RISC-V",
      "extension": "Zba (Address Gen)",
      "full_name": "Shift Left 3 and Add",
      "summary": "Shifts rs1 left by 3 and adds rs2. Used for calculating addresses of 64-bit elements.",
      "syntax": "SH3ADD rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0010000 | rs2 | rs1 | 110 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0010000",
            "clean": "0010000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "110",
            "clean": "110"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Index"
        },
        {
          "name": "rs2",
          "desc": "Base"
        }
      ],
      "pseudocode": "R[rd] = R[rs2] + (R[rs1] << 3);",
      "example": "SH3ADD x10, x11, x12",
      "example_note": "Calculate address: x12 + (x11 * 8).",
      "slug": "sh3add",
      "rel_url": "risc-v/sh3add/",
      "linked_summary": "Shifts rs1 left by 3 <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../armv8-a/adds_5/\">adds</a> rs2. Used for calculating addresses of 64-<a href=\"../../armv8-a/bit/\">bit</a> elements.",
      "linked_pseudocode": "R[rd] = R[rs2] + (R[rs1] << 3);"
    },
    {
      "mnemonic": "ADDUW",
      "architecture": "RISC-V",
      "extension": "Zba (Address Gen)",
      "full_name": "Add Unsigned Word",
      "summary": "Zero-extends the lower 32 bits of rs1 and adds it to rs2. Useful for 64-bit address calculations with 32-bit unsigned indices.",
      "syntax": "ADDUW rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000100 | rs2 | rs1 | 000 | rd | 0111011",
        "hex_opcode": "0x3B",
        "visual_parts": [
          {
            "raw": "0000100",
            "clean": "0000100"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0111011",
            "clean": "0111011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Index (32-bit)"
        },
        {
          "name": "rs2",
          "desc": "Base"
        }
      ],
      "pseudocode": "R[rd] = R[rs2] + zext(R[rs1][31:0]);",
      "example": "ADDUW x10, x11, x12",
      "example_note": "x10 = x12 + (uint32_t)x11",
      "slug": "adduw",
      "rel_url": "risc-v/adduw/",
      "linked_summary": "Zero-extends the lower 32 bits of rs1 <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../armv8-a/adds_5/\">adds</a> <a href=\"../../armv8-a/it/\">it</a> to rs2. Useful for 64-<a href=\"../../armv8-a/bit/\">bit</a> address calculations with 32-<a href=\"../../armv8-a/bit/\">bit</a> unsigned indices.",
      "linked_pseudocode": "R[rd] = R[rs2] + zext(R[rs1][31:0]);"
    },
    {
      "mnemonic": "BSET",
      "architecture": "RISC-V",
      "extension": "Zbs (Single Bit)",
      "full_name": "Bit Set",
      "summary": "Sets a single bit in rs1 at the index specified by rs2.",
      "syntax": "BSET rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0010100 | rs2 | rs1 | 001 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0010100",
            "clean": "0010100"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        },
        {
          "name": "rs2",
          "desc": "Index"
        }
      ],
      "pseudocode": "R[rd] = R[rs1] | (1 << (R[rs2] & (XLEN-1)));",
      "example": "BSET x10, x11, x12",
      "example_note": "Set the bit at index x12 in x11.",
      "slug": "bset",
      "rel_url": "risc-v/bset/",
      "linked_summary": "Sets a single <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> rs1 <a href=\"../../armv8-a/at_2/\">at</a> the <a href=\"../../armv8-a/index/\">index</a> specified by rs2.",
      "linked_pseudocode": "R[rd] = R[rs1] | (1 << (R[rs2] & (XLEN-1)));"
    },
    {
      "mnemonic": "BSETI",
      "architecture": "RISC-V",
      "extension": "Zbs (Single Bit)",
      "full_name": "Bit Set Immediate",
      "summary": "Sets a single bit in rs1 at the index specified by an immediate.",
      "syntax": "BSETI rd, rs1, imm",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "0010100 | imm | rs1 | 001 | rd | 0010011",
        "hex_opcode": "0x13",
        "visual_parts": [
          {
            "raw": "0010100",
            "clean": "0010100"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0010011",
            "clean": "0010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        },
        {
          "name": "imm",
          "desc": "Index"
        }
      ],
      "pseudocode": "R[rd] = R[rs1] | (1 << imm);",
      "example": "BSETI x10, x11, 5",
      "example_note": "Set bit 5.",
      "slug": "bseti",
      "rel_url": "risc-v/bseti/",
      "linked_summary": "Sets a single <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> rs1 <a href=\"../../armv8-a/at_2/\">at</a> the <a href=\"../../armv8-a/index/\">index</a> specified by an immediate.",
      "linked_pseudocode": "R[rd] = R[rs1] | (1 << imm);"
    },
    {
      "mnemonic": "BCLR",
      "architecture": "RISC-V",
      "extension": "Zbs (Single Bit)",
      "full_name": "Bit Clear",
      "summary": "Clears a single bit in rs1 at the index specified by rs2.",
      "syntax": "BCLR rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0100100 | rs2 | rs1 | 001 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0100100",
            "clean": "0100100"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        },
        {
          "name": "rs2",
          "desc": "Index"
        }
      ],
      "pseudocode": "R[rd] = R[rs1] & ~(1 << (R[rs2] & (XLEN-1)));",
      "example": "BCLR x10, x11, x12",
      "example_note": "Clear the bit at index x12.",
      "slug": "bclr",
      "rel_url": "risc-v/bclr/",
      "linked_summary": "Clears a single <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> rs1 <a href=\"../../armv8-a/at_2/\">at</a> the <a href=\"../../armv8-a/index/\">index</a> specified by rs2.",
      "linked_pseudocode": "R[rd] = R[rs1] & ~(1 << (R[rs2] & (XLEN-1)));"
    },
    {
      "mnemonic": "BCLRI",
      "architecture": "RISC-V",
      "extension": "Zbs (Single Bit)",
      "full_name": "Bit Clear Immediate",
      "summary": "Clears a single bit in rs1 at the index specified by an immediate.",
      "syntax": "BCLRI rd, rs1, imm",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "0100100 | imm | rs1 | 001 | rd | 0010011",
        "hex_opcode": "0x13",
        "visual_parts": [
          {
            "raw": "0100100",
            "clean": "0100100"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0010011",
            "clean": "0010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        },
        {
          "name": "imm",
          "desc": "Index"
        }
      ],
      "pseudocode": "R[rd] = R[rs1] & ~(1 << imm);",
      "example": "BCLRI x10, x11, 3",
      "example_note": "Clear bit 3.",
      "slug": "bclri",
      "rel_url": "risc-v/bclri/",
      "linked_summary": "Clears a single <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> rs1 <a href=\"../../armv8-a/at_2/\">at</a> the <a href=\"../../armv8-a/index/\">index</a> specified by an immediate.",
      "linked_pseudocode": "R[rd] = R[rs1] & ~(1 << imm);"
    },
    {
      "mnemonic": "BINV",
      "architecture": "RISC-V",
      "extension": "Zbs (Single Bit)",
      "full_name": "Bit Invert",
      "summary": "Inverts (toggles) a single bit in rs1 at the index specified by rs2.",
      "syntax": "BINV rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0110100 | rs2 | rs1 | 001 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0110100",
            "clean": "0110100"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        },
        {
          "name": "rs2",
          "desc": "Index"
        }
      ],
      "pseudocode": "R[rd] = R[rs1] ^ (1 << (R[rs2] & (XLEN-1)));",
      "example": "BINV x10, x11, x12",
      "example_note": "Toggle the bit at index x12.",
      "slug": "binv",
      "rel_url": "risc-v/binv/",
      "linked_summary": "Inverts (toggles) a single <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> rs1 <a href=\"../../armv8-a/at_2/\">at</a> the <a href=\"../../armv8-a/index/\">index</a> specified by rs2.",
      "linked_pseudocode": "R[rd] = R[rs1] ^ (1 << (R[rs2] & (XLEN-1)));"
    },
    {
      "mnemonic": "BINVI",
      "architecture": "RISC-V",
      "extension": "Zbs (Single Bit)",
      "full_name": "Bit Invert Immediate",
      "summary": "Inverts (toggles) a single bit in rs1 at the index specified by an immediate.",
      "syntax": "BINVI rd, rs1, imm",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "0110100 | imm | rs1 | 001 | rd | 0010011",
        "hex_opcode": "0x13",
        "visual_parts": [
          {
            "raw": "0110100",
            "clean": "0110100"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0010011",
            "clean": "0010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        },
        {
          "name": "imm",
          "desc": "Index"
        }
      ],
      "pseudocode": "R[rd] = R[rs1] ^ (1 << imm);",
      "example": "BINVI x10, x11, 7",
      "example_note": "Toggle bit 7.",
      "slug": "binvi",
      "rel_url": "risc-v/binvi/",
      "linked_summary": "Inverts (toggles) a single <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> rs1 <a href=\"../../armv8-a/at_2/\">at</a> the <a href=\"../../armv8-a/index/\">index</a> specified by an immediate.",
      "linked_pseudocode": "R[rd] = R[rs1] ^ (1 << imm);"
    },
    {
      "mnemonic": "BEXT",
      "architecture": "RISC-V",
      "extension": "Zbs (Single Bit)",
      "full_name": "Bit Extract",
      "summary": "Extracts the value of a single bit (0 or 1) at the index specified by rs2. The result is placed in the LSB of rd.",
      "syntax": "BEXT rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0100100 | rs2 | rs1 | 101 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0100100",
            "clean": "0100100"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "101",
            "clean": "101"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (0 or 1)"
        },
        {
          "name": "rs1",
          "desc": "Source"
        },
        {
          "name": "rs2",
          "desc": "Index"
        }
      ],
      "pseudocode": "R[rd] = (R[rs1] >> (R[rs2] & (XLEN-1))) & 1;",
      "example": "BEXT x10, x11, x12",
      "example_note": "x10 = (x11 >> x12) & 1",
      "slug": "bext",
      "rel_url": "risc-v/bext/",
      "linked_summary": "Extracts the value of a single <a href=\"../../armv8-a/bit/\">bit</a> (0 <a href=\"../../powerisa/or/\">or</a> 1) <a href=\"../../armv8-a/at_2/\">at</a> the <a href=\"../../armv8-a/index/\">index</a> specified by rs2. The result is placed <a href=\"../../x86/in/\">in</a> the LSB of rd.",
      "linked_pseudocode": "R[rd] = (R[rs1] >> (R[rs2] & (XLEN-1))) & 1;"
    },
    {
      "mnemonic": "BEXTI",
      "architecture": "RISC-V",
      "extension": "Zbs (Single Bit)",
      "full_name": "Bit Extract Immediate",
      "summary": "Extracts the value of a single bit (0 or 1) at the index specified by an immediate.",
      "syntax": "BEXTI rd, rs1, imm",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "0100100 | imm | rs1 | 101 | rd | 0010011",
        "hex_opcode": "0x13",
        "visual_parts": [
          {
            "raw": "0100100",
            "clean": "0100100"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "101",
            "clean": "101"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0010011",
            "clean": "0010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (0 or 1)"
        },
        {
          "name": "rs1",
          "desc": "Source"
        },
        {
          "name": "imm",
          "desc": "Index"
        }
      ],
      "pseudocode": "R[rd] = (R[rs1] >> imm) & 1;",
      "example": "BEXTI x10, x11, 31",
      "example_note": "Get sign bit (bit 31) of x11.",
      "slug": "bexti",
      "rel_url": "risc-v/bexti/",
      "linked_summary": "Extracts the value of a single <a href=\"../../armv8-a/bit/\">bit</a> (0 <a href=\"../../powerisa/or/\">or</a> 1) <a href=\"../../armv8-a/at_2/\">at</a> the <a href=\"../../armv8-a/index/\">index</a> specified by an immediate.",
      "linked_pseudocode": "R[rd] = (R[rs1] >> imm) & 1;"
    },
    {
      "mnemonic": "CLMUL",
      "architecture": "RISC-V",
      "extension": "Zbc (Carry-less)",
      "full_name": "Carry-less Multiply",
      "summary": "Performs carry-less multiplication of the lower bits of rs1 and rs2. Used for CRC and GCM (crypto).",
      "syntax": "CLMUL rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000101 | rs2 | rs1 | 001 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0000101",
            "clean": "0000101"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        }
      ],
      "pseudocode": "R[rd] = clmul(R[rs1], R[rs2]);",
      "example": "CLMUL x10, x11, x12",
      "example_note": "Carry-less multiply (GF(2^n)).",
      "slug": "clmul",
      "rel_url": "risc-v/clmul/",
      "linked_summary": "Performs carry-less multiplication of the lower bits of rs1 <a href=\"../../armv8-a/and_6/\">and</a> rs2. Used for CRC <a href=\"../../armv8-a/and_6/\">and</a> GCM (crypto).",
      "linked_pseudocode": "R[rd] = clmul(R[rs1], R[rs2]);"
    },
    {
      "mnemonic": "VSADDU.VV",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Saturating Integer Add Unsigned",
      "summary": "Adds unsigned integers with saturation (clips to max instead of wrapping).",
      "syntax": "VSADDU.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "100000 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "100000",
            "clean": "100000"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = saturate_u(vs1[i] + vs2[i]);",
      "slug": "vsaddu_vv",
      "rel_url": "risc-v/vsaddu_vv/",
      "linked_summary": "Adds unsigned integers with saturation (clips to max instead of wrapping).",
      "linked_pseudocode": "foreach(i < vl): vd[i] = saturate_u(vs1[i] + vs2[i]);"
    },
    {
      "mnemonic": "VSSUBU.VV",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Saturating Integer Subtract Unsigned",
      "summary": "Subtracts unsigned integers with saturation (clips to 0 instead of wrapping).",
      "syntax": "VSSUBU.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "100010 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "100010",
            "clean": "100010"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = saturate_u(vs1[i] - vs2[i]);",
      "slug": "vssubu_vv",
      "rel_url": "risc-v/vssubu_vv/",
      "linked_summary": "Subtracts unsigned integers with saturation (clips to 0 instead of wrapping).",
      "linked_pseudocode": "foreach(i < vl): vd[i] = saturate_u(vs1[i] - vs2[i]);"
    },
    {
      "mnemonic": "VAADDU.VV",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Averaging Add Unsigned",
      "summary": "Computes (a + b + 1) >> 1 for unsigned integers.",
      "syntax": "VAADDU.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "100100 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "100100",
            "clean": "100100"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = (vs1[i] + vs2[i] + 1) >> 1;",
      "slug": "vaaddu_vv",
      "rel_url": "risc-v/vaaddu_vv/",
      "linked_summary": "Computes (a + <a href=\"../../armv8-a/b_1/\">b</a> + 1) >> 1 for unsigned integers.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = (vs1[i] + vs2[i] + 1) >> 1;"
    },
    {
      "mnemonic": "VASUB.VV",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Averaging Subtract Signed",
      "summary": "Computes (a - b) >> 1 for signed integers.",
      "syntax": "VASUB.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "100110 | vm | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "100110",
            "clean": "100110"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = (vs1[i] - vs2[i]) >> 1;",
      "slug": "vasub_vv",
      "rel_url": "risc-v/vasub_vv/",
      "linked_summary": "Computes (a - <a href=\"../../armv8-a/b_1/\">b</a>) >> 1 for signed integers.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = (vs1[i] - vs2[i]) >> 1;"
    },
    {
      "mnemonic": "VASUBU.VV",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Averaging Subtract Unsigned",
      "summary": "Computes (a - b) >> 1 for unsigned integers.",
      "syntax": "VASUBU.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "100110 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "100110",
            "clean": "100110"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = (vs1[i] - vs2[i]) >> 1;",
      "slug": "vasubu_vv",
      "rel_url": "risc-v/vasubu_vv/",
      "linked_summary": "Computes (a - <a href=\"../../armv8-a/b_1/\">b</a>) >> 1 for unsigned integers.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = (vs1[i] - vs2[i]) >> 1;"
    },
    {
      "mnemonic": "VSSRA.VV",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Saturating Shift Right Arithmetic",
      "summary": "Shifts right with sign extension and rounding/saturation logic.",
      "syntax": "VSSRA.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "101001 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "101001",
            "clean": "101001"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Source"
        },
        {
          "name": "vs1",
          "desc": "Shift"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = saturate(vs2[i] >>s vs1[i]);",
      "slug": "vssra_vv",
      "rel_url": "risc-v/vssra_vv/",
      "linked_summary": "Shifts right with sign extension <a href=\"../../armv8-a/and_6/\">and</a> rounding/saturation logic.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = saturate(vs2[i] >>s vs1[i]);"
    },
    {
      "mnemonic": "VSSRL.VV",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Saturating Shift Right Logical",
      "summary": "Shifts right with zero extension and rounding/saturation logic.",
      "syntax": "VSSRL.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "101000 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "101000",
            "clean": "101000"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Source"
        },
        {
          "name": "vs1",
          "desc": "Shift"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = saturate(vs2[i] >>u vs1[i]);",
      "slug": "vssrl_vv",
      "rel_url": "risc-v/vssrl_vv/",
      "linked_summary": "Shifts right with <a href=\"../../armv9-a/zero_1/\">zero</a> extension <a href=\"../../armv8-a/and_6/\">and</a> rounding/saturation logic.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = saturate(vs2[i] >>u vs1[i]);"
    },
    {
      "mnemonic": "VWREDSUM.VS",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Widening Reduction Sum Signed",
      "summary": "Sums N-bit elements into a 2*N-bit scalar accumulator (Signed).",
      "syntax": "VWREDSUM.VS vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPMVV",
        "binary_pattern": "110001 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "110001",
            "clean": "110001"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (Scalar Wide)"
        },
        {
          "name": "vs2",
          "desc": "Vector (Narrow)"
        },
        {
          "name": "vs1",
          "desc": "Start (Wide)"
        }
      ],
      "pseudocode": "vd[0] = vs1[0] + sum(extend(vs2[*]));",
      "slug": "vwredsum_vs",
      "rel_url": "risc-v/vwredsum_vs/",
      "linked_summary": "Sums N-<a href=\"../../armv8-a/bit/\">bit</a> elements into a 2*N-<a href=\"../../armv8-a/bit/\">bit</a> scalar accumulator (Signed).",
      "linked_pseudocode": "vd[0] = vs1[0] + sum(extend(vs2[*]));"
    },
    {
      "mnemonic": "VWREDSUMU.VS",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Widening Reduction Sum Unsigned",
      "summary": "Sums N-bit elements into a 2*N-bit scalar accumulator (Unsigned).",
      "syntax": "VWREDSUMU.VS vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPMVV",
        "binary_pattern": "110000 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "110000",
            "clean": "110000"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (Scalar Wide)"
        },
        {
          "name": "vs2",
          "desc": "Vector (Narrow)"
        },
        {
          "name": "vs1",
          "desc": "Start (Wide)"
        }
      ],
      "pseudocode": "vd[0] = vs1[0] + sum(zext(vs2[*]));",
      "slug": "vwredsumu_vs",
      "rel_url": "risc-v/vwredsumu_vs/",
      "linked_summary": "Sums N-<a href=\"../../armv8-a/bit/\">bit</a> elements into a 2*N-<a href=\"../../armv8-a/bit/\">bit</a> scalar accumulator (Unsigned).",
      "linked_pseudocode": "vd[0] = vs1[0] + sum(zext(vs2[*]));"
    },
    {
      "mnemonic": "VMANDN.MM",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Mask AND NOT",
      "summary": "Computes vd = vs1 & ~vs2 (mask operation).",
      "syntax": "VMANDN.MM vd, vs2, vs1",
      "encoding": {
        "format": "OPMVV",
        "binary_pattern": "011000 | 1 | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "011000",
            "clean": "011000"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest Mask"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "vd = vs1 & ~vs2;",
      "slug": "vmandn_mm",
      "rel_url": "risc-v/vmandn_mm/",
      "linked_summary": "Computes vd = vs1 & ~vs2 (mask operation).",
      "linked_pseudocode": "vd = vs1 & ~vs2;"
    },
    {
      "mnemonic": "VMORN.MM",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Mask OR NOT",
      "summary": "Computes vd = vs1 | ~vs2 (mask operation).",
      "syntax": "VMORN.MM vd, vs2, vs1",
      "encoding": {
        "format": "OPMVV",
        "binary_pattern": "011010 | 1 | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "011010",
            "clean": "011010"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest Mask"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "vd = vs1 | ~vs2;",
      "slug": "vmorn_mm",
      "rel_url": "risc-v/vmorn_mm/",
      "linked_summary": "Computes vd = vs1 | ~vs2 (mask operation).",
      "linked_pseudocode": "vd = vs1 | ~vs2;"
    },
    {
      "mnemonic": "VMXNOR.MM",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Mask XNOR",
      "summary": "Computes vd = ~(vs1 ^ vs2) (mask operation).",
      "syntax": "VMXNOR.MM vd, vs2, vs1",
      "encoding": {
        "format": "OPMVV",
        "binary_pattern": "011011 | 1 | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "011011",
            "clean": "011011"
          },
          {
            "raw": "1",
            "clean": "1"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest Mask"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "vd = ~(vs1 ^ vs2);",
      "slug": "vmxnor_mm",
      "rel_url": "risc-v/vmxnor_mm/",
      "linked_summary": "Computes vd = ~(vs1 ^ vs2) (mask operation).",
      "linked_pseudocode": "vd = ~(vs1 ^ vs2);"
    },
    {
      "mnemonic": "MAXU",
      "architecture": "RISC-V",
      "extension": "Zbb",
      "full_name": "Maximum Unsigned",
      "summary": "Computes the maximum of two unsigned integers.",
      "syntax": "MAXU rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000101 | rs2 | rs1 | 111 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0000101",
            "clean": "0000101"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "111",
            "clean": "111"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        }
      ],
      "pseudocode": "R[rd] = (R[rs1] >u R[rs2]) ? R[rs1] : R[rs2];",
      "slug": "maxu",
      "rel_url": "risc-v/maxu/",
      "linked_summary": "Computes the maximum of two unsigned integers.",
      "linked_pseudocode": "R[rd] = (R[rs1] >u R[rs2]) ? R[rs1] : R[rs2];"
    },
    {
      "mnemonic": "MINU",
      "architecture": "RISC-V",
      "extension": "Zbb",
      "full_name": "Minimum Unsigned",
      "summary": "Computes the minimum of two unsigned integers.",
      "syntax": "MINU rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000101 | rs2 | rs1 | 101 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0000101",
            "clean": "0000101"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "101",
            "clean": "101"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        }
      ],
      "pseudocode": "R[rd] = (R[rs1] <u R[rs2]) ? R[rs1] : R[rs2];",
      "slug": "minu",
      "rel_url": "risc-v/minu/",
      "linked_summary": "Computes the minimum of two unsigned integers.",
      "linked_pseudocode": "R[rd] = (R[rs1] <u R[rs2]) ? R[rs1] : R[rs2];"
    },
    {
      "mnemonic": "PACK",
      "architecture": "RISC-V",
      "extension": "Zbkb",
      "full_name": "Pack two words into a register",
      "summary": "Packs the lower halves of rs1 and rs2 into rd.",
      "syntax": "PACK rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000100 | rs2 | rs1 | 100 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0000100",
            "clean": "0000100"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Lower Half"
        },
        {
          "name": "rs2",
          "desc": "Upper Half"
        }
      ],
      "pseudocode": "R[rd] = (R[rs2] << XLEN/2) | (R[rs1] & ((1 << XLEN/2)-1));",
      "slug": "pack",
      "rel_url": "risc-v/pack/",
      "linked_summary": "Packs the lower halves of rs1 <a href=\"../../armv8-a/and_6/\">and</a> rs2 into rd.",
      "linked_pseudocode": "R[rd] = (R[rs2] << XLEN/2) | (R[rs1] & ((1 << XLEN/2)-1));"
    },
    {
      "mnemonic": "PACKH",
      "architecture": "RISC-V",
      "extension": "Zbkb",
      "full_name": "Pack Byte",
      "summary": "Packs the lower bytes of rs1 and rs2 into a 16-bit value.",
      "syntax": "PACKH rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000100 | rs2 | rs1 | 111 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0000100",
            "clean": "0000100"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "111",
            "clean": "111"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        }
      ],
      "pseudocode": "R[rd] = (R[rs2] << 8) | (R[rs1] & 0xFF);",
      "slug": "packh",
      "rel_url": "risc-v/packh/",
      "linked_summary": "Packs the lower bytes of rs1 <a href=\"../../armv8-a/and_6/\">and</a> rs2 into a 16-<a href=\"../../armv8-a/bit/\">bit</a> value.",
      "linked_pseudocode": "R[rd] = (R[rs2] << 8) | (R[rs1] & 0xFF);"
    },
    {
      "mnemonic": "HLV.WU",
      "architecture": "RISC-V",
      "extension": "H",
      "full_name": "Hypervisor Load Word Unsigned",
      "summary": "Loads a word from guest physical memory (unsigned).",
      "syntax": "HLV.WU rd, (rs1)",
      "encoding": {
        "format": "R-Type (System)",
        "binary_pattern": "0110100 | 00000 | rs1 | 100 | rd | 1110011",
        "hex_opcode": "0x73",
        "visual_parts": [
          {
            "raw": "0110100",
            "clean": "0110100"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1110011",
            "clean": "1110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Guest Addr"
        }
      ],
      "pseudocode": "R[rd] = zext(GuestMem[rs1][31:0]);",
      "slug": "hlv_wu",
      "rel_url": "risc-v/hlv_wu/",
      "linked_summary": "Loads a word from guest physical memory (unsigned).",
      "linked_pseudocode": "R[rd] = zext(GuestMem[rs1][31:0]);"
    },
    {
      "mnemonic": "HLV.D",
      "architecture": "RISC-V",
      "extension": "H",
      "full_name": "Hypervisor Load Double",
      "summary": "Loads a doubleword from guest physical memory.",
      "syntax": "HLV.D rd, (rs1)",
      "encoding": {
        "format": "R-Type (System)",
        "binary_pattern": "0110110 | 00000 | rs1 | 100 | rd | 1110011",
        "hex_opcode": "0x73",
        "visual_parts": [
          {
            "raw": "0110110",
            "clean": "0110110"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1110011",
            "clean": "1110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Guest Addr"
        }
      ],
      "pseudocode": "R[rd] = GuestMem[rs1][63:0];",
      "slug": "hlv_d",
      "rel_url": "risc-v/hlv_d/",
      "linked_summary": "Loads a doubleword from guest physical memory.",
      "linked_pseudocode": "R[rd] = GuestMem[rs1][63:0];"
    },
    {
      "mnemonic": "HSV.D",
      "architecture": "RISC-V",
      "extension": "H",
      "full_name": "Hypervisor Store Double",
      "summary": "Stores a doubleword to guest physical memory.",
      "syntax": "HSV.D rs2, (rs1)",
      "encoding": {
        "format": "R-Type (System)",
        "binary_pattern": "0110111 | rs2 | rs1 | 100 | 00000 | 1110011",
        "hex_opcode": "0x73",
        "visual_parts": [
          {
            "raw": "0110111",
            "clean": "0110111"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "1110011",
            "clean": "1110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rs2",
          "desc": "Source"
        },
        {
          "name": "rs1",
          "desc": "Guest Addr"
        }
      ],
      "pseudocode": "GuestMem[rs1][63:0] = R[rs2];",
      "slug": "hsv_d",
      "rel_url": "risc-v/hsv_d/",
      "linked_summary": "Stores a doubleword to guest physical memory.",
      "linked_pseudocode": "GuestMem[rs1][63:0] = R[rs2];"
    },
    {
      "mnemonic": "VLOXEI32.V",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Load Ordered Indexed (32-bit indices)",
      "summary": "Loads elements using indices, ensuring order (useful for I/O buffers).",
      "syntax": "VLOXEI32.V vd, (rs1), vs2, vm",
      "encoding": {
        "format": "VL-Type",
        "binary_pattern": "000110 | mop | vm | rs1 | 110 | vd | 0000111",
        "hex_opcode": "0x07",
        "visual_parts": [
          {
            "raw": "000110",
            "clean": "000110"
          },
          {
            "raw": "mop",
            "clean": "mop"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "110",
            "clean": "110"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "0000111",
            "clean": "0000111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Base"
        },
        {
          "name": "vs2",
          "desc": "Indices"
        }
      ],
      "pseudocode": "Ordered_Load(vd, rs1, vs2);",
      "slug": "vloxei32_v",
      "rel_url": "risc-v/vloxei32_v/",
      "linked_summary": "Loads elements using indices, ensuring order (useful for I/O buffers).",
      "linked_pseudocode": "Ordered_Load(vd, rs1, vs2);"
    },
    {
      "mnemonic": "VSOXEI32.V",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Store Ordered Indexed (32-bit indices)",
      "summary": "Stores elements using indices, ensuring order.",
      "syntax": "VSOXEI32.V vs3, (rs1), vs2, vm",
      "encoding": {
        "format": "VS-Type",
        "binary_pattern": "000110 | mop | vm | rs1 | 110 | vs3 | 0100111",
        "hex_opcode": "0x27",
        "visual_parts": [
          {
            "raw": "000110",
            "clean": "000110"
          },
          {
            "raw": "mop",
            "clean": "mop"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "110",
            "clean": "110"
          },
          {
            "raw": "vs3",
            "clean": "vs3"
          },
          {
            "raw": "0100111",
            "clean": "0100111"
          }
        ]
      },
      "operands": [
        {
          "name": "vs3",
          "desc": "Source"
        },
        {
          "name": "rs1",
          "desc": "Base"
        },
        {
          "name": "vs2",
          "desc": "Indices"
        }
      ],
      "pseudocode": "Ordered_Store(vs3, rs1, vs2);",
      "slug": "vsoxei32_v",
      "rel_url": "risc-v/vsoxei32_v/",
      "linked_summary": "Stores elements using indices, ensuring order.",
      "linked_pseudocode": "Ordered_Store(vs3, rs1, vs2);"
    },
    {
      "mnemonic": "VMULH.VV",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Multiply High Signed",
      "summary": "Multiplies signed integers and keeps the high N bits.",
      "syntax": "VMULH.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "100111 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "100111",
            "clean": "100111"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = (sext(vs1[i]) * sext(vs2[i])) >> SEW;",
      "slug": "vmulh_vv",
      "rel_url": "risc-v/vmulh_vv/",
      "linked_summary": "Multiplies signed integers <a href=\"../../armv8-a/and_6/\">and</a> keeps the high N bits.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = (sext(vs1[i]) * sext(vs2[i])) >> SEW;"
    },
    {
      "mnemonic": "VMULHU.VV",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Multiply High Unsigned",
      "summary": "Multiplies unsigned integers and keeps the high N bits.",
      "syntax": "VMULHU.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "100100 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "100100",
            "clean": "100100"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = (zext(vs1[i]) * zext(vs2[i])) >> SEW;",
      "slug": "vmulhu_vv",
      "rel_url": "risc-v/vmulhu_vv/",
      "linked_summary": "Multiplies unsigned integers <a href=\"../../armv8-a/and_6/\">and</a> keeps the high N bits.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = (zext(vs1[i]) * zext(vs2[i])) >> SEW;"
    },
    {
      "mnemonic": "VDIV.VV",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Integer Divide Signed",
      "summary": "Divides signed vector elements.",
      "syntax": "VDIV.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "100000 | vm | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "100000",
            "clean": "100000"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Divisor"
        },
        {
          "name": "vs1",
          "desc": "Dividend"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs1[i] / vs2[i];",
      "slug": "vdiv_vv",
      "rel_url": "risc-v/vdiv_vv/",
      "linked_summary": "Divides signed vector elements.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = vs1[i] / vs2[i];"
    },
    {
      "mnemonic": "VDIVU.VV",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Integer Divide Unsigned",
      "summary": "Divides unsigned vector elements.",
      "syntax": "VDIVU.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "100000 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "100000",
            "clean": "100000"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Divisor"
        },
        {
          "name": "vs1",
          "desc": "Dividend"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs1[i] /u vs2[i];",
      "slug": "vdivu_vv",
      "rel_url": "risc-v/vdivu_vv/",
      "linked_summary": "Divides unsigned vector elements.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = vs1[i] /u vs2[i];"
    },
    {
      "mnemonic": "VREM.VV",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Remainder Signed",
      "summary": "Computes signed remainder.",
      "syntax": "VREM.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "100010 | vm | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "100010",
            "clean": "100010"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Divisor"
        },
        {
          "name": "vs1",
          "desc": "Dividend"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs1[i] % vs2[i];",
      "slug": "vrem_vv",
      "rel_url": "risc-v/vrem_vv/",
      "linked_summary": "Computes signed remainder.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = vs1[i] % vs2[i];"
    },
    {
      "mnemonic": "VREMU.VV",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Remainder Unsigned",
      "summary": "Computes unsigned remainder.",
      "syntax": "VREMU.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "100010 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "100010",
            "clean": "100010"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Divisor"
        },
        {
          "name": "vs1",
          "desc": "Dividend"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs1[i] %u vs2[i];",
      "slug": "vremu_vv",
      "rel_url": "risc-v/vremu_vv/",
      "linked_summary": "Computes unsigned remainder.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = vs1[i] %u vs2[i];"
    },
    {
      "mnemonic": "VWMACC.VV",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Widening Multiply-Accumulate",
      "summary": "Computes vd = vd + (vs1 * vs2) with widening (N*N -> 2N + 2N).",
      "syntax": "VWMACC.VV vd, vs1, vs2, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "111101 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "111101",
            "clean": "111101"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest/Acc (2*SEW)"
        },
        {
          "name": "vs1",
          "desc": "Src 1 (SEW)"
        },
        {
          "name": "vs2",
          "desc": "Src 2 (SEW)"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vd[i] + (sext(vs1[i]) * sext(vs2[i]));",
      "slug": "vwmacc_vv",
      "rel_url": "risc-v/vwmacc_vv/",
      "linked_summary": "Computes vd = vd + (vs1 * vs2) with widening (N*N -> 2N + 2N).",
      "linked_pseudocode": "foreach(i < vl): vd[i] = vd[i] + (sext(vs1[i]) * sext(vs2[i]));"
    },
    {
      "mnemonic": "VWMACCU.VV",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Widening Multiply-Accumulate Unsigned",
      "summary": "Computes vd = vd + (vs1 * vs2) widening unsigned.",
      "syntax": "VWMACCU.VV vd, vs1, vs2, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "111100 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "111100",
            "clean": "111100"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest/Acc (2*SEW)"
        },
        {
          "name": "vs1",
          "desc": "Src 1 (SEW)"
        },
        {
          "name": "vs2",
          "desc": "Src 2 (SEW)"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vd[i] + (zext(vs1[i]) * zext(vs2[i]));",
      "slug": "vwmaccu_vv",
      "rel_url": "risc-v/vwmaccu_vv/",
      "linked_summary": "Computes vd = vd + (vs1 * vs2) widening unsigned.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = vd[i] + (zext(vs1[i]) * zext(vs2[i]));"
    },
    {
      "mnemonic": "VIOTA.M",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Iota",
      "summary": "Writes the index of the active element to the destination. Useful for parallel prefix sums.",
      "syntax": "VIOTA.M vd, vs2, vm",
      "encoding": {
        "format": "OPMVV",
        "binary_pattern": "010100 | vm | vs2 | 10000 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010100",
            "clean": "010100"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "10000",
            "clean": "10000"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Mask Src"
        }
      ],
      "pseudocode": "count = 0; foreach(i < vl): if vm[i]: vd[i] = count++;",
      "slug": "viota_m",
      "rel_url": "risc-v/viota_m/",
      "linked_summary": "Writes the <a href=\"../../armv8-a/index/\">index</a> of the active element to the destination. Useful for parallel prefix sums.",
      "linked_pseudocode": "count = 0; foreach(i < vl): if vm[i]: vd[i] = count++;"
    },
    {
      "mnemonic": "VID.V",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Element Index",
      "summary": "Writes the element index (0, 1, 2...) to the destination.",
      "syntax": "VID.V vd, vm",
      "encoding": {
        "format": "OPMVV",
        "binary_pattern": "010100 | vm | 00000 | 10001 | 010 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010100",
            "clean": "010100"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "10001",
            "clean": "10001"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = i;",
      "slug": "vid_v",
      "rel_url": "risc-v/vid_v/",
      "linked_summary": "Writes the element <a href=\"../../armv8-a/index/\">index</a> (0, 1, 2...) to the destination.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = i;"
    },
    {
      "mnemonic": "VFWCVT.F.F.V",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Widening Float to Float Convert",
      "summary": "Converts N-bit floats to 2*N-bit floats (e.g., FP16 -> FP32).",
      "syntax": "VFWCVT.F.F.V vd, vs2, vm",
      "encoding": {
        "format": "OPFVV",
        "binary_pattern": "010010 | vm | vs2 | 01110 | 001 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010010",
            "clean": "010010"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "01110",
            "clean": "01110"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (Wide)"
        },
        {
          "name": "vs2",
          "desc": "Src (Narrow)"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = convert_w(vs2[i]);",
      "slug": "vfwcvt_f_f_v",
      "rel_url": "risc-v/vfwcvt_f_f_v/",
      "linked_summary": "Converts N-<a href=\"../../armv8-a/bit/\">bit</a> floats to 2*N-<a href=\"../../armv8-a/bit/\">bit</a> floats (e.g., FP16 -> FP32).",
      "linked_pseudocode": "foreach(i < vl): vd[i] = convert_w(vs2[i]);"
    },
    {
      "mnemonic": "VFWCVT.X.F.V",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Widening Float to Signed Int",
      "summary": "Converts N-bit float to 2*N-bit signed integer.",
      "syntax": "VFWCVT.X.F.V vd, vs2, vm",
      "encoding": {
        "format": "OPFVV",
        "binary_pattern": "010010 | vm | vs2 | 01000 | 001 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010010",
            "clean": "010010"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "01000",
            "clean": "01000"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (Wide Int)"
        },
        {
          "name": "vs2",
          "desc": "Src (Float)"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = f_to_x_w(vs2[i]);",
      "slug": "vfwcvt_x_f_v",
      "rel_url": "risc-v/vfwcvt_x_f_v/",
      "linked_summary": "Converts N-<a href=\"../../armv8-a/bit/\">bit</a> float to 2*N-<a href=\"../../armv8-a/bit/\">bit</a> signed integer.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = f_to_x_w(vs2[i]);"
    },
    {
      "mnemonic": "VFNCVT.X.F.W",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Narrowing Float to Signed Int",
      "summary": "Converts 2*N-bit float to N-bit signed integer.",
      "syntax": "VFNCVT.X.F.W vd, vs2, vm",
      "encoding": {
        "format": "OPFVV",
        "binary_pattern": "010010 | vm | vs2 | 10001 | 001 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010010",
            "clean": "010010"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "10001",
            "clean": "10001"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (Int)"
        },
        {
          "name": "vs2",
          "desc": "Src (Wide Float)"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = f_to_x_n(vs2[i]);",
      "slug": "vfncvt_x_f_w",
      "rel_url": "risc-v/vfncvt_x_f_w/",
      "linked_summary": "Converts 2*N-<a href=\"../../armv8-a/bit/\">bit</a> float to N-<a href=\"../../armv8-a/bit/\">bit</a> signed integer.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = f_to_x_n(vs2[i]);"
    },
    {
      "mnemonic": "VNSRL.WI",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Narrowing Shift Right Logical Immediate",
      "summary": "Shifts wide elements right by immediate and narrows.",
      "syntax": "VNSRL.WI vd, vs2, imm, vm",
      "encoding": {
        "format": "OPIVI",
        "binary_pattern": "101100 | vm | vs2 | imm | 011 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "101100",
            "clean": "101100"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (Narrow)"
        },
        {
          "name": "vs2",
          "desc": "Src (Wide)"
        },
        {
          "name": "imm",
          "desc": "Shift"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = (vs2[i] >>u imm) & Mask;",
      "slug": "vnsrl_wi",
      "rel_url": "risc-v/vnsrl_wi/",
      "linked_summary": "Shifts wide elements right by immediate <a href=\"../../armv8-a/and_6/\">and</a> narrows.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = (vs2[i] >>u imm) & Mask;"
    },
    {
      "mnemonic": "VNSRA.WI",
      "architecture": "RISC-V",
      "extension": "V",
      "full_name": "Vector Narrowing Shift Right Arithmetic Immediate",
      "summary": "Shifts wide elements right (arithmetic) by immediate and narrows.",
      "syntax": "VNSRA.WI vd, vs2, imm, vm",
      "encoding": {
        "format": "OPIVI",
        "binary_pattern": "101101 | vm | vs2 | imm | 011 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "101101",
            "clean": "101101"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest (Narrow)"
        },
        {
          "name": "vs2",
          "desc": "Src (Wide)"
        },
        {
          "name": "imm",
          "desc": "Shift"
        }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = (vs2[i] >>s imm) & Mask;",
      "slug": "vnsra_wi",
      "rel_url": "risc-v/vnsra_wi/",
      "linked_summary": "Shifts wide elements right (arithmetic) by immediate <a href=\"../../armv8-a/and_6/\">and</a> narrows.",
      "linked_pseudocode": "foreach(i < vl): vd[i] = (vs2[i] >>s imm) & Mask;"
    },
    {
      "mnemonic": "FCLASS.S",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Float Classify (Single)",
      "summary": "Examines the value in a float register and generates a 10-bit bitmask indicating its class (NaN, Inf, Zero, Normal, etc.).",
      "syntax": "FCLASS.S rd, rs1",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "1110000 | 00000 | rs1 | 001 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1110000",
            "clean": "1110000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Integer Mask)"
        },
        {
          "name": "rs1",
          "desc": "Source (Float)"
        }
      ],
      "pseudocode": "R[rd] = classify_float(F[rs1]);",
      "example": "FCLASS.S x10, f1",
      "example_note": "Check if f1 is NaN, Infinity, or Zero.",
      "slug": "fclass_s",
      "rel_url": "risc-v/fclass_s/",
      "linked_summary": "Examines the value <a href=\"../../x86/in/\">in</a> a float register <a href=\"../../armv8-a/and_6/\">and</a> generates a 10-<a href=\"../../armv8-a/bit/\">bit</a> bitmask indicating its class (NaN, Inf, Zero, Normal, etc.).",
      "linked_pseudocode": "R[rd] = classify_float(F[rs1]);"
    },
    {
      "mnemonic": "FCLASS.D",
      "architecture": "RISC-V",
      "extension": "D",
      "full_name": "Float Classify (Double)",
      "summary": "Examines a double-precision register and generates a classification bitmask.",
      "syntax": "FCLASS.D rd, rs1",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "1110001 | 00000 | rs1 | 001 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1110001",
            "clean": "1110001"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Integer Mask)"
        },
        {
          "name": "rs1",
          "desc": "Source (Double)"
        }
      ],
      "pseudocode": "R[rd] = classify_double(F[rs1]);",
      "example": "FCLASS.D x10, f0",
      "example_note": "Check if f0 is NaN/Inf/Zero.",
      "slug": "fclass_d",
      "rel_url": "risc-v/fclass_d/",
      "linked_summary": "Examines a double-precision register <a href=\"../../armv8-a/and_6/\">and</a> generates a classification bitmask.",
      "linked_pseudocode": "R[rd] = classify_double(F[rs1]);"
    },
    {
      "mnemonic": "FCVT.S.L",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Convert Long to Float",
      "summary": "Converts a 64-bit signed integer (Long) to a single-precision float.",
      "syntax": "FCVT.S.L rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "1101000 | 00010 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1101000",
            "clean": "1101000"
          },
          {
            "raw": "00010",
            "clean": "00010"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Float)"
        },
        {
          "name": "rs1",
          "desc": "Source (Long Int)"
        }
      ],
      "pseudocode": "F[rd] = i64_to_f32(R[rs1]);",
      "example": "FCVT.S.L f1, x10",
      "example_note": "64-bit int -> 32-bit float.",
      "slug": "fcvt_s_l",
      "rel_url": "risc-v/fcvt_s_l/",
      "linked_summary": "Converts a 64-<a href=\"../../armv8-a/bit/\">bit</a> signed integer (Long) to a single-precision float.",
      "linked_pseudocode": "F[rd] = i64_to_f32(R[rs1]);"
    },
    {
      "mnemonic": "FCVT.S.LU",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Convert Unsigned Long to Float",
      "summary": "Converts a 64-bit unsigned integer to a single-precision float.",
      "syntax": "FCVT.S.LU rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "1101000 | 00011 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1101000",
            "clean": "1101000"
          },
          {
            "raw": "00011",
            "clean": "00011"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Float)"
        },
        {
          "name": "rs1",
          "desc": "Source (U-Long)"
        }
      ],
      "pseudocode": "F[rd] = u64_to_f32(R[rs1]);",
      "example": "FCVT.S.LU f1, x10",
      "example_note": "Unsigned 64-bit int -> float.",
      "slug": "fcvt_s_lu",
      "rel_url": "risc-v/fcvt_s_lu/",
      "linked_summary": "Converts a 64-<a href=\"../../armv8-a/bit/\">bit</a> unsigned integer to a single-precision float.",
      "linked_pseudocode": "F[rd] = u64_to_f32(R[rs1]);"
    },
    {
      "mnemonic": "FCVT.L.S",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Convert Float to Long",
      "summary": "Converts a single-precision float to a 64-bit signed integer.",
      "syntax": "FCVT.L.S rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "1100000 | 00010 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1100000",
            "clean": "1100000"
          },
          {
            "raw": "00010",
            "clean": "00010"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Long Int)"
        },
        {
          "name": "rs1",
          "desc": "Source (Float)"
        }
      ],
      "pseudocode": "R[rd] = f32_to_i64(F[rs1]);",
      "example": "FCVT.L.S x10, f1",
      "example_note": "Float -> 64-bit signed int.",
      "slug": "fcvt_l_s",
      "rel_url": "risc-v/fcvt_l_s/",
      "linked_summary": "Converts a single-precision float to a 64-<a href=\"../../armv8-a/bit/\">bit</a> signed integer.",
      "linked_pseudocode": "R[rd] = f32_to_i64(F[rs1]);"
    },
    {
      "mnemonic": "FCVT.LU.S",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Convert Float to Unsigned Long",
      "summary": "Converts a single-precision float to a 64-bit unsigned integer.",
      "syntax": "FCVT.LU.S rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "1100000 | 00011 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1100000",
            "clean": "1100000"
          },
          {
            "raw": "00011",
            "clean": "00011"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (U-Long)"
        },
        {
          "name": "rs1",
          "desc": "Source (Float)"
        }
      ],
      "pseudocode": "R[rd] = f32_to_u64(F[rs1]);",
      "example": "FCVT.LU.S x10, f1",
      "example_note": "Float -> 64-bit unsigned int.",
      "slug": "fcvt_lu_s",
      "rel_url": "risc-v/fcvt_lu_s/",
      "linked_summary": "Converts a single-precision float to a 64-<a href=\"../../armv8-a/bit/\">bit</a> unsigned integer.",
      "linked_pseudocode": "R[rd] = f32_to_u64(F[rs1]);"
    },
    {
      "mnemonic": "FCVT.D.L",
      "architecture": "RISC-V",
      "extension": "D",
      "full_name": "Convert Long to Double",
      "summary": "Converts a 64-bit signed integer to a double-precision float.",
      "syntax": "FCVT.D.L rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "1101001 | 00010 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1101001",
            "clean": "1101001"
          },
          {
            "raw": "00010",
            "clean": "00010"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Double)"
        },
        {
          "name": "rs1",
          "desc": "Source (Long)"
        }
      ],
      "pseudocode": "F[rd] = i64_to_f64(R[rs1]);",
      "example": "FCVT.D.L f0, x10",
      "example_note": "64-bit Int -> Double.",
      "slug": "fcvt_d_l",
      "rel_url": "risc-v/fcvt_d_l/",
      "linked_summary": "Converts a 64-<a href=\"../../armv8-a/bit/\">bit</a> signed integer to a double-precision float.",
      "linked_pseudocode": "F[rd] = i64_to_f64(R[rs1]);"
    },
    {
      "mnemonic": "FCVT.D.LU",
      "architecture": "RISC-V",
      "extension": "D",
      "full_name": "Convert Unsigned Long to Double",
      "summary": "Converts a 64-bit unsigned integer to a double-precision float.",
      "syntax": "FCVT.D.LU rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "1101001 | 00011 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1101001",
            "clean": "1101001"
          },
          {
            "raw": "00011",
            "clean": "00011"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Double)"
        },
        {
          "name": "rs1",
          "desc": "Source (U-Long)"
        }
      ],
      "pseudocode": "F[rd] = u64_to_f64(R[rs1]);",
      "example": "FCVT.D.LU f0, x10",
      "example_note": "Unsigned 64-bit Int -> Double.",
      "slug": "fcvt_d_lu",
      "rel_url": "risc-v/fcvt_d_lu/",
      "linked_summary": "Converts a 64-<a href=\"../../armv8-a/bit/\">bit</a> unsigned integer to a double-precision float.",
      "linked_pseudocode": "F[rd] = u64_to_f64(R[rs1]);"
    },
    {
      "mnemonic": "FCVT.L.D",
      "architecture": "RISC-V",
      "extension": "D",
      "full_name": "Convert Double to Long",
      "summary": "Converts a double-precision float to a 64-bit signed integer.",
      "syntax": "FCVT.L.D rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "1100001 | 00010 | rs1 | rm | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1100001",
            "clean": "1100001"
          },
          {
            "raw": "00010",
            "clean": "00010"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "rm",
            "clean": "rm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Long)"
        },
        {
          "name": "rs1",
          "desc": "Source (Double)"
        }
      ],
      "pseudocode": "R[rd] = f64_to_i64(F[rs1]);",
      "example": "FCVT.L.D x10, f0",
      "example_note": "Double -> 64-bit Int.",
      "slug": "fcvt_l_d",
      "rel_url": "risc-v/fcvt_l_d/",
      "linked_summary": "Converts a double-precision float to a 64-<a href=\"../../armv8-a/bit/\">bit</a> signed integer.",
      "linked_pseudocode": "R[rd] = f64_to_i64(F[rs1]);"
    },
    {
      "mnemonic": "FSGNJ.D",
      "architecture": "RISC-V",
      "extension": "D",
      "full_name": "Float Sign Injection (Double)",
      "summary": "Injects the sign of rs2 into rs1 (Double Precision).",
      "syntax": "FSGNJ.D rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0010001 | rs2 | rs1 | 000 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0010001",
            "clean": "0010001"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source (Body)"
        },
        {
          "name": "rs2",
          "desc": "Source (Sign)"
        }
      ],
      "pseudocode": "F[rd] = {F[rs2][63], F[rs1][62:0]};",
      "example": "FSGNJ.D f0, f1, f2",
      "example_note": "Copy sign of f2 to f1.",
      "slug": "fsgnj_d",
      "rel_url": "risc-v/fsgnj_d/",
      "linked_summary": "Injects the sign of rs2 into rs1 (Double Precision).",
      "linked_pseudocode": "F[rd] = {F[rs2][63], F[rs1][62:0]};"
    },
    {
      "mnemonic": "FSGNJN.D",
      "architecture": "RISC-V",
      "extension": "D",
      "full_name": "Float Sign Injection Negate (Double)",
      "summary": "Injects the *negated* sign of rs2 into rs1 (Double Precision).",
      "syntax": "FSGNJN.D rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0010001 | rs2 | rs1 | 001 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0010001",
            "clean": "0010001"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source (Body)"
        },
        {
          "name": "rs2",
          "desc": "Source (Sign)"
        }
      ],
      "pseudocode": "F[rd] = {~F[rs2][63], F[rs1][62:0]};",
      "example": "FSGNJN.D f0, f1, f1",
      "example_note": "Negate f1 (f0 = -f1).",
      "slug": "fsgnjn_d",
      "rel_url": "risc-v/fsgnjn_d/",
      "linked_summary": "Injects the *negated* sign of rs2 into rs1 (Double Precision).",
      "linked_pseudocode": "F[rd] = {~F[rs2][63], F[rs1][62:0]};"
    },
    {
      "mnemonic": "FEQ.D",
      "architecture": "RISC-V",
      "extension": "D",
      "full_name": "Float Equal (Double)",
      "summary": "Sets integer rd to 1 if double rs1 equals double rs2, else 0.",
      "syntax": "FEQ.D rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "1010001 | rs2 | rs1 | 010 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1010001",
            "clean": "1010001"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Int)"
        },
        {
          "name": "rs1",
          "desc": "Src 1 (Double)"
        },
        {
          "name": "rs2",
          "desc": "Src 2 (Double)"
        }
      ],
      "pseudocode": "R[rd] = (F[rs1] == F[rs2]) ? 1 : 0;",
      "example": "FEQ.D x10, f0, f1",
      "example_note": "Compare equality.",
      "slug": "feq_d",
      "rel_url": "risc-v/feq_d/",
      "linked_summary": "Sets integer rd to 1 if double rs1 equals double rs2, else 0.",
      "linked_pseudocode": "R[rd] = (F[rs1] == F[rs2]) ? 1 : 0;"
    },
    {
      "mnemonic": "FLT.D",
      "architecture": "RISC-V",
      "extension": "D",
      "full_name": "Float Less Than (Double)",
      "summary": "Sets integer rd to 1 if double rs1 is less than double rs2, else 0.",
      "syntax": "FLT.D rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "1010001 | rs2 | rs1 | 001 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1010001",
            "clean": "1010001"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Int)"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        }
      ],
      "pseudocode": "R[rd] = (F[rs1] < F[rs2]) ? 1 : 0;",
      "example": "FLT.D x10, f0, f1",
      "example_note": "Less than check.",
      "slug": "flt_d",
      "rel_url": "risc-v/flt_d/",
      "linked_summary": "Sets integer rd to 1 if double rs1 is less than double rs2, else 0.",
      "linked_pseudocode": "R[rd] = (F[rs1] < F[rs2]) ? 1 : 0;"
    },
    {
      "mnemonic": "FLE.D",
      "architecture": "RISC-V",
      "extension": "D",
      "full_name": "Float Less or Equal (Double)",
      "summary": "Sets integer rd to 1 if double rs1 is less than or equal to double rs2, else 0.",
      "syntax": "FLE.D rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "1010001 | rs2 | rs1 | 000 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "1010001",
            "clean": "1010001"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Int)"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        }
      ],
      "pseudocode": "R[rd] = (F[rs1] <= F[rs2]) ? 1 : 0;",
      "example": "FLE.D x10, f0, f1",
      "example_note": "Less equal check.",
      "slug": "fle_d",
      "rel_url": "risc-v/fle_d/",
      "linked_summary": "Sets integer rd to 1 if double rs1 is less than <a href=\"../../powerisa/or/\">or</a> equal to double rs2, else 0.",
      "linked_pseudocode": "R[rd] = (F[rs1] <= F[rs2]) ? 1 : 0;"
    },
    {
      "mnemonic": "C.FLD",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Float Load Double",
      "summary": "Loads a double-precision float from memory (Compressed).",
      "syntax": "C.FLD rd&#x27;, offset(rs1&#x27;)",
      "encoding": {
        "format": "CL",
        "binary_pattern": "001 | imm | rs1' | imm | rd' | 00",
        "hex_opcode": "00",
        "visual_parts": [
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rs1'",
            "clean": "rs1'"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rd'",
            "clean": "rd'"
          },
          {
            "raw": "00",
            "clean": "00"
          }
        ]
      },
      "operands": [
        {
          "name": "rd'",
          "desc": "Dest (f8-f15)"
        },
        {
          "name": "rs1'",
          "desc": "Base (x8-x15)"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "F[rd'] = M[R[rs1'] + offset][63:0];",
      "slug": "c_fld",
      "rel_url": "risc-v/c_fld/",
      "linked_summary": "Loads a double-precision float from memory (Compressed).",
      "linked_pseudocode": "F[rd'] = M[R[rs1'] + offset][63:0];"
    },
    {
      "mnemonic": "C.FSD",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Float Store Double",
      "summary": "Stores a double-precision float to memory (Compressed).",
      "syntax": "C.FSD rs2&#x27;, offset(rs1&#x27;)",
      "encoding": {
        "format": "CS",
        "binary_pattern": "101 | imm | rs1' | imm | rs2' | 00",
        "hex_opcode": "00",
        "visual_parts": [
          {
            "raw": "101",
            "clean": "101"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rs1'",
            "clean": "rs1'"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rs2'",
            "clean": "rs2'"
          },
          {
            "raw": "00",
            "clean": "00"
          }
        ]
      },
      "operands": [
        {
          "name": "rs2'",
          "desc": "Source (f8-f15)"
        },
        {
          "name": "rs1'",
          "desc": "Base (x8-x15)"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "M[R[rs1'] + offset][63:0] = F[rs2'];",
      "slug": "c_fsd",
      "rel_url": "risc-v/c_fsd/",
      "linked_summary": "Stores a double-precision float to memory (Compressed).",
      "linked_pseudocode": "M[R[rs1'] + offset][63:0] = F[rs2'];"
    },
    {
      "mnemonic": "C.ADDI4SPN",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Add Immediate to Stack Pointer (Non-zero)",
      "summary": "Adds a zero-extended non-zero immediate to the stack pointer (x2) and stores the result in a register.",
      "syntax": "C.ADDI4SPN rd&#x27;, uimm",
      "encoding": {
        "format": "CIW",
        "binary_pattern": "000 | uimm | rd' | 00",
        "hex_opcode": "00",
        "visual_parts": [
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "uimm",
            "clean": "uimm"
          },
          {
            "raw": "rd'",
            "clean": "rd'"
          },
          {
            "raw": "00",
            "clean": "00"
          }
        ]
      },
      "operands": [
        {
          "name": "rd'",
          "desc": "Dest (x8-x15)"
        },
        {
          "name": "uimm",
          "desc": "Immediate"
        }
      ],
      "pseudocode": "R[rd'] = R[2] + zext(uimm);",
      "example": "C.ADDI4SPN x8, 16",
      "example_note": "Load address of stack object.",
      "slug": "c_addi4spn",
      "rel_url": "risc-v/c_addi4spn/",
      "linked_summary": "Adds a <a href=\"../../armv9-a/zero_1/\">zero</a>-extended non-<a href=\"../../armv9-a/zero_1/\">zero</a> immediate to the stack pointer (x2) <a href=\"../../armv8-a/and_6/\">and</a> stores the result <a href=\"../../x86/in/\">in</a> a register.",
      "linked_pseudocode": "R[rd'] = R[2] + zext(uimm);"
    },
    {
      "mnemonic": "C.LW",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Load Word",
      "summary": "Loads a 32-bit word from memory using a compressed encoding.",
      "syntax": "C.LW rd&#x27;, offset(rs1&#x27;)",
      "encoding": {
        "format": "CL",
        "binary_pattern": "010 | imm | rs1' | imm | rd' | 00",
        "hex_opcode": "00",
        "visual_parts": [
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rs1'",
            "clean": "rs1'"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rd'",
            "clean": "rd'"
          },
          {
            "raw": "00",
            "clean": "00"
          }
        ]
      },
      "operands": [
        {
          "name": "rd'",
          "desc": "Dest (x8-x15)"
        },
        {
          "name": "rs1'",
          "desc": "Base (x8-x15)"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "R[rd'] = M[R[rs1'] + offset][31:0];",
      "example": "C.LW x8, 4(x9)",
      "example_note": "16-bit encoding of LW.",
      "slug": "c_lw",
      "rel_url": "risc-v/c_lw/",
      "linked_summary": "Loads a 32-<a href=\"../../armv8-a/bit/\">bit</a> word from memory using a compressed encoding.",
      "linked_pseudocode": "R[rd'] = M[R[rs1'] + offset][31:0];"
    },
    {
      "mnemonic": "C.SW",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Store Word",
      "summary": "Stores a 32-bit word to memory using a compressed encoding.",
      "syntax": "C.SW rs2&#x27;, offset(rs1&#x27;)",
      "encoding": {
        "format": "CS",
        "binary_pattern": "110 | imm | rs1' | imm | rs2' | 00",
        "hex_opcode": "00",
        "visual_parts": [
          {
            "raw": "110",
            "clean": "110"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rs1'",
            "clean": "rs1'"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rs2'",
            "clean": "rs2'"
          },
          {
            "raw": "00",
            "clean": "00"
          }
        ]
      },
      "operands": [
        {
          "name": "rs2'",
          "desc": "Source (x8-x15)"
        },
        {
          "name": "rs1'",
          "desc": "Base (x8-x15)"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "M[R[rs1'] + offset][31:0] = R[rs2'];",
      "example": "C.SW x8, 4(x9)",
      "example_note": "16-bit encoding of SW.",
      "slug": "c_sw",
      "rel_url": "risc-v/c_sw/",
      "linked_summary": "Stores a 32-<a href=\"../../armv8-a/bit/\">bit</a> word to memory using a compressed encoding.",
      "linked_pseudocode": "M[R[rs1'] + offset][31:0] = R[rs2'];"
    },
    {
      "mnemonic": "C.ADDI",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Add Immediate",
      "summary": "Adds a non-zero immediate to a register.",
      "syntax": "C.ADDI rd, imm",
      "encoding": {
        "format": "CI",
        "binary_pattern": "000 | imm | rd | imm | 01",
        "hex_opcode": "01",
        "visual_parts": [
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "01",
            "clean": "01"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest/Source"
        },
        {
          "name": "imm",
          "desc": "6-bit Signed Imm"
        }
      ],
      "pseudocode": "R[rd] = R[rd] + sext(imm);",
      "example": "C.ADDI x10, 1",
      "example_note": "Increment x10.",
      "slug": "c_addi",
      "rel_url": "risc-v/c_addi/",
      "linked_summary": "Adds a non-<a href=\"../../armv9-a/zero_1/\">zero</a> immediate to a register.",
      "linked_pseudocode": "R[rd] = R[rd] + sext(imm);"
    },
    {
      "mnemonic": "C.JAL",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Jump and Link",
      "summary": "Performs a PC-relative jump and stores return address in x1 (ra). RV32 only.",
      "syntax": "C.JAL offset",
      "encoding": {
        "format": "CJ",
        "binary_pattern": "001 | imm | 01",
        "hex_opcode": "01",
        "visual_parts": [
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "01",
            "clean": "01"
          }
        ]
      },
      "operands": [
        {
          "name": "offset",
          "desc": "Jump Target"
        }
      ],
      "pseudocode": "R[1] = PC + 2; PC += sext(offset);",
      "example": "C.JAL func",
      "example_note": "Compressed function call.",
      "slug": "c_jal",
      "rel_url": "risc-v/c_jal/",
      "linked_summary": "Performs a PC-relative jump <a href=\"../../armv8-a/and_6/\">and</a> stores return address <a href=\"../../x86/in/\">in</a> x1 (ra). RV32 only.",
      "linked_pseudocode": "R[1] = PC + 2; PC += sext(offset);"
    },
    {
      "mnemonic": "C.LI",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Load Immediate",
      "summary": "Loads a 6-bit signed immediate into a register.",
      "syntax": "C.LI rd, imm",
      "encoding": {
        "format": "CI",
        "binary_pattern": "010 | imm | rd | imm | 01",
        "hex_opcode": "01",
        "visual_parts": [
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "01",
            "clean": "01"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "imm",
          "desc": "Immediate"
        }
      ],
      "pseudocode": "R[rd] = sext(imm);",
      "example": "C.LI x10, 1",
      "example_note": "Set x10 to 1.",
      "slug": "c_li",
      "rel_url": "risc-v/c_li/",
      "linked_summary": "Loads a 6-<a href=\"../../armv8-a/bit/\">bit</a> signed immediate into a register.",
      "linked_pseudocode": "R[rd] = sext(imm);"
    },
    {
      "mnemonic": "C.ADDI16SP",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Add Immediate to Stack Pointer",
      "summary": "Adds a signed non-zero immediate to the stack pointer (x2).",
      "syntax": "C.ADDI16SP imm",
      "encoding": {
        "format": "CI",
        "binary_pattern": "011 | imm | 00010 | imm | 01",
        "hex_opcode": "01",
        "visual_parts": [
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "00010",
            "clean": "00010"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "01",
            "clean": "01"
          }
        ]
      },
      "operands": [
        {
          "name": "imm",
          "desc": "Signed Imm * 16"
        }
      ],
      "pseudocode": "R[2] = R[2] + sext(imm);",
      "example": "C.ADDI16SP -64",
      "example_note": "Allocate 64 bytes on stack.",
      "slug": "c_addi16sp",
      "rel_url": "risc-v/c_addi16sp/",
      "linked_summary": "Adds a signed non-<a href=\"../../armv9-a/zero_1/\">zero</a> immediate to the stack pointer (x2).",
      "linked_pseudocode": "R[2] = R[2] + sext(imm);"
    },
    {
      "mnemonic": "C.LUI",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Load Upper Immediate",
      "summary": "Loads a non-zero 6-bit immediate into bits 17-12 of the destination register, clears lower 12 bits, sign-extends bit 17.",
      "syntax": "C.LUI rd, imm",
      "encoding": {
        "format": "CI",
        "binary_pattern": "011 | imm | rd | imm | 01",
        "hex_opcode": "01",
        "visual_parts": [
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "01",
            "clean": "01"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "imm",
          "desc": "Immediate"
        }
      ],
      "pseudocode": "R[rd] = sext(imm << 12);",
      "example": "C.LUI x10, 1",
      "example_note": "Loads 0x1000 into x10.",
      "slug": "c_lui",
      "rel_url": "risc-v/c_lui/",
      "linked_summary": "Loads a non-<a href=\"../../armv9-a/zero_1/\">zero</a> 6-<a href=\"../../armv8-a/bit/\">bit</a> immediate into bits 17-12 of the destination register, clears lower 12 bits, sign-extends <a href=\"../../armv8-a/bit/\">bit</a> 17.",
      "linked_pseudocode": "R[rd] = sext(imm << 12);"
    },
    {
      "mnemonic": "C.SRLI",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Shift Right Logical Immediate",
      "summary": "Logically shifts a register right by immediate.",
      "syntax": "C.SRLI rd&#x27;, imm",
      "encoding": {
        "format": "CB",
        "binary_pattern": "100 | imm | 00 | imm | rd' | 01",
        "hex_opcode": "01",
        "visual_parts": [
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "00",
            "clean": "00"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rd'",
            "clean": "rd'"
          },
          {
            "raw": "01",
            "clean": "01"
          }
        ]
      },
      "operands": [
        {
          "name": "rd'",
          "desc": "Dest/Source (x8-x15)"
        },
        {
          "name": "imm",
          "desc": "Shift Amount"
        }
      ],
      "pseudocode": "R[rd'] = R[rd'] >> imm;",
      "example": "C.SRLI x8, 2",
      "example_note": "x8 = x8 >> 2",
      "slug": "c_srli",
      "rel_url": "risc-v/c_srli/",
      "linked_summary": "Logically shifts a register right by immediate.",
      "linked_pseudocode": "R[rd'] = R[rd'] >> imm;"
    },
    {
      "mnemonic": "C.SRAI",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Shift Right Arithmetic Immediate",
      "summary": "Arithmetically shifts a register right by immediate.",
      "syntax": "C.SRAI rd&#x27;, imm",
      "encoding": {
        "format": "CB",
        "binary_pattern": "100 | imm | 01 | imm | rd' | 01",
        "hex_opcode": "01",
        "visual_parts": [
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "01",
            "clean": "01"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rd'",
            "clean": "rd'"
          },
          {
            "raw": "01",
            "clean": "01"
          }
        ]
      },
      "operands": [
        {
          "name": "rd'",
          "desc": "Dest/Source"
        },
        {
          "name": "imm",
          "desc": "Shift Amount"
        }
      ],
      "pseudocode": "R[rd'] = R[rd'] >>s imm;",
      "example": "C.SRAI x8, 2",
      "example_note": "x8 = x8 >>s 2",
      "slug": "c_srai",
      "rel_url": "risc-v/c_srai/",
      "linked_summary": "Arithmetically shifts a register right by immediate.",
      "linked_pseudocode": "R[rd'] = R[rd'] >>s imm;"
    },
    {
      "mnemonic": "C.ANDI",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed AND Immediate",
      "summary": "Computes bitwise AND with a signed immediate.",
      "syntax": "C.ANDI rd&#x27;, imm",
      "encoding": {
        "format": "CB",
        "binary_pattern": "100 | imm | 10 | imm | rd' | 01",
        "hex_opcode": "01",
        "visual_parts": [
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "10",
            "clean": "10"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rd'",
            "clean": "rd'"
          },
          {
            "raw": "01",
            "clean": "01"
          }
        ]
      },
      "operands": [
        {
          "name": "rd'",
          "desc": "Dest/Source"
        },
        {
          "name": "imm",
          "desc": "Signed Imm"
        }
      ],
      "pseudocode": "R[rd'] = R[rd'] & sext(imm);",
      "example": "C.ANDI x8, 15",
      "example_note": "Keep lowest 4 bits.",
      "slug": "c_andi",
      "rel_url": "risc-v/c_andi/",
      "linked_summary": "Computes bitwise <a href=\"../../risc-v/and/\">AND</a> with a signed immediate.",
      "linked_pseudocode": "R[rd'] = R[rd'] & sext(imm);"
    },
    {
      "mnemonic": "C.SUB",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Subtract",
      "summary": "Subtracts two registers.",
      "syntax": "C.SUB rd&#x27;, rs2&#x27;",
      "encoding": {
        "format": "CA",
        "binary_pattern": "100011 | rd' | 00 | rs2' | 01",
        "hex_opcode": "01",
        "visual_parts": [
          {
            "raw": "100011",
            "clean": "100011"
          },
          {
            "raw": "rd'",
            "clean": "rd'"
          },
          {
            "raw": "00",
            "clean": "00"
          },
          {
            "raw": "rs2'",
            "clean": "rs2'"
          },
          {
            "raw": "01",
            "clean": "01"
          }
        ]
      },
      "operands": [
        {
          "name": "rd'",
          "desc": "Dest/Src1"
        },
        {
          "name": "rs2'",
          "desc": "Src2"
        }
      ],
      "pseudocode": "R[rd'] = R[rd'] - R[rs2'];",
      "example": "C.SUB x8, x9",
      "example_note": "x8 = x8 - x9",
      "slug": "c_sub",
      "rel_url": "risc-v/c_sub/",
      "linked_summary": "Subtracts two registers.",
      "linked_pseudocode": "R[rd'] = R[rd'] - R[rs2'];"
    },
    {
      "mnemonic": "C.XOR",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed XOR",
      "summary": "Bitwise XOR of two registers.",
      "syntax": "C.XOR rd&#x27;, rs2&#x27;",
      "encoding": {
        "format": "CA",
        "binary_pattern": "100011 | rd' | 01 | rs2' | 01",
        "hex_opcode": "01",
        "visual_parts": [
          {
            "raw": "100011",
            "clean": "100011"
          },
          {
            "raw": "rd'",
            "clean": "rd'"
          },
          {
            "raw": "01",
            "clean": "01"
          },
          {
            "raw": "rs2'",
            "clean": "rs2'"
          },
          {
            "raw": "01",
            "clean": "01"
          }
        ]
      },
      "operands": [
        {
          "name": "rd'",
          "desc": "Dest/Src1"
        },
        {
          "name": "rs2'",
          "desc": "Src2"
        }
      ],
      "pseudocode": "R[rd'] = R[rd'] ^ R[rs2'];",
      "example": "C.XOR x8, x9",
      "example_note": "x8 = x8 ^ x9",
      "slug": "c_xor",
      "rel_url": "risc-v/c_xor/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/xor/\">XOR</a> of two registers.",
      "linked_pseudocode": "R[rd'] = R[rd'] ^ R[rs2'];"
    },
    {
      "mnemonic": "C.OR",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed OR",
      "summary": "Bitwise OR of two registers.",
      "syntax": "C.OR rd&#x27;, rs2&#x27;",
      "encoding": {
        "format": "CA",
        "binary_pattern": "100011 | rd' | 10 | rs2' | 01",
        "hex_opcode": "01",
        "visual_parts": [
          {
            "raw": "100011",
            "clean": "100011"
          },
          {
            "raw": "rd'",
            "clean": "rd'"
          },
          {
            "raw": "10",
            "clean": "10"
          },
          {
            "raw": "rs2'",
            "clean": "rs2'"
          },
          {
            "raw": "01",
            "clean": "01"
          }
        ]
      },
      "operands": [
        {
          "name": "rd'",
          "desc": "Dest/Src1"
        },
        {
          "name": "rs2'",
          "desc": "Src2"
        }
      ],
      "pseudocode": "R[rd'] = R[rd'] | R[rs2'];",
      "example": "C.OR x8, x9",
      "example_note": "x8 = x8 | x9",
      "slug": "c_or",
      "rel_url": "risc-v/c_or/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/or/\">OR</a> of two registers.",
      "linked_pseudocode": "R[rd'] = R[rd'] | R[rs2'];"
    },
    {
      "mnemonic": "C.AND",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed AND",
      "summary": "Bitwise AND of two registers.",
      "syntax": "C.AND rd&#x27;, rs2&#x27;",
      "encoding": {
        "format": "CA",
        "binary_pattern": "100011 | rd' | 11 | rs2' | 01",
        "hex_opcode": "01",
        "visual_parts": [
          {
            "raw": "100011",
            "clean": "100011"
          },
          {
            "raw": "rd'",
            "clean": "rd'"
          },
          {
            "raw": "11",
            "clean": "11"
          },
          {
            "raw": "rs2'",
            "clean": "rs2'"
          },
          {
            "raw": "01",
            "clean": "01"
          }
        ]
      },
      "operands": [
        {
          "name": "rd'",
          "desc": "Dest/Src1"
        },
        {
          "name": "rs2'",
          "desc": "Src2"
        }
      ],
      "pseudocode": "R[rd'] = R[rd'] & R[rs2'];",
      "example": "C.AND x8, x9",
      "example_note": "x8 = x8 & x9",
      "slug": "c_and",
      "rel_url": "risc-v/c_and/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/and/\">AND</a> of two registers.",
      "linked_pseudocode": "R[rd'] = R[rd'] & R[rs2'];"
    },
    {
      "mnemonic": "C.J",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Jump",
      "summary": "Unconditional PC-relative jump.",
      "syntax": "C.J offset",
      "encoding": {
        "format": "CJ",
        "binary_pattern": "101 | imm | 01",
        "hex_opcode": "01",
        "visual_parts": [
          {
            "raw": "101",
            "clean": "101"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "01",
            "clean": "01"
          }
        ]
      },
      "operands": [
        {
          "name": "offset",
          "desc": "Target"
        }
      ],
      "pseudocode": "PC += sext(offset);",
      "example": "C.J label",
      "example_note": "Jump to label.",
      "slug": "c_j",
      "rel_url": "risc-v/c_j/",
      "linked_summary": "Unconditional PC-relative jump.",
      "linked_pseudocode": "PC += sext(offset);"
    },
    {
      "mnemonic": "C.BEQZ",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Branch if Equal to Zero",
      "summary": "Branches if the register is zero.",
      "syntax": "C.BEQZ rs1&#x27;, offset",
      "encoding": {
        "format": "CB",
        "binary_pattern": "110 | imm | rs1' | imm | 01",
        "hex_opcode": "01",
        "visual_parts": [
          {
            "raw": "110",
            "clean": "110"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rs1'",
            "clean": "rs1'"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "01",
            "clean": "01"
          }
        ]
      },
      "operands": [
        {
          "name": "rs1'",
          "desc": "Source"
        },
        {
          "name": "offset",
          "desc": "Target"
        }
      ],
      "pseudocode": "if (R[rs1'] == 0) PC += sext(offset);",
      "example": "C.BEQZ x8, exit",
      "example_note": "Jump if x8 is 0.",
      "slug": "c_beqz",
      "rel_url": "risc-v/c_beqz/",
      "linked_summary": "Branches if the register is <a href=\"../../armv9-a/zero_1/\">zero</a>.",
      "linked_pseudocode": "if (R[rs1'] == 0) PC += sext(offset);"
    },
    {
      "mnemonic": "C.BNEZ",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Branch if Not Equal to Zero",
      "summary": "Branches if the register is not zero.",
      "syntax": "C.BNEZ rs1&#x27;, offset",
      "encoding": {
        "format": "CB",
        "binary_pattern": "111 | imm | rs1' | imm | 01",
        "hex_opcode": "01",
        "visual_parts": [
          {
            "raw": "111",
            "clean": "111"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rs1'",
            "clean": "rs1'"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "01",
            "clean": "01"
          }
        ]
      },
      "operands": [
        {
          "name": "rs1'",
          "desc": "Source"
        },
        {
          "name": "offset",
          "desc": "Target"
        }
      ],
      "pseudocode": "if (R[rs1'] != 0) PC += sext(offset);",
      "example": "C.BNEZ x8, loop",
      "example_note": "Jump if x8 is not 0.",
      "slug": "c_bnez",
      "rel_url": "risc-v/c_bnez/",
      "linked_summary": "Branches if the register is <a href=\"../../armv8-a/not_1/\">not</a> <a href=\"../../armv9-a/zero_1/\">zero</a>.",
      "linked_pseudocode": "if (R[rs1'] != 0) PC += sext(offset);"
    },
    {
      "mnemonic": "C.SLLI",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Shift Left Logical Immediate",
      "summary": "Logically shifts a register left by immediate.",
      "syntax": "C.SLLI rd, imm",
      "encoding": {
        "format": "CI",
        "binary_pattern": "000 | imm | rd | imm | 10",
        "hex_opcode": "02",
        "visual_parts": [
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "10",
            "clean": "10"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest/Source"
        },
        {
          "name": "imm",
          "desc": "Shift Amount"
        }
      ],
      "pseudocode": "R[rd] = R[rd] << imm;",
      "example": "C.SLLI x10, 2",
      "example_note": "x10 = x10 << 2",
      "slug": "c_slli",
      "rel_url": "risc-v/c_slli/",
      "linked_summary": "Logically shifts a register left by immediate.",
      "linked_pseudocode": "R[rd] = R[rd] << imm;"
    },
    {
      "mnemonic": "C.LWSP",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Load Word from Stack Pointer",
      "summary": "Loads a word from the stack pointer (x2).",
      "syntax": "C.LWSP rd, offset(x2)",
      "encoding": {
        "format": "CI",
        "binary_pattern": "010 | imm | rd | imm | 10",
        "hex_opcode": "02",
        "visual_parts": [
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "10",
            "clean": "10"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "R[rd] = M[R[2] + offset][31:0];",
      "example": "C.LWSP x10, 4(x2)",
      "example_note": "Load from stack.",
      "slug": "c_lwsp",
      "rel_url": "risc-v/c_lwsp/",
      "linked_summary": "Loads a word from the stack pointer (x2).",
      "linked_pseudocode": "R[rd] = M[R[2] + offset][31:0];"
    },
    {
      "mnemonic": "C.SWSP",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Store Word to Stack Pointer",
      "summary": "Stores a word to the stack pointer (x2).",
      "syntax": "C.SWSP rs2, offset(x2)",
      "encoding": {
        "format": "CSS",
        "binary_pattern": "110 | imm | rs2 | 10",
        "hex_opcode": "02",
        "visual_parts": [
          {
            "raw": "110",
            "clean": "110"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "10",
            "clean": "10"
          }
        ]
      },
      "operands": [
        {
          "name": "rs2",
          "desc": "Source"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "M[R[2] + offset][31:0] = R[rs2];",
      "example": "C.SWSP x10, 8(x2)",
      "example_note": "Store to stack.",
      "slug": "c_swsp",
      "rel_url": "risc-v/c_swsp/",
      "linked_summary": "Stores a word to the stack pointer (x2).",
      "linked_pseudocode": "M[R[2] + offset][31:0] = R[rs2];"
    },
    {
      "mnemonic": "C.JR",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Jump Register",
      "summary": "Unconditionally jumps to address in register.",
      "syntax": "C.JR rs1",
      "encoding": {
        "format": "CR",
        "binary_pattern": "1000 | rs1 | 00000 | 10",
        "hex_opcode": "02",
        "visual_parts": [
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "10",
            "clean": "10"
          }
        ]
      },
      "operands": [
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "PC = R[rs1];",
      "example": "C.JR x1",
      "example_note": "Return (if x1 is ra).",
      "slug": "c_jr",
      "rel_url": "risc-v/c_jr/",
      "linked_summary": "Unconditionally jumps to address <a href=\"../../x86/in/\">in</a> register.",
      "linked_pseudocode": "PC = R[rs1];"
    },
    {
      "mnemonic": "C.MV",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Move",
      "summary": "Copies register rs2 to rd.",
      "syntax": "C.MV rd, rs2",
      "encoding": {
        "format": "CR",
        "binary_pattern": "1000 | rd | rs2 | 10",
        "hex_opcode": "02",
        "visual_parts": [
          {
            "raw": "1000",
            "clean": "1000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "10",
            "clean": "10"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs2",
          "desc": "Source"
        }
      ],
      "pseudocode": "R[rd] = R[rs2];",
      "example": "C.MV x10, x11",
      "example_note": "Copy x11 to x10.",
      "slug": "c_mv",
      "rel_url": "risc-v/c_mv/",
      "linked_summary": "Copies register rs2 to rd.",
      "linked_pseudocode": "R[rd] = R[rs2];"
    },
    {
      "mnemonic": "C.EBREAK",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Environment Break",
      "summary": "Triggers a debugger breakpoint.",
      "syntax": "C.EBREAK",
      "encoding": {
        "format": "CR",
        "binary_pattern": "1001000000000010",
        "hex_opcode": "9002",
        "visual_parts": [
          {
            "raw": "1001000000000010",
            "clean": "1001000000000010"
          }
        ]
      },
      "operands": [],
      "pseudocode": "RaiseException(Breakpoint);",
      "example": "C.EBREAK",
      "example_note": "Break.",
      "slug": "c_ebreak",
      "rel_url": "risc-v/c_ebreak/",
      "linked_summary": "Triggers a debugger breakpoint.",
      "linked_pseudocode": "RaiseException(Breakpoint);"
    },
    {
      "mnemonic": "C.JALR",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Jump and Link Register",
      "summary": "Jumps to register address and links (saves PC+2 to ra).",
      "syntax": "C.JALR rs1",
      "encoding": {
        "format": "CR",
        "binary_pattern": "1001 | rs1 | 00000 | 10",
        "hex_opcode": "02",
        "visual_parts": [
          {
            "raw": "1001",
            "clean": "1001"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "10",
            "clean": "10"
          }
        ]
      },
      "operands": [
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "t = PC + 2; PC = R[rs1]; R[1] = t;",
      "example": "C.JALR x10",
      "example_note": "Call function pointer in x10.",
      "slug": "c_jalr",
      "rel_url": "risc-v/c_jalr/",
      "linked_summary": "Jumps to register address <a href=\"../../armv8-a/and_6/\">and</a> links (saves PC+2 to ra).",
      "linked_pseudocode": "t = PC + 2; PC = R[rs1]; R[1] = t;"
    },
    {
      "mnemonic": "C.ADD",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Add",
      "summary": "Adds two registers.",
      "syntax": "C.ADD rd, rs2",
      "encoding": {
        "format": "CR",
        "binary_pattern": "1001 | rd | rs2 | 10",
        "hex_opcode": "02",
        "visual_parts": [
          {
            "raw": "1001",
            "clean": "1001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "10",
            "clean": "10"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest/Src1"
        },
        {
          "name": "rs2",
          "desc": "Src2"
        }
      ],
      "pseudocode": "R[rd] = R[rd] + R[rs2];",
      "example": "C.ADD x10, x11",
      "example_note": "x10 = x10 + x11",
      "slug": "c_add",
      "rel_url": "risc-v/c_add/",
      "linked_summary": "Adds two registers.",
      "linked_pseudocode": "R[rd] = R[rd] + R[rs2];"
    },
    {
      "mnemonic": "BEQ",
      "architecture": "RISC-V",
      "full_name": "Branch if Equal",
      "summary": "Take the branch if registers rs1 and rs2 are equal.",
      "syntax": "BEQ rs1, rs2, offset",
      "encoding": {
        "format": "B-Type",
        "binary_pattern": "imm[12|10:5] | rs2 | rs1 | 000 | imm[4:1|11] | 1100011",
        "hex_opcode": "0x63",
        "visual_parts": [
          {
            "raw": "imm[12",
            "clean": "imm"
          },
          {
            "raw": "10:5]",
            "clean": "10:5]"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "imm[4:1",
            "clean": "imm"
          },
          {
            "raw": "11]",
            "clean": "11]"
          },
          {
            "raw": "1100011",
            "clean": "1100011"
          }
        ]
      },
      "operands": [
        {
          "name": "rs1",
          "desc": "Source 1"
        },
        {
          "name": "rs2",
          "desc": "Source 2"
        },
        {
          "name": "offset",
          "desc": "PC-relative offset"
        }
      ],
      "pseudocode": "if (R[rs1] == R[rs2]) PC += sext(offset);",
      "example": "BEQ x5, x6, 100",
      "example_note": "Jump to PC+100 if x5 == x6.",
      "slug": "beq",
      "rel_url": "risc-v/beq/",
      "linked_summary": "Take the branch if registers rs1 <a href=\"../../armv8-a/and_6/\">and</a> rs2 are equal.",
      "linked_pseudocode": "if (R[rs1] == R[rs2]) PC += sext(offset);"
    },
    {
      "mnemonic": "BNE",
      "architecture": "RISC-V",
      "full_name": "Branch if Not Equal",
      "summary": "Take the branch if registers rs1 and rs2 are not equal.",
      "syntax": "BNE rs1, rs2, offset",
      "encoding": {
        "format": "B-Type",
        "binary_pattern": "imm[12|10:5] | rs2 | rs1 | 001 | imm[4:1|11] | 1100011",
        "hex_opcode": "0x63",
        "visual_parts": [
          {
            "raw": "imm[12",
            "clean": "imm"
          },
          {
            "raw": "10:5]",
            "clean": "10:5]"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "imm[4:1",
            "clean": "imm"
          },
          {
            "raw": "11]",
            "clean": "11]"
          },
          {
            "raw": "1100011",
            "clean": "1100011"
          }
        ]
      },
      "operands": [
        {
          "name": "rs1",
          "desc": "Source 1"
        },
        {
          "name": "rs2",
          "desc": "Source 2"
        },
        {
          "name": "offset",
          "desc": "PC-relative offset"
        }
      ],
      "pseudocode": "if (R[rs1] != R[rs2]) PC += sext(offset);",
      "example": "BNE x5, x6, loop",
      "example_note": "Jump to 'loop' if x5 != x6.",
      "slug": "bne",
      "rel_url": "risc-v/bne/",
      "linked_summary": "Take the branch if registers rs1 <a href=\"../../armv8-a/and_6/\">and</a> rs2 are <a href=\"../../armv8-a/not_1/\">not</a> equal.",
      "linked_pseudocode": "if (R[rs1] != R[rs2]) PC += sext(offset);"
    },
    {
      "mnemonic": "BLT",
      "architecture": "RISC-V",
      "full_name": "Branch if Less Than",
      "summary": "Take the branch if rs1 is less than rs2 (signed).",
      "syntax": "BLT rs1, rs2, offset",
      "encoding": {
        "format": "B-Type",
        "binary_pattern": "imm[12|10:5] | rs2 | rs1 | 100 | imm[4:1|11] | 1100011",
        "hex_opcode": "0x63",
        "visual_parts": [
          {
            "raw": "imm[12",
            "clean": "imm"
          },
          {
            "raw": "10:5]",
            "clean": "10:5]"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "imm[4:1",
            "clean": "imm"
          },
          {
            "raw": "11]",
            "clean": "11]"
          },
          {
            "raw": "1100011",
            "clean": "1100011"
          }
        ]
      },
      "operands": [
        {
          "name": "rs1",
          "desc": "Source 1"
        },
        {
          "name": "rs2",
          "desc": "Source 2"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "if (R[rs1] <s R[rs2]) PC += sext(offset);",
      "example": "BLT x10, x11, exit",
      "example_note": "Branch to 'exit' if x10 < x11 (signed comparison).",
      "slug": "blt",
      "rel_url": "risc-v/blt/",
      "linked_summary": "Take the branch if rs1 is less than rs2 (signed).",
      "linked_pseudocode": "if (R[rs1] <s R[rs2]) PC += sext(offset);"
    },
    {
      "mnemonic": "BGE",
      "architecture": "RISC-V",
      "full_name": "Branch if Greater or Equal",
      "summary": "Take the branch if rs1 is greater than or equal to rs2 (signed).",
      "syntax": "BGE rs1, rs2, offset",
      "encoding": {
        "format": "B-Type",
        "binary_pattern": "imm[12|10:5] | rs2 | rs1 | 101 | imm[4:1|11] | 1100011",
        "hex_opcode": "0x63",
        "visual_parts": [
          {
            "raw": "imm[12",
            "clean": "imm"
          },
          {
            "raw": "10:5]",
            "clean": "10:5]"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "101",
            "clean": "101"
          },
          {
            "raw": "imm[4:1",
            "clean": "imm"
          },
          {
            "raw": "11]",
            "clean": "11]"
          },
          {
            "raw": "1100011",
            "clean": "1100011"
          }
        ]
      },
      "operands": [
        {
          "name": "rs1",
          "desc": "Source 1"
        },
        {
          "name": "rs2",
          "desc": "Source 2"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "if (R[rs1] >=s R[rs2]) PC += sext(offset);",
      "example": "BGE x10, x0, positive",
      "example_note": "Branch if x10 is positive or zero.",
      "slug": "bge",
      "rel_url": "risc-v/bge/",
      "linked_summary": "Take the branch if rs1 is greater than <a href=\"../../powerisa/or/\">or</a> equal to rs2 (signed).",
      "linked_pseudocode": "if (R[rs1] >=s R[rs2]) PC += sext(offset);"
    },
    {
      "mnemonic": "CSRRW",
      "architecture": "RISC-V",
      "extension": "Zicsr",
      "full_name": "Control Status Register Read/Write",
      "summary": "Atomically swaps values in the CSRs. Reads the old value of the CSR into rd, then writes rs1 to the CSR.",
      "syntax": "CSRRW rd, csr, rs1",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "csr | rs1 | 001 | rd | 1110011",
        "hex_opcode": "0x73",
        "visual_parts": [
          {
            "raw": "csr",
            "clean": "csr"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1110011",
            "clean": "1110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Old Value)"
        },
        {
          "name": "csr",
          "desc": "CSR Address"
        },
        {
          "name": "rs1",
          "desc": "Src (New Value)"
        }
      ],
      "pseudocode": "t = CSRs[csr]; CSRs[csr] = R[rs1]; R[rd] = t;",
      "example": "CSRRW x10, scause, x11",
      "example_note": "Writes x11 to 'scause' CSR and reads old 'scause' into x10.",
      "slug": "csrrw",
      "rel_url": "risc-v/csrrw/",
      "linked_summary": "Atomically swaps values <a href=\"../../x86/in/\">in</a> the CSRs. Reads the old value of the CSR into rd, then writes rs1 to the CSR.",
      "linked_pseudocode": "t = CSRs[csr]; CSRs[csr] = R[rs1]; R[rd] = t;"
    },
    {
      "mnemonic": "CSRRS",
      "architecture": "RISC-V",
      "extension": "Zicsr",
      "full_name": "Control Status Register Read and Set",
      "summary": "Reads the value of the CSR into rd, then bitwise ORs the value in rs1 into the CSR (setting bits).",
      "syntax": "CSRRS rd, csr, rs1",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "csr | rs1 | 010 | rd | 1110011",
        "hex_opcode": "0x73",
        "visual_parts": [
          {
            "raw": "csr",
            "clean": "csr"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1110011",
            "clean": "1110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "csr",
          "desc": "CSR Address"
        },
        {
          "name": "rs1",
          "desc": "Bit Mask"
        }
      ],
      "pseudocode": "t = CSRs[csr]; CSRs[csr] = t | R[rs1]; R[rd] = t;",
      "example": "CSRRS x0, sstatus, x5",
      "example_note": "Sets bits in 'sstatus' using mask in x5 (Result discarded).",
      "slug": "csrrs",
      "rel_url": "risc-v/csrrs/",
      "linked_summary": "Reads the value of the CSR into rd, then bitwise ORs the value <a href=\"../../x86/in/\">in</a> rs1 into the CSR (setting bits).",
      "linked_pseudocode": "t = CSRs[csr]; CSRs[csr] = t | R[rs1]; R[rd] = t;"
    },
    {
      "mnemonic": "DIV",
      "architecture": "RISC-V",
      "extension": "M",
      "full_name": "Divide",
      "summary": "Performs signed integer division.",
      "syntax": "DIV rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000001 | rs2 | rs1 | 100 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0000001",
            "clean": "0000001"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Quotient)"
        },
        {
          "name": "rs1",
          "desc": "Dividend"
        },
        {
          "name": "rs2",
          "desc": "Divisor"
        }
      ],
      "pseudocode": "R[rd] = R[rs1] / R[rs2];",
      "example": "DIV x10, x11, x12",
      "example_note": "Signed division of x11 by x12.",
      "slug": "div",
      "rel_url": "risc-v/div/",
      "linked_summary": "Performs signed integer division.",
      "linked_pseudocode": "R[rd] = R[rs1] / R[rs2];"
    },
    {
      "mnemonic": "DIVU",
      "architecture": "RISC-V",
      "extension": "M",
      "full_name": "Divide Unsigned",
      "summary": "Performs unsigned integer division.",
      "syntax": "DIVU rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000001 | rs2 | rs1 | 101 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0000001",
            "clean": "0000001"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "101",
            "clean": "101"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Dividend"
        },
        {
          "name": "rs2",
          "desc": "Divisor"
        }
      ],
      "pseudocode": "R[rd] = R[rs1] /u R[rs2];",
      "example": "DIVU x5, x6, x7",
      "example_note": "Unsigned division.",
      "slug": "divu",
      "rel_url": "risc-v/divu/",
      "linked_summary": "Performs unsigned integer division.",
      "linked_pseudocode": "R[rd] = R[rs1] /u R[rs2];"
    },
    {
      "mnemonic": "EBREAK",
      "architecture": "RISC-V",
      "full_name": "Environment Break",
      "summary": "Used by debuggers to cause control to be transferred back to a debugging environment.",
      "syntax": "EBREAK",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "000000000001 | 00000 | 000 | 00000 | 1110011",
        "hex_opcode": "0x73",
        "visual_parts": [
          {
            "raw": "000000000001",
            "clean": "000000000001"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "1110011",
            "clean": "1110011"
          }
        ]
      },
      "operands": [],
      "pseudocode": "RaiseException(Breakpoint);",
      "example": "EBREAK",
      "example_note": "Triggers a debugger breakpoint.",
      "slug": "ebreak",
      "rel_url": "risc-v/ebreak/",
      "linked_summary": "Used by debuggers to cause control to be transferred back to a debugging environment.",
      "linked_pseudocode": "RaiseException(Breakpoint);"
    },
    {
      "mnemonic": "FENCE",
      "architecture": "RISC-V",
      "full_name": "Fence",
      "summary": "Orders device I/O and memory accesses.",
      "syntax": "FENCE pred, succ",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "fm | pred | succ | rs1 | 000 | rd | 0001111",
        "hex_opcode": "0x0F",
        "visual_parts": [
          {
            "raw": "fm",
            "clean": "fm"
          },
          {
            "raw": "pred",
            "clean": "pred"
          },
          {
            "raw": "succ",
            "clean": "succ"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0001111",
            "clean": "0001111"
          }
        ]
      },
      "operands": [
        {
          "name": "pred",
          "desc": "Predecessor Set"
        },
        {
          "name": "succ",
          "desc": "Successor Set"
        }
      ],
      "pseudocode": "MemoryBarrier(pred, succ);",
      "example": "FENCE rw, rw",
      "example_note": "Ensures all previous reads/writes complete before subsequent reads/writes.",
      "slug": "fence",
      "rel_url": "risc-v/fence/",
      "linked_summary": "Orders device I/O <a href=\"../../armv8-a/and_6/\">and</a> memory accesses.",
      "linked_pseudocode": "MemoryBarrier(pred, succ);"
    },
    {
      "mnemonic": "FLW",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Float Load Word",
      "summary": "Loads a single-precision floating-point value from memory.",
      "syntax": "FLW rd, offset(rs1)",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "offset | rs1 | 010 | rd | 0000111",
        "hex_opcode": "0x07",
        "visual_parts": [
          {
            "raw": "offset",
            "clean": "offset"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0000111",
            "clean": "0000111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Float Reg)"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "F[rd] = M[R[rs1] + sext(offset)][31:0];",
      "example": "FLW f1, 0(x10)",
      "example_note": "Loads float from address in x10 to f1.",
      "slug": "flw",
      "rel_url": "risc-v/flw/",
      "linked_summary": "Loads a single-precision floating-point value from memory.",
      "linked_pseudocode": "F[rd] = M[R[rs1] + sext(offset)][31:0];"
    },
    {
      "mnemonic": "FSW",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Float Store Word",
      "summary": "Stores a single-precision floating-point value to memory.",
      "syntax": "FSW rs2, offset(rs1)",
      "encoding": {
        "format": "S-Type",
        "binary_pattern": "imm[11:5] | rs2 | rs1 | 010 | imm[4:0] | 0100111",
        "hex_opcode": "0x27",
        "visual_parts": [
          {
            "raw": "imm[11:5]",
            "clean": "imm"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "imm[4:0]",
            "clean": "imm"
          },
          {
            "raw": "0100111",
            "clean": "0100111"
          }
        ]
      },
      "operands": [
        {
          "name": "rs2",
          "desc": "Src (Float Reg)"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "M[R[rs1] + sext(offset)] = F[rs2][31:0];",
      "example": "FSW f1, 4(x2)",
      "example_note": "Stores float in f1 to stack + 4.",
      "slug": "fsw",
      "rel_url": "risc-v/fsw/",
      "linked_summary": "Stores a single-precision floating-point value to memory.",
      "linked_pseudocode": "M[R[rs1] + sext(offset)] = F[rs2][31:0];"
    },
    {
      "mnemonic": "FADD.S",
      "architecture": "RISC-V",
      "extension": "F",
      "full_name": "Float Add (Single)",
      "summary": "Performs single-precision floating-point addition.",
      "syntax": "FADD.S rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000000 | rs2 | rs1 | 000 | rd | 1010011",
        "hex_opcode": "0x53",
        "visual_parts": [
          {
            "raw": "0000000",
            "clean": "0000000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1010011",
            "clean": "1010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Src 1"
        },
        {
          "name": "rs2",
          "desc": "Src 2"
        }
      ],
      "pseudocode": "F[rd] = F[rs1] + F[rs2];",
      "example": "FADD.S f0, f1, f2",
      "example_note": "f0 = f1 + f2",
      "slug": "fadd_s",
      "rel_url": "risc-v/fadd_s/",
      "linked_summary": "Performs single-precision floating-point addition.",
      "linked_pseudocode": "F[rd] = F[rs1] + F[rs2];"
    },
    {
      "mnemonic": "MUL",
      "architecture": "RISC-V",
      "extension": "M",
      "full_name": "Multiply",
      "summary": "Performs a 32-bit (or 64-bit) multiplication of rs1 and rs2 and stores the lower bits in rd.",
      "syntax": "MUL rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000001 | rs2 | rs1 | 000 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0000001",
            "clean": "0000001"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Lower Bits)"
        },
        {
          "name": "rs1",
          "desc": "Source 1"
        },
        {
          "name": "rs2",
          "desc": "Source 2"
        }
      ],
      "pseudocode": "R[rd] = (R[rs1] * R[rs2])[XLEN-1:0];",
      "example": "MUL x10, x11, x12",
      "example_note": "x10 = lower bits of x11 * x12.",
      "slug": "mul",
      "rel_url": "risc-v/mul/",
      "linked_summary": "Performs a 32-<a href=\"../../armv8-a/bit/\">bit</a> (<a href=\"../../powerisa/or/\">or</a> 64-<a href=\"../../armv8-a/bit/\">bit</a>) multiplication of rs1 <a href=\"../../armv8-a/and_6/\">and</a> rs2 <a href=\"../../armv8-a/and_6/\">and</a> stores the lower bits <a href=\"../../x86/in/\">in</a> rd.",
      "linked_pseudocode": "R[rd] = (R[rs1] * R[rs2])[XLEN-1:0];"
    },
    {
      "mnemonic": "MULH",
      "architecture": "RISC-V",
      "extension": "M",
      "full_name": "Multiply High Signed",
      "summary": "Performs a signed multiplication and stores the upper bits of the result.",
      "syntax": "MULH rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000001 | rs2 | rs1 | 001 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0000001",
            "clean": "0000001"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Upper Bits)"
        },
        {
          "name": "rs1",
          "desc": "Source 1"
        },
        {
          "name": "rs2",
          "desc": "Source 2"
        }
      ],
      "pseudocode": "R[rd] = (sext(R[rs1]) * sext(R[rs2])) >> XLEN;",
      "example": "MULH x5, x6, x7",
      "example_note": "Get upper bits of signed multiplication.",
      "slug": "mulh",
      "rel_url": "risc-v/mulh/",
      "linked_summary": "Performs a signed multiplication <a href=\"../../armv8-a/and_6/\">and</a> stores the upper bits of the result.",
      "linked_pseudocode": "R[rd] = (sext(R[rs1]) * sext(R[rs2])) >> XLEN;"
    },
    {
      "mnemonic": "MRET",
      "architecture": "RISC-V",
      "extension": "Privileged",
      "full_name": "Machine Return",
      "summary": "Returns from a machine-mode trap handler.",
      "syntax": "MRET",
      "encoding": {
        "format": "R-Type (System)",
        "binary_pattern": "0011000 | 00010 | 00000 | 000 | 00000 | 1110011",
        "hex_opcode": "0x73",
        "visual_parts": [
          {
            "raw": "0011000",
            "clean": "0011000"
          },
          {
            "raw": "00010",
            "clean": "00010"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "1110011",
            "clean": "1110011"
          }
        ]
      },
      "operands": [],
      "pseudocode": "PC = MEPC; Priv = MPP; MIE = MPIE;",
      "example": "MRET",
      "example_note": "Return to previous privilege level defined in mstatus.",
      "slug": "mret",
      "rel_url": "risc-v/mret/",
      "linked_summary": "Returns from a machine-mode <a href=\"../../powerisa/trap/\">trap</a> handler.",
      "linked_pseudocode": "PC = MEPC; Priv = MPP; MIE = MPIE;"
    },
    {
      "mnemonic": "OR",
      "architecture": "RISC-V",
      "full_name": "Logical OR",
      "summary": "Performs a bitwise logical OR operation.",
      "syntax": "OR rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000000 | rs2 | rs1 | 110 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0000000",
            "clean": "0000000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "110",
            "clean": "110"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source 1"
        },
        {
          "name": "rs2",
          "desc": "Source 2"
        }
      ],
      "pseudocode": "R[rd] = R[rs1] | R[rs2];",
      "example": "OR x10, x11, x12",
      "example_note": "Bitwise OR of x11 and x12.",
      "slug": "or",
      "rel_url": "risc-v/or/",
      "linked_summary": "Performs a bitwise logical <a href=\"../../risc-v/or/\">OR</a> operation.",
      "linked_pseudocode": "R[rd] = R[rs1] | R[rs2];"
    },
    {
      "mnemonic": "ORI",
      "architecture": "RISC-V",
      "full_name": "Logical OR Immediate",
      "summary": "Performs a bitwise logical OR with a sign-extended immediate.",
      "syntax": "ORI rd, rs1, imm",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "imm[11:0] | rs1 | 110 | rd | 0010011",
        "hex_opcode": "0x13",
        "visual_parts": [
          {
            "raw": "imm[11:0]",
            "clean": "imm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "110",
            "clean": "110"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0010011",
            "clean": "0010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        },
        {
          "name": "imm",
          "desc": "Immediate"
        }
      ],
      "pseudocode": "R[rd] = R[rs1] | sext(imm);",
      "example": "ORI x10, x11, 1",
      "example_note": "Sets the lowest bit of x11.",
      "slug": "ori",
      "rel_url": "risc-v/ori/",
      "linked_summary": "Performs a bitwise logical <a href=\"../../risc-v/or/\">OR</a> with a sign-extended immediate.",
      "linked_pseudocode": "R[rd] = R[rs1] | sext(imm);"
    },
    {
      "mnemonic": "REM",
      "architecture": "RISC-V",
      "extension": "M",
      "full_name": "Remainder",
      "summary": "Computes the signed remainder of division.",
      "syntax": "REM rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000001 | rs2 | rs1 | 110 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0000001",
            "clean": "0000001"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "110",
            "clean": "110"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Remainder)"
        },
        {
          "name": "rs1",
          "desc": "Dividend"
        },
        {
          "name": "rs2",
          "desc": "Divisor"
        }
      ],
      "pseudocode": "R[rd] = R[rs1] % R[rs2];",
      "example": "REM x5, x6, x7",
      "example_note": "Signed remainder.",
      "slug": "rem",
      "rel_url": "risc-v/rem/",
      "linked_summary": "Computes the signed remainder of division.",
      "linked_pseudocode": "R[rd] = R[rs1] % R[rs2];"
    },
    {
      "mnemonic": "SB",
      "architecture": "RISC-V",
      "full_name": "Store Byte",
      "summary": "Stores the lowest 8 bits of a register to memory.",
      "syntax": "SB rs2, offset(rs1)",
      "encoding": {
        "format": "S-Type",
        "binary_pattern": "imm[11:5] | rs2 | rs1 | 000 | imm[4:0] | 0100011",
        "hex_opcode": "0x23",
        "visual_parts": [
          {
            "raw": "imm[11:5]",
            "clean": "imm"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "imm[4:0]",
            "clean": "imm"
          },
          {
            "raw": "0100011",
            "clean": "0100011"
          }
        ]
      },
      "operands": [
        {
          "name": "rs2",
          "desc": "Source"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "M[R[rs1] + sext(offset)][7:0] = R[rs2][7:0];",
      "example": "SB x5, 0(x10)",
      "example_note": "Store low byte of x5 to address in x10.",
      "slug": "sb",
      "rel_url": "risc-v/sb/",
      "linked_summary": "Stores the lowest 8 bits of a register to memory.",
      "linked_pseudocode": "M[R[rs1] + sext(offset)][7:0] = R[rs2][7:0];"
    },
    {
      "mnemonic": "SH",
      "architecture": "RISC-V",
      "full_name": "Store Halfword",
      "summary": "Stores the lowest 16 bits of a register to memory.",
      "syntax": "SH rs2, offset(rs1)",
      "encoding": {
        "format": "S-Type",
        "binary_pattern": "imm[11:5] | rs2 | rs1 | 001 | imm[4:0] | 0100011",
        "hex_opcode": "0x23",
        "visual_parts": [
          {
            "raw": "imm[11:5]",
            "clean": "imm"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "imm[4:0]",
            "clean": "imm"
          },
          {
            "raw": "0100011",
            "clean": "0100011"
          }
        ]
      },
      "operands": [
        {
          "name": "rs2",
          "desc": "Source"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "M[R[rs1] + sext(offset)][15:0] = R[rs2][15:0];",
      "example": "SH x5, 4(x10)",
      "example_note": "Store halfword.",
      "slug": "sh",
      "rel_url": "risc-v/sh/",
      "linked_summary": "Stores the lowest 16 bits of a register to memory.",
      "linked_pseudocode": "M[R[rs1] + sext(offset)][15:0] = R[rs2][15:0];"
    },
    {
      "mnemonic": "SW",
      "architecture": "RISC-V",
      "full_name": "Store Word",
      "summary": "Stores a 32-bit word to memory.",
      "syntax": "SW rs2, offset(rs1)",
      "encoding": {
        "format": "S-Type",
        "binary_pattern": "imm[11:5] | rs2 | rs1 | 010 | imm[4:0] | 0100011",
        "hex_opcode": "0x23",
        "visual_parts": [
          {
            "raw": "imm[11:5]",
            "clean": "imm"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "imm[4:0]",
            "clean": "imm"
          },
          {
            "raw": "0100011",
            "clean": "0100011"
          }
        ]
      },
      "operands": [
        {
          "name": "rs2",
          "desc": "Source"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "M[R[rs1] + sext(offset)][31:0] = R[rs2][31:0];",
      "example": "SW x5, 8(x10)",
      "example_note": "Store word.",
      "slug": "sw",
      "rel_url": "risc-v/sw/",
      "linked_summary": "Stores a 32-<a href=\"../../armv8-a/bit/\">bit</a> word to memory.",
      "linked_pseudocode": "M[R[rs1] + sext(offset)][31:0] = R[rs2][31:0];"
    },
    {
      "mnemonic": "SD",
      "architecture": "RISC-V",
      "extension": "RV64",
      "full_name": "Store Doubleword",
      "summary": "Stores a 64-bit doubleword to memory.",
      "syntax": "SD rs2, offset(rs1)",
      "encoding": {
        "format": "S-Type",
        "binary_pattern": "imm[11:5] | rs2 | rs1 | 011 | imm[4:0] | 0100011",
        "hex_opcode": "0x23",
        "visual_parts": [
          {
            "raw": "imm[11:5]",
            "clean": "imm"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "imm[4:0]",
            "clean": "imm"
          },
          {
            "raw": "0100011",
            "clean": "0100011"
          }
        ]
      },
      "operands": [
        {
          "name": "rs2",
          "desc": "Source"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        },
        {
          "name": "offset",
          "desc": "Offset"
        }
      ],
      "pseudocode": "M[R[rs1] + sext(offset)][63:0] = R[rs2][63:0];",
      "example": "SD x5, 16(x10)",
      "example_note": "Store 64-bit value.",
      "slug": "sd",
      "rel_url": "risc-v/sd/",
      "linked_summary": "Stores a 64-<a href=\"../../armv8-a/bit/\">bit</a> doubleword to memory.",
      "linked_pseudocode": "M[R[rs1] + sext(offset)][63:0] = R[rs2][63:0];"
    },
    {
      "mnemonic": "SLL",
      "architecture": "RISC-V",
      "full_name": "Shift Left Logical",
      "summary": "Shifts a register left by the number of bits specified in another register.",
      "syntax": "SLL rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000000 | rs2 | rs1 | 001 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0000000",
            "clean": "0000000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        },
        {
          "name": "rs2",
          "desc": "Shift Amount"
        }
      ],
      "pseudocode": "R[rd] = R[rs1] << (R[rs2] & 0x1F);",
      "example": "SLL x10, x11, x12",
      "example_note": "Shift x11 left by x12.",
      "slug": "sll",
      "rel_url": "risc-v/sll/",
      "linked_summary": "Shifts a register left by the number of bits specified <a href=\"../../x86/in/\">in</a> another register.",
      "linked_pseudocode": "R[rd] = R[rs1] << (R[rs2] & 0x1F);"
    },
    {
      "mnemonic": "SLLI",
      "architecture": "RISC-V",
      "full_name": "Shift Left Logical Immediate",
      "summary": "Shifts a register left by a constant amount.",
      "syntax": "SLLI rd, rs1, shamt",
      "encoding": {
        "format": "I-Type (Shift)",
        "binary_pattern": "0000000 | shamt | rs1 | 001 | rd | 0010011",
        "hex_opcode": "0x13",
        "visual_parts": [
          {
            "raw": "0000000",
            "clean": "0000000"
          },
          {
            "raw": "shamt",
            "clean": "shamt"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0010011",
            "clean": "0010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        },
        {
          "name": "shamt",
          "desc": "Shift Amount"
        }
      ],
      "pseudocode": "R[rd] = R[rs1] << shamt;",
      "example": "SLLI x10, x11, 2",
      "example_note": "Multiply x11 by 4.",
      "slug": "slli",
      "rel_url": "risc-v/slli/",
      "linked_summary": "Shifts a register left by a constant amount.",
      "linked_pseudocode": "R[rd] = R[rs1] << shamt;"
    },
    {
      "mnemonic": "SRL",
      "architecture": "RISC-V",
      "full_name": "Shift Right Logical",
      "summary": "Shifts a register right, shifting in zeros.",
      "syntax": "SRL rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000000 | rs2 | rs1 | 101 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0000000",
            "clean": "0000000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "101",
            "clean": "101"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        },
        {
          "name": "rs2",
          "desc": "Shift Amount"
        }
      ],
      "pseudocode": "R[rd] = R[rs1] >> (R[rs2] & 0x1F);",
      "example": "SRL x10, x11, x12",
      "example_note": "Logical right shift.",
      "slug": "srl",
      "rel_url": "risc-v/srl/",
      "linked_summary": "Shifts a register right, shifting <a href=\"../../x86/in/\">in</a> zeros.",
      "linked_pseudocode": "R[rd] = R[rs1] >> (R[rs2] & 0x1F);"
    },
    {
      "mnemonic": "SRA",
      "architecture": "RISC-V",
      "full_name": "Shift Right Arithmetic",
      "summary": "Shifts a register right, preserving the sign bit.",
      "syntax": "SRA rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0100000 | rs2 | rs1 | 101 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0100000",
            "clean": "0100000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "101",
            "clean": "101"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        },
        {
          "name": "rs2",
          "desc": "Shift Amount"
        }
      ],
      "pseudocode": "R[rd] = R[rs1] >>s (R[rs2] & 0x1F);",
      "example": "SRA x10, x11, x12",
      "example_note": "Arithmetic right shift (sign preserved).",
      "slug": "sra",
      "rel_url": "risc-v/sra/",
      "linked_summary": "Shifts a register right, preserving the sign <a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": "R[rd] = R[rs1] >>s (R[rs2] & 0x1F);"
    },
    {
      "mnemonic": "SLT",
      "architecture": "RISC-V",
      "full_name": "Set Less Than",
      "summary": "Sets rd to 1 if rs1 < rs2 (signed), otherwise 0.",
      "syntax": "SLT rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000000 | rs2 | rs1 | 010 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0000000",
            "clean": "0000000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source 1"
        },
        {
          "name": "rs2",
          "desc": "Source 2"
        }
      ],
      "pseudocode": "R[rd] = (R[rs1] <s R[rs2]) ? 1 : 0;",
      "example": "SLT x5, x6, x7",
      "example_note": "Check if x6 < x7.",
      "slug": "slt",
      "rel_url": "risc-v/slt/",
      "linked_summary": "Sets rd to 1 if rs1 < rs2 (signed), otherwise 0.",
      "linked_pseudocode": "R[rd] = (R[rs1] <s R[rs2]) ? 1 : 0;"
    },
    {
      "mnemonic": "SLTI",
      "architecture": "RISC-V",
      "full_name": "Set Less Than Immediate",
      "summary": "Sets rd to 1 if rs1 < immediate (signed), otherwise 0.",
      "syntax": "SLTI rd, rs1, imm",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "imm[11:0] | rs1 | 010 | rd | 0010011",
        "hex_opcode": "0x13",
        "visual_parts": [
          {
            "raw": "imm[11:0]",
            "clean": "imm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0010011",
            "clean": "0010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        },
        {
          "name": "imm",
          "desc": "Immediate"
        }
      ],
      "pseudocode": "R[rd] = (R[rs1] <s sext(imm)) ? 1 : 0;",
      "example": "SLTI x5, x6, 10",
      "example_note": "Check if x6 < 10.",
      "slug": "slti",
      "rel_url": "risc-v/slti/",
      "linked_summary": "Sets rd to 1 if rs1 < immediate (signed), otherwise 0.",
      "linked_pseudocode": "R[rd] = (R[rs1] <s sext(imm)) ? 1 : 0;"
    },
    {
      "mnemonic": "SC.W",
      "architecture": "RISC-V",
      "extension": "A (Atomic)",
      "full_name": "Store Conditional Word",
      "summary": "Conditionally stores a word to memory if the reservation (from LR) is still valid.",
      "syntax": "SC.W rd, rs2, (rs1)",
      "encoding": {
        "format": "R-Type (Atomic)",
        "binary_pattern": "00011 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
        "hex_opcode": "0x2F",
        "visual_parts": [
          {
            "raw": "00011",
            "clean": "00011"
          },
          {
            "raw": "aq",
            "clean": "aq"
          },
          {
            "raw": "rl",
            "clean": "rl"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0101111",
            "clean": "0101111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Success/Fail)"
        },
        {
          "name": "rs2",
          "desc": "Source Value"
        },
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "if (ReservationValid) { M[R[rs1]] = R[rs2]; R[rd] = 0; } else { R[rd] = 1; }",
      "example": "SC.W x10, x11, (x12)",
      "example_note": "Try to store x11 to x12. x10=0 on success.",
      "slug": "sc_w",
      "rel_url": "risc-v/sc_w/",
      "linked_summary": "Conditionally stores a word to memory if the reservation (from LR) is still valid.",
      "linked_pseudocode": "if (ReservationValid) { M[R[rs1]] = R[rs2]; R[rd] = 0; } else { R[rd] = 1; }"
    },
    {
      "mnemonic": "SFENCE.VMA",
      "architecture": "RISC-V",
      "extension": "Privileged",
      "full_name": "Supervisor Fence Virtual Memory",
      "summary": "Synchronizes updates to in-memory address translation data structures (TLB flush).",
      "syntax": "SFENCE.VMA rs1, rs2",
      "encoding": {
        "format": "R-Type (System)",
        "binary_pattern": "0001001 | rs2 | rs1 | 000 | 00000 | 1110011",
        "hex_opcode": "0x73",
        "visual_parts": [
          {
            "raw": "0001001",
            "clean": "0001001"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "1110011",
            "clean": "1110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rs1",
          "desc": "Virtual Address (optional)"
        },
        {
          "name": "rs2",
          "desc": "ASID (optional)"
        }
      ],
      "pseudocode": "Fence(PageTable);",
      "example": "SFENCE.VMA x0, x0",
      "example_note": "Flush all TLB entries.",
      "slug": "sfence_vma",
      "rel_url": "risc-v/sfence_vma/",
      "linked_summary": "Synchronizes updates to <a href=\"../../x86/in/\">in</a>-memory address translation data structures (TLB flush).",
      "linked_pseudocode": "Fence(PageTable);"
    },
    {
      "mnemonic": "SRET",
      "architecture": "RISC-V",
      "extension": "Privileged",
      "full_name": "Supervisor Return",
      "summary": "Returns from a supervisor-mode trap handler.",
      "syntax": "SRET",
      "encoding": {
        "format": "R-Type (System)",
        "binary_pattern": "0001000 | 00010 | 00000 | 000 | 00000 | 1110011",
        "hex_opcode": "0x73",
        "visual_parts": [
          {
            "raw": "0001000",
            "clean": "0001000"
          },
          {
            "raw": "00010",
            "clean": "00010"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "1110011",
            "clean": "1110011"
          }
        ]
      },
      "operands": [],
      "pseudocode": "PC = SEPC; Priv = SPP; SIE = SPIE;",
      "example": "SRET",
      "example_note": "Return from exception/interrupt in supervisor mode.",
      "slug": "sret",
      "rel_url": "risc-v/sret/",
      "linked_summary": "Returns from a supervisor-mode <a href=\"../../powerisa/trap/\">trap</a> handler.",
      "linked_pseudocode": "PC = SEPC; Priv = SPP; SIE = SPIE;"
    },
    {
      "mnemonic": "WFI",
      "architecture": "RISC-V",
      "extension": "Privileged",
      "full_name": "Wait for Interrupt",
      "summary": "Provides a hint to the implementation that the current hart can be stalled until an interrupt occurs.",
      "syntax": "WFI",
      "encoding": {
        "format": "R-Type (System)",
        "binary_pattern": "0001000 | 00101 | 00000 | 000 | 00000 | 1110011",
        "hex_opcode": "0x73",
        "visual_parts": [
          {
            "raw": "0001000",
            "clean": "0001000"
          },
          {
            "raw": "00101",
            "clean": "00101"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "1110011",
            "clean": "1110011"
          }
        ]
      },
      "operands": [],
      "pseudocode": "while(!Interrupt) { /* low power state */ }",
      "example": "WFI",
      "example_note": "Pause execution until interrupt.",
      "slug": "wfi",
      "rel_url": "risc-v/wfi/",
      "linked_summary": "Provides a <a href=\"../../armv8-a/hint/\">hint</a> to the implementation that the current hart can be stalled until an interrupt occurs.",
      "linked_pseudocode": "while(!Interrupt) { /* low power state */ }"
    },
    {
      "mnemonic": "XOR",
      "architecture": "RISC-V",
      "full_name": "Logical XOR",
      "summary": "Performs a bitwise logical Exclusive-OR operation.",
      "syntax": "XOR rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000000 | rs2 | rs1 | 100 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0000000",
            "clean": "0000000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source 1"
        },
        {
          "name": "rs2",
          "desc": "Source 2"
        }
      ],
      "pseudocode": "R[rd] = R[rs1] ^ R[rs2];",
      "example": "XOR x10, x11, x12",
      "example_note": "x10 = x11 ^ x12",
      "slug": "xor",
      "rel_url": "risc-v/xor/",
      "linked_summary": "Performs a bitwise logical Exclusive-<a href=\"../../risc-v/or/\">OR</a> operation.",
      "linked_pseudocode": "R[rd] = R[rs1] ^ R[rs2];"
    },
    {
      "mnemonic": "XORI",
      "architecture": "RISC-V",
      "full_name": "Logical XOR Immediate",
      "summary": "Performs a bitwise logical Exclusive-OR with a sign-extended immediate.",
      "syntax": "XORI rd, rs1, imm",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "imm[11:0] | rs1 | 100 | rd | 0010011",
        "hex_opcode": "0x13",
        "visual_parts": [
          {
            "raw": "imm[11:0]",
            "clean": "imm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0010011",
            "clean": "0010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest"
        },
        {
          "name": "rs1",
          "desc": "Source"
        },
        {
          "name": "imm",
          "desc": "Immediate"
        }
      ],
      "pseudocode": "R[rd] = R[rs1] ^ sext(imm);",
      "example": "XORI x10, x11, -1",
      "example_note": "Bitwise invert (NOT) x11.",
      "slug": "xori",
      "rel_url": "risc-v/xori/",
      "linked_summary": "Performs a bitwise logical Exclusive-<a href=\"../../risc-v/or/\">OR</a> with a sign-extended immediate.",
      "linked_pseudocode": "R[rd] = R[rs1] ^ sext(imm);"
    },
    {
      "mnemonic": "HFENCE.GVMA",
      "architecture": "RISC-V",
      "extension": "H (Hypervisor)",
      "full_name": "Hypervisor Fence Guest Virtual Memory Address",
      "summary": "Synchronizes updates to guest physical address translation data structures.",
      "syntax": "HFENCE.GVMA rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0110001 | rs2 | rs1 | 000 | 00000 | 1110011",
        "hex_opcode": "0x73",
        "visual_parts": [
          {
            "raw": "0110001",
            "clean": "0110001"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "1110011",
            "clean": "1110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rs1",
          "desc": "Guest Virtual Address (optional)"
        },
        {
          "name": "rs2",
          "desc": "Guest ASID (optional)"
        }
      ],
      "pseudocode": "Fence(GuestPageTable);",
      "example": "HFENCE.GVMA x0, x0",
      "example_note": "Flush all guest TLB entries.",
      "slug": "hfence_gvma",
      "rel_url": "risc-v/hfence_gvma/",
      "linked_summary": "Synchronizes updates to guest physical address translation data structures.",
      "linked_pseudocode": "Fence(GuestPageTable);"
    },
    {
      "mnemonic": "HFENCE.VVMA",
      "architecture": "RISC-V",
      "extension": "H (Hypervisor)",
      "full_name": "Hypervisor Fence Virtual Virtual Memory Address",
      "summary": "Synchronizes updates to VS-stage address translation data structures.",
      "syntax": "HFENCE.VVMA rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0010001 | rs2 | rs1 | 000 | 00000 | 1110011",
        "hex_opcode": "0x73",
        "visual_parts": [
          {
            "raw": "0010001",
            "clean": "0010001"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "1110011",
            "clean": "1110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rs1",
          "desc": "Virtual Address (optional)"
        },
        {
          "name": "rs2",
          "desc": "ASID (optional)"
        }
      ],
      "pseudocode": "Fence(VS-StagePageTable);",
      "example": "HFENCE.VVMA x10, x0",
      "example_note": "Flush TLB entries for address in x10.",
      "slug": "hfence_vvma",
      "rel_url": "risc-v/hfence_vvma/",
      "linked_summary": "Synchronizes updates to VS-stage address translation data structures.",
      "linked_pseudocode": "Fence(VS-StagePageTable);"
    },
    {
      "mnemonic": "JAL",
      "architecture": "RISC-V",
      "full_name": "Jump and Link",
      "summary": "Jumps to an offset relative to PC and saves the return address (PC+4) to rd.",
      "syntax": "JAL rd, offset",
      "encoding": {
        "format": "J-Type",
        "binary_pattern": "imm[20|10:1|11|19:12] | rd | 1101111",
        "hex_opcode": "0x6F",
        "visual_parts": [
          {
            "raw": "imm[20",
            "clean": "imm"
          },
          {
            "raw": "10:1",
            "clean": "10:1"
          },
          {
            "raw": "11",
            "clean": "11"
          },
          {
            "raw": "19:12]",
            "clean": "19:12]"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1101111",
            "clean": "1101111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Return Address Dest"
        },
        {
          "name": "offset",
          "desc": "20-bit PC-relative Offset"
        }
      ],
      "pseudocode": "R[rd] = PC + 4; PC += sext(offset);",
      "example": "JAL x1, loop_target",
      "example_note": "Jump to 'loop_target' and save return address in x1 (ra).",
      "slug": "jal",
      "rel_url": "risc-v/jal/",
      "linked_summary": "Jumps to an offset relative to PC <a href=\"../../armv8-a/and_6/\">and</a> saves the return address (PC+4) to rd.",
      "linked_pseudocode": "R[rd] = PC + 4; PC += sext(offset);"
    },
    {
      "mnemonic": "JALR",
      "architecture": "RISC-V",
      "full_name": "Jump and Link Register",
      "summary": "Jumps to address in rs1 + offset, saving return address to rd.",
      "syntax": "JALR rd, offset(rs1)",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "imm[11:0] | rs1 | 000 | rd | 1100111",
        "hex_opcode": "0x67",
        "visual_parts": [
          {
            "raw": "imm[11:0]",
            "clean": "imm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "1100111",
            "clean": "1100111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Return Address Dest"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        },
        {
          "name": "offset",
          "desc": "12-bit Immediate"
        }
      ],
      "pseudocode": "t = PC + 4; PC = (R[rs1] + sext(offset)) & ~1; R[rd] = t;",
      "example": "JALR x0, 0(x1)",
      "example_note": "Return from function (jumps to address in x1/ra).",
      "slug": "jalr",
      "rel_url": "risc-v/jalr/",
      "linked_summary": "Jumps to address <a href=\"../../x86/in/\">in</a> rs1 + offset, saving return address to rd.",
      "linked_pseudocode": "t = PC + 4; PC = (R[rs1] + sext(offset)) & ~1; R[rd] = t;"
    },
    {
      "mnemonic": "LB",
      "architecture": "RISC-V",
      "full_name": "Load Byte",
      "summary": "Loads an 8-bit byte from memory and sign-extends it to the register width.",
      "syntax": "LB rd, offset(rs1)",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "imm[11:0] | rs1 | 000 | rd | 0000011",
        "hex_opcode": "0x03",
        "visual_parts": [
          {
            "raw": "imm[11:0]",
            "clean": "imm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0000011",
            "clean": "0000011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Destination Register"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        },
        {
          "name": "offset",
          "desc": "Byte Offset"
        }
      ],
      "pseudocode": "R[rd] = sext(M[R[rs1] + sext(offset)][7:0]);",
      "example": "LB x10, 0(x2)",
      "example_note": "Load byte from stack pointer (x2) into x10.",
      "slug": "lb",
      "rel_url": "risc-v/lb/",
      "linked_summary": "Loads an 8-<a href=\"../../armv8-a/bit/\">bit</a> byte from memory <a href=\"../../armv8-a/and_6/\">and</a> sign-extends <a href=\"../../armv8-a/it/\">it</a> to the register width.",
      "linked_pseudocode": "R[rd] = sext(M[R[rs1] + sext(offset)][7:0]);"
    },
    {
      "mnemonic": "LH",
      "architecture": "RISC-V",
      "full_name": "Load Halfword",
      "summary": "Loads a 16-bit halfword from memory and sign-extends it.",
      "syntax": "LH rd, offset(rs1)",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "imm[11:0] | rs1 | 001 | rd | 0000011",
        "hex_opcode": "0x03",
        "visual_parts": [
          {
            "raw": "imm[11:0]",
            "clean": "imm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "001",
            "clean": "001"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0000011",
            "clean": "0000011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Destination Register"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        },
        {
          "name": "offset",
          "desc": "Byte Offset"
        }
      ],
      "pseudocode": "R[rd] = sext(M[R[rs1] + sext(offset)][15:0]);",
      "example": "LH x5, 4(x10)",
      "example_note": "Load halfword from address x10+4.",
      "slug": "lh",
      "rel_url": "risc-v/lh/",
      "linked_summary": "Loads a 16-<a href=\"../../armv8-a/bit/\">bit</a> halfword from memory <a href=\"../../armv8-a/and_6/\">and</a> sign-extends <a href=\"../../armv8-a/it/\">it</a>.",
      "linked_pseudocode": "R[rd] = sext(M[R[rs1] + sext(offset)][15:0]);"
    },
    {
      "mnemonic": "LW",
      "architecture": "RISC-V",
      "full_name": "Load Word",
      "summary": "Loads a 32-bit word from memory and sign-extends it to 64 bits.",
      "syntax": "LW rd, offset(rs1)",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "imm[11:0] | rs1 | 010 | rd | 0000011",
        "hex_opcode": "0x03",
        "visual_parts": [
          {
            "raw": "imm[11:0]",
            "clean": "imm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0000011",
            "clean": "0000011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Destination Register"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        },
        {
          "name": "offset",
          "desc": "Byte Offset"
        }
      ],
      "pseudocode": "R[rd] = sext(M[R[rs1] + sext(offset)][31:0]);",
      "example": "LW x6, 12(x2)",
      "example_note": "Load 32-bit word from stack offset 12.",
      "slug": "lw",
      "rel_url": "risc-v/lw/",
      "linked_summary": "Loads a 32-<a href=\"../../armv8-a/bit/\">bit</a> word from memory <a href=\"../../armv8-a/and_6/\">and</a> sign-extends <a href=\"../../armv8-a/it/\">it</a> to 64 bits.",
      "linked_pseudocode": "R[rd] = sext(M[R[rs1] + sext(offset)][31:0]);"
    },
    {
      "mnemonic": "LBU",
      "architecture": "RISC-V",
      "full_name": "Load Byte Unsigned",
      "summary": "Loads an 8-bit byte from memory and zero-extends it.",
      "syntax": "LBU rd, offset(rs1)",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "imm[11:0] | rs1 | 100 | rd | 0000011",
        "hex_opcode": "0x03",
        "visual_parts": [
          {
            "raw": "imm[11:0]",
            "clean": "imm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "100",
            "clean": "100"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0000011",
            "clean": "0000011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Destination Register"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        },
        {
          "name": "offset",
          "desc": "Byte Offset"
        }
      ],
      "pseudocode": "R[rd] = zext(M[R[rs1] + sext(offset)][7:0]);",
      "example": "LBU x10, 0(x2)",
      "example_note": "Load byte and zero-extend.",
      "slug": "lbu",
      "rel_url": "risc-v/lbu/",
      "linked_summary": "Loads an 8-<a href=\"../../armv8-a/bit/\">bit</a> byte from memory <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../armv9-a/zero_1/\">zero</a>-extends <a href=\"../../armv8-a/it/\">it</a>.",
      "linked_pseudocode": "R[rd] = zext(M[R[rs1] + sext(offset)][7:0]);"
    },
    {
      "mnemonic": "LHU",
      "architecture": "RISC-V",
      "full_name": "Load Halfword Unsigned",
      "summary": "Loads a 16-bit halfword from memory and zero-extends it.",
      "syntax": "LHU rd, offset(rs1)",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "imm[11:0] | rs1 | 101 | rd | 0000011",
        "hex_opcode": "0x03",
        "visual_parts": [
          {
            "raw": "imm[11:0]",
            "clean": "imm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "101",
            "clean": "101"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0000011",
            "clean": "0000011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Destination Register"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        },
        {
          "name": "offset",
          "desc": "Byte Offset"
        }
      ],
      "pseudocode": "R[rd] = zext(M[R[rs1] + sext(offset)][15:0]);",
      "example": "LHU x5, 4(x10)",
      "example_note": "Load halfword and zero-extend.",
      "slug": "lhu",
      "rel_url": "risc-v/lhu/",
      "linked_summary": "Loads a 16-<a href=\"../../armv8-a/bit/\">bit</a> halfword from memory <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../armv9-a/zero_1/\">zero</a>-extends <a href=\"../../armv8-a/it/\">it</a>.",
      "linked_pseudocode": "R[rd] = zext(M[R[rs1] + sext(offset)][15:0]);"
    },
    {
      "mnemonic": "LD",
      "architecture": "RISC-V",
      "extension": "RV64",
      "full_name": "Load Doubleword",
      "summary": "Loads a 64-bit doubleword from memory.",
      "syntax": "LD rd, offset(rs1)",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "imm[11:0] | rs1 | 011 | rd | 0000011",
        "hex_opcode": "0x03",
        "visual_parts": [
          {
            "raw": "imm[11:0]",
            "clean": "imm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0000011",
            "clean": "0000011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Destination Register"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        },
        {
          "name": "offset",
          "desc": "Byte Offset"
        }
      ],
      "pseudocode": "R[rd] = M[R[rs1] + sext(offset)][63:0];",
      "example": "LD x1, 0(x2)",
      "example_note": "Load 64-bit value from stack.",
      "slug": "ld",
      "rel_url": "risc-v/ld/",
      "linked_summary": "Loads a 64-<a href=\"../../armv8-a/bit/\">bit</a> doubleword from memory.",
      "linked_pseudocode": "R[rd] = M[R[rs1] + sext(offset)][63:0];"
    },
    {
      "mnemonic": "LWU",
      "architecture": "RISC-V",
      "extension": "RV64",
      "full_name": "Load Word Unsigned",
      "summary": "Loads a 32-bit word from memory and zero-extends it to 64 bits.",
      "syntax": "LWU rd, offset(rs1)",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "imm[11:0] | rs1 | 110 | rd | 0000011",
        "hex_opcode": "0x03",
        "visual_parts": [
          {
            "raw": "imm[11:0]",
            "clean": "imm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "110",
            "clean": "110"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0000011",
            "clean": "0000011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Destination Register"
        },
        {
          "name": "rs1",
          "desc": "Base Address"
        },
        {
          "name": "offset",
          "desc": "Byte Offset"
        }
      ],
      "pseudocode": "R[rd] = zext(M[R[rs1] + sext(offset)][31:0]);",
      "example": "LWU x6, 12(x2)",
      "example_note": "Load 32-bit word and zero-extend to 64-bit.",
      "slug": "lwu",
      "rel_url": "risc-v/lwu/",
      "linked_summary": "Loads a 32-<a href=\"../../armv8-a/bit/\">bit</a> word from memory <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../armv9-a/zero_1/\">zero</a>-extends <a href=\"../../armv8-a/it/\">it</a> to 64 bits.",
      "linked_pseudocode": "R[rd] = zext(M[R[rs1] + sext(offset)][31:0]);"
    },
    {
      "mnemonic": "LUI",
      "architecture": "RISC-V",
      "full_name": "Load Upper Immediate",
      "summary": "Loads the 20-bit immediate into the upper 20 bits of the register (lower 12 bits are zero).",
      "syntax": "LUI rd, imm",
      "encoding": {
        "format": "U-Type",
        "binary_pattern": "imm[31:12] | rd | 0110111",
        "hex_opcode": "0x37",
        "visual_parts": [
          {
            "raw": "imm[31:12]",
            "clean": "imm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110111",
            "clean": "0110111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Destination Register"
        },
        {
          "name": "imm",
          "desc": "20-bit Upper Immediate"
        }
      ],
      "pseudocode": "R[rd] = imm << 12;",
      "example": "LUI x10, 0x12345",
      "example_note": "Puts 0x12345000 into x10.",
      "slug": "lui",
      "rel_url": "risc-v/lui/",
      "linked_summary": "Loads the 20-<a href=\"../../armv8-a/bit/\">bit</a> immediate into the upper 20 bits of the register (lower 12 bits are <a href=\"../../armv9-a/zero_1/\">zero</a>).",
      "linked_pseudocode": "R[rd] = imm << 12;"
    },
    {
      "mnemonic": "LR.W",
      "architecture": "RISC-V",
      "extension": "A (Atomic)",
      "full_name": "Load Reserved Word",
      "summary": "Loads a word from memory and registers a reservation set for the address.",
      "syntax": "LR.W rd, (rs1)",
      "encoding": {
        "format": "R-Type (Atomic)",
        "binary_pattern": "00010 | aq | rl | 00000 | rs1 | 010 | rd | 0101111",
        "hex_opcode": "0x2F",
        "visual_parts": [
          {
            "raw": "00010",
            "clean": "00010"
          },
          {
            "raw": "aq",
            "clean": "aq"
          },
          {
            "raw": "rl",
            "clean": "rl"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0101111",
            "clean": "0101111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Destination Register"
        },
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "R[rd] = LoadReserved32(M[R[rs1]]);",
      "example": "LR.W x10, (x11)",
      "example_note": "Start atomic read-modify-write sequence.",
      "slug": "lr_w",
      "rel_url": "risc-v/lr_w/",
      "linked_summary": "Loads a word from memory <a href=\"../../armv8-a/and_6/\">and</a> registers a reservation set for the address.",
      "linked_pseudocode": "R[rd] = LoadReserved32(M[R[rs1]]);"
    },
    {
      "mnemonic": "LR.D",
      "architecture": "RISC-V",
      "extension": "A (Atomic)",
      "full_name": "Load Reserved Doubleword",
      "summary": "Loads a doubleword from memory and registers a reservation set.",
      "syntax": "LR.D rd, (rs1)",
      "encoding": {
        "format": "R-Type (Atomic)",
        "binary_pattern": "00010 | aq | rl | 00000 | rs1 | 011 | rd | 0101111",
        "hex_opcode": "0x2F",
        "visual_parts": [
          {
            "raw": "00010",
            "clean": "00010"
          },
          {
            "raw": "aq",
            "clean": "aq"
          },
          {
            "raw": "rl",
            "clean": "rl"
          },
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0101111",
            "clean": "0101111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Destination Register"
        },
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "R[rd] = LoadReserved64(M[R[rs1]]);",
      "example": "LR.D x10, (x11)",
      "example_note": "64-bit atomic load reserved.",
      "slug": "lr_d",
      "rel_url": "risc-v/lr_d/",
      "linked_summary": "Loads a doubleword from memory <a href=\"../../armv8-a/and_6/\">and</a> registers a reservation set.",
      "linked_pseudocode": "R[rd] = LoadReserved64(M[R[rs1]]);"
    },
    {
      "mnemonic": "VMSGT.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Mask Set Greater Than (Signed)",
      "summary": "Sets mask if vs2 > vs1.",
      "syntax": "VMSGT.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "011111 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "011111",
            "clean": "011111"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Mask"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "vd = (vs2 > vs1);",
      "slug": "vmsgt_vv",
      "rel_url": "risc-v/vmsgt_vv/",
      "linked_summary": "Sets mask if vs2 > vs1.",
      "linked_pseudocode": "vd = (vs2 > vs1);"
    },
    {
      "mnemonic": "VMSGTU.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Mask Set Greater Than (Unsigned)",
      "summary": "Sets mask if vs2 > vs1 (Unsigned).",
      "syntax": "VMSGTU.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "011111 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "011111",
            "clean": "011111"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Mask"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "vd = (vs2 >u vs1);",
      "slug": "vmsgtu_vv",
      "rel_url": "risc-v/vmsgtu_vv/",
      "linked_summary": "Sets mask if vs2 > vs1 (Unsigned).",
      "linked_pseudocode": "vd = (vs2 >u vs1);"
    },
    {
      "mnemonic": "VMSLE.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Mask Set Less or Equal (Signed)",
      "summary": "Sets mask if vs2 <= vs1.",
      "syntax": "VMSLE.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "011101 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "011101",
            "clean": "011101"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Mask"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "vd = (vs2 <= vs1);",
      "slug": "vmsle_vv",
      "rel_url": "risc-v/vmsle_vv/",
      "linked_summary": "Sets mask if vs2 <= vs1.",
      "linked_pseudocode": "vd = (vs2 <= vs1);"
    },
    {
      "mnemonic": "VMSLEU.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Mask Set Less or Equal (Unsigned)",
      "summary": "Sets mask if vs2 <= vs1 (Unsigned).",
      "syntax": "VMSLEU.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "011101 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "011101",
            "clean": "011101"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Mask"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "vd = (vs2 <=u vs1);",
      "slug": "vmsleu_vv",
      "rel_url": "risc-v/vmsleu_vv/",
      "linked_summary": "Sets mask if vs2 <= vs1 (Unsigned).",
      "linked_pseudocode": "vd = (vs2 <=u vs1);"
    },
    {
      "mnemonic": "VMSGE.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Mask Set Greater or Equal (Signed)",
      "summary": "Sets mask if vs2 >= vs1.",
      "syntax": "VMSGE.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "011111 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "011111",
            "clean": "011111"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Mask"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "vd = (vs2 >= vs1);",
      "slug": "vmsge_vv",
      "rel_url": "risc-v/vmsge_vv/",
      "linked_summary": "Sets mask if vs2 >= vs1.",
      "linked_pseudocode": "vd = (vs2 >= vs1);"
    },
    {
      "mnemonic": "VMSGEU.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Mask Set Greater or Equal (Unsigned)",
      "summary": "Sets mask if vs2 >= vs1 (Unsigned).",
      "syntax": "VMSGEU.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "011111 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "011111",
            "clean": "011111"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Mask"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "vd = (vs2 >=u vs1);",
      "slug": "vmsgeu_vv",
      "rel_url": "risc-v/vmsgeu_vv/",
      "linked_summary": "Sets mask if vs2 >= vs1 (Unsigned).",
      "linked_pseudocode": "vd = (vs2 >=u vs1);"
    },
    {
      "mnemonic": "VMADC.VIM",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Mask Add with Carry Immediate",
      "summary": "Add Immediate with Carry.",
      "syntax": "VMADC.VIM vd, vs2, imm, v0",
      "encoding": {
        "format": "OPIVI",
        "binary_pattern": "010001 | 0 | vs2 | imm | 011 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010001",
            "clean": "010001"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Carry Out"
        },
        {
          "name": "vs2",
          "desc": "Src"
        },
        {
          "name": "imm",
          "desc": "Imm"
        }
      ],
      "pseudocode": "vd = carry(vs2 + imm + v0);",
      "slug": "vmadc_vim",
      "rel_url": "risc-v/vmadc_vim/",
      "linked_summary": "Add Immediate with Carry.",
      "linked_pseudocode": "vd = carry(vs2 + imm + v0);"
    },
    {
      "mnemonic": "VWMACCSU.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Widening MAC (Signed * Unsigned)",
      "summary": "vd = vd + (signed(vs1) * unsigned(vs2)).",
      "syntax": "VWMACCSU.VV vd, vs1, vs2, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "111111 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "111111",
            "clean": "111111"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Acc"
        },
        {
          "name": "vs1",
          "desc": "Signed"
        },
        {
          "name": "vs2",
          "desc": "Unsigned"
        }
      ],
      "pseudocode": "vd += sext(vs1) * zext(vs2);",
      "slug": "vwmaccsu_vv",
      "rel_url": "risc-v/vwmaccsu_vv/",
      "linked_summary": "vd = vd + (signed(vs1) * unsigned(vs2)).",
      "linked_pseudocode": "vd += sext(vs1) * zext(vs2);"
    },
    {
      "mnemonic": "VWMACCUS.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Widening MAC (Unsigned * Signed)",
      "summary": "vd = vd + (unsigned(vs1) * signed(vs2)).",
      "syntax": "VWMACCUS.VV vd, vs1, vs2, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "111110 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "111110",
            "clean": "111110"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Acc"
        },
        {
          "name": "vs1",
          "desc": "Unsigned"
        },
        {
          "name": "vs2",
          "desc": "Signed"
        }
      ],
      "pseudocode": "vd += zext(vs1) * sext(vs2);",
      "slug": "vwmaccus_vv",
      "rel_url": "risc-v/vwmaccus_vv/",
      "linked_summary": "vd = vd + (unsigned(vs1) * signed(vs2)).",
      "linked_pseudocode": "vd += zext(vs1) * sext(vs2);"
    },
    {
      "mnemonic": "VADC.VVM",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Add with Carry",
      "summary": "Computes vd = vs1 + vs2 + carry (v0).",
      "syntax": "VADC.VVM vd, vs2, vs1, v0",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "010000 | 0 | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "010000",
            "clean": "010000"
          },
          {
            "raw": "0",
            "clean": "0"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "vs1",
            "clean": "vs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src 2"
        },
        {
          "name": "vs1",
          "desc": "Src 1"
        }
      ],
      "pseudocode": "vd = vs1 + vs2 + v0;",
      "slug": "vadc_vvm",
      "rel_url": "risc-v/vadc_vvm/",
      "linked_summary": "Computes vd = vs1 + vs2 + carry (v0).",
      "linked_pseudocode": "vd = vs1 + vs2 + v0;"
    },
    {
      "mnemonic": "VADD.VI",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Add Immediate",
      "summary": "Adds immediate to vector.",
      "syntax": "VADD.VI vd, vs2, imm, vm",
      "encoding": {
        "format": "OPIVI",
        "binary_pattern": "000000 | vm | vs2 | imm | 011 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "000000",
            "clean": "000000"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src"
        },
        {
          "name": "imm",
          "desc": "Imm"
        }
      ],
      "pseudocode": "vd = vs2 + imm;",
      "slug": "vadd_vi",
      "rel_url": "risc-v/vadd_vi/",
      "linked_summary": "Adds immediate to vector.",
      "linked_pseudocode": "vd = vs2 + imm;"
    },
    {
      "mnemonic": "VRSUB.VI",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Reverse Subtract Immediate",
      "summary": "Computes vd = imm - vs2.",
      "syntax": "VRSUB.VI vd, vs2, imm, vm",
      "encoding": {
        "format": "OPIVI",
        "binary_pattern": "000011 | vm | vs2 | imm | 011 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "000011",
            "clean": "000011"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src"
        },
        {
          "name": "imm",
          "desc": "Imm"
        }
      ],
      "pseudocode": "vd = imm - vs2;",
      "slug": "vrsub_vi",
      "rel_url": "risc-v/vrsub_vi/",
      "linked_summary": "Computes vd = imm - vs2.",
      "linked_pseudocode": "vd = imm - vs2;"
    },
    {
      "mnemonic": "VAND.VI",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector AND Immediate",
      "summary": "Bitwise AND with immediate.",
      "syntax": "VAND.VI vd, vs2, imm, vm",
      "encoding": {
        "format": "OPIVI",
        "binary_pattern": "001001 | vm | vs2 | imm | 011 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "001001",
            "clean": "001001"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src"
        },
        {
          "name": "imm",
          "desc": "Imm"
        }
      ],
      "pseudocode": "vd = vs2 & imm;",
      "slug": "vand_vi",
      "rel_url": "risc-v/vand_vi/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/and/\">AND</a> with immediate.",
      "linked_pseudocode": "vd = vs2 & imm;"
    },
    {
      "mnemonic": "VOR.VI",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector OR Immediate",
      "summary": "Bitwise OR with immediate.",
      "syntax": "VOR.VI vd, vs2, imm, vm",
      "encoding": {
        "format": "OPIVI",
        "binary_pattern": "001010 | vm | vs2 | imm | 011 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "001010",
            "clean": "001010"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src"
        },
        {
          "name": "imm",
          "desc": "Imm"
        }
      ],
      "pseudocode": "vd = vs2 | imm;",
      "slug": "vor_vi",
      "rel_url": "risc-v/vor_vi/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/or/\">OR</a> with immediate.",
      "linked_pseudocode": "vd = vs2 | imm;"
    },
    {
      "mnemonic": "VXOR.VI",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector XOR Immediate",
      "summary": "Bitwise XOR with immediate.",
      "syntax": "VXOR.VI vd, vs2, imm, vm",
      "encoding": {
        "format": "OPIVI",
        "binary_pattern": "001011 | vm | vs2 | imm | 011 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "001011",
            "clean": "001011"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src"
        },
        {
          "name": "imm",
          "desc": "Imm"
        }
      ],
      "pseudocode": "vd = vs2 ^ imm;",
      "slug": "vxor_vi",
      "rel_url": "risc-v/vxor_vi/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/xor/\">XOR</a> with immediate.",
      "linked_pseudocode": "vd = vs2 ^ imm;"
    },
    {
      "mnemonic": "VRGATHER.VI",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Register Gather Immediate",
      "summary": "Gathers element at index 'imm' from vs2 (splat).",
      "syntax": "VRGATHER.VI vd, vs2, imm, vm",
      "encoding": {
        "format": "OPIVI",
        "binary_pattern": "001100 | vm | vs2 | imm | 011 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "001100",
            "clean": "001100"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Table"
        },
        {
          "name": "imm",
          "desc": "Index"
        }
      ],
      "pseudocode": "vd[*] = vs2[imm];",
      "slug": "vrgather_vi",
      "rel_url": "risc-v/vrgather_vi/",
      "linked_summary": "Gathers element <a href=\"../../armv8-a/at_2/\">at</a> <a href=\"../../armv8-a/index/\">index</a> 'imm' from vs2 (splat).",
      "linked_pseudocode": "vd[*] = vs2[imm];"
    },
    {
      "mnemonic": "VSLIDEUP.VI",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Slide Up Immediate",
      "summary": "Moves elements up by immediate amount.",
      "syntax": "VSLIDEUP.VI vd, vs2, imm, vm",
      "encoding": {
        "format": "OPIVI",
        "binary_pattern": "001110 | vm | vs2 | imm | 011 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "001110",
            "clean": "001110"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src"
        },
        {
          "name": "imm",
          "desc": "Shift"
        }
      ],
      "pseudocode": "vd[i] = vs2[i - imm];",
      "slug": "vslideup_vi",
      "rel_url": "risc-v/vslideup_vi/",
      "linked_summary": "Moves elements up by immediate amount.",
      "linked_pseudocode": "vd[i] = vs2[i - imm];"
    },
    {
      "mnemonic": "VSLIDEDOWN.VI",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Slide Down Immediate",
      "summary": "Moves elements down by immediate amount.",
      "syntax": "VSLIDEDOWN.VI vd, vs2, imm, vm",
      "encoding": {
        "format": "OPIVI",
        "binary_pattern": "001111 | vm | vs2 | imm | 011 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "001111",
            "clean": "001111"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src"
        },
        {
          "name": "imm",
          "desc": "Shift"
        }
      ],
      "pseudocode": "vd[i] = vs2[i + imm];",
      "slug": "vslidedown_vi",
      "rel_url": "risc-v/vslidedown_vi/",
      "linked_summary": "Moves elements down by immediate amount.",
      "linked_pseudocode": "vd[i] = vs2[i + imm];"
    },
    {
      "mnemonic": "VMSEQ.VI",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Mask Set Equal Immediate",
      "summary": "Sets mask if element == imm.",
      "syntax": "VMSEQ.VI vd, vs2, imm, vm",
      "encoding": {
        "format": "OPIVI",
        "binary_pattern": "011000 | vm | vs2 | imm | 011 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "011000",
            "clean": "011000"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Mask"
        },
        {
          "name": "vs2",
          "desc": "Src"
        },
        {
          "name": "imm",
          "desc": "Val"
        }
      ],
      "pseudocode": "vd = (vs2 == imm);",
      "slug": "vmseq_vi",
      "rel_url": "risc-v/vmseq_vi/",
      "linked_summary": "Sets mask if element == imm.",
      "linked_pseudocode": "vd = (vs2 == imm);"
    },
    {
      "mnemonic": "VMSNE.VI",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Mask Set Not Equal Immediate",
      "summary": "Sets mask if element != imm.",
      "syntax": "VMSNE.VI vd, vs2, imm, vm",
      "encoding": {
        "format": "OPIVI",
        "binary_pattern": "011001 | vm | vs2 | imm | 011 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "011001",
            "clean": "011001"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Mask"
        },
        {
          "name": "vs2",
          "desc": "Src"
        },
        {
          "name": "imm",
          "desc": "Val"
        }
      ],
      "pseudocode": "vd = (vs2 != imm);",
      "slug": "vmsne_vi",
      "rel_url": "risc-v/vmsne_vi/",
      "linked_summary": "Sets mask if element != imm.",
      "linked_pseudocode": "vd = (vs2 != imm);"
    },
    {
      "mnemonic": "VMSLE.VI",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Mask Set Less or Equal Immediate",
      "summary": "Sets mask if element <= imm (Signed).",
      "syntax": "VMSLE.VI vd, vs2, imm, vm",
      "encoding": {
        "format": "OPIVI",
        "binary_pattern": "011101 | vm | vs2 | imm | 011 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "011101",
            "clean": "011101"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Mask"
        },
        {
          "name": "vs2",
          "desc": "Src"
        },
        {
          "name": "imm",
          "desc": "Val"
        }
      ],
      "pseudocode": "vd = (vs2 <= imm);",
      "slug": "vmsle_vi",
      "rel_url": "risc-v/vmsle_vi/",
      "linked_summary": "Sets mask if element <= imm (Signed).",
      "linked_pseudocode": "vd = (vs2 <= imm);"
    },
    {
      "mnemonic": "VMSLEU.VI",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Mask Set Less or Equal Unsigned Immediate",
      "summary": "Sets mask if element <= imm (Unsigned).",
      "syntax": "VMSLEU.VI vd, vs2, imm, vm",
      "encoding": {
        "format": "OPIVI",
        "binary_pattern": "011100 | vm | vs2 | imm | 011 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "011100",
            "clean": "011100"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Mask"
        },
        {
          "name": "vs2",
          "desc": "Src"
        },
        {
          "name": "imm",
          "desc": "Val"
        }
      ],
      "pseudocode": "vd = (vs2 <=u imm);",
      "slug": "vmsleu_vi",
      "rel_url": "risc-v/vmsleu_vi/",
      "linked_summary": "Sets mask if element <= imm (Unsigned).",
      "linked_pseudocode": "vd = (vs2 <=u imm);"
    },
    {
      "mnemonic": "VMSLT.VI",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Mask Set Less Than Immediate",
      "summary": "Sets mask if element < imm (Signed).",
      "syntax": "VMSLT.VI vd, vs2, imm, vm",
      "encoding": {
        "format": "OPIVI",
        "binary_pattern": "011011 | vm | vs2 | imm | 011 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "011011",
            "clean": "011011"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Mask"
        },
        {
          "name": "vs2",
          "desc": "Src"
        },
        {
          "name": "imm",
          "desc": "Val"
        }
      ],
      "pseudocode": "vd = (vs2 < imm);",
      "slug": "vmslt_vi",
      "rel_url": "risc-v/vmslt_vi/",
      "linked_summary": "Sets mask if element < imm (Signed).",
      "linked_pseudocode": "vd = (vs2 < imm);"
    },
    {
      "mnemonic": "VMSLTU.VI",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Mask Set Less Than Unsigned Immediate",
      "summary": "Sets mask if element < imm (Unsigned).",
      "syntax": "VMSLTU.VI vd, vs2, imm, vm",
      "encoding": {
        "format": "OPIVI",
        "binary_pattern": "011010 | vm | vs2 | imm | 011 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "011010",
            "clean": "011010"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Mask"
        },
        {
          "name": "vs2",
          "desc": "Src"
        },
        {
          "name": "imm",
          "desc": "Val"
        }
      ],
      "pseudocode": "vd = (vs2 <u imm);",
      "slug": "vmsltu_vi",
      "rel_url": "risc-v/vmsltu_vi/",
      "linked_summary": "Sets mask if element < imm (Unsigned).",
      "linked_pseudocode": "vd = (vs2 <u imm);"
    },
    {
      "mnemonic": "VSLL.VI",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Shift Left Logical Immediate",
      "summary": "Shifts elements left by immediate.",
      "syntax": "VSLL.VI vd, vs2, imm, vm",
      "encoding": {
        "format": "OPIVI",
        "binary_pattern": "100101 | vm | vs2 | imm | 011 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "100101",
            "clean": "100101"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src"
        },
        {
          "name": "imm",
          "desc": "Shift"
        }
      ],
      "pseudocode": "vd = vs2 << imm;",
      "slug": "vsll_vi",
      "rel_url": "risc-v/vsll_vi/",
      "linked_summary": "Shifts elements left by immediate.",
      "linked_pseudocode": "vd = vs2 << imm;"
    },
    {
      "mnemonic": "VSRL.VI",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Shift Right Logical Immediate",
      "summary": "Shifts elements right (logical) by immediate.",
      "syntax": "VSRL.VI vd, vs2, imm, vm",
      "encoding": {
        "format": "OPIVI",
        "binary_pattern": "101000 | vm | vs2 | imm | 011 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "101000",
            "clean": "101000"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src"
        },
        {
          "name": "imm",
          "desc": "Shift"
        }
      ],
      "pseudocode": "vd = vs2 >>u imm;",
      "slug": "vsrl_vi",
      "rel_url": "risc-v/vsrl_vi/",
      "linked_summary": "Shifts elements right (logical) by immediate.",
      "linked_pseudocode": "vd = vs2 >>u imm;"
    },
    {
      "mnemonic": "VSRA.VI",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Shift Right Arithmetic Immediate",
      "summary": "Shifts elements right (arithmetic) by immediate.",
      "syntax": "VSRA.VI vd, vs2, imm, vm",
      "encoding": {
        "format": "OPIVI",
        "binary_pattern": "101001 | vm | vs2 | imm | 011 | vd | 1010111",
        "hex_opcode": "0x57",
        "visual_parts": [
          {
            "raw": "101001",
            "clean": "101001"
          },
          {
            "raw": "vm",
            "clean": "vm"
          },
          {
            "raw": "vs2",
            "clean": "vs2"
          },
          {
            "raw": "imm",
            "clean": "imm"
          },
          {
            "raw": "011",
            "clean": "011"
          },
          {
            "raw": "vd",
            "clean": "vd"
          },
          {
            "raw": "1010111",
            "clean": "1010111"
          }
        ]
      },
      "operands": [
        {
          "name": "vd",
          "desc": "Dest"
        },
        {
          "name": "vs2",
          "desc": "Src"
        },
        {
          "name": "imm",
          "desc": "Shift"
        }
      ],
      "pseudocode": "vd = vs2 >>s imm;",
      "slug": "vsra_vi",
      "rel_url": "risc-v/vsra_vi/",
      "linked_summary": "Shifts elements right (arithmetic) by immediate.",
      "linked_pseudocode": "vd = vs2 >>s imm;"
    },
    {
      "mnemonic": "ADD",
      "architecture": "RISC-V",
      "full_name": "Add",
      "summary": "Adds the contents of two registers.",
      "syntax": "ADD rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000000 | rs2 | rs1 | 000 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0000000",
            "clean": "0000000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Destination Register"
        },
        {
          "name": "rs1",
          "desc": "Source Register 1"
        },
        {
          "name": "rs2",
          "desc": "Source Register 2"
        }
      ],
      "pseudocode": "R[rd] = R[rs1] + R[rs2];",
      "example": "ADD x10, x11, x12",
      "example_note": "Computes x11 + x12 and stores the result in x10.",
      "slug": "add",
      "rel_url": "risc-v/add/",
      "linked_summary": "Adds the contents of two registers.",
      "linked_pseudocode": "R[rd] = R[rs1] + R[rs2];"
    },
    {
      "mnemonic": "ADDI",
      "architecture": "RISC-V",
      "full_name": "Add Immediate",
      "summary": "Adds a register and a sign-extended 12-bit immediate value.",
      "syntax": "ADDI rd, rs1, imm",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "imm[11:0] | rs1 | 000 | rd | 0010011",
        "hex_opcode": "0x13",
        "visual_parts": [
          {
            "raw": "imm[11:0]",
            "clean": "imm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0010011",
            "clean": "0010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Destination Register"
        },
        {
          "name": "rs1",
          "desc": "Source Register"
        },
        {
          "name": "imm",
          "desc": "12-bit Signed Immediate"
        }
      ],
      "pseudocode": "R[rd] = R[rs1] + sext(imm);",
      "example": "ADDI x5, x6, 10",
      "example_note": "Adds 10 to the value in x6 and stores it in x5.",
      "slug": "addi",
      "rel_url": "risc-v/addi/",
      "linked_summary": "Adds a register <a href=\"../../armv8-a/and_6/\">and</a> a sign-extended 12-<a href=\"../../armv8-a/bit/\">bit</a> immediate value.",
      "linked_pseudocode": "R[rd] = R[rs1] + sext(imm);"
    },
    {
      "mnemonic": "ADDW",
      "architecture": "RISC-V",
      "extension": "RV64",
      "full_name": "Add Word",
      "summary": "Adds two 32-bit registers and sign-extends the result to 64 bits.",
      "syntax": "ADDW rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000000 | rs2 | rs1 | 000 | rd | 0111011",
        "hex_opcode": "0x3B",
        "visual_parts": [
          {
            "raw": "0000000",
            "clean": "0000000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0111011",
            "clean": "0111011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Destination Register"
        },
        {
          "name": "rs1",
          "desc": "Source Register 1"
        },
        {
          "name": "rs2",
          "desc": "Source Register 2"
        }
      ],
      "pseudocode": "R[rd] = sext((R[rs1] + R[rs2])[31:0]);",
      "example": "ADDW x10, x11, x12",
      "example_note": "Performs 32-bit addition of x11 and x12, result is sign-extended to 64 bits.",
      "slug": "addw",
      "rel_url": "risc-v/addw/",
      "linked_summary": "Adds two 32-<a href=\"../../armv8-a/bit/\">bit</a> registers <a href=\"../../armv8-a/and_6/\">and</a> sign-extends the result to 64 bits.",
      "linked_pseudocode": "R[rd] = sext((R[rs1] + R[rs2])[31:0]);"
    },
    {
      "mnemonic": "ADDIW",
      "architecture": "RISC-V",
      "extension": "RV64",
      "full_name": "Add Immediate Word",
      "summary": "Adds a 12-bit immediate to a register (32-bit arithmetic) and sign-extends to 64 bits.",
      "syntax": "ADDIW rd, rs1, imm",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "imm[11:0] | rs1 | 000 | rd | 0011011",
        "hex_opcode": "0x1B",
        "visual_parts": [
          {
            "raw": "imm[11:0]",
            "clean": "imm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "000",
            "clean": "000"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0011011",
            "clean": "0011011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Destination Register"
        },
        {
          "name": "rs1",
          "desc": "Source Register"
        },
        {
          "name": "imm",
          "desc": "12-bit Signed Immediate"
        }
      ],
      "pseudocode": "R[rd] = sext((R[rs1] + sext(imm))[31:0]);",
      "example": "ADDIW x5, x6, 5",
      "example_note": "Adds 5 to lower 32 bits of x6, sign-extends result to x5.",
      "slug": "addiw",
      "rel_url": "risc-v/addiw/",
      "linked_summary": "Adds a 12-<a href=\"../../armv8-a/bit/\">bit</a> immediate to a register (32-<a href=\"../../armv8-a/bit/\">bit</a> arithmetic) <a href=\"../../armv8-a/and_6/\">and</a> sign-extends to 64 bits.",
      "linked_pseudocode": "R[rd] = sext((R[rs1] + sext(imm))[31:0]);"
    },
    {
      "mnemonic": "AND",
      "architecture": "RISC-V",
      "full_name": "Logical AND",
      "summary": "Performs a bitwise logical AND operation between two registers.",
      "syntax": "AND rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0000000 | rs2 | rs1 | 111 | rd | 0110011",
        "hex_opcode": "0x33",
        "visual_parts": [
          {
            "raw": "0000000",
            "clean": "0000000"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "111",
            "clean": "111"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0110011",
            "clean": "0110011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Destination Register"
        },
        {
          "name": "rs1",
          "desc": "Source Register 1"
        },
        {
          "name": "rs2",
          "desc": "Source Register 2"
        }
      ],
      "pseudocode": "R[rd] = R[rs1] & R[rs2];",
      "example": "AND x10, x11, x12",
      "example_note": "Bitwise AND of x11 and x12.",
      "slug": "and",
      "rel_url": "risc-v/and/",
      "linked_summary": "Performs a bitwise logical <a href=\"../../risc-v/and/\">AND</a> operation between two registers.",
      "linked_pseudocode": "R[rd] = R[rs1] & R[rs2];"
    },
    {
      "mnemonic": "ANDI",
      "architecture": "RISC-V",
      "full_name": "Logical AND Immediate",
      "summary": "Performs a bitwise logical AND between a register and a sign-extended 12-bit immediate.",
      "syntax": "ANDI rd, rs1, imm",
      "encoding": {
        "format": "I-Type",
        "binary_pattern": "imm[11:0] | rs1 | 111 | rd | 0010011",
        "hex_opcode": "0x13",
        "visual_parts": [
          {
            "raw": "imm[11:0]",
            "clean": "imm"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "111",
            "clean": "111"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0010011",
            "clean": "0010011"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Destination Register"
        },
        {
          "name": "rs1",
          "desc": "Source Register"
        },
        {
          "name": "imm",
          "desc": "12-bit Signed Immediate"
        }
      ],
      "pseudocode": "R[rd] = R[rs1] & sext(imm);",
      "example": "ANDI x10, x11, 15",
      "example_note": "Keeps only the lowest 4 bits of x11 (mask 0xF).",
      "slug": "andi",
      "rel_url": "risc-v/andi/",
      "linked_summary": "Performs a bitwise logical <a href=\"../../risc-v/and/\">AND</a> between a register <a href=\"../../armv8-a/and_6/\">and</a> a sign-extended 12-<a href=\"../../armv8-a/bit/\">bit</a> immediate.",
      "linked_pseudocode": "R[rd] = R[rs1] & sext(imm);"
    },
    {
      "mnemonic": "AUIPC",
      "architecture": "RISC-V",
      "full_name": "Add Upper Immediate to PC",
      "summary": "Adds a 20-bit upper immediate to the Program Counter, used for PC-relative addressing.",
      "syntax": "AUIPC rd, imm",
      "encoding": {
        "format": "U-Type",
        "binary_pattern": "imm[31:12] | rd | 0010111",
        "hex_opcode": "0x17",
        "visual_parts": [
          {
            "raw": "imm[31:12]",
            "clean": "imm"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0010111",
            "clean": "0010111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Destination Register"
        },
        {
          "name": "imm",
          "desc": "20-bit Upper Immediate"
        }
      ],
      "pseudocode": "R[rd] = PC + (imm << 12);",
      "example": "AUIPC x10, 0x1000",
      "example_note": "Adds 0x1000000 to the current PC and stores in x10.",
      "slug": "auipc",
      "rel_url": "risc-v/auipc/",
      "linked_summary": "Adds a 20-<a href=\"../../armv8-a/bit/\">bit</a> upper immediate to the Program Counter, used for PC-relative addressing.",
      "linked_pseudocode": "R[rd] = PC + (imm << 12);"
    },
    {
      "mnemonic": "AMOADD.W",
      "architecture": "RISC-V",
      "extension": "A (Atomic)",
      "full_name": "Atomic Add Word",
      "summary": "Atomically adds a value to a word in memory.",
      "syntax": "AMOADD.W rd, rs2, (rs1)",
      "encoding": {
        "format": "R-Type (Atomic)",
        "binary_pattern": "00000 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
        "hex_opcode": "0x2F",
        "visual_parts": [
          {
            "raw": "00000",
            "clean": "00000"
          },
          {
            "raw": "aq",
            "clean": "aq"
          },
          {
            "raw": "rl",
            "clean": "rl"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0101111",
            "clean": "0101111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Old Value)"
        },
        {
          "name": "rs2",
          "desc": "Value to Add"
        },
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp + R[rs2]; R[rd] = temp;",
      "example": "AMOADD.W x10, x11, (x12)",
      "example_note": "Atomically adds x11 to memory at x12. Old value stored in x10.",
      "slug": "amoadd_w",
      "rel_url": "risc-v/amoadd_w/",
      "linked_summary": "Atomically <a href=\"../../armv8-a/adds_5/\">adds</a> a value to a word <a href=\"../../x86/in/\">in</a> memory.",
      "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp + R[rs2]; R[rd] = temp;"
    },
    {
      "mnemonic": "AMOSWAP.W",
      "architecture": "RISC-V",
      "extension": "A (Atomic)",
      "full_name": "Atomic Swap Word",
      "summary": "Atomically swaps a value in memory with a register.",
      "syntax": "AMOSWAP.W rd, rs2, (rs1)",
      "encoding": {
        "format": "R-Type (Atomic)",
        "binary_pattern": "00001 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
        "hex_opcode": "0x2F",
        "visual_parts": [
          {
            "raw": "00001",
            "clean": "00001"
          },
          {
            "raw": "aq",
            "clean": "aq"
          },
          {
            "raw": "rl",
            "clean": "rl"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0101111",
            "clean": "0101111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Old Value)"
        },
        {
          "name": "rs2",
          "desc": "New Value"
        },
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = R[rs2]; R[rd] = temp;",
      "example": "AMOSWAP.W x10, x11, (x12)",
      "example_note": "Writes x11 to memory at x12, loads old memory value into x10.",
      "slug": "amoswap_w",
      "rel_url": "risc-v/amoswap_w/",
      "linked_summary": "Atomically swaps a value <a href=\"../../x86/in/\">in</a> memory with a register.",
      "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = R[rs2]; R[rd] = temp;"
    },
    {
      "mnemonic": "AMOAND.W",
      "architecture": "RISC-V",
      "extension": "A (Atomic)",
      "full_name": "Atomic AND Word",
      "summary": "Atomically performs bitwise AND on a word in memory.",
      "syntax": "AMOAND.W rd, rs2, (rs1)",
      "encoding": {
        "format": "R-Type (Atomic)",
        "binary_pattern": "01100 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
        "hex_opcode": "0x2F",
        "visual_parts": [
          {
            "raw": "01100",
            "clean": "01100"
          },
          {
            "raw": "aq",
            "clean": "aq"
          },
          {
            "raw": "rl",
            "clean": "rl"
          },
          {
            "raw": "rs2",
            "clean": "rs2"
          },
          {
            "raw": "rs1",
            "clean": "rs1"
          },
          {
            "raw": "010",
            "clean": "010"
          },
          {
            "raw": "rd",
            "clean": "rd"
          },
          {
            "raw": "0101111",
            "clean": "0101111"
          }
        ]
      },
      "operands": [
        {
          "name": "rd",
          "desc": "Dest (Old Value)"
        },
        {
          "name": "rs2",
          "desc": "Operand"
        },
        {
          "name": "rs1",
          "desc": "Address"
        }
      ],
      "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp & R[rs2]; R[rd] = temp;",
      "example": "AMOAND.W x5, x6, (x7)",
      "example_note": "Atomically ANDs memory at x7 with x6.",
      "slug": "amoand_w",
      "rel_url": "risc-v/amoand_w/",
      "linked_summary": "Atomically performs bitwise <a href=\"../../risc-v/and/\">AND</a> on a word <a href=\"../../x86/in/\">in</a> memory.",
      "linked_pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp & R[rs2]; R[rd] = temp;"
    }
  ]
}