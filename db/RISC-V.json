[
  {
    "mnemonic": "ADDI",
    "architecture": "RISC-V",
    "full_name": "Add Immediate",
    "summary": "Adds a register and a sign-extended 12-bit immediate value.",
    "syntax": "ADDI rd, rs1, imm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "...",
      "hex_opcode": "0x13"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Src"
      },
      {
        "name": "imm",
        "desc": "Value"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] + sext(imm);",
    "example": "ADDI x5, x0, 10",
    "example_note": "Loads the value 10 into register x5."
  },
  {
    "mnemonic": "ADD",
    "architecture": "RISC-V",
    "full_name": "Add",
    "summary": "Adds the contents of two registers.",
    "syntax": "ADD rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 000 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] + R[rs2];",
    "example": "ADD x6, x5, x4",
    "example_note": "x6 = x5 + x4"
  },
  {
    "mnemonic": "SUB",
    "architecture": "RISC-V",
    "full_name": "Subtract",
    "summary": "Subtracts rs2 from rs1.",
    "syntax": "SUB rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0100000 | rs2 | rs1 | 000 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Minuend"
      },
      {
        "name": "rs2",
        "desc": "Subtrahend"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] - R[rs2];",
    "example": "SUB x10, x11, x12",
    "example_note": "x10 = x11 - x12"
  },
  {
    "mnemonic": "LUI",
    "architecture": "RISC-V",
    "full_name": "Load Upper Immediate",
    "summary": "Loads the 20-bit immediate into the upper 20 bits of the register.",
    "syntax": "LUI rd, imm",
    "encoding": {
      "format": "U-Type",
      "binary_pattern": "imm[31:12] | rd | 0110111",
      "hex_opcode": "0x37"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "imm",
        "desc": "20-bit Upper Value"
      }
    ],
    "pseudocode": "R[rd] = imm << 12;",
    "example": "LUI x5, 0x12345",
    "example_note": "Loads 0x12345000 into x5."
  },
  {
    "mnemonic": "AUIPC",
    "architecture": "RISC-V",
    "full_name": "Add Upper Immediate to PC",
    "summary": "Adds a 20-bit upper immediate to the Program Counter.",
    "syntax": "AUIPC rd, imm",
    "encoding": {
      "format": "U-Type",
      "binary_pattern": "imm[31:12] | rd | 0010111",
      "hex_opcode": "0x17"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "imm",
        "desc": "20-bit offset"
      }
    ],
    "pseudocode": "R[rd] = PC + (imm << 12);",
    "example": "AUIPC x10, 0",
    "example_note": "Loads the current PC value into x10."
  },
  {
    "mnemonic": "JAL",
    "architecture": "RISC-V",
    "full_name": "Jump and Link",
    "summary": "Jumps to an offset and saves return address.",
    "syntax": "JAL rd, offset",
    "encoding": {
      "format": "J-Type",
      "binary_pattern": "imm | rd | 1101111",
      "hex_opcode": "0x6F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Return Address Dest"
      },
      {
        "name": "offset",
        "desc": "Jump Offset"
      }
    ],
    "pseudocode": "R[rd] = PC + 4; PC += sext(offset);",
    "example": "JAL x1, 1024",
    "example_note": "Calls function at PC+1024, saves return address in RA (x1)."
  },
  {
    "mnemonic": "BEQ",
    "architecture": "RISC-V",
    "full_name": "Branch if Equal",
    "summary": "Branches if two registers are equal.",
    "syntax": "BEQ rs1, rs2, offset",
    "encoding": {
      "format": "B-Type",
      "binary_pattern": "imm | rs2 | rs1 | 000 | imm | 1100011",
      "hex_opcode": "0x63"
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      },
      {
        "name": "offset",
        "desc": "Branch target"
      }
    ],
    "pseudocode": "if (R[rs1] == R[rs2]) PC += sext(offset);",
    "example": "BEQ x5, x6, 100",
    "example_note": "Jump 100 bytes forward if x5 equals x6."
  },
  {
    "mnemonic": "LW",
    "architecture": "RISC-V",
    "full_name": "Load Word",
    "summary": "Loads a 32-bit word from memory.",
    "syntax": "LW rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "offset | rs1 | 010 | rd | 0000011",
      "hex_opcode": "0x03"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Byte Offset"
      }
    ],
    "pseudocode": "R[rd] = M[R[rs1] + sext(offset)][31:0];",
    "example": "LW x5, 8(x2)",
    "example_note": "Load value from memory at address (StackPointer + 8) into x5."
  },
  {
    "mnemonic": "SW",
    "architecture": "RISC-V",
    "full_name": "Store Word",
    "summary": "Stores a 32-bit word to memory.",
    "syntax": "SW rs2, offset(rs1)",
    "encoding": {
      "format": "S-Type",
      "binary_pattern": "imm | rs2 | rs1 | 010 | imm | 0100011",
      "hex_opcode": "0x23"
    },
    "operands": [
      {
        "name": "rs2",
        "desc": "Source Data"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Byte Offset"
      }
    ],
    "pseudocode": "M[R[rs1] + sext(offset)] = R[rs2][31:0];",
    "example": "SW x5, 12(x2)",
    "example_note": "Store x5 into stack memory at offset 12."
  },
  {
    "mnemonic": "ECALL",
    "architecture": "RISC-V",
    "full_name": "Environment Call",
    "summary": "Triggers a service request to the execution environment (OS).",
    "syntax": "ECALL",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "000000000000 | 00000 | 000 | 00000 | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [],
    "pseudocode": "RaiseException(EnvironmentCall);",
    "example": "ECALL",
    "example_note": "Used to make syscalls (e.g. print, exit)."
  },
  {
    "mnemonic": "ADDW",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Add Word",
    "summary": "Adds two 32-bit registers and sign-extends the result to 64 bits.",
    "syntax": "ADDW rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 000 | rd | 0111011",
      "hex_opcode": "0x3B"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Source Register 1"
      },
      {
        "name": "rs2",
        "desc": "Source Register 2"
      }
    ],
    "pseudocode": "R[rd] = sext((R[rs1] + R[rs2])[31:0]);",
    "example": "ADDW x10, x11, x12",
    "example_note": "Performs 32-bit addition of x11 and x12, result is sign-extended to 64 bits."
  },
  {
    "mnemonic": "ADDIW",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Add Immediate Word",
    "summary": "Adds a 12-bit immediate to a register (32-bit arithmetic) and sign-extends to 64 bits.",
    "syntax": "ADDIW rd, rs1, imm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 000 | rd | 0011011",
      "hex_opcode": "0x1B"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Source Register"
      },
      {
        "name": "imm",
        "desc": "12-bit Signed Immediate"
      }
    ],
    "pseudocode": "R[rd] = sext((R[rs1] + sext(imm))[31:0]);",
    "example": "ADDIW x5, x6, 5",
    "example_note": "Adds 5 to lower 32 bits of x6, sign-extends result to x5."
  },
  {
    "mnemonic": "AND",
    "architecture": "RISC-V",
    "full_name": "Logical AND",
    "summary": "Performs a bitwise logical AND operation between two registers.",
    "syntax": "AND rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 111 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Source Register 1"
      },
      {
        "name": "rs2",
        "desc": "Source Register 2"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] & R[rs2];",
    "example": "AND x10, x11, x12",
    "example_note": "Bitwise AND of x11 and x12."
  },
  {
    "mnemonic": "ANDI",
    "architecture": "RISC-V",
    "full_name": "Logical AND Immediate",
    "summary": "Performs a bitwise logical AND between a register and a sign-extended 12-bit immediate.",
    "syntax": "ANDI rd, rs1, imm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 111 | rd | 0010011",
      "hex_opcode": "0x13"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Source Register"
      },
      {
        "name": "imm",
        "desc": "12-bit Signed Immediate"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] & sext(imm);",
    "example": "ANDI x10, x11, 15",
    "example_note": "Keeps only the lowest 4 bits of x11 (mask 0xF)."
  },
  {
    "mnemonic": "AMOADD.W",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic Add Word",
    "summary": "Atomically adds a value to a word in memory.",
    "syntax": "AMOADD.W rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "00000 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
      "hex_opcode": "0x2F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Value to Add"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp + R[rs2]; R[rd] = temp;",
    "example": "AMOADD.W x10, x11, (x12)",
    "example_note": "Atomically adds x11 to memory at x12. Old value stored in x10."
  },
  {
    "mnemonic": "AMOSWAP.W",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic Swap Word",
    "summary": "Atomically swaps a value in memory with a register.",
    "syntax": "AMOSWAP.W rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "00001 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
      "hex_opcode": "0x2F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "New Value"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = R[rs2]; R[rd] = temp;",
    "example": "AMOSWAP.W x10, x11, (x12)",
    "example_note": "Writes x11 to memory at x12, loads old memory value into x10."
  },
  {
    "mnemonic": "AMOAND.W",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic AND Word",
    "summary": "Atomically performs bitwise AND on a word in memory.",
    "syntax": "AMOAND.W rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "01100 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
      "hex_opcode": "0x2F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Operand"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp & R[rs2]; R[rd] = temp;",
    "example": "AMOAND.W x5, x6, (x7)",
    "example_note": "Atomically ANDs memory at x7 with x6."
  },
  {
    "mnemonic": "BNE",
    "architecture": "RISC-V",
    "full_name": "Branch if Not Equal",
    "summary": "Take the branch if registers rs1 and rs2 are not equal.",
    "syntax": "BNE rs1, rs2, offset",
    "encoding": {
      "format": "B-Type",
      "binary_pattern": "imm[12|10:5] | rs2 | rs1 | 001 | imm[4:1|11] | 1100011",
      "hex_opcode": "0x63"
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      },
      {
        "name": "offset",
        "desc": "PC-relative offset"
      }
    ],
    "pseudocode": "if (R[rs1] != R[rs2]) PC += sext(offset);",
    "example": "BNE x5, x6, loop",
    "example_note": "Jump to 'loop' if x5 != x6."
  },
  {
    "mnemonic": "BLT",
    "architecture": "RISC-V",
    "full_name": "Branch if Less Than",
    "summary": "Take the branch if rs1 is less than rs2 (signed).",
    "syntax": "BLT rs1, rs2, offset",
    "encoding": {
      "format": "B-Type",
      "binary_pattern": "imm[12|10:5] | rs2 | rs1 | 100 | imm[4:1|11] | 1100011",
      "hex_opcode": "0x63"
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "if (R[rs1] <s R[rs2]) PC += sext(offset);",
    "example": "BLT x10, x11, exit",
    "example_note": "Branch to 'exit' if x10 < x11 (signed comparison)."
  },
  {
    "mnemonic": "BGE",
    "architecture": "RISC-V",
    "full_name": "Branch if Greater or Equal",
    "summary": "Take the branch if rs1 is greater than or equal to rs2 (signed).",
    "syntax": "BGE rs1, rs2, offset",
    "encoding": {
      "format": "B-Type",
      "binary_pattern": "imm[12|10:5] | rs2 | rs1 | 101 | imm[4:1|11] | 1100011",
      "hex_opcode": "0x63"
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "if (R[rs1] >=s R[rs2]) PC += sext(offset);",
    "example": "BGE x10, x0, positive",
    "example_note": "Branch if x10 is positive or zero."
  },
  {
    "mnemonic": "CSRRW",
    "architecture": "RISC-V",
    "extension": "Zicsr",
    "full_name": "Control Status Register Read/Write",
    "summary": "Atomically swaps values in the CSRs. Reads the old value of the CSR into rd, then writes rs1 to the CSR.",
    "syntax": "CSRRW rd, csr, rs1",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "csr | rs1 | 001 | rd | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "csr",
        "desc": "CSR Address"
      },
      {
        "name": "rs1",
        "desc": "Src (New Value)"
      }
    ],
    "pseudocode": "t = CSRs[csr]; CSRs[csr] = R[rs1]; R[rd] = t;",
    "example": "CSRRW x10, scause, x11",
    "example_note": "Writes x11 to 'scause' CSR and reads old 'scause' into x10."
  },
  {
    "mnemonic": "CSRRS",
    "architecture": "RISC-V",
    "extension": "Zicsr",
    "full_name": "Control Status Register Read and Set",
    "summary": "Reads the value of the CSR into rd, then bitwise ORs the value in rs1 into the CSR (setting bits).",
    "syntax": "CSRRS rd, csr, rs1",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "csr | rs1 | 010 | rd | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "csr",
        "desc": "CSR Address"
      },
      {
        "name": "rs1",
        "desc": "Bit Mask"
      }
    ],
    "pseudocode": "t = CSRs[csr]; CSRs[csr] = t | R[rs1]; R[rd] = t;",
    "example": "CSRRS x0, sstatus, x5",
    "example_note": "Sets bits in 'sstatus' using mask in x5 (Result discarded)."
  },
  {
    "mnemonic": "DIV",
    "architecture": "RISC-V",
    "extension": "M",
    "full_name": "Divide",
    "summary": "Performs signed integer division.",
    "syntax": "DIV rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000001 | rs2 | rs1 | 100 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Quotient)"
      },
      {
        "name": "rs1",
        "desc": "Dividend"
      },
      {
        "name": "rs2",
        "desc": "Divisor"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] / R[rs2];",
    "example": "DIV x10, x11, x12",
    "example_note": "Signed division of x11 by x12."
  },
  {
    "mnemonic": "DIVU",
    "architecture": "RISC-V",
    "extension": "M",
    "full_name": "Divide Unsigned",
    "summary": "Performs unsigned integer division.",
    "syntax": "DIVU rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000001 | rs2 | rs1 | 101 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Dividend"
      },
      {
        "name": "rs2",
        "desc": "Divisor"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] /u R[rs2];",
    "example": "DIVU x5, x6, x7",
    "example_note": "Unsigned division."
  },
  {
    "mnemonic": "EBREAK",
    "architecture": "RISC-V",
    "full_name": "Environment Break",
    "summary": "Used by debuggers to cause control to be transferred back to a debugging environment.",
    "syntax": "EBREAK",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "000000000001 | 00000 | 000 | 00000 | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [],
    "pseudocode": "RaiseException(Breakpoint);",
    "example": "EBREAK",
    "example_note": "Triggers a debugger breakpoint."
  },
  {
    "mnemonic": "FENCE",
    "architecture": "RISC-V",
    "full_name": "Fence",
    "summary": "Orders device I/O and memory accesses.",
    "syntax": "FENCE pred, succ",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "fm | pred | succ | rs1 | 000 | rd | 0001111",
      "hex_opcode": "0x0F"
    },
    "operands": [
      {
        "name": "pred",
        "desc": "Predecessor Set"
      },
      {
        "name": "succ",
        "desc": "Successor Set"
      }
    ],
    "pseudocode": "MemoryBarrier(pred, succ);",
    "example": "FENCE rw, rw",
    "example_note": "Ensures all previous reads/writes complete before subsequent reads/writes."
  },
  {
    "mnemonic": "FLW",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Float Load Word",
    "summary": "Loads a single-precision floating-point value from memory.",
    "syntax": "FLW rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "offset | rs1 | 010 | rd | 0000111",
      "hex_opcode": "0x07"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Float Reg)"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "F[rd] = M[R[rs1] + sext(offset)][31:0];",
    "example": "FLW f1, 0(x10)",
    "example_note": "Loads float from address in x10 to f1."
  },
  {
    "mnemonic": "FSW",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Float Store Word",
    "summary": "Stores a single-precision floating-point value to memory.",
    "syntax": "FSW rs2, offset(rs1)",
    "encoding": {
      "format": "S-Type",
      "binary_pattern": "imm[11:5] | rs2 | rs1 | 010 | imm[4:0] | 0100111",
      "hex_opcode": "0x27"
    },
    "operands": [
      {
        "name": "rs2",
        "desc": "Src (Float Reg)"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "M[R[rs1] + sext(offset)] = F[rs2][31:0];",
    "example": "FSW f1, 4(x2)",
    "example_note": "Stores float in f1 to stack + 4."
  },
  {
    "mnemonic": "FADD.S",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Float Add (Single)",
    "summary": "Performs single-precision floating-point addition.",
    "syntax": "FADD.S rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 000 | rd | 1010011",
      "hex_opcode": "0x53"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Src 1"
      },
      {
        "name": "rs2",
        "desc": "Src 2"
      }
    ],
    "pseudocode": "F[rd] = F[rs1] + F[rs2];",
    "example": "FADD.S f0, f1, f2",
    "example_note": "f0 = f1 + f2"
  },
  {
    "mnemonic": "HFENCE.GVMA",
    "architecture": "RISC-V",
    "extension": "H (Hypervisor)",
    "full_name": "Hypervisor Fence Guest Virtual Memory Address",
    "summary": "Synchronizes updates to guest physical address translation data structures.",
    "syntax": "HFENCE.GVMA rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0110001 | rs2 | rs1 | 000 | 00000 | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Guest Virtual Address (optional)"
      },
      {
        "name": "rs2",
        "desc": "Guest ASID (optional)"
      }
    ],
    "pseudocode": "Fence(GuestPageTable);",
    "example": "HFENCE.GVMA x0, x0",
    "example_note": "Flush all guest TLB entries."
  },
  {
    "mnemonic": "HFENCE.VVMA",
    "architecture": "RISC-V",
    "extension": "H (Hypervisor)",
    "full_name": "Hypervisor Fence Virtual Virtual Memory Address",
    "summary": "Synchronizes updates to VS-stage address translation data structures.",
    "syntax": "HFENCE.VVMA rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0010001 | rs2 | rs1 | 000 | 00000 | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Virtual Address (optional)"
      },
      {
        "name": "rs2",
        "desc": "ASID (optional)"
      }
    ],
    "pseudocode": "Fence(VS-StagePageTable);",
    "example": "HFENCE.VVMA x10, x0",
    "example_note": "Flush TLB entries for address in x10."
  },
  {
    "mnemonic": "JALR",
    "architecture": "RISC-V",
    "full_name": "Jump and Link Register",
    "summary": "Jumps to address in rs1 + offset, saving return address to rd.",
    "syntax": "JALR rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 000 | rd | 1100111",
      "hex_opcode": "0x67"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Return Address Dest"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "12-bit Immediate"
      }
    ],
    "pseudocode": "t = PC + 4; PC = (R[rs1] + sext(offset)) & ~1; R[rd] = t;",
    "example": "JALR x0, 0(x1)",
    "example_note": "Return from function (jumps to address in x1/ra)."
  },
  {
    "mnemonic": "LB",
    "architecture": "RISC-V",
    "full_name": "Load Byte",
    "summary": "Loads an 8-bit byte from memory and sign-extends it to the register width.",
    "syntax": "LB rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 000 | rd | 0000011",
      "hex_opcode": "0x03"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Byte Offset"
      }
    ],
    "pseudocode": "R[rd] = sext(M[R[rs1] + sext(offset)][7:0]);",
    "example": "LB x10, 0(x2)",
    "example_note": "Load byte from stack pointer (x2) into x10."
  },
  {
    "mnemonic": "LH",
    "architecture": "RISC-V",
    "full_name": "Load Halfword",
    "summary": "Loads a 16-bit halfword from memory and sign-extends it.",
    "syntax": "LH rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 001 | rd | 0000011",
      "hex_opcode": "0x03"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Byte Offset"
      }
    ],
    "pseudocode": "R[rd] = sext(M[R[rs1] + sext(offset)][15:0]);",
    "example": "LH x5, 4(x10)",
    "example_note": "Load halfword from address x10+4."
  },
  {
    "mnemonic": "LBU",
    "architecture": "RISC-V",
    "full_name": "Load Byte Unsigned",
    "summary": "Loads an 8-bit byte from memory and zero-extends it.",
    "syntax": "LBU rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 100 | rd | 0000011",
      "hex_opcode": "0x03"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Byte Offset"
      }
    ],
    "pseudocode": "R[rd] = zext(M[R[rs1] + sext(offset)][7:0]);",
    "example": "LBU x10, 0(x2)",
    "example_note": "Load byte and zero-extend."
  },
  {
    "mnemonic": "LHU",
    "architecture": "RISC-V",
    "full_name": "Load Halfword Unsigned",
    "summary": "Loads a 16-bit halfword from memory and zero-extends it.",
    "syntax": "LHU rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 101 | rd | 0000011",
      "hex_opcode": "0x03"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Byte Offset"
      }
    ],
    "pseudocode": "R[rd] = zext(M[R[rs1] + sext(offset)][15:0]);",
    "example": "LHU x5, 4(x10)",
    "example_note": "Load halfword and zero-extend."
  },
  {
    "mnemonic": "LD",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Load Doubleword",
    "summary": "Loads a 64-bit doubleword from memory.",
    "syntax": "LD rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 011 | rd | 0000011",
      "hex_opcode": "0x03"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Byte Offset"
      }
    ],
    "pseudocode": "R[rd] = M[R[rs1] + sext(offset)][63:0];",
    "example": "LD x1, 0(x2)",
    "example_note": "Load 64-bit value from stack."
  },
  {
    "mnemonic": "LWU",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Load Word Unsigned",
    "summary": "Loads a 32-bit word from memory and zero-extends it to 64 bits.",
    "syntax": "LWU rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 110 | rd | 0000011",
      "hex_opcode": "0x03"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Byte Offset"
      }
    ],
    "pseudocode": "R[rd] = zext(M[R[rs1] + sext(offset)][31:0]);",
    "example": "LWU x6, 12(x2)",
    "example_note": "Load 32-bit word and zero-extend to 64-bit."
  },
  {
    "mnemonic": "LR.W",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Load Reserved Word",
    "summary": "Loads a word from memory and registers a reservation set for the address.",
    "syntax": "LR.W rd, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "00010 | aq | rl | 00000 | rs1 | 010 | rd | 0101111",
      "hex_opcode": "0x2F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "R[rd] = LoadReserved32(M[R[rs1]]);",
    "example": "LR.W x10, (x11)",
    "example_note": "Start atomic read-modify-write sequence."
  },
  {
    "mnemonic": "LR.D",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Load Reserved Doubleword",
    "summary": "Loads a doubleword from memory and registers a reservation set.",
    "syntax": "LR.D rd, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "00010 | aq | rl | 00000 | rs1 | 011 | rd | 0101111",
      "hex_opcode": "0x2F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "R[rd] = LoadReserved64(M[R[rs1]]);",
    "example": "LR.D x10, (x11)",
    "example_note": "64-bit atomic load reserved."
  },
  {
    "mnemonic": "MUL",
    "architecture": "RISC-V",
    "extension": "M",
    "full_name": "Multiply",
    "summary": "Performs a 32-bit (or 64-bit) multiplication of rs1 and rs2 and stores the lower bits in rd.",
    "syntax": "MUL rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000001 | rs2 | rs1 | 000 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Lower Bits)"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "R[rd] = (R[rs1] * R[rs2])[XLEN-1:0];",
    "example": "MUL x10, x11, x12",
    "example_note": "x10 = lower bits of x11 * x12."
  },
  {
    "mnemonic": "MULH",
    "architecture": "RISC-V",
    "extension": "M",
    "full_name": "Multiply High Signed",
    "summary": "Performs a signed multiplication and stores the upper bits of the result.",
    "syntax": "MULH rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000001 | rs2 | rs1 | 001 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Upper Bits)"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "R[rd] = (sext(R[rs1]) * sext(R[rs2])) >> XLEN;",
    "example": "MULH x5, x6, x7",
    "example_note": "Get upper bits of signed multiplication."
  },
  {
    "mnemonic": "MRET",
    "architecture": "RISC-V",
    "extension": "Privileged",
    "full_name": "Machine Return",
    "summary": "Returns from a machine-mode trap handler.",
    "syntax": "MRET",
    "encoding": {
      "format": "R-Type (System)",
      "binary_pattern": "0011000 | 00010 | 00000 | 000 | 00000 | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [],
    "pseudocode": "PC = MEPC; Priv = MPP; MIE = MPIE;",
    "example": "MRET",
    "example_note": "Return to previous privilege level defined in mstatus."
  },
  {
    "mnemonic": "OR",
    "architecture": "RISC-V",
    "full_name": "Logical OR",
    "summary": "Performs a bitwise logical OR operation.",
    "syntax": "OR rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 110 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] | R[rs2];",
    "example": "OR x10, x11, x12",
    "example_note": "Bitwise OR of x11 and x12."
  },
  {
    "mnemonic": "ORI",
    "architecture": "RISC-V",
    "full_name": "Logical OR Immediate",
    "summary": "Performs a bitwise logical OR with a sign-extended immediate.",
    "syntax": "ORI rd, rs1, imm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 110 | rd | 0010011",
      "hex_opcode": "0x13"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "imm",
        "desc": "Immediate"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] | sext(imm);",
    "example": "ORI x10, x11, 1",
    "example_note": "Sets the lowest bit of x11."
  },
  {
    "mnemonic": "REM",
    "architecture": "RISC-V",
    "extension": "M",
    "full_name": "Remainder",
    "summary": "Computes the signed remainder of division.",
    "syntax": "REM rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000001 | rs2 | rs1 | 110 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Remainder)"
      },
      {
        "name": "rs1",
        "desc": "Dividend"
      },
      {
        "name": "rs2",
        "desc": "Divisor"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] % R[rs2];",
    "example": "REM x5, x6, x7",
    "example_note": "Signed remainder."
  },
  {
    "mnemonic": "SB",
    "architecture": "RISC-V",
    "full_name": "Store Byte",
    "summary": "Stores the lowest 8 bits of a register to memory.",
    "syntax": "SB rs2, offset(rs1)",
    "encoding": {
      "format": "S-Type",
      "binary_pattern": "imm[11:5] | rs2 | rs1 | 000 | imm[4:0] | 0100011",
      "hex_opcode": "0x23"
    },
    "operands": [
      {
        "name": "rs2",
        "desc": "Source"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "M[R[rs1] + sext(offset)][7:0] = R[rs2][7:0];",
    "example": "SB x5, 0(x10)",
    "example_note": "Store low byte of x5 to address in x10."
  },
  {
    "mnemonic": "SH",
    "architecture": "RISC-V",
    "full_name": "Store Halfword",
    "summary": "Stores the lowest 16 bits of a register to memory.",
    "syntax": "SH rs2, offset(rs1)",
    "encoding": {
      "format": "S-Type",
      "binary_pattern": "imm[11:5] | rs2 | rs1 | 001 | imm[4:0] | 0100011",
      "hex_opcode": "0x23"
    },
    "operands": [
      {
        "name": "rs2",
        "desc": "Source"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "M[R[rs1] + sext(offset)][15:0] = R[rs2][15:0];",
    "example": "SH x5, 4(x10)",
    "example_note": "Store halfword."
  },
  {
    "mnemonic": "SD",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Store Doubleword",
    "summary": "Stores a 64-bit doubleword to memory.",
    "syntax": "SD rs2, offset(rs1)",
    "encoding": {
      "format": "S-Type",
      "binary_pattern": "imm[11:5] | rs2 | rs1 | 011 | imm[4:0] | 0100011",
      "hex_opcode": "0x23"
    },
    "operands": [
      {
        "name": "rs2",
        "desc": "Source"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "M[R[rs1] + sext(offset)][63:0] = R[rs2][63:0];",
    "example": "SD x5, 16(x10)",
    "example_note": "Store 64-bit value."
  },
  {
    "mnemonic": "SLL",
    "architecture": "RISC-V",
    "full_name": "Shift Left Logical",
    "summary": "Shifts a register left by the number of bits specified in another register.",
    "syntax": "SLL rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 001 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "rs2",
        "desc": "Shift Amount"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] << (R[rs2] & 0x1F);",
    "example": "SLL x10, x11, x12",
    "example_note": "Shift x11 left by x12."
  },
  {
    "mnemonic": "SLLI",
    "architecture": "RISC-V",
    "full_name": "Shift Left Logical Immediate",
    "summary": "Shifts a register left by a constant amount.",
    "syntax": "SLLI rd, rs1, shamt",
    "encoding": {
      "format": "I-Type (Shift)",
      "binary_pattern": "0000000 | shamt | rs1 | 001 | rd | 0010011",
      "hex_opcode": "0x13"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "shamt",
        "desc": "Shift Amount"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] << shamt;",
    "example": "SLLI x10, x11, 2",
    "example_note": "Multiply x11 by 4."
  },
  {
    "mnemonic": "SRL",
    "architecture": "RISC-V",
    "full_name": "Shift Right Logical",
    "summary": "Shifts a register right, shifting in zeros.",
    "syntax": "SRL rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 101 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "rs2",
        "desc": "Shift Amount"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] >> (R[rs2] & 0x1F);",
    "example": "SRL x10, x11, x12",
    "example_note": "Logical right shift."
  },
  {
    "mnemonic": "SRA",
    "architecture": "RISC-V",
    "full_name": "Shift Right Arithmetic",
    "summary": "Shifts a register right, preserving the sign bit.",
    "syntax": "SRA rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0100000 | rs2 | rs1 | 101 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "rs2",
        "desc": "Shift Amount"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] >>s (R[rs2] & 0x1F);",
    "example": "SRA x10, x11, x12",
    "example_note": "Arithmetic right shift (sign preserved)."
  },
  {
    "mnemonic": "SLT",
    "architecture": "RISC-V",
    "full_name": "Set Less Than",
    "summary": "Sets rd to 1 if rs1 < rs2 (signed), otherwise 0.",
    "syntax": "SLT rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 010 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "R[rd] = (R[rs1] <s R[rs2]) ? 1 : 0;",
    "example": "SLT x5, x6, x7",
    "example_note": "Check if x6 < x7."
  },
  {
    "mnemonic": "SLTI",
    "architecture": "RISC-V",
    "full_name": "Set Less Than Immediate",
    "summary": "Sets rd to 1 if rs1 < immediate (signed), otherwise 0.",
    "syntax": "SLTI rd, rs1, imm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 010 | rd | 0010011",
      "hex_opcode": "0x13"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "imm",
        "desc": "Immediate"
      }
    ],
    "pseudocode": "R[rd] = (R[rs1] <s sext(imm)) ? 1 : 0;",
    "example": "SLTI x5, x6, 10",
    "example_note": "Check if x6 < 10."
  },
  {
    "mnemonic": "SC.W",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Store Conditional Word",
    "summary": "Conditionally stores a word to memory if the reservation (from LR) is still valid.",
    "syntax": "SC.W rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "00011 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
      "hex_opcode": "0x2F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Success/Fail)"
      },
      {
        "name": "rs2",
        "desc": "Source Value"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "if (ReservationValid) { M[R[rs1]] = R[rs2]; R[rd] = 0; } else { R[rd] = 1; }",
    "example": "SC.W x10, x11, (x12)",
    "example_note": "Try to store x11 to x12. x10=0 on success."
  },
  {
    "mnemonic": "SFENCE.VMA",
    "architecture": "RISC-V",
    "extension": "Privileged",
    "full_name": "Supervisor Fence Virtual Memory",
    "summary": "Synchronizes updates to in-memory address translation data structures (TLB flush).",
    "syntax": "SFENCE.VMA rs1, rs2",
    "encoding": {
      "format": "R-Type (System)",
      "binary_pattern": "0001001 | rs2 | rs1 | 000 | 00000 | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Virtual Address (optional)"
      },
      {
        "name": "rs2",
        "desc": "ASID (optional)"
      }
    ],
    "pseudocode": "Fence(PageTable);",
    "example": "SFENCE.VMA x0, x0",
    "example_note": "Flush all TLB entries."
  },
  {
    "mnemonic": "SRET",
    "architecture": "RISC-V",
    "extension": "Privileged",
    "full_name": "Supervisor Return",
    "summary": "Returns from a supervisor-mode trap handler.",
    "syntax": "SRET",
    "encoding": {
      "format": "R-Type (System)",
      "binary_pattern": "0001000 | 00010 | 00000 | 000 | 00000 | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [],
    "pseudocode": "PC = SEPC; Priv = SPP; SIE = SPIE;",
    "example": "SRET",
    "example_note": "Return from exception/interrupt in supervisor mode."
  },
  {
    "mnemonic": "WFI",
    "architecture": "RISC-V",
    "extension": "Privileged",
    "full_name": "Wait for Interrupt",
    "summary": "Provides a hint to the implementation that the current hart can be stalled until an interrupt occurs.",
    "syntax": "WFI",
    "encoding": {
      "format": "R-Type (System)",
      "binary_pattern": "0001000 | 00101 | 00000 | 000 | 00000 | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [],
    "pseudocode": "while(!Interrupt) { /* low power state */ }",
    "example": "WFI",
    "example_note": "Pause execution until interrupt."
  },
  {
    "mnemonic": "XOR",
    "architecture": "RISC-V",
    "full_name": "Logical XOR",
    "summary": "Performs a bitwise logical Exclusive-OR operation.",
    "syntax": "XOR rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 100 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] ^ R[rs2];",
    "example": "XOR x10, x11, x12",
    "example_note": "x10 = x11 ^ x12"
  },
  {
    "mnemonic": "XORI",
    "architecture": "RISC-V",
    "full_name": "Logical XOR Immediate",
    "summary": "Performs a bitwise logical Exclusive-OR with a sign-extended immediate.",
    "syntax": "XORI rd, rs1, imm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 100 | rd | 0010011",
      "hex_opcode": "0x13"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "imm",
        "desc": "Immediate"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] ^ sext(imm);",
    "example": "XORI x10, x11, -1",
    "example_note": "Bitwise invert (NOT) x11."
  },
  {
    "mnemonic": "CSRRC",
    "architecture": "RISC-V",
    "extension": "Zicsr",
    "full_name": "Control Status Register Read and Clear",
    "summary": "Reads the old value of the CSR, then clears bits in the CSR based on the mask in rs1.",
    "syntax": "CSRRC rd, csr, rs1",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "csr | rs1 | 011 | rd | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "csr",
        "desc": "CSR Address"
      },
      {
        "name": "rs1",
        "desc": "Bit Mask"
      }
    ],
    "pseudocode": "t = CSRs[csr]; CSRs[csr] = t & ~R[rs1]; R[rd] = t;",
    "example": "CSRRC x10, sstatus, x5",
    "example_note": "Clears bits in 'sstatus' where x5 is 1."
  },
  {
    "mnemonic": "CSRRWI",
    "architecture": "RISC-V",
    "extension": "Zicsr",
    "full_name": "CSR Read/Write Immediate",
    "summary": "Updates a CSR using a 5-bit unsigned immediate (zimm) instead of a register.",
    "syntax": "CSRRWI rd, csr, uimm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "csr | uimm | 101 | rd | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "csr",
        "desc": "CSR Address"
      },
      {
        "name": "uimm",
        "desc": "5-bit Unsigned Imm"
      }
    ],
    "pseudocode": "t = CSRs[csr]; CSRs[csr] = zext(uimm); R[rd] = t;",
    "example": "CSRRWI x0, 0x001, 0",
    "example_note": "Writes 0 to CSR 0x001."
  },
  {
    "mnemonic": "CSRRSI",
    "architecture": "RISC-V",
    "extension": "Zicsr",
    "full_name": "CSR Read and Set Immediate",
    "summary": "Sets bits in a CSR using a 5-bit unsigned immediate.",
    "syntax": "CSRRSI rd, csr, uimm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "csr | uimm | 110 | rd | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "csr",
        "desc": "CSR Address"
      },
      {
        "name": "uimm",
        "desc": "Bit Mask"
      }
    ],
    "pseudocode": "t = CSRs[csr]; CSRs[csr] = t | zext(uimm); R[rd] = t;",
    "example": "CSRRSI x0, sstatus, 1",
    "example_note": "Sets bit 0 of sstatus."
  },
  {
    "mnemonic": "CSRRCI",
    "architecture": "RISC-V",
    "extension": "Zicsr",
    "full_name": "CSR Read and Clear Immediate",
    "summary": "Clears bits in a CSR using a 5-bit unsigned immediate.",
    "syntax": "CSRRCI rd, csr, uimm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "csr | uimm | 111 | rd | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "csr",
        "desc": "CSR Address"
      },
      {
        "name": "uimm",
        "desc": "Bit Mask"
      }
    ],
    "pseudocode": "t = CSRs[csr]; CSRs[csr] = t & ~zext(uimm); R[rd] = t;",
    "example": "CSRRCI x0, sstatus, 2",
    "example_note": "Clears bit 1 of sstatus."
  },
  {
    "mnemonic": "FLD",
    "architecture": "RISC-V",
    "extension": "D (Double)",
    "full_name": "Float Load Double",
    "summary": "Loads a 64-bit double-precision floating-point value from memory.",
    "syntax": "FLD rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "offset | rs1 | 011 | rd | 0000111",
      "hex_opcode": "0x07"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Float Reg)"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "F[rd] = M[R[rs1] + sext(offset)][63:0];",
    "example": "FLD f1, 8(x10)",
    "example_note": "Loads double from address x10+8."
  },
  {
    "mnemonic": "FSD",
    "architecture": "RISC-V",
    "extension": "D (Double)",
    "full_name": "Float Store Double",
    "summary": "Stores a 64-bit double-precision floating-point value to memory.",
    "syntax": "FSD rs2, offset(rs1)",
    "encoding": {
      "format": "S-Type",
      "binary_pattern": "imm[11:5] | rs2 | rs1 | 011 | imm[4:0] | 0100111",
      "hex_opcode": "0x27"
    },
    "operands": [
      {
        "name": "rs2",
        "desc": "Src (Float Reg)"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "M[R[rs1] + sext(offset)][63:0] = F[rs2];",
    "example": "FSD f1, 16(x2)",
    "example_note": "Stores f1 to stack+16."
  },
  {
    "mnemonic": "FADD.D",
    "architecture": "RISC-V",
    "extension": "D (Double)",
    "full_name": "Float Add Double",
    "summary": "Performs double-precision floating-point addition.",
    "syntax": "FADD.D rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000001 | rs2 | rs1 | 000 | rd | 1010011",
      "hex_opcode": "0x53"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Src 1"
      },
      {
        "name": "rs2",
        "desc": "Src 2"
      }
    ],
    "pseudocode": "F[rd] = F[rs1] + F[rs2];",
    "example": "FADD.D f0, f1, f2",
    "example_note": "64-bit float addition."
  },
  {
    "mnemonic": "FSUB.D",
    "architecture": "RISC-V",
    "extension": "D (Double)",
    "full_name": "Float Subtract Double",
    "summary": "Performs double-precision floating-point subtraction.",
    "syntax": "FSUB.D rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000101 | rs2 | rs1 | 000 | rd | 1010011",
      "hex_opcode": "0x53"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Src 1"
      },
      {
        "name": "rs2",
        "desc": "Src 2"
      }
    ],
    "pseudocode": "F[rd] = F[rs1] - F[rs2];",
    "example": "FSUB.D f0, f1, f2",
    "example_note": "64-bit float subtraction."
  },
  {
    "mnemonic": "FMUL.D",
    "architecture": "RISC-V",
    "extension": "D (Double)",
    "full_name": "Float Multiply Double",
    "summary": "Performs double-precision floating-point multiplication.",
    "syntax": "FMUL.D rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0001001 | rs2 | rs1 | 000 | rd | 1010011",
      "hex_opcode": "0x53"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Src 1"
      },
      {
        "name": "rs2",
        "desc": "Src 2"
      }
    ],
    "pseudocode": "F[rd] = F[rs1] * F[rs2];",
    "example": "FMUL.D f0, f1, f2",
    "example_note": "64-bit float multiplication."
  },
  {
    "mnemonic": "FDIV.D",
    "architecture": "RISC-V",
    "extension": "D (Double)",
    "full_name": "Float Divide Double",
    "summary": "Performs double-precision floating-point division.",
    "syntax": "FDIV.D rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0001101 | rs2 | rs1 | 000 | rd | 1010011",
      "hex_opcode": "0x53"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Dividend"
      },
      {
        "name": "rs2",
        "desc": "Divisor"
      }
    ],
    "pseudocode": "F[rd] = F[rs1] / F[rs2];",
    "example": "FDIV.D f0, f1, f2",
    "example_note": "64-bit float division."
  },
  {
    "mnemonic": "AMOOR.W",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic OR Word",
    "summary": "Atomically performs bitwise OR on a word in memory.",
    "syntax": "AMOOR.W rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "01000 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
      "hex_opcode": "0x2F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Operand"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp | R[rs2]; R[rd] = temp;",
    "example": "AMOOR.W x10, x11, (x12)",
    "example_note": "Atomic OR."
  },
  {
    "mnemonic": "AMOXOR.W",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic XOR Word",
    "summary": "Atomically performs bitwise XOR on a word in memory.",
    "syntax": "AMOXOR.W rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "00100 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
      "hex_opcode": "0x2F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Operand"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp ^ R[rs2]; R[rd] = temp;",
    "example": "AMOXOR.W x10, x11, (x12)",
    "example_note": "Atomic XOR."
  },
  {
    "mnemonic": "AMOMAX.W",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic Max Word",
    "summary": "Atomically updates memory with the maximum of the memory value and register value (Signed).",
    "syntax": "AMOMAX.W rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "10100 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
      "hex_opcode": "0x2F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Operand"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = max(temp, R[rs2]); R[rd] = temp;",
    "example": "AMOMAX.W x10, x11, (x12)",
    "example_note": "Atomic Signed Max."
  },
  {
    "mnemonic": "AMOMIN.W",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic Min Word",
    "summary": "Atomically updates memory with the minimum of the memory value and register value (Signed).",
    "syntax": "AMOMIN.W rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "10000 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
      "hex_opcode": "0x2F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Operand"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = min(temp, R[rs2]); R[rd] = temp;",
    "example": "AMOMIN.W x10, x11, (x12)",
    "example_note": "Atomic Signed Min."
  },
  {
    "mnemonic": "URET",
    "architecture": "RISC-V",
    "extension": "Privileged",
    "full_name": "User Return",
    "summary": "Returns from a user-mode trap handler (requires N extension).",
    "syntax": "URET",
    "encoding": {
      "format": "R-Type (System)",
      "binary_pattern": "0000000 | 00010 | 00000 | 000 | 00000 | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [],
    "pseudocode": "PC = UEPC; Priv = U; UIE = UPIE;",
    "example": "URET",
    "example_note": "Return from User-mode exception."
  },
  {
    "mnemonic": "NOP",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "No Operation",
    "summary": "Performs no operation. Used for alignment or timing delays.",
    "syntax": "NOP",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "ADDI x0, x0, 0",
      "hex_opcode": "0x00000013"
    },
    "operands": [],
    "pseudocode": "R[0] = R[0] + 0;",
    "example": "NOP",
    "example_note": "Does nothing."
  },
  {
    "mnemonic": "MV",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Move",
    "summary": "Copies the value of one register into another.",
    "syntax": "MV rd, rs",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "ADDI rd, rs, 0",
      "hex_opcode": "See ADDI"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination"
      },
      {
        "name": "rs",
        "desc": "Source"
      }
    ],
    "pseudocode": "R[rd] = R[rs];",
    "example": "MV x10, x11",
    "example_note": "Copies x11 to x10."
  },
  {
    "mnemonic": "LI",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Load Immediate",
    "summary": "Loads an arbitrary immediate value into a register.",
    "syntax": "LI rd, imm",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "LUI + ADDI",
      "hex_opcode": "Variable"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination"
      },
      {
        "name": "imm",
        "desc": "Immediate Value"
      }
    ],
    "pseudocode": "R[rd] = imm;",
    "example": "LI x5, 0x12345",
    "example_note": "Expands to: LUI x5, 0x12; ADDI x5, x5, 0x345"
  },
  {
    "mnemonic": "RET",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Return",
    "summary": "Returns from a subroutine call.",
    "syntax": "RET",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "JALR x0, 0(x1)",
      "hex_opcode": "0x00008067"
    },
    "operands": [],
    "pseudocode": "PC = R[1];",
    "example": "RET",
    "example_note": "Jumps to the address in the Return Address register (ra/x1)."
  },
  {
    "mnemonic": "J",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Jump",
    "summary": "Unconditionally jumps to a target offset.",
    "syntax": "J offset",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "JAL x0, offset",
      "hex_opcode": "See JAL"
    },
    "operands": [
      {
        "name": "offset",
        "desc": "Jump Target"
      }
    ],
    "pseudocode": "PC += sext(offset);",
    "example": "J label",
    "example_note": "Unconditional jump (discarding return address)."
  },
  {
    "mnemonic": "JR",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Jump Register",
    "summary": "Unconditionally jumps to an address held in a register.",
    "syntax": "JR rs",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "JALR x0, 0(rs)",
      "hex_opcode": "See JALR"
    },
    "operands": [
      {
        "name": "rs",
        "desc": "Address Register"
      }
    ],
    "pseudocode": "PC = R[rs];",
    "example": "JR x10",
    "example_note": "Jump to address stored in x10."
  },
  {
    "mnemonic": "CALL",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Call Subroutine",
    "summary": "Calls a function by jumping to an address and saving the return address.",
    "syntax": "CALL symbol",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "AUIPC + JALR",
      "hex_opcode": "Variable"
    },
    "operands": [
      {
        "name": "symbol",
        "desc": "Function Name"
      }
    ],
    "pseudocode": "x1 = PC + 4; PC = symbol;",
    "example": "CALL printf",
    "example_note": "Sets up x1 (ra) and jumps to printf."
  },
  {
    "mnemonic": "NOT",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Bitwise NOT",
    "summary": "Computes the bitwise logical negation (one's complement).",
    "syntax": "NOT rd, rs",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "XORI rd, rs, -1",
      "hex_opcode": "See XORI"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination"
      },
      {
        "name": "rs",
        "desc": "Source"
      }
    ],
    "pseudocode": "R[rd] = ~R[rs];",
    "example": "NOT x10, x11",
    "example_note": "Inverts all bits of x11."
  },
  {
    "mnemonic": "NEG",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Negate",
    "summary": "Computes the two's complement negation (arithmetic negative).",
    "syntax": "NEG rd, rs",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "SUB rd, x0, rs",
      "hex_opcode": "See SUB"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination"
      },
      {
        "name": "rs",
        "desc": "Source"
      }
    ],
    "pseudocode": "R[rd] = 0 - R[rs];",
    "example": "NEG x5, x6",
    "example_note": "x5 = -x6"
  },
  {
    "mnemonic": "BEQZ",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Branch if Equal to Zero",
    "summary": "Branches if the register is zero.",
    "syntax": "BEQZ rs, offset",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "BEQ rs, x0, offset",
      "hex_opcode": "See BEQ"
    },
    "operands": [
      {
        "name": "rs",
        "desc": "Source"
      },
      {
        "name": "offset",
        "desc": "Label"
      }
    ],
    "pseudocode": "if (R[rs] == 0) PC += offset;",
    "example": "BEQZ x10, exit",
    "example_note": "Jump to exit if x10 is zero."
  },
  {
    "mnemonic": "BNEZ",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Branch if Not Equal to Zero",
    "summary": "Branches if the register is not zero.",
    "syntax": "BNEZ rs, offset",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "BNE rs, x0, offset",
      "hex_opcode": "See BNE"
    },
    "operands": [
      {
        "name": "rs",
        "desc": "Source"
      },
      {
        "name": "offset",
        "desc": "Label"
      }
    ],
    "pseudocode": "if (R[rs] != 0) PC += offset;",
    "example": "BNEZ x10, loop",
    "example_note": "Jump to loop if x10 is not zero."
  },
  {
    "mnemonic": "SEQZ",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Set if Equal to Zero",
    "summary": "Sets rd to 1 if rs is zero, otherwise 0.",
    "syntax": "SEQZ rd, rs",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "SLTIU rd, rs, 1",
      "hex_opcode": "See SLTIU"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs",
        "desc": "Source"
      }
    ],
    "pseudocode": "R[rd] = (R[rs] == 0) ? 1 : 0;",
    "example": "SEQZ x5, x10",
    "example_note": "Sets x5 to 1 if x10 is 0."
  },
  {
    "mnemonic": "SNEZ",
    "architecture": "RISC-V",
    "extension": "Pseudo",
    "full_name": "Set if Not Equal to Zero",
    "summary": "Sets rd to 1 if rs is not zero, otherwise 0.",
    "syntax": "SNEZ rd, rs",
    "encoding": {
      "format": "Pseudo",
      "binary_pattern": "SLTU rd, x0, rs",
      "hex_opcode": "See SLTU"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs",
        "desc": "Source"
      }
    ],
    "pseudocode": "R[rd] = (R[rs] != 0) ? 1 : 0;",
    "example": "SNEZ x5, x10",
    "example_note": "Sets x5 to 1 if x10 is non-zero."
  },
  {
    "mnemonic": "C.ADDI4SPN",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Add Immediate to Stack Pointer (Non-zero)",
    "summary": "Adds a zero-extended non-zero immediate to the stack pointer (x2) and stores the result in a register.",
    "syntax": "C.ADDI4SPN rd', uimm",
    "encoding": {
      "format": "CIW",
      "binary_pattern": "000 | uimm | rd' | 00",
      "hex_opcode": "00"
    },
    "operands": [
      {
        "name": "rd'",
        "desc": "Dest (x8-x15)"
      },
      {
        "name": "uimm",
        "desc": "Immediate"
      }
    ],
    "pseudocode": "R[rd'] = R[2] + zext(uimm);",
    "example": "C.ADDI4SPN x8, 16",
    "example_note": "Load address of stack object."
  },
  {
    "mnemonic": "C.LW",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Load Word",
    "summary": "Loads a 32-bit word from memory using a compressed encoding.",
    "syntax": "C.LW rd', offset(rs1')",
    "encoding": {
      "format": "CL",
      "binary_pattern": "010 | imm | rs1' | imm | rd' | 00",
      "hex_opcode": "00"
    },
    "operands": [
      {
        "name": "rd'",
        "desc": "Dest (x8-x15)"
      },
      {
        "name": "rs1'",
        "desc": "Base (x8-x15)"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "R[rd'] = M[R[rs1'] + offset][31:0];",
    "example": "C.LW x8, 4(x9)",
    "example_note": "16-bit encoding of LW."
  },
  {
    "mnemonic": "C.SW",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Store Word",
    "summary": "Stores a 32-bit word to memory using a compressed encoding.",
    "syntax": "C.SW rs2', offset(rs1')",
    "encoding": {
      "format": "CS",
      "binary_pattern": "110 | imm | rs1' | imm | rs2' | 00",
      "hex_opcode": "00"
    },
    "operands": [
      {
        "name": "rs2'",
        "desc": "Source (x8-x15)"
      },
      {
        "name": "rs1'",
        "desc": "Base (x8-x15)"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "M[R[rs1'] + offset][31:0] = R[rs2'];",
    "example": "C.SW x8, 4(x9)",
    "example_note": "16-bit encoding of SW."
  },
  {
    "mnemonic": "C.ADDI",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Add Immediate",
    "summary": "Adds a non-zero immediate to a register.",
    "syntax": "C.ADDI rd, imm",
    "encoding": {
      "format": "CI",
      "binary_pattern": "000 | imm | rd | imm | 01",
      "hex_opcode": "01"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest/Source"
      },
      {
        "name": "imm",
        "desc": "6-bit Signed Imm"
      }
    ],
    "pseudocode": "R[rd] = R[rd] + sext(imm);",
    "example": "C.ADDI x10, 1",
    "example_note": "Increment x10."
  },
  {
    "mnemonic": "C.JAL",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Jump and Link",
    "summary": "Performs a PC-relative jump and stores return address in x1 (ra). RV32 only.",
    "syntax": "C.JAL offset",
    "encoding": {
      "format": "CJ",
      "binary_pattern": "001 | imm | 01",
      "hex_opcode": "01"
    },
    "operands": [
      {
        "name": "offset",
        "desc": "Jump Target"
      }
    ],
    "pseudocode": "R[1] = PC + 2; PC += sext(offset);",
    "example": "C.JAL func",
    "example_note": "Compressed function call."
  },
  {
    "mnemonic": "C.LI",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Load Immediate",
    "summary": "Loads a 6-bit signed immediate into a register.",
    "syntax": "C.LI rd, imm",
    "encoding": {
      "format": "CI",
      "binary_pattern": "010 | imm | rd | imm | 01",
      "hex_opcode": "01"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "imm",
        "desc": "Immediate"
      }
    ],
    "pseudocode": "R[rd] = sext(imm);",
    "example": "C.LI x10, 1",
    "example_note": "Set x10 to 1."
  },
  {
    "mnemonic": "C.ADDI16SP",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Add Immediate to Stack Pointer",
    "summary": "Adds a signed non-zero immediate to the stack pointer (x2).",
    "syntax": "C.ADDI16SP imm",
    "encoding": {
      "format": "CI",
      "binary_pattern": "011 | imm | 00010 | imm | 01",
      "hex_opcode": "01"
    },
    "operands": [
      {
        "name": "imm",
        "desc": "Signed Imm * 16"
      }
    ],
    "pseudocode": "R[2] = R[2] + sext(imm);",
    "example": "C.ADDI16SP -64",
    "example_note": "Allocate 64 bytes on stack."
  },
  {
    "mnemonic": "C.LUI",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Load Upper Immediate",
    "summary": "Loads a non-zero 6-bit immediate into bits 17-12 of the destination register, clears lower 12 bits, sign-extends bit 17.",
    "syntax": "C.LUI rd, imm",
    "encoding": {
      "format": "CI",
      "binary_pattern": "011 | imm | rd | imm | 01",
      "hex_opcode": "01"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "imm",
        "desc": "Immediate"
      }
    ],
    "pseudocode": "R[rd] = sext(imm << 12);",
    "example": "C.LUI x10, 1",
    "example_note": "Loads 0x1000 into x10."
  },
  {
    "mnemonic": "C.SRLI",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Shift Right Logical Immediate",
    "summary": "Logically shifts a register right by immediate.",
    "syntax": "C.SRLI rd', imm",
    "encoding": {
      "format": "CB",
      "binary_pattern": "100 | imm | 00 | imm | rd' | 01",
      "hex_opcode": "01"
    },
    "operands": [
      {
        "name": "rd'",
        "desc": "Dest/Source (x8-x15)"
      },
      {
        "name": "imm",
        "desc": "Shift Amount"
      }
    ],
    "pseudocode": "R[rd'] = R[rd'] >> imm;",
    "example": "C.SRLI x8, 2",
    "example_note": "x8 = x8 >> 2"
  },
  {
    "mnemonic": "C.SRAI",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Shift Right Arithmetic Immediate",
    "summary": "Arithmetically shifts a register right by immediate.",
    "syntax": "C.SRAI rd', imm",
    "encoding": {
      "format": "CB",
      "binary_pattern": "100 | imm | 01 | imm | rd' | 01",
      "hex_opcode": "01"
    },
    "operands": [
      {
        "name": "rd'",
        "desc": "Dest/Source"
      },
      {
        "name": "imm",
        "desc": "Shift Amount"
      }
    ],
    "pseudocode": "R[rd'] = R[rd'] >>s imm;",
    "example": "C.SRAI x8, 2",
    "example_note": "x8 = x8 >>s 2"
  },
  {
    "mnemonic": "C.ANDI",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed AND Immediate",
    "summary": "Computes bitwise AND with a signed immediate.",
    "syntax": "C.ANDI rd', imm",
    "encoding": {
      "format": "CB",
      "binary_pattern": "100 | imm | 10 | imm | rd' | 01",
      "hex_opcode": "01"
    },
    "operands": [
      {
        "name": "rd'",
        "desc": "Dest/Source"
      },
      {
        "name": "imm",
        "desc": "Signed Imm"
      }
    ],
    "pseudocode": "R[rd'] = R[rd'] & sext(imm);",
    "example": "C.ANDI x8, 15",
    "example_note": "Keep lowest 4 bits."
  },
  {
    "mnemonic": "C.SUB",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Subtract",
    "summary": "Subtracts two registers.",
    "syntax": "C.SUB rd', rs2'",
    "encoding": {
      "format": "CA",
      "binary_pattern": "100011 | rd' | 00 | rs2' | 01",
      "hex_opcode": "01"
    },
    "operands": [
      {
        "name": "rd'",
        "desc": "Dest/Src1"
      },
      {
        "name": "rs2'",
        "desc": "Src2"
      }
    ],
    "pseudocode": "R[rd'] = R[rd'] - R[rs2'];",
    "example": "C.SUB x8, x9",
    "example_note": "x8 = x8 - x9"
  },
  {
    "mnemonic": "C.XOR",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed XOR",
    "summary": "Bitwise XOR of two registers.",
    "syntax": "C.XOR rd', rs2'",
    "encoding": {
      "format": "CA",
      "binary_pattern": "100011 | rd' | 01 | rs2' | 01",
      "hex_opcode": "01"
    },
    "operands": [
      {
        "name": "rd'",
        "desc": "Dest/Src1"
      },
      {
        "name": "rs2'",
        "desc": "Src2"
      }
    ],
    "pseudocode": "R[rd'] = R[rd'] ^ R[rs2'];",
    "example": "C.XOR x8, x9",
    "example_note": "x8 = x8 ^ x9"
  },
  {
    "mnemonic": "C.OR",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed OR",
    "summary": "Bitwise OR of two registers.",
    "syntax": "C.OR rd', rs2'",
    "encoding": {
      "format": "CA",
      "binary_pattern": "100011 | rd' | 10 | rs2' | 01",
      "hex_opcode": "01"
    },
    "operands": [
      {
        "name": "rd'",
        "desc": "Dest/Src1"
      },
      {
        "name": "rs2'",
        "desc": "Src2"
      }
    ],
    "pseudocode": "R[rd'] = R[rd'] | R[rs2'];",
    "example": "C.OR x8, x9",
    "example_note": "x8 = x8 | x9"
  },
  {
    "mnemonic": "C.AND",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed AND",
    "summary": "Bitwise AND of two registers.",
    "syntax": "C.AND rd', rs2'",
    "encoding": {
      "format": "CA",
      "binary_pattern": "100011 | rd' | 11 | rs2' | 01",
      "hex_opcode": "01"
    },
    "operands": [
      {
        "name": "rd'",
        "desc": "Dest/Src1"
      },
      {
        "name": "rs2'",
        "desc": "Src2"
      }
    ],
    "pseudocode": "R[rd'] = R[rd'] & R[rs2'];",
    "example": "C.AND x8, x9",
    "example_note": "x8 = x8 & x9"
  },
  {
    "mnemonic": "C.J",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Jump",
    "summary": "Unconditional PC-relative jump.",
    "syntax": "C.J offset",
    "encoding": {
      "format": "CJ",
      "binary_pattern": "101 | imm | 01",
      "hex_opcode": "01"
    },
    "operands": [
      {
        "name": "offset",
        "desc": "Target"
      }
    ],
    "pseudocode": "PC += sext(offset);",
    "example": "C.J label",
    "example_note": "Jump to label."
  },
  {
    "mnemonic": "C.BEQZ",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Branch if Equal to Zero",
    "summary": "Branches if the register is zero.",
    "syntax": "C.BEQZ rs1', offset",
    "encoding": {
      "format": "CB",
      "binary_pattern": "110 | imm | rs1' | imm | 01",
      "hex_opcode": "01"
    },
    "operands": [
      {
        "name": "rs1'",
        "desc": "Source"
      },
      {
        "name": "offset",
        "desc": "Target"
      }
    ],
    "pseudocode": "if (R[rs1'] == 0) PC += sext(offset);",
    "example": "C.BEQZ x8, exit",
    "example_note": "Jump if x8 is 0."
  },
  {
    "mnemonic": "C.BNEZ",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Branch if Not Equal to Zero",
    "summary": "Branches if the register is not zero.",
    "syntax": "C.BNEZ rs1', offset",
    "encoding": {
      "format": "CB",
      "binary_pattern": "111 | imm | rs1' | imm | 01",
      "hex_opcode": "01"
    },
    "operands": [
      {
        "name": "rs1'",
        "desc": "Source"
      },
      {
        "name": "offset",
        "desc": "Target"
      }
    ],
    "pseudocode": "if (R[rs1'] != 0) PC += sext(offset);",
    "example": "C.BNEZ x8, loop",
    "example_note": "Jump if x8 is not 0."
  },
  {
    "mnemonic": "C.SLLI",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Shift Left Logical Immediate",
    "summary": "Logically shifts a register left by immediate.",
    "syntax": "C.SLLI rd, imm",
    "encoding": {
      "format": "CI",
      "binary_pattern": "000 | imm | rd | imm | 10",
      "hex_opcode": "02"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest/Source"
      },
      {
        "name": "imm",
        "desc": "Shift Amount"
      }
    ],
    "pseudocode": "R[rd] = R[rd] << imm;",
    "example": "C.SLLI x10, 2",
    "example_note": "x10 = x10 << 2"
  },
  {
    "mnemonic": "C.LWSP",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Load Word from Stack Pointer",
    "summary": "Loads a word from the stack pointer (x2).",
    "syntax": "C.LWSP rd, offset(x2)",
    "encoding": {
      "format": "CI",
      "binary_pattern": "010 | imm | rd | imm | 10",
      "hex_opcode": "02"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "R[rd] = M[R[2] + offset][31:0];",
    "example": "C.LWSP x10, 4(x2)",
    "example_note": "Load from stack."
  },
  {
    "mnemonic": "C.SWSP",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Store Word to Stack Pointer",
    "summary": "Stores a word to the stack pointer (x2).",
    "syntax": "C.SWSP rs2, offset(x2)",
    "encoding": {
      "format": "CSS",
      "binary_pattern": "110 | imm | rs2 | 10",
      "hex_opcode": "02"
    },
    "operands": [
      {
        "name": "rs2",
        "desc": "Source"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "M[R[2] + offset][31:0] = R[rs2];",
    "example": "C.SWSP x10, 8(x2)",
    "example_note": "Store to stack."
  },
  {
    "mnemonic": "C.JR",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Jump Register",
    "summary": "Unconditionally jumps to address in register.",
    "syntax": "C.JR rs1",
    "encoding": {
      "format": "CR",
      "binary_pattern": "1000 | rs1 | 00000 | 10",
      "hex_opcode": "02"
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "PC = R[rs1];",
    "example": "C.JR x1",
    "example_note": "Return (if x1 is ra)."
  },
  {
    "mnemonic": "C.MV",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Move",
    "summary": "Copies register rs2 to rd.",
    "syntax": "C.MV rd, rs2",
    "encoding": {
      "format": "CR",
      "binary_pattern": "1000 | rd | rs2 | 10",
      "hex_opcode": "02"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs2",
        "desc": "Source"
      }
    ],
    "pseudocode": "R[rd] = R[rs2];",
    "example": "C.MV x10, x11",
    "example_note": "Copy x11 to x10."
  },
  {
    "mnemonic": "C.EBREAK",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Environment Break",
    "summary": "Triggers a debugger breakpoint.",
    "syntax": "C.EBREAK",
    "encoding": {
      "format": "CR",
      "binary_pattern": "1001000000000010",
      "hex_opcode": "9002"
    },
    "operands": [],
    "pseudocode": "RaiseException(Breakpoint);",
    "example": "C.EBREAK",
    "example_note": "Break."
  },
  {
    "mnemonic": "C.JALR",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Jump and Link Register",
    "summary": "Jumps to register address and links (saves PC+2 to ra).",
    "syntax": "C.JALR rs1",
    "encoding": {
      "format": "CR",
      "binary_pattern": "1001 | rs1 | 00000 | 10",
      "hex_opcode": "02"
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "t = PC + 2; PC = R[rs1]; R[1] = t;",
    "example": "C.JALR x10",
    "example_note": "Call function pointer in x10."
  },
  {
    "mnemonic": "C.ADD",
    "architecture": "RISC-V",
    "extension": "C (Compressed)",
    "full_name": "Compressed Add",
    "summary": "Adds two registers.",
    "syntax": "C.ADD rd, rs2",
    "encoding": {
      "format": "CR",
      "binary_pattern": "1001 | rd | rs2 | 10",
      "hex_opcode": "02"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest/Src1"
      },
      {
        "name": "rs2",
        "desc": "Src2"
      }
    ],
    "pseudocode": "R[rd] = R[rd] + R[rs2];",
    "example": "C.ADD x10, x11",
    "example_note": "x10 = x10 + x11"
  },
  {
    "mnemonic": "SUBW",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Subtract Word",
    "summary": "Subtracts the lower 32 bits of rs2 from rs1 and sign-extends the result to 64 bits.",
    "syntax": "SUBW rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0100000 | rs2 | rs1 | 000 | rd | 0111011",
      "hex_opcode": "0x3B"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Minuend"
      },
      {
        "name": "rs2",
        "desc": "Subtrahend"
      }
    ],
    "pseudocode": "R[rd] = sext((R[rs1] - R[rs2])[31:0]);",
    "example": "SUBW x10, x11, x12",
    "example_note": "32-bit subtraction on 64-bit registers."
  },
  {
    "mnemonic": "SLLW",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Shift Left Logical Word",
    "summary": "Performs a 32-bit logical left shift on rs1 by the amount in rs2 (lower 5 bits), sign-extending the result.",
    "syntax": "SLLW rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 001 | rd | 0111011",
      "hex_opcode": "0x3B"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "rs2",
        "desc": "Shift Amount"
      }
    ],
    "pseudocode": "R[rd] = sext((R[rs1] << (R[rs2] & 0x1F))[31:0]);",
    "example": "SLLW x5, x6, x7",
    "example_note": "32-bit shift."
  },
  {
    "mnemonic": "SRLW",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Shift Right Logical Word",
    "summary": "Performs a 32-bit logical right shift on rs1 by the amount in rs2, sign-extending the result.",
    "syntax": "SRLW rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 101 | rd | 0111011",
      "hex_opcode": "0x3B"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "rs2",
        "desc": "Shift Amount"
      }
    ],
    "pseudocode": "R[rd] = sext((R[rs1][31:0] >>u (R[rs2] & 0x1F)));",
    "example": "SRLW x5, x6, x7",
    "example_note": "32-bit logical right shift."
  },
  {
    "mnemonic": "SRAW",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Shift Right Arithmetic Word",
    "summary": "Performs a 32-bit arithmetic right shift on rs1, sign-extending the result.",
    "syntax": "SRAW rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0100000 | rs2 | rs1 | 101 | rd | 0111011",
      "hex_opcode": "0x3B"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "rs2",
        "desc": "Shift Amount"
      }
    ],
    "pseudocode": "R[rd] = sext((R[rs1][31:0] >>s (R[rs2] & 0x1F)));",
    "example": "SRAW x5, x6, x7",
    "example_note": "32-bit arithmetic right shift."
  },
  {
    "mnemonic": "SLLIW",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Shift Left Logical Immediate Word",
    "summary": "Shifts the lower 32 bits of rs1 left by a constant, sign-extending the result.",
    "syntax": "SLLIW rd, rs1, shamt",
    "encoding": {
      "format": "I-Type (Shift)",
      "binary_pattern": "0000000 | shamt | rs1 | 001 | rd | 0011011",
      "hex_opcode": "0x1B"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "shamt",
        "desc": "Shift Amount (0-31)"
      }
    ],
    "pseudocode": "R[rd] = sext((R[rs1] << shamt)[31:0]);",
    "example": "SLLIW x10, x11, 4",
    "example_note": "Shift lower 32 bits left by 4."
  },
  {
    "mnemonic": "SRLIW",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Shift Right Logical Immediate Word",
    "summary": "Logically shifts the lower 32 bits of rs1 right by a constant, sign-extending the result.",
    "syntax": "SRLIW rd, rs1, shamt",
    "encoding": {
      "format": "I-Type (Shift)",
      "binary_pattern": "0000000 | shamt | rs1 | 101 | rd | 0011011",
      "hex_opcode": "0x1B"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "shamt",
        "desc": "Shift Amount"
      }
    ],
    "pseudocode": "R[rd] = sext((R[rs1][31:0] >>u shamt));",
    "example": "SRLIW x10, x11, 4",
    "example_note": "Logical right shift of lower word."
  },
  {
    "mnemonic": "SRAIW",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Shift Right Arithmetic Immediate Word",
    "summary": "Arithmetically shifts the lower 32 bits of rs1 right by a constant, sign-extending the result.",
    "syntax": "SRAIW rd, rs1, shamt",
    "encoding": {
      "format": "I-Type (Shift)",
      "binary_pattern": "0100000 | shamt | rs1 | 101 | rd | 0011011",
      "hex_opcode": "0x1B"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "shamt",
        "desc": "Shift Amount"
      }
    ],
    "pseudocode": "R[rd] = sext((R[rs1][31:0] >>s shamt));",
    "example": "SRAIW x10, x11, 4",
    "example_note": "Arithmetic right shift of lower word."
  },
  {
    "mnemonic": "MULW",
    "architecture": "RISC-V",
    "extension": "M (RV64)",
    "full_name": "Multiply Word",
    "summary": "Performs 32-bit multiplication of rs1 and rs2, sign-extending the 32-bit result to 64 bits.",
    "syntax": "MULW rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000001 | rs2 | rs1 | 000 | rd | 0111011",
      "hex_opcode": "0x3B"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "R[rd] = sext((R[rs1] * R[rs2])[31:0]);",
    "example": "MULW x10, x11, x12",
    "example_note": "32-bit multiplication."
  },
  {
    "mnemonic": "DIVW",
    "architecture": "RISC-V",
    "extension": "M (RV64)",
    "full_name": "Divide Word",
    "summary": "Performs 32-bit signed division of rs1 by rs2, sign-extending the result.",
    "syntax": "DIVW rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000001 | rs2 | rs1 | 100 | rd | 0111011",
      "hex_opcode": "0x3B"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Quotient"
      },
      {
        "name": "rs1",
        "desc": "Dividend"
      },
      {
        "name": "rs2",
        "desc": "Divisor"
      }
    ],
    "pseudocode": "R[rd] = sext(R[rs1][31:0] /s R[rs2][31:0]);",
    "example": "DIVW x10, x11, x12",
    "example_note": "32-bit signed division."
  },
  {
    "mnemonic": "DIVUW",
    "architecture": "RISC-V",
    "extension": "M (RV64)",
    "full_name": "Divide Unsigned Word",
    "summary": "Performs 32-bit unsigned division of rs1 by rs2, sign-extending the result.",
    "syntax": "DIVUW rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000001 | rs2 | rs1 | 101 | rd | 0111011",
      "hex_opcode": "0x3B"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Quotient"
      },
      {
        "name": "rs1",
        "desc": "Dividend"
      },
      {
        "name": "rs2",
        "desc": "Divisor"
      }
    ],
    "pseudocode": "R[rd] = sext(R[rs1][31:0] /u R[rs2][31:0]);",
    "example": "DIVUW x10, x11, x12",
    "example_note": "32-bit unsigned division."
  },
  {
    "mnemonic": "REMW",
    "architecture": "RISC-V",
    "extension": "M (RV64)",
    "full_name": "Remainder Word",
    "summary": "Computes the remainder of 32-bit signed division, sign-extending the result.",
    "syntax": "REMW rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000001 | rs2 | rs1 | 110 | rd | 0111011",
      "hex_opcode": "0x3B"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Remainder"
      },
      {
        "name": "rs1",
        "desc": "Dividend"
      },
      {
        "name": "rs2",
        "desc": "Divisor"
      }
    ],
    "pseudocode": "R[rd] = sext(R[rs1][31:0] %s R[rs2][31:0]);",
    "example": "REMW x10, x11, x12",
    "example_note": "32-bit signed remainder."
  },
  {
    "mnemonic": "REMUW",
    "architecture": "RISC-V",
    "extension": "M (RV64)",
    "full_name": "Remainder Unsigned Word",
    "summary": "Computes the remainder of 32-bit unsigned division, sign-extending the result.",
    "syntax": "REMUW rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000001 | rs2 | rs1 | 111 | rd | 0111011",
      "hex_opcode": "0x3B"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Remainder"
      },
      {
        "name": "rs1",
        "desc": "Dividend"
      },
      {
        "name": "rs2",
        "desc": "Divisor"
      }
    ],
    "pseudocode": "R[rd] = sext(R[rs1][31:0] %u R[rs2][31:0]);",
    "example": "REMUW x10, x11, x12",
    "example_note": "32-bit unsigned remainder."
  },
  {
    "mnemonic": "FENCE.I",
    "architecture": "RISC-V",
    "extension": "Zifencei",
    "full_name": "Instruction Fence",
    "summary": "Synchronizes the instruction cache with the data cache (used after self-modifying code).",
    "syntax": "FENCE.I",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "000000000000 | 00000 | 001 | 00000 | 0001111",
      "hex_opcode": "0x0F"
    },
    "operands": [],
    "pseudocode": "Fence(Store, Fetch);",
    "example": "FENCE.I",
    "example_note": "Flushes I-Cache; ensures previous writes are visible to instruction fetch."
  },
  {
    "mnemonic": "AMOADD.D",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic Add Doubleword",
    "summary": "Atomically adds a value to a 64-bit doubleword in memory.",
    "syntax": "AMOADD.D rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "00000 | aq | rl | rs2 | rs1 | 011 | rd | 0101111",
      "hex_opcode": "0x2F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Value to Add"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp + R[rs2]; R[rd] = temp;",
    "example": "AMOADD.D x10, x11, (x12)",
    "example_note": "64-bit atomic add."
  },
  {
    "mnemonic": "AMOSWAP.D",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic Swap Doubleword",
    "summary": "Atomically swaps a 64-bit value in memory with a register.",
    "syntax": "AMOSWAP.D rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "00001 | aq | rl | rs2 | rs1 | 011 | rd | 0101111",
      "hex_opcode": "0x2F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "New Value"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = R[rs2]; R[rd] = temp;",
    "example": "AMOSWAP.D x10, x11, (x12)",
    "example_note": "64-bit atomic swap."
  },
  {
    "mnemonic": "AMOAND.D",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic AND Doubleword",
    "summary": "Atomically performs bitwise AND on a 64-bit doubleword in memory.",
    "syntax": "AMOAND.D rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "01100 | aq | rl | rs2 | rs1 | 011 | rd | 0101111",
      "hex_opcode": "0x2F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Operand"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp & R[rs2]; R[rd] = temp;",
    "example": "AMOAND.D x5, x6, (x7)",
    "example_note": "64-bit atomic AND."
  },
  {
    "mnemonic": "AMOOR.D",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic OR Doubleword",
    "summary": "Atomically performs bitwise OR on a 64-bit doubleword in memory.",
    "syntax": "AMOOR.D rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "01000 | aq | rl | rs2 | rs1 | 011 | rd | 0101111",
      "hex_opcode": "0x2F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Operand"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp | R[rs2]; R[rd] = temp;",
    "example": "AMOOR.D x10, x11, (x12)",
    "example_note": "64-bit atomic OR."
  },
  {
    "mnemonic": "AMOXOR.D",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic XOR Doubleword",
    "summary": "Atomically performs bitwise XOR on a 64-bit doubleword in memory.",
    "syntax": "AMOXOR.D rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "00100 | aq | rl | rs2 | rs1 | 011 | rd | 0101111",
      "hex_opcode": "0x2F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Operand"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp ^ R[rs2]; R[rd] = temp;",
    "example": "AMOXOR.D x10, x11, (x12)",
    "example_note": "64-bit atomic XOR."
  },
  {
    "mnemonic": "AMOMAX.D",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic Max Doubleword",
    "summary": "Atomically updates memory with the maximum of the memory value and register value (64-bit Signed).",
    "syntax": "AMOMAX.D rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "10100 | aq | rl | rs2 | rs1 | 011 | rd | 0101111",
      "hex_opcode": "0x2F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Operand"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = max(temp, R[rs2]); R[rd] = temp;",
    "example": "AMOMAX.D x10, x11, (x12)",
    "example_note": "64-bit atomic max."
  },
  {
    "mnemonic": "AMOMIN.D",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic Min Doubleword",
    "summary": "Atomically updates memory with the minimum of the memory value and register value (64-bit Signed).",
    "syntax": "AMOMIN.D rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "10000 | aq | rl | rs2 | rs1 | 011 | rd | 0101111",
      "hex_opcode": "0x2F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Operand"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = min(temp, R[rs2]); R[rd] = temp;",
    "example": "AMOMIN.D x10, x11, (x12)",
    "example_note": "64-bit atomic min."
  },
  {
    "mnemonic": "SC.D",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Store Conditional Doubleword",
    "summary": "Conditionally stores a 64-bit value to memory if the reservation is valid.",
    "syntax": "SC.D rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "00011 | aq | rl | rs2 | rs1 | 011 | rd | 0101111",
      "hex_opcode": "0x2F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (0=Success)"
      },
      {
        "name": "rs2",
        "desc": "Source Value"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "if (ReservationValid) { M[R[rs1]] = R[rs2]; R[rd] = 0; } else { R[rd] = 1; }",
    "example": "SC.D x10, x11, (x12)",
    "example_note": "64-bit conditional store."
  },
  {
    "mnemonic": "FMADD.S",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Float Fused Multiply-Add (Single)",
    "summary": "Computes (rs1 * rs2) + rs3 with a single rounding.",
    "syntax": "FMADD.S rd, rs1, rs2, rs3",
    "encoding": {
      "format": "R4-Type",
      "binary_pattern": "rs3 | 00 | rs2 | rs1 | rm | rd | 1000011",
      "hex_opcode": "0x43"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Src 1"
      },
      {
        "name": "rs2",
        "desc": "Src 2"
      },
      {
        "name": "rs3",
        "desc": "Src 3"
      }
    ],
    "pseudocode": "F[rd] = (F[rs1] * F[rs2]) + F[rs3];",
    "example": "FMADD.S f0, f1, f2, f3",
    "example_note": "f0 = (f1 * f2) + f3"
  },
  {
    "mnemonic": "FMADD.D",
    "architecture": "RISC-V",
    "extension": "D (Double)",
    "full_name": "Float Fused Multiply-Add (Double)",
    "summary": "Computes (rs1 * rs2) + rs3 with a single rounding (64-bit).",
    "syntax": "FMADD.D rd, rs1, rs2, rs3",
    "encoding": {
      "format": "R4-Type",
      "binary_pattern": "rs3 | 01 | rs2 | rs1 | rm | rd | 1000011",
      "hex_opcode": "0x43"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Src 1"
      },
      {
        "name": "rs2",
        "desc": "Src 2"
      },
      {
        "name": "rs3",
        "desc": "Src 3"
      }
    ],
    "pseudocode": "F[rd] = (F[rs1] * F[rs2]) + F[rs3];",
    "example": "FMADD.D f0, f1, f2, f3",
    "example_note": "64-bit fused multiply-add."
  },
  {
    "mnemonic": "FCVT.W.S",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Float Convert to Word (Single)",
    "summary": "Converts a single-precision floating-point number to a signed 32-bit integer.",
    "syntax": "FCVT.W.S rd, rs1",
    "encoding": {
      "format": "I-Type (Float)",
      "binary_pattern": "1100000 | 00000 | rs1 | rm | rd | 1010011",
      "hex_opcode": "0x53"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Integer)"
      },
      {
        "name": "rs1",
        "desc": "Source (Float)"
      }
    ],
    "pseudocode": "R[rd] = sext(f32_to_i32(F[rs1]));",
    "example": "FCVT.W.S x10, f1",
    "example_note": "Convert float f1 to int x10."
  },
  {
    "mnemonic": "FCVT.S.W",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Float Convert from Word (Single)",
    "summary": "Converts a signed 32-bit integer to a single-precision floating-point number.",
    "syntax": "FCVT.S.W rd, rs1",
    "encoding": {
      "format": "I-Type (Float)",
      "binary_pattern": "1101000 | 00000 | rs1 | rm | rd | 1010011",
      "hex_opcode": "0x53"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Float)"
      },
      {
        "name": "rs1",
        "desc": "Source (Integer)"
      }
    ],
    "pseudocode": "F[rd] = i32_to_f32(R[rs1]);",
    "example": "FCVT.S.W f1, x10",
    "example_note": "Convert int x10 to float f1."
  },
  {
    "mnemonic": "FCVT.D.S",
    "architecture": "RISC-V",
    "extension": "D",
    "full_name": "Float Convert Single to Double",
    "summary": "Converts a single-precision float to a double-precision float.",
    "syntax": "FCVT.D.S rd, rs1",
    "encoding": {
      "format": "I-Type (Float)",
      "binary_pattern": "0100001 | 00000 | rs1 | rm | rd | 1010011",
      "hex_opcode": "0x53"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Double)"
      },
      {
        "name": "rs1",
        "desc": "Source (Single)"
      }
    ],
    "pseudocode": "F[rd] = f32_to_f64(F[rs1]);",
    "example": "FCVT.D.S f0, f1",
    "example_note": "Promote float to double."
  },
  {
    "mnemonic": "FCVT.S.D",
    "architecture": "RISC-V",
    "extension": "D",
    "full_name": "Float Convert Double to Single",
    "summary": "Converts a double-precision float to a single-precision float.",
    "syntax": "FCVT.S.D rd, rs1",
    "encoding": {
      "format": "I-Type (Float)",
      "binary_pattern": "0100000 | 00001 | rs1 | rm | rd | 1010011",
      "hex_opcode": "0x53"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Single)"
      },
      {
        "name": "rs1",
        "desc": "Source (Double)"
      }
    ],
    "pseudocode": "F[rd] = f64_to_f32(F[rs1]);",
    "example": "FCVT.S.D f1, f0",
    "example_note": "Demote double to float."
  },
  {
    "mnemonic": "FSGNJ.S",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Float Sign Injection (Single)",
    "summary": "Injects the sign of rs2 into rs1. Used to copy values or manipulate signs.",
    "syntax": "FSGNJ.S rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0010000 | rs2 | rs1 | 000 | rd | 1010011",
      "hex_opcode": "0x53"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source (Body)"
      },
      {
        "name": "rs2",
        "desc": "Source (Sign)"
      }
    ],
    "pseudocode": "F[rd] = {F[rs2][31], F[rs1][30:0]};",
    "example": "FSGNJ.S f1, f2, f3",
    "example_note": "f1 gets magnitude of f2 and sign of f3."
  },
  {
    "mnemonic": "FSGNJN.S",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Float Sign Injection Negate (Single)",
    "summary": "Injects the *negated* sign of rs2 into rs1. Used for negation and absolute value.",
    "syntax": "FSGNJN.S rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0010000 | rs2 | rs1 | 001 | rd | 1010011",
      "hex_opcode": "0x53"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source (Body)"
      },
      {
        "name": "rs2",
        "desc": "Source (Sign)"
      }
    ],
    "pseudocode": "F[rd] = {~F[rs2][31], F[rs1][30:0]};",
    "example": "FSGNJN.S f1, f2, f2",
    "example_note": "Negates f2 (f1 = -f2)."
  },
  {
    "mnemonic": "FSGNJX.S",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Float Sign Injection XOR (Single)",
    "summary": "Injects the XOR of signs of rs1 and rs2. Used to copy sign.",
    "syntax": "FSGNJX.S rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0010000 | rs2 | rs1 | 010 | rd | 1010011",
      "hex_opcode": "0x53"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "F[rd] = {F[rs1][31] ^ F[rs2][31], F[rs1][30:0]};",
    "example": "FSGNJX.S f1, f1, f2",
    "example_note": "Logic similar to Abs(f1) if f2 is properly set."
  },
  {
    "mnemonic": "FEQ.S",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Float Equal (Single)",
    "summary": "Sets integer rd to 1 if float rs1 equals float rs2, else 0.",
    "syntax": "FEQ.S rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "1010000 | rs2 | rs1 | 010 | rd | 1010011",
      "hex_opcode": "0x53"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Integer)"
      },
      {
        "name": "rs1",
        "desc": "Src 1 (Float)"
      },
      {
        "name": "rs2",
        "desc": "Src 2 (Float)"
      }
    ],
    "pseudocode": "R[rd] = (F[rs1] == F[rs2]) ? 1 : 0;",
    "example": "FEQ.S x10, f1, f2",
    "example_note": "x10 = (f1 == f2)"
  },
  {
    "mnemonic": "FLT.S",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Float Less Than (Single)",
    "summary": "Sets integer rd to 1 if float rs1 is less than float rs2, else 0.",
    "syntax": "FLT.S rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "1010000 | rs2 | rs1 | 001 | rd | 1010011",
      "hex_opcode": "0x53"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Integer)"
      },
      {
        "name": "rs1",
        "desc": "Src 1 (Float)"
      },
      {
        "name": "rs2",
        "desc": "Src 2 (Float)"
      }
    ],
    "pseudocode": "R[rd] = (F[rs1] < F[rs2]) ? 1 : 0;",
    "example": "FLT.S x10, f1, f2",
    "example_note": "x10 = (f1 < f2)"
  },
  {
    "mnemonic": "FLE.S",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Float Less or Equal (Single)",
    "summary": "Sets integer rd to 1 if float rs1 is less than or equal to float rs2, else 0.",
    "syntax": "FLE.S rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "1010000 | rs2 | rs1 | 000 | rd | 1010011",
      "hex_opcode": "0x53"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Integer)"
      },
      {
        "name": "rs1",
        "desc": "Src 1 (Float)"
      },
      {
        "name": "rs2",
        "desc": "Src 2 (Float)"
      }
    ],
    "pseudocode": "R[rd] = (F[rs1] <= F[rs2]) ? 1 : 0;",
    "example": "FLE.S x10, f1, f2",
    "example_note": "x10 = (f1 <= f2)"
  },
  {
    "mnemonic": "FMV.X.W",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Move Float to Integer",
    "summary": "Moves the bit pattern of a floating-point register to an integer register.",
    "syntax": "FMV.X.W rd, rs1",
    "encoding": {
      "format": "I-Type (Float)",
      "binary_pattern": "1110000 | 00000 | rs1 | 000 | rd | 1010011",
      "hex_opcode": "0x53"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Integer)"
      },
      {
        "name": "rs1",
        "desc": "Source (Float)"
      }
    ],
    "pseudocode": "R[rd] = sext(F[rs1]);",
    "example": "FMV.X.W x10, f1",
    "example_note": "Copy bits from f1 to x10."
  },
  {
    "mnemonic": "FMV.W.X",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Move Integer to Float",
    "summary": "Moves the bit pattern of an integer register to a floating-point register.",
    "syntax": "FMV.W.X rd, rs1",
    "encoding": {
      "format": "I-Type (Float)",
      "binary_pattern": "1111000 | 00000 | rs1 | 000 | rd | 1010011",
      "hex_opcode": "0x53"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Float)"
      },
      {
        "name": "rs1",
        "desc": "Source (Integer)"
      }
    ],
    "pseudocode": "F[rd] = R[rs1];",
    "example": "FMV.W.X f1, x10",
    "example_note": "Copy bits from x10 to f1."
  },
  {
    "mnemonic": "VSETVLI",
    "architecture": "RISC-V",
    "extension": "V (Vector)",
    "full_name": "Vector Set VL Immediate",
    "summary": "Configures the vector length (vl) and vector type (vtype) based on application needs.",
    "syntax": "VSETVLI rd, rs1, vtypei",
    "encoding": {
      "format": "V-Type",
      "binary_pattern": "0 | zimm[10:0] | rs1 | 111 | rd | 1010111",
      "hex_opcode": "0x57"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Actual VL)"
      },
      {
        "name": "rs1",
        "desc": "Req VL (Avail)"
      },
      {
        "name": "vtypei",
        "desc": "Config (SEW/LMUL)"
      }
    ],
    "pseudocode": "vl = set_config(rs1, vtypei); R[rd] = vl;",
    "example": "VSETVLI t0, a0, e32, m1, ta, ma",
    "example_note": "Request VL=a0, 32-bit elements, 1 register group."
  },
  {
    "mnemonic": "VLE32.V",
    "architecture": "RISC-V",
    "extension": "V (Vector)",
    "full_name": "Vector Load Element (32-bit)",
    "summary": "Loads a vector of 32-bit elements from memory into a vector register.",
    "syntax": "VLE32.V vd, (rs1), vm",
    "encoding": {
      "format": "V-Load",
      "binary_pattern": "000000 | mop | vm | rs1 | 110 | vd | 0000111",
      "hex_opcode": "0x07"
    },
    "operands": [
      {
        "name": "vd",
        "desc": "Vector Dest"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "vm",
        "desc": "Mask"
      }
    ],
    "pseudocode": "foreach(i < vl): vd[i] = Mem[rs1 + i*4];",
    "example": "VLE32.V v8, (a0)",
    "example_note": "Load 32-bit integers from address in a0 to v8."
  },
  {
    "mnemonic": "VSE32.V",
    "architecture": "RISC-V",
    "extension": "V (Vector)",
    "full_name": "Vector Store Element (32-bit)",
    "summary": "Stores a vector of 32-bit elements from a vector register to memory.",
    "syntax": "VSE32.V vs3, (rs1), vm",
    "encoding": {
      "format": "V-Store",
      "binary_pattern": "000000 | mop | vm | rs1 | 110 | vs3 | 0100111",
      "hex_opcode": "0x27"
    },
    "operands": [
      {
        "name": "vs3",
        "desc": "Vector Source"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "vm",
        "desc": "Mask"
      }
    ],
    "pseudocode": "foreach(i < vl): Mem[rs1 + i*4] = vs3[i];",
    "example": "VSE32.V v8, (a0)",
    "example_note": "Store v8 to memory at a0."
  },
  {
    "mnemonic": "VADD.VV",
    "architecture": "RISC-V",
    "extension": "V (Vector)",
    "full_name": "Vector Integer Add",
    "summary": "Adds elements of two vector registers.",
    "syntax": "VADD.VV vd, vs2, vs1, vm",
    "encoding": {
      "format": "OPIVV",
      "binary_pattern": "000000 | vm | vs2 | vs1 | 000 | vd | 1010111",
      "hex_opcode": "0x57"
    },
    "operands": [
      {
        "name": "vd",
        "desc": "Dest"
      },
      {
        "name": "vs2",
        "desc": "Src 2"
      },
      {
        "name": "vs1",
        "desc": "Src 1"
      }
    ],
    "pseudocode": "foreach(i < vl): vd[i] = vs1[i] + vs2[i];",
    "example": "VADD.VV v10, v8, v9",
    "example_note": "v10[i] = v8[i] + v9[i]"
  },
  {
    "mnemonic": "VMUL.VV",
    "architecture": "RISC-V",
    "extension": "V (Vector)",
    "full_name": "Vector Integer Multiply",
    "summary": "Multiplies elements of two vector registers.",
    "syntax": "VMUL.VV vd, vs2, vs1, vm",
    "encoding": {
      "format": "OPIVV",
      "binary_pattern": "100101 | vm | vs2 | vs1 | 010 | vd | 1010111",
      "hex_opcode": "0x57"
    },
    "operands": [
      {
        "name": "vd",
        "desc": "Dest"
      },
      {
        "name": "vs2",
        "desc": "Src 2"
      },
      {
        "name": "vs1",
        "desc": "Src 1"
      }
    ],
    "pseudocode": "foreach(i < vl): vd[i] = vs1[i] * vs2[i];",
    "example": "VMUL.VV v10, v8, v9",
    "example_note": "v10[i] = v8[i] * v9[i]"
  },
  {
    "mnemonic": "CLZ",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "Count Leading Zeros",
    "summary": "Counts the number of 0 bits at the MSB end of the register.",
    "syntax": "CLZ rd, rs1",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "0110000 | 00000 | rs1 | 001 | rd | 0010011",
      "hex_opcode": "0x13"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      }
    ],
    "pseudocode": "int count = 0; while(rs1[XLEN-1-count] == 0) count++; R[rd] = count;",
    "example": "CLZ x10, x11",
    "example_note": "Find highest set bit index."
  },
  {
    "mnemonic": "CTZ",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "Count Trailing Zeros",
    "summary": "Counts the number of 0 bits at the LSB end of the register.",
    "syntax": "CTZ rd, rs1",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "0110000 | 00001 | rs1 | 001 | rd | 0010011",
      "hex_opcode": "0x13"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      }
    ],
    "pseudocode": "int count = 0; while(rs1[count] == 0) count++; R[rd] = count;",
    "example": "CTZ x10, x11",
    "example_note": "Find lowest set bit index."
  },
  {
    "mnemonic": "CPOP",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "Population Count",
    "summary": "Counts the number of set bits (1s) in the register.",
    "syntax": "CPOP rd, rs1",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "0110000 | 00010 | rs1 | 001 | rd | 0010011",
      "hex_opcode": "0x13"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      }
    ],
    "pseudocode": "R[rd] = count_set_bits(R[rs1]);",
    "example": "CPOP x10, x11",
    "example_note": "Hamming weight calculation."
  },
  {
    "mnemonic": "ANDN",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "AND Not",
    "summary": "Performs bitwise AND with the bitwise negation of rs2 (rs1 & ~rs2).",
    "syntax": "ANDN rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0100000 | rs2 | rs1 | 111 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2 (Inverted)"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] & ~R[rs2];",
    "example": "ANDN x10, x11, x12",
    "example_note": "Clear bits in x11 that are set in x12."
  },
  {
    "mnemonic": "ORN",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "OR Not",
    "summary": "Performs bitwise OR with the bitwise negation of rs2 (rs1 | ~rs2).",
    "syntax": "ORN rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0100000 | rs2 | rs1 | 110 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2 (Inverted)"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] | ~R[rs2];",
    "example": "ORN x10, x11, x12",
    "example_note": "Set bits."
  },
  {
    "mnemonic": "XNOR",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "Exclusive NOR",
    "summary": "Performs bitwise exclusive-NOR (rs1 ^ ~rs2).",
    "syntax": "XNOR rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0100000 | rs2 | rs1 | 100 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "R[rd] = ~(R[rs1] ^ R[rs2]);",
    "example": "XNOR x10, x11, x12",
    "example_note": "Logical equivalence."
  },
  {
    "mnemonic": "ROL",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "Rotate Left",
    "summary": "Rotates the bits in rs1 left by the amount in rs2.",
    "syntax": "ROL rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0110000 | rs2 | rs1 | 001 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "rs2",
        "desc": "Rotate Amount"
      }
    ],
    "pseudocode": "shamt = R[rs2] & (XLEN-1); R[rd] = (R[rs1] << shamt) | (R[rs1] >> (XLEN-shamt));",
    "example": "ROL x10, x11, x12",
    "example_note": "Bitwise rotation."
  },
  {
    "mnemonic": "ROR",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "Rotate Right",
    "summary": "Rotates the bits in rs1 right by the amount in rs2.",
    "syntax": "ROR rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0110000 | rs2 | rs1 | 101 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "rs2",
        "desc": "Rotate Amount"
      }
    ],
    "pseudocode": "shamt = R[rs2] & (XLEN-1); R[rd] = (R[rs1] >> shamt) | (R[rs1] << (XLEN-shamt));",
    "example": "ROR x10, x11, x12",
    "example_note": "Bitwise rotation."
  },
  {
    "mnemonic": "MAX",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "Maximum",
    "summary": "Computes the signed maximum of two registers.",
    "syntax": "MAX rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000101 | rs2 | rs1 | 110 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "R[rd] = (R[rs1] >s R[rs2]) ? R[rs1] : R[rs2];",
    "example": "MAX x10, x11, x12",
    "example_note": "Signed Max."
  },
  {
    "mnemonic": "MIN",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "Minimum",
    "summary": "Computes the signed minimum of two registers.",
    "syntax": "MIN rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000101 | rs2 | rs1 | 100 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "R[rd] = (R[rs1] <s R[rs2]) ? R[rs1] : R[rs2];",
    "example": "MIN x10, x11, x12",
    "example_note": "Signed Min."
  },
  {
    "mnemonic": "SEX.B",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "Sign Extend Byte",
    "summary": "Sign-extends the lowest byte (8 bits) to XLEN bits.",
    "syntax": "SEX.B rd, rs1",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "0110000 | 00100 | rs1 | 001 | rd | 0010011",
      "hex_opcode": "0x13"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      }
    ],
    "pseudocode": "R[rd] = sext(R[rs1][7:0]);",
    "example": "SEX.B x10, x11",
    "example_note": "Sign extend 8-bit value."
  },
  {
    "mnemonic": "SEX.H",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "Sign Extend Halfword",
    "summary": "Sign-extends the lowest halfword (16 bits) to XLEN bits.",
    "syntax": "SEX.H rd, rs1",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "0110000 | 00101 | rs1 | 001 | rd | 0010011",
      "hex_opcode": "0x13"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      }
    ],
    "pseudocode": "R[rd] = sext(R[rs1][15:0]);",
    "example": "SEX.H x10, x11",
    "example_note": "Sign extend 16-bit value."
  },
  {
    "mnemonic": "ZEXT.H",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "Zero Extend Halfword",
    "summary": "Zero-extends the lowest halfword (16 bits) to XLEN bits.",
    "syntax": "ZEXT.H rd, rs1",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "0000100 | 00000 | rs1 | 100 | rd | 0111011",
      "hex_opcode": "0x3B"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      }
    ],
    "pseudocode": "R[rd] = zext(R[rs1][15:0]);",
    "example": "ZEXT.H x10, x11",
    "example_note": "Zero extend 16-bit value."
  },
  {
    "mnemonic": "ORC.B",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "Bitwise OR-Combine Byte",
    "summary": "Sets each byte of the result to 0xFF if the corresponding byte of the source is non-zero, else 0x00.",
    "syntax": "ORC.B rd, rs1",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "0010100 | 00111 | rs1 | 101 | rd | 0010011",
      "hex_opcode": "0x13"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      }
    ],
    "pseudocode": "For each byte i: R[rd].byte[i] = (R[rs1].byte[i] != 0) ? 0xFF : 0x00;",
    "example": "ORC.B x10, x11",
    "example_note": "Used for string processing (strlen, strcpy)."
  },
  {
    "mnemonic": "REV8",
    "architecture": "RISC-V",
    "extension": "Zbb (BitManip)",
    "full_name": "Byte Reverse",
    "summary": "Reverses the order of bytes in a register (Endian swap).",
    "syntax": "REV8 rd, rs1",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "0110101 | 11000 | rs1 | 101 | rd | 0010011",
      "hex_opcode": "0x13"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      }
    ],
    "pseudocode": "R[rd] = Byteswap(R[rs1]);",
    "example": "REV8 x10, x11",
    "example_note": "Converts Big-Endian to Little-Endian."
  }
]