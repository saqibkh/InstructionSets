[
  {
    "mnemonic": "ADDI",
    "architecture": "RISC-V",
    "full_name": "Add Immediate",
    "summary": "Adds a register and a sign-extended 12-bit immediate value.",
    "syntax": "ADDI rd, rs1, imm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "...",
      "hex_opcode": "0x13"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Src"
      },
      {
        "name": "imm",
        "desc": "Value"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] + sext(imm);",
    "example": "ADDI x5, x0, 10",
    "example_note": "Loads the value 10 into register x5."
  },
  {
    "mnemonic": "ADD",
    "architecture": "RISC-V",
    "full_name": "Add",
    "summary": "Adds the contents of two registers.",
    "syntax": "ADD rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 000 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] + R[rs2];",
    "example": "ADD x6, x5, x4",
    "example_note": "x6 = x5 + x4"
  },
  {
    "mnemonic": "SUB",
    "architecture": "RISC-V",
    "full_name": "Subtract",
    "summary": "Subtracts rs2 from rs1.",
    "syntax": "SUB rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0100000 | rs2 | rs1 | 000 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Minuend"
      },
      {
        "name": "rs2",
        "desc": "Subtrahend"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] - R[rs2];",
    "example": "SUB x10, x11, x12",
    "example_note": "x10 = x11 - x12"
  },
  {
    "mnemonic": "LUI",
    "architecture": "RISC-V",
    "full_name": "Load Upper Immediate",
    "summary": "Loads the 20-bit immediate into the upper 20 bits of the register.",
    "syntax": "LUI rd, imm",
    "encoding": {
      "format": "U-Type",
      "binary_pattern": "imm[31:12] | rd | 0110111",
      "hex_opcode": "0x37"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "imm",
        "desc": "20-bit Upper Value"
      }
    ],
    "pseudocode": "R[rd] = imm << 12;",
    "example": "LUI x5, 0x12345",
    "example_note": "Loads 0x12345000 into x5."
  },
  {
    "mnemonic": "AUIPC",
    "architecture": "RISC-V",
    "full_name": "Add Upper Immediate to PC",
    "summary": "Adds a 20-bit upper immediate to the Program Counter.",
    "syntax": "AUIPC rd, imm",
    "encoding": {
      "format": "U-Type",
      "binary_pattern": "imm[31:12] | rd | 0010111",
      "hex_opcode": "0x17"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "imm",
        "desc": "20-bit offset"
      }
    ],
    "pseudocode": "R[rd] = PC + (imm << 12);",
    "example": "AUIPC x10, 0",
    "example_note": "Loads the current PC value into x10."
  },
  {
    "mnemonic": "JAL",
    "architecture": "RISC-V",
    "full_name": "Jump and Link",
    "summary": "Jumps to an offset and saves return address.",
    "syntax": "JAL rd, offset",
    "encoding": {
      "format": "J-Type",
      "binary_pattern": "imm | rd | 1101111",
      "hex_opcode": "0x6F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Return Address Dest"
      },
      {
        "name": "offset",
        "desc": "Jump Offset"
      }
    ],
    "pseudocode": "R[rd] = PC + 4; PC += sext(offset);",
    "example": "JAL x1, 1024",
    "example_note": "Calls function at PC+1024, saves return address in RA (x1)."
  },
  {
    "mnemonic": "BEQ",
    "architecture": "RISC-V",
    "full_name": "Branch if Equal",
    "summary": "Branches if two registers are equal.",
    "syntax": "BEQ rs1, rs2, offset",
    "encoding": {
      "format": "B-Type",
      "binary_pattern": "imm | rs2 | rs1 | 000 | imm | 1100011",
      "hex_opcode": "0x63"
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      },
      {
        "name": "offset",
        "desc": "Branch target"
      }
    ],
    "pseudocode": "if (R[rs1] == R[rs2]) PC += sext(offset);",
    "example": "BEQ x5, x6, 100",
    "example_note": "Jump 100 bytes forward if x5 equals x6."
  },
  {
    "mnemonic": "LW",
    "architecture": "RISC-V",
    "full_name": "Load Word",
    "summary": "Loads a 32-bit word from memory.",
    "syntax": "LW rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "offset | rs1 | 010 | rd | 0000011",
      "hex_opcode": "0x03"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Byte Offset"
      }
    ],
    "pseudocode": "R[rd] = M[R[rs1] + sext(offset)][31:0];",
    "example": "LW x5, 8(x2)",
    "example_note": "Load value from memory at address (StackPointer + 8) into x5."
  },
  {
    "mnemonic": "SW",
    "architecture": "RISC-V",
    "full_name": "Store Word",
    "summary": "Stores a 32-bit word to memory.",
    "syntax": "SW rs2, offset(rs1)",
    "encoding": {
      "format": "S-Type",
      "binary_pattern": "imm | rs2 | rs1 | 010 | imm | 0100011",
      "hex_opcode": "0x23"
    },
    "operands": [
      {
        "name": "rs2",
        "desc": "Source Data"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Byte Offset"
      }
    ],
    "pseudocode": "M[R[rs1] + sext(offset)] = R[rs2][31:0];",
    "example": "SW x5, 12(x2)",
    "example_note": "Store x5 into stack memory at offset 12."
  },
  {
    "mnemonic": "ECALL",
    "architecture": "RISC-V",
    "full_name": "Environment Call",
    "summary": "Triggers a service request to the execution environment (OS).",
    "syntax": "ECALL",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "000000000000 | 00000 | 000 | 00000 | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [],
    "pseudocode": "RaiseException(EnvironmentCall);",
    "example": "ECALL",
    "example_note": "Used to make syscalls (e.g. print, exit)."
  },
  {
    "mnemonic": "ADDW",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Add Word",
    "summary": "Adds two 32-bit registers and sign-extends the result to 64 bits.",
    "syntax": "ADDW rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 000 | rd | 0111011",
      "hex_opcode": "0x3B"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Source Register 1"
      },
      {
        "name": "rs2",
        "desc": "Source Register 2"
      }
    ],
    "pseudocode": "R[rd] = sext((R[rs1] + R[rs2])[31:0]);",
    "example": "ADDW x10, x11, x12",
    "example_note": "Performs 32-bit addition of x11 and x12, result is sign-extended to 64 bits."
  },
  {
    "mnemonic": "ADDIW",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Add Immediate Word",
    "summary": "Adds a 12-bit immediate to a register (32-bit arithmetic) and sign-extends to 64 bits.",
    "syntax": "ADDIW rd, rs1, imm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 000 | rd | 0011011",
      "hex_opcode": "0x1B"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Source Register"
      },
      {
        "name": "imm",
        "desc": "12-bit Signed Immediate"
      }
    ],
    "pseudocode": "R[rd] = sext((R[rs1] + sext(imm))[31:0]);",
    "example": "ADDIW x5, x6, 5",
    "example_note": "Adds 5 to lower 32 bits of x6, sign-extends result to x5."
  },
  {
    "mnemonic": "AND",
    "architecture": "RISC-V",
    "full_name": "Logical AND",
    "summary": "Performs a bitwise logical AND operation between two registers.",
    "syntax": "AND rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 111 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Source Register 1"
      },
      {
        "name": "rs2",
        "desc": "Source Register 2"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] & R[rs2];",
    "example": "AND x10, x11, x12",
    "example_note": "Bitwise AND of x11 and x12."
  },
  {
    "mnemonic": "ANDI",
    "architecture": "RISC-V",
    "full_name": "Logical AND Immediate",
    "summary": "Performs a bitwise logical AND between a register and a sign-extended 12-bit immediate.",
    "syntax": "ANDI rd, rs1, imm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 111 | rd | 0010011",
      "hex_opcode": "0x13"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Source Register"
      },
      {
        "name": "imm",
        "desc": "12-bit Signed Immediate"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] & sext(imm);",
    "example": "ANDI x10, x11, 15",
    "example_note": "Keeps only the lowest 4 bits of x11 (mask 0xF)."
  },
  {
    "mnemonic": "AMOADD.W",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic Add Word",
    "summary": "Atomically adds a value to a word in memory.",
    "syntax": "AMOADD.W rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "00000 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
      "hex_opcode": "0x2F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Value to Add"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp + R[rs2]; R[rd] = temp;",
    "example": "AMOADD.W x10, x11, (x12)",
    "example_note": "Atomically adds x11 to memory at x12. Old value stored in x10."
  },
  {
    "mnemonic": "AMOSWAP.W",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic Swap Word",
    "summary": "Atomically swaps a value in memory with a register.",
    "syntax": "AMOSWAP.W rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "00001 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
      "hex_opcode": "0x2F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "New Value"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = R[rs2]; R[rd] = temp;",
    "example": "AMOSWAP.W x10, x11, (x12)",
    "example_note": "Writes x11 to memory at x12, loads old memory value into x10."
  },
  {
    "mnemonic": "AMOAND.W",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic AND Word",
    "summary": "Atomically performs bitwise AND on a word in memory.",
    "syntax": "AMOAND.W rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "01100 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
      "hex_opcode": "0x2F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Operand"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp & R[rs2]; R[rd] = temp;",
    "example": "AMOAND.W x5, x6, (x7)",
    "example_note": "Atomically ANDs memory at x7 with x6."
  },
  {
    "mnemonic": "BNE",
    "architecture": "RISC-V",
    "full_name": "Branch if Not Equal",
    "summary": "Take the branch if registers rs1 and rs2 are not equal.",
    "syntax": "BNE rs1, rs2, offset",
    "encoding": {
      "format": "B-Type",
      "binary_pattern": "imm[12|10:5] | rs2 | rs1 | 001 | imm[4:1|11] | 1100011",
      "hex_opcode": "0x63"
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      },
      {
        "name": "offset",
        "desc": "PC-relative offset"
      }
    ],
    "pseudocode": "if (R[rs1] != R[rs2]) PC += sext(offset);",
    "example": "BNE x5, x6, loop",
    "example_note": "Jump to 'loop' if x5 != x6."
  },
  {
    "mnemonic": "BLT",
    "architecture": "RISC-V",
    "full_name": "Branch if Less Than",
    "summary": "Take the branch if rs1 is less than rs2 (signed).",
    "syntax": "BLT rs1, rs2, offset",
    "encoding": {
      "format": "B-Type",
      "binary_pattern": "imm[12|10:5] | rs2 | rs1 | 100 | imm[4:1|11] | 1100011",
      "hex_opcode": "0x63"
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "if (R[rs1] <s R[rs2]) PC += sext(offset);",
    "example": "BLT x10, x11, exit",
    "example_note": "Branch to 'exit' if x10 < x11 (signed comparison)."
  },
  {
    "mnemonic": "BGE",
    "architecture": "RISC-V",
    "full_name": "Branch if Greater or Equal",
    "summary": "Take the branch if rs1 is greater than or equal to rs2 (signed).",
    "syntax": "BGE rs1, rs2, offset",
    "encoding": {
      "format": "B-Type",
      "binary_pattern": "imm[12|10:5] | rs2 | rs1 | 101 | imm[4:1|11] | 1100011",
      "hex_opcode": "0x63"
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "if (R[rs1] >=s R[rs2]) PC += sext(offset);",
    "example": "BGE x10, x0, positive",
    "example_note": "Branch if x10 is positive or zero."
  },
  {
    "mnemonic": "CSRRW",
    "architecture": "RISC-V",
    "extension": "Zicsr",
    "full_name": "Control Status Register Read/Write",
    "summary": "Atomically swaps values in the CSRs. Reads the old value of the CSR into rd, then writes rs1 to the CSR.",
    "syntax": "CSRRW rd, csr, rs1",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "csr | rs1 | 001 | rd | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "csr",
        "desc": "CSR Address"
      },
      {
        "name": "rs1",
        "desc": "Src (New Value)"
      }
    ],
    "pseudocode": "t = CSRs[csr]; CSRs[csr] = R[rs1]; R[rd] = t;",
    "example": "CSRRW x10, scause, x11",
    "example_note": "Writes x11 to 'scause' CSR and reads old 'scause' into x10."
  },
  {
    "mnemonic": "CSRRS",
    "architecture": "RISC-V",
    "extension": "Zicsr",
    "full_name": "Control Status Register Read and Set",
    "summary": "Reads the value of the CSR into rd, then bitwise ORs the value in rs1 into the CSR (setting bits).",
    "syntax": "CSRRS rd, csr, rs1",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "csr | rs1 | 010 | rd | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "csr",
        "desc": "CSR Address"
      },
      {
        "name": "rs1",
        "desc": "Bit Mask"
      }
    ],
    "pseudocode": "t = CSRs[csr]; CSRs[csr] = t | R[rs1]; R[rd] = t;",
    "example": "CSRRS x0, sstatus, x5",
    "example_note": "Sets bits in 'sstatus' using mask in x5 (Result discarded)."
  },
  {
    "mnemonic": "DIV",
    "architecture": "RISC-V",
    "extension": "M",
    "full_name": "Divide",
    "summary": "Performs signed integer division.",
    "syntax": "DIV rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000001 | rs2 | rs1 | 100 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Quotient)"
      },
      {
        "name": "rs1",
        "desc": "Dividend"
      },
      {
        "name": "rs2",
        "desc": "Divisor"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] / R[rs2];",
    "example": "DIV x10, x11, x12",
    "example_note": "Signed division of x11 by x12."
  },
  {
    "mnemonic": "DIVU",
    "architecture": "RISC-V",
    "extension": "M",
    "full_name": "Divide Unsigned",
    "summary": "Performs unsigned integer division.",
    "syntax": "DIVU rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000001 | rs2 | rs1 | 101 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Dividend"
      },
      {
        "name": "rs2",
        "desc": "Divisor"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] /u R[rs2];",
    "example": "DIVU x5, x6, x7",
    "example_note": "Unsigned division."
  },
  {
    "mnemonic": "EBREAK",
    "architecture": "RISC-V",
    "full_name": "Environment Break",
    "summary": "Used by debuggers to cause control to be transferred back to a debugging environment.",
    "syntax": "EBREAK",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "000000000001 | 00000 | 000 | 00000 | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [],
    "pseudocode": "RaiseException(Breakpoint);",
    "example": "EBREAK",
    "example_note": "Triggers a debugger breakpoint."
  },
  {
    "mnemonic": "FENCE",
    "architecture": "RISC-V",
    "full_name": "Fence",
    "summary": "Orders device I/O and memory accesses.",
    "syntax": "FENCE pred, succ",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "fm | pred | succ | rs1 | 000 | rd | 0001111",
      "hex_opcode": "0x0F"
    },
    "operands": [
      {
        "name": "pred",
        "desc": "Predecessor Set"
      },
      {
        "name": "succ",
        "desc": "Successor Set"
      }
    ],
    "pseudocode": "MemoryBarrier(pred, succ);",
    "example": "FENCE rw, rw",
    "example_note": "Ensures all previous reads/writes complete before subsequent reads/writes."
  },
  {
    "mnemonic": "FLW",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Float Load Word",
    "summary": "Loads a single-precision floating-point value from memory.",
    "syntax": "FLW rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "offset | rs1 | 010 | rd | 0000111",
      "hex_opcode": "0x07"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Float Reg)"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "F[rd] = M[R[rs1] + sext(offset)][31:0];",
    "example": "FLW f1, 0(x10)",
    "example_note": "Loads float from address in x10 to f1."
  },
  {
    "mnemonic": "FSW",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Float Store Word",
    "summary": "Stores a single-precision floating-point value to memory.",
    "syntax": "FSW rs2, offset(rs1)",
    "encoding": {
      "format": "S-Type",
      "binary_pattern": "imm[11:5] | rs2 | rs1 | 010 | imm[4:0] | 0100111",
      "hex_opcode": "0x27"
    },
    "operands": [
      {
        "name": "rs2",
        "desc": "Src (Float Reg)"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "M[R[rs1] + sext(offset)] = F[rs2][31:0];",
    "example": "FSW f1, 4(x2)",
    "example_note": "Stores float in f1 to stack + 4."
  },
  {
    "mnemonic": "FADD.S",
    "architecture": "RISC-V",
    "extension": "F",
    "full_name": "Float Add (Single)",
    "summary": "Performs single-precision floating-point addition.",
    "syntax": "FADD.S rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 000 | rd | 1010011",
      "hex_opcode": "0x53"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Src 1"
      },
      {
        "name": "rs2",
        "desc": "Src 2"
      }
    ],
    "pseudocode": "F[rd] = F[rs1] + F[rs2];",
    "example": "FADD.S f0, f1, f2",
    "example_note": "f0 = f1 + f2"
  },
  {
    "mnemonic": "HFENCE.GVMA",
    "architecture": "RISC-V",
    "extension": "H (Hypervisor)",
    "full_name": "Hypervisor Fence Guest Virtual Memory Address",
    "summary": "Synchronizes updates to guest physical address translation data structures.",
    "syntax": "HFENCE.GVMA rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0110001 | rs2 | rs1 | 000 | 00000 | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Guest Virtual Address (optional)"
      },
      {
        "name": "rs2",
        "desc": "Guest ASID (optional)"
      }
    ],
    "pseudocode": "Fence(GuestPageTable);",
    "example": "HFENCE.GVMA x0, x0",
    "example_note": "Flush all guest TLB entries."
  },
  {
    "mnemonic": "HFENCE.VVMA",
    "architecture": "RISC-V",
    "extension": "H (Hypervisor)",
    "full_name": "Hypervisor Fence Virtual Virtual Memory Address",
    "summary": "Synchronizes updates to VS-stage address translation data structures.",
    "syntax": "HFENCE.VVMA rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0010001 | rs2 | rs1 | 000 | 00000 | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Virtual Address (optional)"
      },
      {
        "name": "rs2",
        "desc": "ASID (optional)"
      }
    ],
    "pseudocode": "Fence(VS-StagePageTable);",
    "example": "HFENCE.VVMA x10, x0",
    "example_note": "Flush TLB entries for address in x10."
  },
  {
    "mnemonic": "JALR",
    "architecture": "RISC-V",
    "full_name": "Jump and Link Register",
    "summary": "Jumps to address in rs1 + offset, saving return address to rd.",
    "syntax": "JALR rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 000 | rd | 1100111",
      "hex_opcode": "0x67"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Return Address Dest"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "12-bit Immediate"
      }
    ],
    "pseudocode": "t = PC + 4; PC = (R[rs1] + sext(offset)) & ~1; R[rd] = t;",
    "example": "JALR x0, 0(x1)",
    "example_note": "Return from function (jumps to address in x1/ra)."
  },
  {
    "mnemonic": "LB",
    "architecture": "RISC-V",
    "full_name": "Load Byte",
    "summary": "Loads an 8-bit byte from memory and sign-extends it to the register width.",
    "syntax": "LB rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 000 | rd | 0000011",
      "hex_opcode": "0x03"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Byte Offset"
      }
    ],
    "pseudocode": "R[rd] = sext(M[R[rs1] + sext(offset)][7:0]);",
    "example": "LB x10, 0(x2)",
    "example_note": "Load byte from stack pointer (x2) into x10."
  },
  {
    "mnemonic": "LH",
    "architecture": "RISC-V",
    "full_name": "Load Halfword",
    "summary": "Loads a 16-bit halfword from memory and sign-extends it.",
    "syntax": "LH rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 001 | rd | 0000011",
      "hex_opcode": "0x03"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Byte Offset"
      }
    ],
    "pseudocode": "R[rd] = sext(M[R[rs1] + sext(offset)][15:0]);",
    "example": "LH x5, 4(x10)",
    "example_note": "Load halfword from address x10+4."
  },
  {
    "mnemonic": "LBU",
    "architecture": "RISC-V",
    "full_name": "Load Byte Unsigned",
    "summary": "Loads an 8-bit byte from memory and zero-extends it.",
    "syntax": "LBU rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 100 | rd | 0000011",
      "hex_opcode": "0x03"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Byte Offset"
      }
    ],
    "pseudocode": "R[rd] = zext(M[R[rs1] + sext(offset)][7:0]);",
    "example": "LBU x10, 0(x2)",
    "example_note": "Load byte and zero-extend."
  },
  {
    "mnemonic": "LHU",
    "architecture": "RISC-V",
    "full_name": "Load Halfword Unsigned",
    "summary": "Loads a 16-bit halfword from memory and zero-extends it.",
    "syntax": "LHU rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 101 | rd | 0000011",
      "hex_opcode": "0x03"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Byte Offset"
      }
    ],
    "pseudocode": "R[rd] = zext(M[R[rs1] + sext(offset)][15:0]);",
    "example": "LHU x5, 4(x10)",
    "example_note": "Load halfword and zero-extend."
  },
  {
    "mnemonic": "LD",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Load Doubleword",
    "summary": "Loads a 64-bit doubleword from memory.",
    "syntax": "LD rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 011 | rd | 0000011",
      "hex_opcode": "0x03"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Byte Offset"
      }
    ],
    "pseudocode": "R[rd] = M[R[rs1] + sext(offset)][63:0];",
    "example": "LD x1, 0(x2)",
    "example_note": "Load 64-bit value from stack."
  },
  {
    "mnemonic": "LWU",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Load Word Unsigned",
    "summary": "Loads a 32-bit word from memory and zero-extends it to 64 bits.",
    "syntax": "LWU rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 110 | rd | 0000011",
      "hex_opcode": "0x03"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Byte Offset"
      }
    ],
    "pseudocode": "R[rd] = zext(M[R[rs1] + sext(offset)][31:0]);",
    "example": "LWU x6, 12(x2)",
    "example_note": "Load 32-bit word and zero-extend to 64-bit."
  },
  {
    "mnemonic": "LR.W",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Load Reserved Word",
    "summary": "Loads a word from memory and registers a reservation set for the address.",
    "syntax": "LR.W rd, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "00010 | aq | rl | 00000 | rs1 | 010 | rd | 0101111",
      "hex_opcode": "0x2F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "R[rd] = LoadReserved32(M[R[rs1]]);",
    "example": "LR.W x10, (x11)",
    "example_note": "Start atomic read-modify-write sequence."
  },
  {
    "mnemonic": "LR.D",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Load Reserved Doubleword",
    "summary": "Loads a doubleword from memory and registers a reservation set.",
    "syntax": "LR.D rd, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "00010 | aq | rl | 00000 | rs1 | 011 | rd | 0101111",
      "hex_opcode": "0x2F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Destination Register"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "R[rd] = LoadReserved64(M[R[rs1]]);",
    "example": "LR.D x10, (x11)",
    "example_note": "64-bit atomic load reserved."
  },
  {
    "mnemonic": "MUL",
    "architecture": "RISC-V",
    "extension": "M",
    "full_name": "Multiply",
    "summary": "Performs a 32-bit (or 64-bit) multiplication of rs1 and rs2 and stores the lower bits in rd.",
    "syntax": "MUL rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000001 | rs2 | rs1 | 000 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Lower Bits)"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "R[rd] = (R[rs1] * R[rs2])[XLEN-1:0];",
    "example": "MUL x10, x11, x12",
    "example_note": "x10 = lower bits of x11 * x12."
  },
  {
    "mnemonic": "MULH",
    "architecture": "RISC-V",
    "extension": "M",
    "full_name": "Multiply High Signed",
    "summary": "Performs a signed multiplication and stores the upper bits of the result.",
    "syntax": "MULH rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000001 | rs2 | rs1 | 001 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Upper Bits)"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "R[rd] = (sext(R[rs1]) * sext(R[rs2])) >> XLEN;",
    "example": "MULH x5, x6, x7",
    "example_note": "Get upper bits of signed multiplication."
  },
  {
    "mnemonic": "MRET",
    "architecture": "RISC-V",
    "extension": "Privileged",
    "full_name": "Machine Return",
    "summary": "Returns from a machine-mode trap handler.",
    "syntax": "MRET",
    "encoding": {
      "format": "R-Type (System)",
      "binary_pattern": "0011000 | 00010 | 00000 | 000 | 00000 | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [],
    "pseudocode": "PC = MEPC; Priv = MPP; MIE = MPIE;",
    "example": "MRET",
    "example_note": "Return to previous privilege level defined in mstatus."
  },
  {
    "mnemonic": "OR",
    "architecture": "RISC-V",
    "full_name": "Logical OR",
    "summary": "Performs a bitwise logical OR operation.",
    "syntax": "OR rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 110 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] | R[rs2];",
    "example": "OR x10, x11, x12",
    "example_note": "Bitwise OR of x11 and x12."
  },
  {
    "mnemonic": "ORI",
    "architecture": "RISC-V",
    "full_name": "Logical OR Immediate",
    "summary": "Performs a bitwise logical OR with a sign-extended immediate.",
    "syntax": "ORI rd, rs1, imm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 110 | rd | 0010011",
      "hex_opcode": "0x13"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "imm",
        "desc": "Immediate"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] | sext(imm);",
    "example": "ORI x10, x11, 1",
    "example_note": "Sets the lowest bit of x11."
  },
  {
    "mnemonic": "REM",
    "architecture": "RISC-V",
    "extension": "M",
    "full_name": "Remainder",
    "summary": "Computes the signed remainder of division.",
    "syntax": "REM rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000001 | rs2 | rs1 | 110 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Remainder)"
      },
      {
        "name": "rs1",
        "desc": "Dividend"
      },
      {
        "name": "rs2",
        "desc": "Divisor"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] % R[rs2];",
    "example": "REM x5, x6, x7",
    "example_note": "Signed remainder."
  },
  {
    "mnemonic": "SB",
    "architecture": "RISC-V",
    "full_name": "Store Byte",
    "summary": "Stores the lowest 8 bits of a register to memory.",
    "syntax": "SB rs2, offset(rs1)",
    "encoding": {
      "format": "S-Type",
      "binary_pattern": "imm[11:5] | rs2 | rs1 | 000 | imm[4:0] | 0100011",
      "hex_opcode": "0x23"
    },
    "operands": [
      {
        "name": "rs2",
        "desc": "Source"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "M[R[rs1] + sext(offset)][7:0] = R[rs2][7:0];",
    "example": "SB x5, 0(x10)",
    "example_note": "Store low byte of x5 to address in x10."
  },
  {
    "mnemonic": "SH",
    "architecture": "RISC-V",
    "full_name": "Store Halfword",
    "summary": "Stores the lowest 16 bits of a register to memory.",
    "syntax": "SH rs2, offset(rs1)",
    "encoding": {
      "format": "S-Type",
      "binary_pattern": "imm[11:5] | rs2 | rs1 | 001 | imm[4:0] | 0100011",
      "hex_opcode": "0x23"
    },
    "operands": [
      {
        "name": "rs2",
        "desc": "Source"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "M[R[rs1] + sext(offset)][15:0] = R[rs2][15:0];",
    "example": "SH x5, 4(x10)",
    "example_note": "Store halfword."
  },
  {
    "mnemonic": "SD",
    "architecture": "RISC-V",
    "extension": "RV64",
    "full_name": "Store Doubleword",
    "summary": "Stores a 64-bit doubleword to memory.",
    "syntax": "SD rs2, offset(rs1)",
    "encoding": {
      "format": "S-Type",
      "binary_pattern": "imm[11:5] | rs2 | rs1 | 011 | imm[4:0] | 0100011",
      "hex_opcode": "0x23"
    },
    "operands": [
      {
        "name": "rs2",
        "desc": "Source"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "M[R[rs1] + sext(offset)][63:0] = R[rs2][63:0];",
    "example": "SD x5, 16(x10)",
    "example_note": "Store 64-bit value."
  },
  {
    "mnemonic": "SLL",
    "architecture": "RISC-V",
    "full_name": "Shift Left Logical",
    "summary": "Shifts a register left by the number of bits specified in another register.",
    "syntax": "SLL rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 001 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "rs2",
        "desc": "Shift Amount"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] << (R[rs2] & 0x1F);",
    "example": "SLL x10, x11, x12",
    "example_note": "Shift x11 left by x12."
  },
  {
    "mnemonic": "SLLI",
    "architecture": "RISC-V",
    "full_name": "Shift Left Logical Immediate",
    "summary": "Shifts a register left by a constant amount.",
    "syntax": "SLLI rd, rs1, shamt",
    "encoding": {
      "format": "I-Type (Shift)",
      "binary_pattern": "0000000 | shamt | rs1 | 001 | rd | 0010011",
      "hex_opcode": "0x13"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "shamt",
        "desc": "Shift Amount"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] << shamt;",
    "example": "SLLI x10, x11, 2",
    "example_note": "Multiply x11 by 4."
  },
  {
    "mnemonic": "SRL",
    "architecture": "RISC-V",
    "full_name": "Shift Right Logical",
    "summary": "Shifts a register right, shifting in zeros.",
    "syntax": "SRL rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 101 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "rs2",
        "desc": "Shift Amount"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] >> (R[rs2] & 0x1F);",
    "example": "SRL x10, x11, x12",
    "example_note": "Logical right shift."
  },
  {
    "mnemonic": "SRA",
    "architecture": "RISC-V",
    "full_name": "Shift Right Arithmetic",
    "summary": "Shifts a register right, preserving the sign bit.",
    "syntax": "SRA rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0100000 | rs2 | rs1 | 101 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "rs2",
        "desc": "Shift Amount"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] >>s (R[rs2] & 0x1F);",
    "example": "SRA x10, x11, x12",
    "example_note": "Arithmetic right shift (sign preserved)."
  },
  {
    "mnemonic": "SLT",
    "architecture": "RISC-V",
    "full_name": "Set Less Than",
    "summary": "Sets rd to 1 if rs1 < rs2 (signed), otherwise 0.",
    "syntax": "SLT rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 010 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "R[rd] = (R[rs1] <s R[rs2]) ? 1 : 0;",
    "example": "SLT x5, x6, x7",
    "example_note": "Check if x6 < x7."
  },
  {
    "mnemonic": "SLTI",
    "architecture": "RISC-V",
    "full_name": "Set Less Than Immediate",
    "summary": "Sets rd to 1 if rs1 < immediate (signed), otherwise 0.",
    "syntax": "SLTI rd, rs1, imm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 010 | rd | 0010011",
      "hex_opcode": "0x13"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "imm",
        "desc": "Immediate"
      }
    ],
    "pseudocode": "R[rd] = (R[rs1] <s sext(imm)) ? 1 : 0;",
    "example": "SLTI x5, x6, 10",
    "example_note": "Check if x6 < 10."
  },
  {
    "mnemonic": "SC.W",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Store Conditional Word",
    "summary": "Conditionally stores a word to memory if the reservation (from LR) is still valid.",
    "syntax": "SC.W rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "00011 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
      "hex_opcode": "0x2F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Success/Fail)"
      },
      {
        "name": "rs2",
        "desc": "Source Value"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "if (ReservationValid) { M[R[rs1]] = R[rs2]; R[rd] = 0; } else { R[rd] = 1; }",
    "example": "SC.W x10, x11, (x12)",
    "example_note": "Try to store x11 to x12. x10=0 on success."
  },
  {
    "mnemonic": "SFENCE.VMA",
    "architecture": "RISC-V",
    "extension": "Privileged",
    "full_name": "Supervisor Fence Virtual Memory",
    "summary": "Synchronizes updates to in-memory address translation data structures (TLB flush).",
    "syntax": "SFENCE.VMA rs1, rs2",
    "encoding": {
      "format": "R-Type (System)",
      "binary_pattern": "0001001 | rs2 | rs1 | 000 | 00000 | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [
      {
        "name": "rs1",
        "desc": "Virtual Address (optional)"
      },
      {
        "name": "rs2",
        "desc": "ASID (optional)"
      }
    ],
    "pseudocode": "Fence(PageTable);",
    "example": "SFENCE.VMA x0, x0",
    "example_note": "Flush all TLB entries."
  },
  {
    "mnemonic": "SRET",
    "architecture": "RISC-V",
    "extension": "Privileged",
    "full_name": "Supervisor Return",
    "summary": "Returns from a supervisor-mode trap handler.",
    "syntax": "SRET",
    "encoding": {
      "format": "R-Type (System)",
      "binary_pattern": "0001000 | 00010 | 00000 | 000 | 00000 | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [],
    "pseudocode": "PC = SEPC; Priv = SPP; SIE = SPIE;",
    "example": "SRET",
    "example_note": "Return from exception/interrupt in supervisor mode."
  },
  {
    "mnemonic": "WFI",
    "architecture": "RISC-V",
    "extension": "Privileged",
    "full_name": "Wait for Interrupt",
    "summary": "Provides a hint to the implementation that the current hart can be stalled until an interrupt occurs.",
    "syntax": "WFI",
    "encoding": {
      "format": "R-Type (System)",
      "binary_pattern": "0001000 | 00101 | 00000 | 000 | 00000 | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [],
    "pseudocode": "while(!Interrupt) { /* low power state */ }",
    "example": "WFI",
    "example_note": "Pause execution until interrupt."
  },
  {
    "mnemonic": "XOR",
    "architecture": "RISC-V",
    "full_name": "Logical XOR",
    "summary": "Performs a bitwise logical Exclusive-OR operation.",
    "syntax": "XOR rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000000 | rs2 | rs1 | 100 | rd | 0110011",
      "hex_opcode": "0x33"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source 1"
      },
      {
        "name": "rs2",
        "desc": "Source 2"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] ^ R[rs2];",
    "example": "XOR x10, x11, x12",
    "example_note": "x10 = x11 ^ x12"
  },
  {
    "mnemonic": "XORI",
    "architecture": "RISC-V",
    "full_name": "Logical XOR Immediate",
    "summary": "Performs a bitwise logical Exclusive-OR with a sign-extended immediate.",
    "syntax": "XORI rd, rs1, imm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "imm[11:0] | rs1 | 100 | rd | 0010011",
      "hex_opcode": "0x13"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Source"
      },
      {
        "name": "imm",
        "desc": "Immediate"
      }
    ],
    "pseudocode": "R[rd] = R[rs1] ^ sext(imm);",
    "example": "XORI x10, x11, -1",
    "example_note": "Bitwise invert (NOT) x11."
  },
  {
    "mnemonic": "CSRRC",
    "architecture": "RISC-V",
    "extension": "Zicsr",
    "full_name": "Control Status Register Read and Clear",
    "summary": "Reads the old value of the CSR, then clears bits in the CSR based on the mask in rs1.",
    "syntax": "CSRRC rd, csr, rs1",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "csr | rs1 | 011 | rd | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "csr",
        "desc": "CSR Address"
      },
      {
        "name": "rs1",
        "desc": "Bit Mask"
      }
    ],
    "pseudocode": "t = CSRs[csr]; CSRs[csr] = t & ~R[rs1]; R[rd] = t;",
    "example": "CSRRC x10, sstatus, x5",
    "example_note": "Clears bits in 'sstatus' where x5 is 1."
  },
  {
    "mnemonic": "CSRRWI",
    "architecture": "RISC-V",
    "extension": "Zicsr",
    "full_name": "CSR Read/Write Immediate",
    "summary": "Updates a CSR using a 5-bit unsigned immediate (zimm) instead of a register.",
    "syntax": "CSRRWI rd, csr, uimm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "csr | uimm | 101 | rd | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "csr",
        "desc": "CSR Address"
      },
      {
        "name": "uimm",
        "desc": "5-bit Unsigned Imm"
      }
    ],
    "pseudocode": "t = CSRs[csr]; CSRs[csr] = zext(uimm); R[rd] = t;",
    "example": "CSRRWI x0, 0x001, 0",
    "example_note": "Writes 0 to CSR 0x001."
  },
  {
    "mnemonic": "CSRRSI",
    "architecture": "RISC-V",
    "extension": "Zicsr",
    "full_name": "CSR Read and Set Immediate",
    "summary": "Sets bits in a CSR using a 5-bit unsigned immediate.",
    "syntax": "CSRRSI rd, csr, uimm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "csr | uimm | 110 | rd | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "csr",
        "desc": "CSR Address"
      },
      {
        "name": "uimm",
        "desc": "Bit Mask"
      }
    ],
    "pseudocode": "t = CSRs[csr]; CSRs[csr] = t | zext(uimm); R[rd] = t;",
    "example": "CSRRSI x0, sstatus, 1",
    "example_note": "Sets bit 0 of sstatus."
  },
  {
    "mnemonic": "CSRRCI",
    "architecture": "RISC-V",
    "extension": "Zicsr",
    "full_name": "CSR Read and Clear Immediate",
    "summary": "Clears bits in a CSR using a 5-bit unsigned immediate.",
    "syntax": "CSRRCI rd, csr, uimm",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "csr | uimm | 111 | rd | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "csr",
        "desc": "CSR Address"
      },
      {
        "name": "uimm",
        "desc": "Bit Mask"
      }
    ],
    "pseudocode": "t = CSRs[csr]; CSRs[csr] = t & ~zext(uimm); R[rd] = t;",
    "example": "CSRRCI x0, sstatus, 2",
    "example_note": "Clears bit 1 of sstatus."
  },
  {
    "mnemonic": "FLD",
    "architecture": "RISC-V",
    "extension": "D (Double)",
    "full_name": "Float Load Double",
    "summary": "Loads a 64-bit double-precision floating-point value from memory.",
    "syntax": "FLD rd, offset(rs1)",
    "encoding": {
      "format": "I-Type",
      "binary_pattern": "offset | rs1 | 011 | rd | 0000111",
      "hex_opcode": "0x07"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Float Reg)"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "F[rd] = M[R[rs1] + sext(offset)][63:0];",
    "example": "FLD f1, 8(x10)",
    "example_note": "Loads double from address x10+8."
  },
  {
    "mnemonic": "FSD",
    "architecture": "RISC-V",
    "extension": "D (Double)",
    "full_name": "Float Store Double",
    "summary": "Stores a 64-bit double-precision floating-point value to memory.",
    "syntax": "FSD rs2, offset(rs1)",
    "encoding": {
      "format": "S-Type",
      "binary_pattern": "imm[11:5] | rs2 | rs1 | 011 | imm[4:0] | 0100111",
      "hex_opcode": "0x27"
    },
    "operands": [
      {
        "name": "rs2",
        "desc": "Src (Float Reg)"
      },
      {
        "name": "rs1",
        "desc": "Base Address"
      },
      {
        "name": "offset",
        "desc": "Offset"
      }
    ],
    "pseudocode": "M[R[rs1] + sext(offset)][63:0] = F[rs2];",
    "example": "FSD f1, 16(x2)",
    "example_note": "Stores f1 to stack+16."
  },
  {
    "mnemonic": "FADD.D",
    "architecture": "RISC-V",
    "extension": "D (Double)",
    "full_name": "Float Add Double",
    "summary": "Performs double-precision floating-point addition.",
    "syntax": "FADD.D rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000001 | rs2 | rs1 | 000 | rd | 1010011",
      "hex_opcode": "0x53"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Src 1"
      },
      {
        "name": "rs2",
        "desc": "Src 2"
      }
    ],
    "pseudocode": "F[rd] = F[rs1] + F[rs2];",
    "example": "FADD.D f0, f1, f2",
    "example_note": "64-bit float addition."
  },
  {
    "mnemonic": "FSUB.D",
    "architecture": "RISC-V",
    "extension": "D (Double)",
    "full_name": "Float Subtract Double",
    "summary": "Performs double-precision floating-point subtraction.",
    "syntax": "FSUB.D rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0000101 | rs2 | rs1 | 000 | rd | 1010011",
      "hex_opcode": "0x53"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Src 1"
      },
      {
        "name": "rs2",
        "desc": "Src 2"
      }
    ],
    "pseudocode": "F[rd] = F[rs1] - F[rs2];",
    "example": "FSUB.D f0, f1, f2",
    "example_note": "64-bit float subtraction."
  },
  {
    "mnemonic": "FMUL.D",
    "architecture": "RISC-V",
    "extension": "D (Double)",
    "full_name": "Float Multiply Double",
    "summary": "Performs double-precision floating-point multiplication.",
    "syntax": "FMUL.D rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0001001 | rs2 | rs1 | 000 | rd | 1010011",
      "hex_opcode": "0x53"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Src 1"
      },
      {
        "name": "rs2",
        "desc": "Src 2"
      }
    ],
    "pseudocode": "F[rd] = F[rs1] * F[rs2];",
    "example": "FMUL.D f0, f1, f2",
    "example_note": "64-bit float multiplication."
  },
  {
    "mnemonic": "FDIV.D",
    "architecture": "RISC-V",
    "extension": "D (Double)",
    "full_name": "Float Divide Double",
    "summary": "Performs double-precision floating-point division.",
    "syntax": "FDIV.D rd, rs1, rs2",
    "encoding": {
      "format": "R-Type",
      "binary_pattern": "0001101 | rs2 | rs1 | 000 | rd | 1010011",
      "hex_opcode": "0x53"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest"
      },
      {
        "name": "rs1",
        "desc": "Dividend"
      },
      {
        "name": "rs2",
        "desc": "Divisor"
      }
    ],
    "pseudocode": "F[rd] = F[rs1] / F[rs2];",
    "example": "FDIV.D f0, f1, f2",
    "example_note": "64-bit float division."
  },
  {
    "mnemonic": "AMOOR.W",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic OR Word",
    "summary": "Atomically performs bitwise OR on a word in memory.",
    "syntax": "AMOOR.W rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "01000 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
      "hex_opcode": "0x2F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Operand"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp | R[rs2]; R[rd] = temp;",
    "example": "AMOOR.W x10, x11, (x12)",
    "example_note": "Atomic OR."
  },
  {
    "mnemonic": "AMOXOR.W",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic XOR Word",
    "summary": "Atomically performs bitwise XOR on a word in memory.",
    "syntax": "AMOXOR.W rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "00100 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
      "hex_opcode": "0x2F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Operand"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = temp ^ R[rs2]; R[rd] = temp;",
    "example": "AMOXOR.W x10, x11, (x12)",
    "example_note": "Atomic XOR."
  },
  {
    "mnemonic": "AMOMAX.W",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic Max Word",
    "summary": "Atomically updates memory with the maximum of the memory value and register value (Signed).",
    "syntax": "AMOMAX.W rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "10100 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
      "hex_opcode": "0x2F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Operand"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = max(temp, R[rs2]); R[rd] = temp;",
    "example": "AMOMAX.W x10, x11, (x12)",
    "example_note": "Atomic Signed Max."
  },
  {
    "mnemonic": "AMOMIN.W",
    "architecture": "RISC-V",
    "extension": "A (Atomic)",
    "full_name": "Atomic Min Word",
    "summary": "Atomically updates memory with the minimum of the memory value and register value (Signed).",
    "syntax": "AMOMIN.W rd, rs2, (rs1)",
    "encoding": {
      "format": "R-Type (Atomic)",
      "binary_pattern": "10000 | aq | rl | rs2 | rs1 | 010 | rd | 0101111",
      "hex_opcode": "0x2F"
    },
    "operands": [
      {
        "name": "rd",
        "desc": "Dest (Old Value)"
      },
      {
        "name": "rs2",
        "desc": "Operand"
      },
      {
        "name": "rs1",
        "desc": "Address"
      }
    ],
    "pseudocode": "temp = M[R[rs1]]; M[R[rs1]] = min(temp, R[rs2]); R[rd] = temp;",
    "example": "AMOMIN.W x10, x11, (x12)",
    "example_note": "Atomic Signed Min."
  },
  {
    "mnemonic": "URET",
    "architecture": "RISC-V",
    "extension": "Privileged",
    "full_name": "User Return",
    "summary": "Returns from a user-mode trap handler (requires N extension).",
    "syntax": "URET",
    "encoding": {
      "format": "R-Type (System)",
      "binary_pattern": "0000000 | 00010 | 00000 | 000 | 00000 | 1110011",
      "hex_opcode": "0x73"
    },
    "operands": [],
    "pseudocode": "PC = UEPC; Priv = U; UIE = UPIE;",
    "example": "URET",
    "example_note": "Return from User-mode exception."
  }
]