{
  "instructions": [
    {
      "mnemonic": "adc",
      "architecture": "x86",
      "full_name": "Add with Carry",
      "summary": "Adds operands and the Carry Flag (CF).",
      "syntax": "ADC r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "11",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        },
        {
          "name": "src",
          "desc": "Reg"
        }
      ],
      "extension": "Base",
      "slug": "adc",
      "rel_url": "x86/adc/",
      "linked_summary": "Adds operands <a href=\"../../armv8-a/and_6/\">and</a> the Carry Flag (CF).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sbb",
      "architecture": "x86",
      "full_name": "Subtract with Borrow",
      "summary": "Subtracts operands and the Carry Flag (CF).",
      "syntax": "SBB r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "19",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        },
        {
          "name": "src",
          "desc": "Reg"
        }
      ],
      "extension": "Base",
      "slug": "sbb",
      "rel_url": "x86/sbb/",
      "linked_summary": "Subtracts operands <a href=\"../../armv8-a/and_6/\">and</a> the Carry Flag (CF).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "shld",
      "architecture": "x86",
      "full_name": "Double Precision Shift Left",
      "summary": "Shifts dest left, filling with bits from src.",
      "syntax": "SHLD r/m, r, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F A4",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        },
        {
          "name": "fill",
          "desc": "Reg"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "Base",
      "slug": "shld",
      "rel_url": "x86/shld/",
      "linked_summary": "Shifts dest left, filling with bits from src.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "shrd",
      "architecture": "x86",
      "full_name": "Double Precision Shift Right",
      "summary": "Shifts dest right, filling with bits from src.",
      "syntax": "SHRD r/m, r, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F AC",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        },
        {
          "name": "fill",
          "desc": "Reg"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "Base",
      "slug": "shrd",
      "rel_url": "x86/shrd/",
      "linked_summary": "Shifts dest right, filling with bits from src.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpermb",
      "architecture": "x86",
      "full_name": "Permute Packed Bytes",
      "summary": "Permutes bytes in ZMM based on index vector.",
      "syntax": "VPERMB zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 8D",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "idx",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512_VBMI",
      "slug": "vpermb",
      "rel_url": "x86/vpermb/",
      "linked_summary": "Permutes bytes <a href=\"../../x86/in/\">in</a> ZMM based on <a href=\"../../armv8-a/index/\">index</a> vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpermi2b",
      "architecture": "x86",
      "full_name": "Permute Two-Source Bytes",
      "summary": "Shuffles bytes from two ZMM registers into destination.",
      "syntax": "VPERMI2B zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 75",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "idx",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512_VBMI",
      "slug": "vpermi2b",
      "rel_url": "x86/vpermi2b/",
      "linked_summary": "Shuffles bytes from two ZMM registers into destination.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpermt2b",
      "architecture": "x86",
      "full_name": "Permute Two-Source Bytes (Overwrite)",
      "summary": "Shuffles bytes from two sources, overwriting index.",
      "syntax": "VPERMT2B zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 7D",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "idx",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512_VBMI",
      "slug": "vpermt2b",
      "rel_url": "x86/vpermt2b/",
      "linked_summary": "Shuffles bytes from two sources, overwriting <a href=\"../../armv8-a/index/\">index</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmultishiftqb",
      "architecture": "x86",
      "full_name": "Select Packed Unaligned Bytes from Quadword Sources",
      "summary": "Selects bytes from each 64-bit element based on shift control.",
      "syntax": "VPMULTISHIFTQB zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 83",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "ctrl",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512_VBMI",
      "slug": "vpmultishiftqb",
      "rel_url": "x86/vpmultishiftqb/",
      "linked_summary": "Selects bytes from each 64-<a href=\"../../armv8-a/bit/\">bit</a> element based on shift control.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpshldd",
      "architecture": "x86",
      "full_name": "Packed Shift Left Double Concatenate",
      "summary": "Funnel shift left of doublewords.",
      "syntax": "VPSHLDD zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 71",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        },
        {
          "name": "cnt",
          "desc": "Imm"
        }
      ],
      "extension": "AVX-512_VBMI2",
      "slug": "vpshldd",
      "rel_url": "x86/vpshldd/",
      "linked_summary": "Funnel shift left of doublewords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpshrdd",
      "architecture": "x86",
      "full_name": "Packed Shift Right Double Concatenate",
      "summary": "Funnel shift right of doublewords.",
      "syntax": "VPSHRDD zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 73",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        },
        {
          "name": "cnt",
          "desc": "Imm"
        }
      ],
      "extension": "AVX-512_VBMI2",
      "slug": "vpshrdd",
      "rel_url": "x86/vpshrdd/",
      "linked_summary": "Funnel shift right of doublewords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpcompressb",
      "architecture": "x86",
      "full_name": "Store Sparse Packed Byte Integer Values",
      "summary": "Compresses active bytes from ZMM to memory.",
      "syntax": "VPCOMPRESSB m512 {k1}, zmm1",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 63",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Mem"
        },
        {
          "name": "src",
          "desc": "ZMM"
        }
      ],
      "extension": "AVX-512_VBMI2",
      "slug": "vpcompressb",
      "rel_url": "x86/vpcompressb/",
      "linked_summary": "Compresses active bytes from ZMM to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpexpandb",
      "architecture": "x86",
      "full_name": "Load Sparse Packed Byte Integer Values",
      "summary": "Expands bytes from memory into sparse locations in ZMM.",
      "syntax": "VPEXPANDB zmm1 {k1}, m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 62",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "Mem"
        }
      ],
      "extension": "AVX-512_VBMI2",
      "slug": "vpexpandb",
      "rel_url": "x86/vpexpandb/",
      "linked_summary": "Expands bytes from memory into sparse locations <a href=\"../../x86/in/\">in</a> ZMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpopcntb",
      "architecture": "x86",
      "full_name": "Packed Population Count Byte",
      "summary": "Counts set bits in each byte.",
      "syntax": "VPOPCNTB zmm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 54",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512_BITALG",
      "slug": "vpopcntb",
      "rel_url": "x86/vpopcntb/",
      "linked_summary": "Counts set bits <a href=\"../../x86/in/\">in</a> each byte.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpshufbitqmb",
      "architecture": "x86",
      "full_name": "Shuffle Bits from Quadword Elements to Mask",
      "summary": "Extracts bits from bytes and packs into a mask register.",
      "syntax": "VPSHUFBITQMB k1 {k2}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 8F",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "k-reg"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512_BITALG",
      "slug": "vpshufbitqmb",
      "rel_url": "x86/vpshufbitqmb/",
      "linked_summary": "Extracts bits from bytes <a href=\"../../armv8-a/and_6/\">and</a> packs into a mask register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vp2intersectd",
      "architecture": "x86",
      "full_name": "Compute Intersection Pair Doublewords",
      "summary": "Computes intersection of two ZMM registers into mask pair.",
      "syntax": "VP2INTERSECTD k1+1, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "F2 0F 38 68",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "kdest",
          "desc": "k-pair"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512_VP2INTERSECT",
      "slug": "vp2intersectd",
      "rel_url": "x86/vp2intersectd/",
      "linked_summary": "Computes intersection of two ZMM registers into mask pair.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmadd52luq",
      "architecture": "x86",
      "full_name": "Packed Multiply-Add Unsigned 52-bit Integers (Low)",
      "summary": "Fused multiply-add for 52-bit integers (Low 52 bits).",
      "syntax": "VPMADD52LUQ zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 B4",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512_IFMA",
      "slug": "vpmadd52luq",
      "rel_url": "x86/vpmadd52luq/",
      "linked_summary": "Fused multiply-<a href=\"../../armv8-a/add_8/\">add</a> for 52-<a href=\"../../armv8-a/bit/\">bit</a> integers (Low 52 bits).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmadd52huq",
      "architecture": "x86",
      "full_name": "Packed Multiply-Add Unsigned 52-bit Integers (High)",
      "summary": "Fused multiply-add for 52-bit integers (High 52 bits).",
      "syntax": "VPMADD52HUQ zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 B5",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512_IFMA",
      "slug": "vpmadd52huq",
      "rel_url": "x86/vpmadd52huq/",
      "linked_summary": "Fused multiply-<a href=\"../../armv8-a/add_8/\">add</a> for 52-<a href=\"../../armv8-a/bit/\">bit</a> integers (High 52 bits).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aadd",
      "architecture": "x86",
      "full_name": "Atomically Add",
      "summary": "Atomically adds a value to a remote memory location.",
      "syntax": "AADD m32, r32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "66 0F 38 FC",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Mem"
        },
        {
          "name": "src",
          "desc": "Reg"
        }
      ],
      "extension": "RAO-INT",
      "slug": "aadd",
      "rel_url": "x86/aadd/",
      "linked_summary": "Atomically <a href=\"../../armv8-a/adds_5/\">adds</a> a value to a remote memory location.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aand",
      "architecture": "x86",
      "full_name": "Atomically AND",
      "summary": "Atomically ANDs a value to a remote memory location.",
      "syntax": "AAND m32, r32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "66 0F 38 FC /r",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Mem"
        },
        {
          "name": "src",
          "desc": "Reg"
        }
      ],
      "extension": "RAO-INT",
      "slug": "aand",
      "rel_url": "x86/aand/",
      "linked_summary": "Atomically ANDs a value to a remote memory location.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aor",
      "architecture": "x86",
      "full_name": "Atomically OR",
      "summary": "Atomically ORs a value to a remote memory location.",
      "syntax": "AOR m32, r32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "66 0F 38 FC /r",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Mem"
        },
        {
          "name": "src",
          "desc": "Reg"
        }
      ],
      "extension": "RAO-INT",
      "slug": "aor",
      "rel_url": "x86/aor/",
      "linked_summary": "Atomically ORs a value to a remote memory location.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "axor",
      "architecture": "x86",
      "full_name": "Atomically XOR",
      "summary": "Atomically XORs a value to a remote memory location.",
      "syntax": "AXOR m32, r32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "66 0F 38 FC /r",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Mem"
        },
        {
          "name": "src",
          "desc": "Reg"
        }
      ],
      "extension": "RAO-INT",
      "slug": "axor",
      "rel_url": "x86/axor/",
      "linked_summary": "Atomically XORs a value to a remote memory location.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmpccxadd",
      "architecture": "x86",
      "full_name": "Compare and Add if Condition is Met",
      "summary": "Atomically adds if condition is met.",
      "syntax": "CMPccXADD m32, r32, r32",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 E0",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Mem"
        },
        {
          "name": "src1",
          "desc": "Reg"
        },
        {
          "name": "src2",
          "desc": "Reg"
        }
      ],
      "extension": "CMPccXADD",
      "slug": "cmpccxadd",
      "rel_url": "x86/cmpccxadd/",
      "linked_summary": "Atomically <a href=\"../../armv8-a/adds_5/\">adds</a> if condition is met.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "erets",
      "architecture": "x86",
      "full_name": "Event Return Supervisor",
      "summary": "Returns from an event handler to supervisor mode (FRED).",
      "syntax": "ERETS",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F2 0F 01 CA",
        "length": "4",
        "visual_parts": []
      },
      "operands": [],
      "extension": "FRED",
      "slug": "erets",
      "rel_url": "x86/erets/",
      "linked_summary": "Returns from an event handler to supervisor mode (FRED).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "eretu",
      "architecture": "x86",
      "full_name": "Event Return User",
      "summary": "Returns from an event handler to user mode (FRED).",
      "syntax": "ERETU",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 01 CA",
        "length": "4",
        "visual_parts": []
      },
      "operands": [],
      "extension": "FRED",
      "slug": "eretu",
      "rel_url": "x86/eretu/",
      "linked_summary": "Returns from an event handler to user mode (FRED).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lkgs",
      "architecture": "x86",
      "full_name": "Load Kernel GS Base",
      "summary": "Loads the kernel GS base address (FRED support).",
      "syntax": "LKGS r16",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F2 0F 00 /6",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Reg"
        }
      ],
      "extension": "LKGS",
      "slug": "lkgs",
      "rel_url": "x86/lkgs/",
      "linked_summary": "Loads the kernel GS base address (FRED support).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "enqcmd",
      "architecture": "x86",
      "full_name": "Enqueue Command",
      "summary": "Writes a command to a device (DSA/IAA accelerator).",
      "syntax": "ENQCMD r32, m512",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F2 0F 38 F8",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "Mem"
        }
      ],
      "extension": "ENQCMD",
      "slug": "enqcmd",
      "rel_url": "x86/enqcmd/",
      "linked_summary": "Writes a command to a device (DSA/IAA accelerator).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pconfig",
      "architecture": "x86",
      "full_name": "Platform Configuration",
      "summary": "Configures platform features like MKTME (Memory Encryption).",
      "syntax": "PCONFIG",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 C5",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "PCONFIG",
      "slug": "pconfig",
      "rel_url": "x86/pconfig/",
      "linked_summary": "Configures platform features like MKTME (Memory Encryption).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "wbnoinvd",
      "architecture": "x86",
      "full_name": "Write Back and Do Not Invalidate Cache",
      "summary": "Writes back modified lines but keeps them valid in cache.",
      "syntax": "WBNOINVD",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 09",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "WBNOINVD",
      "slug": "wbnoinvd",
      "rel_url": "x86/wbnoinvd/",
      "linked_summary": "Writes back modified lines but keeps them valid <a href=\"../../x86/in/\">in</a> cache.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aesencwide128kl",
      "architecture": "x86",
      "full_name": "AES Encrypt Wide 128-bit Key Locker",
      "summary": "Encrypts 8 blocks using 128-bit Key Locker handle.",
      "syntax": "AESENCWIDE128KL m128",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 38 D8",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "handle",
          "desc": "Mem"
        }
      ],
      "extension": "KEYLOCKER_WIDE",
      "slug": "aesencwide128kl",
      "rel_url": "x86/aesencwide128kl/",
      "linked_summary": "Encrypts 8 blocks using 128-<a href=\"../../armv8-a/bit/\">bit</a> Key Locker handle.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aesencwide256kl",
      "architecture": "x86",
      "full_name": "AES Encrypt Wide 256-bit Key Locker",
      "summary": "Encrypts 8 blocks using 256-bit Key Locker handle.",
      "syntax": "AESENCWIDE256KL m128",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 38 D8 /1",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "handle",
          "desc": "Mem"
        }
      ],
      "extension": "KEYLOCKER_WIDE",
      "slug": "aesencwide256kl",
      "rel_url": "x86/aesencwide256kl/",
      "linked_summary": "Encrypts 8 blocks using 256-<a href=\"../../armv8-a/bit/\">bit</a> Key Locker handle.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fucom",
      "architecture": "x86",
      "full_name": "Unordered Compare Real",
      "summary": "Compares ST(0) with source (supports NaNs).",
      "syntax": "FUCOM ST(i)",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "DD E0+i",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Reg"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fucom",
      "rel_url": "x86/fucom/",
      "linked_summary": "Compares ST(0) with source (supports NaNs).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "frndint",
      "architecture": "x86",
      "full_name": "Round to Integer",
      "summary": "Rounds ST(0) to integer according to RC field.",
      "syntax": "FRNDINT",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 FC",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "frndint",
      "rel_url": "x86/frndint/",
      "linked_summary": "Rounds ST(0) to integer according to RC field.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fscale",
      "architecture": "x86",
      "full_name": "Scale",
      "summary": "Scales ST(0) by ST(1) (ST(0) * 2^ST(1)).",
      "syntax": "FSCALE",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 FD",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fscale",
      "rel_url": "x86/fscale/",
      "linked_summary": "Scales ST(0) by ST(1) (ST(0) * 2^ST(1)).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fxtract",
      "architecture": "x86",
      "full_name": "Extract Exponent and Significand",
      "summary": "Separates exponent and significand of ST(0).",
      "syntax": "FXTRACT",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 F4",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fxtract",
      "rel_url": "x86/fxtract/",
      "linked_summary": "Separates exponent <a href=\"../../armv8-a/and_6/\">and</a> significand of ST(0).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "f2xm1",
      "architecture": "x86",
      "full_name": "Compute 2^x - 1",
      "summary": "Computes (2^ST(0)) - 1.",
      "syntax": "F2XM1",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 F0",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "f2xm1",
      "rel_url": "x86/f2xm1/",
      "linked_summary": "Computes (2^ST(0)) - 1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fyl2xp1",
      "architecture": "x86",
      "full_name": "Compute y * log2(x + 1)",
      "summary": "Computes ST(1) * log2(ST(0) + 1).",
      "syntax": "FYL2XP1",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 F9",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fyl2xp1",
      "rel_url": "x86/fyl2xp1/",
      "linked_summary": "Computes ST(1) * log2(ST(0) + 1).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "clrssbsy",
      "architecture": "x86",
      "full_name": "Clear Shadow Stack Busy Flag",
      "summary": "Clears the busy flag in the shadow stack token.",
      "syntax": "CLRSSBSY m64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F AE /6",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "token",
          "desc": "Mem"
        }
      ],
      "extension": "CET-SS",
      "slug": "clrssbsy",
      "rel_url": "x86/clrssbsy/",
      "linked_summary": "Clears the busy flag <a href=\"../../x86/in/\">in</a> the shadow stack token.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tdpfp16ps",
      "architecture": "x86",
      "full_name": "Tile Dot Product FP16 Packed Single",
      "summary": "Matrix multiply (FP16 * FP16) accumulating to Float32.",
      "syntax": "TDPFP16PS tmm1, tmm2, tmm3",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 5C",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "TMM"
        },
        {
          "name": "src1",
          "desc": "TMM"
        },
        {
          "name": "src2",
          "desc": "TMM"
        }
      ],
      "extension": "AMX-FP16",
      "slug": "tdpfp16ps",
      "rel_url": "x86/tdpfp16ps/",
      "linked_summary": "Matrix multiply (FP16 * FP16) accumulating to Float32.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mov",
      "architecture": "x86",
      "full_name": "Move",
      "summary": "Copies data from source to destination.",
      "syntax": "MOV r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x89",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        },
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "Base",
      "slug": "mov",
      "rel_url": "x86/mov/",
      "linked_summary": "Copies data from source to destination.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "add",
      "architecture": "x86",
      "full_name": "Add",
      "summary": "Adds src to dest and stores result in dest.",
      "syntax": "ADD r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x01",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        },
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "Base",
      "slug": "add",
      "rel_url": "x86/add/",
      "linked_summary": "Adds src to dest <a href=\"../../armv8-a/and_6/\">and</a> stores result <a href=\"../../x86/in/\">in</a> dest.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sub",
      "architecture": "x86",
      "full_name": "Subtract",
      "summary": "Subtracts src from dest.",
      "syntax": "SUB r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x29",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        },
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "Base",
      "slug": "sub",
      "rel_url": "x86/sub/",
      "linked_summary": "Subtracts src from dest.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "inc",
      "architecture": "x86",
      "full_name": "Increment",
      "summary": "Increments the operand by 1.",
      "syntax": "INC r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xFF /0",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        }
      ],
      "extension": "Base",
      "slug": "inc",
      "rel_url": "x86/inc/",
      "linked_summary": "Increments the operand by 1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dec",
      "architecture": "x86",
      "full_name": "Decrement",
      "summary": "Decrements the operand by 1.",
      "syntax": "DEC r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xFF /1",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        }
      ],
      "extension": "Base",
      "slug": "dec",
      "rel_url": "x86/dec/",
      "linked_summary": "Decrements the operand by 1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mul",
      "architecture": "x86",
      "full_name": "Unsigned Multiply",
      "summary": "Unsigned multiply (AX = AL * src).",
      "syntax": "MUL r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xF7 /4",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Register/Memory"
        }
      ],
      "extension": "Base",
      "slug": "mul",
      "rel_url": "x86/mul/",
      "linked_summary": "Unsigned multiply (AX = AL * src).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "imul",
      "architecture": "x86",
      "full_name": "Signed Multiply",
      "summary": "Signed multiply.",
      "syntax": "IMUL r, r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F AF",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "Base",
      "slug": "imul",
      "rel_url": "x86/imul/",
      "linked_summary": "Signed multiply.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "div",
      "architecture": "x86",
      "full_name": "Unsigned Divide",
      "summary": "Unsigned divide (AX / src).",
      "syntax": "DIV r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xF7 /6",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Register/Memory"
        }
      ],
      "extension": "Base",
      "slug": "div",
      "rel_url": "x86/div/",
      "linked_summary": "Unsigned divide (AX / src).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "idiv",
      "architecture": "x86",
      "full_name": "Signed Divide",
      "summary": "Signed divide (AX / src).",
      "syntax": "IDIV r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xF7 /7",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Register/Memory"
        }
      ],
      "extension": "Base",
      "slug": "idiv",
      "rel_url": "x86/idiv/",
      "linked_summary": "Signed divide (AX / src).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "and",
      "architecture": "x86",
      "full_name": "Logical AND",
      "summary": "Performs bitwise AND.",
      "syntax": "AND r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x21",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        },
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "Base",
      "slug": "and",
      "rel_url": "x86/and/",
      "linked_summary": "Performs bitwise <a href=\"../../risc-v/and/\">AND</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "or",
      "architecture": "x86",
      "full_name": "Logical OR",
      "summary": "Performs bitwise OR.",
      "syntax": "OR r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x09",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        },
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "Base",
      "slug": "or",
      "rel_url": "x86/or/",
      "linked_summary": "Performs bitwise <a href=\"../../risc-v/or/\">OR</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xor",
      "architecture": "x86",
      "full_name": "Logical Exclusive OR",
      "summary": "Performs bitwise XOR.",
      "syntax": "XOR r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x31",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        },
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "Base",
      "slug": "xor",
      "rel_url": "x86/xor/",
      "linked_summary": "Performs bitwise <a href=\"../../risc-v/xor/\">XOR</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "not",
      "architecture": "x86",
      "full_name": "One's Complement Negation",
      "summary": "Reverses bits of operand.",
      "syntax": "NOT r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xF7 /2",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        }
      ],
      "extension": "Base",
      "slug": "not",
      "rel_url": "x86/not/",
      "linked_summary": "Reverses bits of operand.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "neg",
      "architecture": "x86",
      "full_name": "Two's Complement Negation",
      "summary": "Negates value (0 - operand).",
      "syntax": "NEG r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xF7 /3",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        }
      ],
      "extension": "Base",
      "slug": "neg",
      "rel_url": "x86/neg/",
      "linked_summary": "Negates value (0 - operand).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "shl",
      "architecture": "x86",
      "full_name": "Shift Logical Left",
      "summary": "Shifts bits left (same as SAL).",
      "syntax": "SHL r/m, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xC1 /4",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        },
        {
          "name": "count",
          "desc": "Immediate"
        }
      ],
      "extension": "Base",
      "slug": "shl",
      "rel_url": "x86/shl/",
      "linked_summary": "Shifts bits left (same as SAL).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "shr",
      "architecture": "x86",
      "full_name": "Shift Logical Right",
      "summary": "Shifts bits right, filling with zeros.",
      "syntax": "SHR r/m, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xC1 /5",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        },
        {
          "name": "count",
          "desc": "Immediate"
        }
      ],
      "extension": "Base",
      "slug": "shr",
      "rel_url": "x86/shr/",
      "linked_summary": "Shifts bits right, filling with zeros.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sar",
      "architecture": "x86",
      "full_name": "Shift Arithmetic Right",
      "summary": "Shifts bits right, preserving sign bit.",
      "syntax": "SAR r/m, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xC1 /7",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        },
        {
          "name": "count",
          "desc": "Immediate"
        }
      ],
      "extension": "Base",
      "slug": "sar",
      "rel_url": "x86/sar/",
      "linked_summary": "Shifts bits right, preserving sign <a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmp",
      "architecture": "x86",
      "full_name": "Compare Two Operands",
      "summary": "Subtracts src from dest and updates flags (dest not modified).",
      "syntax": "CMP r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x39",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        },
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "Base",
      "slug": "cmp",
      "rel_url": "x86/cmp/",
      "linked_summary": "Subtracts src from dest <a href=\"../../armv8-a/and_6/\">and</a> updates flags (dest <a href=\"../../armv8-a/not_1/\">not</a> modified).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "test",
      "architecture": "x86",
      "full_name": "Logical Compare",
      "summary": "ANDs operands and updates flags (result discarded).",
      "syntax": "TEST r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x85",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        },
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "Base",
      "slug": "test",
      "rel_url": "x86/test/",
      "linked_summary": "ANDs operands <a href=\"../../armv8-a/and_6/\">and</a> updates flags (result discarded).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "jmp",
      "architecture": "x86",
      "full_name": "Jump",
      "summary": "Unconditional jump to target.",
      "syntax": "JMP rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xE9",
        "length": "5",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "rel",
          "desc": "Offset"
        }
      ],
      "extension": "Base",
      "slug": "jmp",
      "rel_url": "x86/jmp/",
      "linked_summary": "Unconditional jump to target.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "je",
      "architecture": "x86",
      "full_name": "Jump if Equal",
      "summary": "Jump if ZF=1 (Same as JZ).",
      "syntax": "JE rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x74",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "rel",
          "desc": "Offset"
        }
      ],
      "extension": "Base",
      "slug": "je",
      "rel_url": "x86/je/",
      "linked_summary": "Jump if ZF=1 (Same as JZ).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "jne",
      "architecture": "x86",
      "full_name": "Jump if Not Equal",
      "summary": "Jump if ZF=0 (Same as JNZ).",
      "syntax": "JNE rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x75",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "rel",
          "desc": "Offset"
        }
      ],
      "extension": "Base",
      "slug": "jne",
      "rel_url": "x86/jne/",
      "linked_summary": "Jump if ZF=0 (Same as JNZ).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "jg",
      "architecture": "x86",
      "full_name": "Jump if Greater",
      "summary": "Jump if ZF=0 and SF=OF (Signed >).",
      "syntax": "JG rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x7F",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "rel",
          "desc": "Offset"
        }
      ],
      "extension": "Base",
      "slug": "jg",
      "rel_url": "x86/jg/",
      "linked_summary": "Jump if ZF=0 <a href=\"../../armv8-a/and_6/\">and</a> SF=OF (Signed >).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "jl",
      "architecture": "x86",
      "full_name": "Jump if Less",
      "summary": "Jump if SF!=OF (Signed <).",
      "syntax": "JL rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x7C",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "rel",
          "desc": "Offset"
        }
      ],
      "extension": "Base",
      "slug": "jl",
      "rel_url": "x86/jl/",
      "linked_summary": "Jump if SF!=OF (Signed <).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ja",
      "architecture": "x86",
      "full_name": "Jump if Above",
      "summary": "Jump if CF=0 and ZF=0 (Unsigned >).",
      "syntax": "JA rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x77",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "rel",
          "desc": "Offset"
        }
      ],
      "extension": "Base",
      "slug": "ja",
      "rel_url": "x86/ja/",
      "linked_summary": "Jump if CF=0 <a href=\"../../armv8-a/and_6/\">and</a> ZF=0 (Unsigned >).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "jb",
      "architecture": "x86",
      "full_name": "Jump if Below",
      "summary": "Jump if CF=1 (Unsigned <).",
      "syntax": "JB rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x72",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "rel",
          "desc": "Offset"
        }
      ],
      "extension": "Base",
      "slug": "jb",
      "rel_url": "x86/jb/",
      "linked_summary": "Jump if CF=1 (Unsigned <).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "call",
      "architecture": "x86",
      "full_name": "Call Procedure",
      "summary": "Push EIP/RIP and jump to target.",
      "syntax": "CALL rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xE8",
        "length": "5",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "rel",
          "desc": "Offset"
        }
      ],
      "extension": "Base",
      "slug": "call",
      "rel_url": "x86/call/",
      "linked_summary": "Push EIP/RIP <a href=\"../../armv8-a/and_6/\">and</a> jump to target.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ret",
      "architecture": "x86",
      "full_name": "Return from Procedure",
      "summary": "Pop EIP/RIP and resume execution.",
      "syntax": "RET",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xC3",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "ret",
      "rel_url": "x86/ret/",
      "linked_summary": "Pop EIP/RIP <a href=\"../../armv8-a/and_6/\">and</a> resume execution.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "push",
      "architecture": "x86",
      "full_name": "Push Word/Doubleword/Quadword Onto Stack",
      "summary": "Decrements SP and stores operand on stack.",
      "syntax": "PUSH r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xFF /6",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "Base",
      "slug": "push",
      "rel_url": "x86/push/",
      "linked_summary": "Decrements SP <a href=\"../../armv8-a/and_6/\">and</a> stores operand on stack.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pop",
      "architecture": "x86",
      "full_name": "Pop Value from Stack",
      "summary": "Loads operand from stack and increments SP.",
      "syntax": "POP r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x8F /0",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "Base",
      "slug": "pop",
      "rel_url": "x86/pop/",
      "linked_summary": "Loads operand from stack <a href=\"../../armv8-a/and_6/\">and</a> increments SP.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lea",
      "architecture": "x86",
      "full_name": "Load Effective Address",
      "summary": "Computes effective address and stores in register.",
      "syntax": "LEA r, m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x8D",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register"
        },
        {
          "name": "src",
          "desc": "Memory"
        }
      ],
      "extension": "Base",
      "slug": "lea",
      "rel_url": "x86/lea/",
      "linked_summary": "Computes effective address <a href=\"../../armv8-a/and_6/\">and</a> stores <a href=\"../../x86/in/\">in</a> register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "nop",
      "architecture": "x86",
      "full_name": "No Operation",
      "summary": "Does nothing (alias for XCHG EAX, EAX).",
      "syntax": "NOP",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x90",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "nop",
      "rel_url": "x86/nop/",
      "linked_summary": "Does nothing (alias for XCHG EAX, EAX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xchg",
      "architecture": "x86",
      "full_name": "Exchange Register/Memory with Register",
      "summary": "Exchanges content of two operands.",
      "syntax": "XCHG r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x87",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "op1",
          "desc": "Reg/Mem"
        },
        {
          "name": "op2",
          "desc": "Register"
        }
      ],
      "extension": "Base",
      "slug": "xchg",
      "rel_url": "x86/xchg/",
      "linked_summary": "Exchanges content of two operands.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cpuid",
      "architecture": "x86",
      "full_name": "CPU Identification",
      "summary": "Returns processor information based on EAX value.",
      "syntax": "CPUID",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F A2",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "cpuid",
      "rel_url": "x86/cpuid/",
      "linked_summary": "Returns processor information based on EAX value.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rdtsc",
      "architecture": "x86",
      "full_name": "Read Time-Stamp Counter",
      "summary": "Reads the time-stamp counter into EDX:EAX.",
      "syntax": "RDTSC",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F 31",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "rdtsc",
      "rel_url": "x86/rdtsc/",
      "linked_summary": "Reads the time-stamp counter into EDX:EAX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movsx",
      "architecture": "x86",
      "full_name": "Move with Sign-Extension",
      "summary": "Copies and sign-extends a smaller value to a larger register.",
      "syntax": "MOVSX r, r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F BE",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "Base",
      "slug": "movsx",
      "rel_url": "x86/movsx/",
      "linked_summary": "Copies <a href=\"../../armv8-a/and_6/\">and</a> sign-extends a smaller value to a larger register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movzx",
      "architecture": "x86",
      "full_name": "Move with Zero-Extension",
      "summary": "Copies and zero-extends a smaller value to a larger register.",
      "syntax": "MOVZX r, r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F B6",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "Base",
      "slug": "movzx",
      "rel_url": "x86/movzx/",
      "linked_summary": "Copies <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../armv9-a/zero_1/\">zero</a>-extends a smaller value to a larger register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cwtl",
      "architecture": "x86",
      "full_name": "Convert Word to Long",
      "summary": "Sign-extends AX into EAX (also CWDE).",
      "syntax": "CWTL",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x98",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "cwtl",
      "rel_url": "x86/cwtl/",
      "linked_summary": "Sign-extends AX into EAX (also CWDE).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cltd",
      "architecture": "x86",
      "full_name": "Convert Long to Double Long",
      "summary": "Sign-extends EAX into EDX:EAX (also CDQ).",
      "syntax": "CLTD",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x99",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "cltd",
      "rel_url": "x86/cltd/",
      "linked_summary": "Sign-extends EAX into EDX:EAX (also CDQ).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cqto",
      "architecture": "x86",
      "full_name": "Convert Quadword to Octoword",
      "summary": "Sign-extends RAX into RDX:RAX (also CQO).",
      "syntax": "CQTO",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x48 99",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base (64-bit)",
      "slug": "cqto",
      "rel_url": "x86/cqto/",
      "linked_summary": "Sign-extends RAX into RDX:RAX (also CQO).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bswap",
      "architecture": "x86",
      "full_name": "Byte Swap",
      "summary": "Reverses the byte order of a register (Endian swap).",
      "syntax": "BSWAP r32",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F C8+rd",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "reg",
          "desc": "Register"
        }
      ],
      "extension": "Base",
      "slug": "bswap",
      "rel_url": "x86/bswap/",
      "linked_summary": "Reverses the byte order of a register (Endian swap).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xadd",
      "architecture": "x86",
      "full_name": "Exchange and Add",
      "summary": "Exchanges dest and src, then loads sum into dest.",
      "syntax": "XADD r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F C1",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        },
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "Base",
      "slug": "xadd",
      "rel_url": "x86/xadd/",
      "linked_summary": "Exchanges dest <a href=\"../../armv8-a/and_6/\">and</a> src, then loads sum into dest.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmpxchg",
      "architecture": "x86",
      "full_name": "Compare and Exchange",
      "summary": "Compares accumulator with dest; if equal, dest = src; else accumulator = dest.",
      "syntax": "CMPXCHG r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F B1",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        },
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "Base",
      "slug": "cmpxchg",
      "rel_url": "x86/cmpxchg/",
      "linked_summary": "Compares accumulator with dest; if equal, dest = src; else accumulator = dest.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmovcc",
      "architecture": "x86",
      "full_name": "Conditional Move",
      "summary": "Moves data if condition code is met (e.g., CMOVE, CMOVNE).",
      "syntax": "CMOVcc r, r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F 4x",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "CMOV",
      "slug": "cmovcc",
      "rel_url": "x86/cmovcc/",
      "linked_summary": "Moves data if condition code is met (e.g., CMOVE, CMOVNE).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "setcc",
      "architecture": "x86",
      "full_name": "Set Byte on Condition",
      "summary": "Sets byte to 1 if condition met, else 0 (e.g., SETE, SETZ).",
      "syntax": "SETcc r/m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F 9x",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "Base",
      "slug": "setcc",
      "rel_url": "x86/setcc/",
      "linked_summary": "Sets byte to 1 if condition met, else 0 (e.g., SETE, SETZ).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "hlt",
      "architecture": "x86",
      "full_name": "Halt",
      "summary": "Stops instruction execution and places processor in HALT state.",
      "syntax": "HLT",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xF4",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "hlt",
      "rel_url": "x86/hlt/",
      "linked_summary": "Stops instruction execution <a href=\"../../armv8-a/and_6/\">and</a> places processor <a href=\"../../x86/in/\">in</a> HALT state.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "int",
      "architecture": "x86",
      "full_name": "Interrupt",
      "summary": "Calls to interrupt procedure.",
      "syntax": "INT imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xCD",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "vector",
          "desc": "ID"
        }
      ],
      "extension": "Base",
      "slug": "int",
      "rel_url": "x86/int/",
      "linked_summary": "Calls to interrupt procedure.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "int3",
      "architecture": "x86",
      "full_name": "Breakpoint",
      "summary": "Calls to interrupt vector 3 (Debugger breakpoint).",
      "syntax": "INT3",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xCC",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "int3",
      "rel_url": "x86/int3/",
      "linked_summary": "Calls to interrupt vector 3 (Debugger breakpoint).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ud2",
      "architecture": "x86",
      "full_name": "Undefined Instruction",
      "summary": "Generates an invalid opcode exception.",
      "syntax": "UD2",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F 0B",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "ud2",
      "rel_url": "x86/ud2/",
      "linked_summary": "Generates an invalid opcode exception.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pause",
      "architecture": "x86",
      "full_name": "Spin Loop Hint",
      "summary": "Improves performance of spin-wait loops (alias for REP NOP).",
      "syntax": "PAUSE",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xF3 90",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "pause",
      "rel_url": "x86/pause/",
      "linked_summary": "Improves performance of spin-<a href=\"../../powerisa/wait_1/\">wait</a> loops (alias for REP <a href=\"../../risc-v/nop/\">NOP</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "clc",
      "architecture": "x86",
      "full_name": "Clear Carry Flag",
      "summary": "Sets the CF flag to 0.",
      "syntax": "CLC",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xF8",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "clc",
      "rel_url": "x86/clc/",
      "linked_summary": "Sets the CF flag to 0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stc",
      "architecture": "x86",
      "full_name": "Set Carry Flag",
      "summary": "Sets the CF flag to 1.",
      "syntax": "STC",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xF9",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "stc",
      "rel_url": "x86/stc/",
      "linked_summary": "Sets the CF flag to 1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmc",
      "architecture": "x86",
      "full_name": "Complement Carry Flag",
      "summary": "Toggles the CF flag.",
      "syntax": "CMC",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xF5",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "cmc",
      "rel_url": "x86/cmc/",
      "linked_summary": "Toggles the CF flag.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cld",
      "architecture": "x86",
      "full_name": "Clear Direction Flag",
      "summary": "Sets DF to 0 (String operations increment).",
      "syntax": "CLD",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xFC",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "cld",
      "rel_url": "x86/cld/",
      "linked_summary": "Sets DF to 0 (String operations increment).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "std",
      "architecture": "x86",
      "full_name": "Set Direction Flag",
      "summary": "Sets DF to 1 (String operations decrement).",
      "syntax": "STD",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xFD",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "std",
      "rel_url": "x86/std/",
      "linked_summary": "Sets DF to 1 (String operations decrement).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cli",
      "architecture": "x86",
      "full_name": "Clear Interrupt Flag",
      "summary": "Disables maskable hardware interrupts.",
      "syntax": "CLI",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xFA",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "cli",
      "rel_url": "x86/cli/",
      "linked_summary": "Disables maskable hardware interrupts.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sti",
      "architecture": "x86",
      "full_name": "Set Interrupt Flag",
      "summary": "Enables maskable hardware interrupts.",
      "syntax": "STI",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xFB",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "sti",
      "rel_url": "x86/sti/",
      "linked_summary": "Enables maskable hardware interrupts.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sahf",
      "architecture": "x86",
      "full_name": "Store AH into Flags",
      "summary": "Loads SF, ZF, AF, PF, and CF from AH.",
      "syntax": "SAHF",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x9E",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "sahf",
      "rel_url": "x86/sahf/",
      "linked_summary": "Loads SF, ZF, AF, PF, <a href=\"../../armv8-a/and_6/\">and</a> CF from AH.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lahf",
      "architecture": "x86",
      "full_name": "Load Flags into AH",
      "summary": "Loads bits 0, 2, 4, 6, and 7 of EFLAGS into AH.",
      "syntax": "LAHF",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x9F",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "lahf",
      "rel_url": "x86/lahf/",
      "linked_summary": "Loads bits 0, 2, 4, 6, <a href=\"../../armv8-a/and_6/\">and</a> 7 of EFLAGS into AH.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "loop",
      "architecture": "x86",
      "full_name": "Loop",
      "summary": "Decrements ECX/RCX and jumps if not zero.",
      "syntax": "LOOP rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xE2",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "rel",
          "desc": "Offset"
        }
      ],
      "extension": "Base",
      "slug": "loop",
      "rel_url": "x86/loop/",
      "linked_summary": "Decrements ECX/RCX <a href=\"../../armv8-a/and_6/\">and</a> jumps if <a href=\"../../armv8-a/not_1/\">not</a> <a href=\"../../armv9-a/zero_1/\">zero</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "loope",
      "architecture": "x86",
      "full_name": "Loop if Equal",
      "summary": "Decrements count; jumps if count!=0 and ZF=1.",
      "syntax": "LOOPE rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xE1",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "rel",
          "desc": "Offset"
        }
      ],
      "extension": "Base",
      "slug": "loope",
      "rel_url": "x86/loope/",
      "linked_summary": "Decrements count; jumps if count!=0 <a href=\"../../armv8-a/and_6/\">and</a> ZF=1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "loopne",
      "architecture": "x86",
      "full_name": "Loop if Not Equal",
      "summary": "Decrements count; jumps if count!=0 and ZF=0.",
      "syntax": "LOOPNE rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xE0",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "rel",
          "desc": "Offset"
        }
      ],
      "extension": "Base",
      "slug": "loopne",
      "rel_url": "x86/loopne/",
      "linked_summary": "Decrements count; jumps if count!=0 <a href=\"../../armv8-a/and_6/\">and</a> ZF=0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "jecxz",
      "architecture": "x86",
      "full_name": "Jump if ECX is Zero",
      "summary": "Jumps if ECX register is 0.",
      "syntax": "JECXZ rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xE3",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "rel",
          "desc": "Offset"
        }
      ],
      "extension": "Base",
      "slug": "jecxz",
      "rel_url": "x86/jecxz/",
      "linked_summary": "Jumps if ECX register is 0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "enter",
      "architecture": "x86",
      "full_name": "Make Stack Frame",
      "summary": "Creates a stack frame for procedure parameters.",
      "syntax": "ENTER imm16, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xC8",
        "length": "4",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "alloc",
          "desc": "Bytes"
        },
        {
          "name": "nesting",
          "desc": "Level"
        }
      ],
      "extension": "Base",
      "slug": "enter",
      "rel_url": "x86/enter/",
      "linked_summary": "Creates a stack frame for procedure parameters.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "leave",
      "architecture": "x86",
      "full_name": "High Level Procedure Exit",
      "summary": "Releases stack frame (MOV ESP, EBP; POP EBP).",
      "syntax": "LEAVE",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xC9",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "leave",
      "rel_url": "x86/leave/",
      "linked_summary": "Releases stack frame (MOV ESP, EBP; POP EBP).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rep movs",
      "architecture": "x86",
      "full_name": "Repeat Move String",
      "summary": "Moves ECX bytes/words from [ESI] to [EDI].",
      "syntax": "REP MOVS m, m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xF3 A4/A5",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "rep_movs",
      "rel_url": "x86/rep_movs/",
      "linked_summary": "Moves ECX bytes/words from [ESI] to [EDI].",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rep stos",
      "architecture": "x86",
      "full_name": "Repeat Store String",
      "summary": "Fills [EDI] with AL/AX/EAX for ECX repeats.",
      "syntax": "REP STOS m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xF3 AA/AB",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "rep_stos",
      "rel_url": "x86/rep_stos/",
      "linked_summary": "Fills [EDI] with AL/AX/EAX for ECX repeats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "repe cmps",
      "architecture": "x86",
      "full_name": "Repeat Compare String Equal",
      "summary": "Compares [ESI] and [EDI] until mismatch or ECX=0.",
      "syntax": "REPE CMPS m, m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xF3 A6/A7",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "repe_cmps",
      "rel_url": "x86/repe_cmps/",
      "linked_summary": "Compares [ESI] <a href=\"../../armv8-a/and_6/\">and</a> [EDI] until mismatch <a href=\"../../powerisa/or/\">or</a> ECX=0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "repne scas",
      "architecture": "x86",
      "full_name": "Repeat Scan String Not Equal",
      "summary": "Scans [EDI] for AL/AX/EAX until match or ECX=0.",
      "syntax": "REPNE SCAS m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xF2 AE/AF",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "repne_scas",
      "rel_url": "x86/repne_scas/",
      "linked_summary": "Scans [EDI] for AL/AX/EAX until <a href=\"../../armv9-a/match_1/\">match</a> <a href=\"../../powerisa/or/\">or</a> ECX=0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rol",
      "architecture": "x86",
      "full_name": "Rotate Left",
      "summary": "Rotates bits left.",
      "syntax": "ROL r/m, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xC1 /0",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "Base",
      "slug": "rol",
      "rel_url": "x86/rol/",
      "linked_summary": "Rotates bits left.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ror",
      "architecture": "x86",
      "full_name": "Rotate Right",
      "summary": "Rotates bits right.",
      "syntax": "ROR r/m, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xC1 /1",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "Base",
      "slug": "ror",
      "rel_url": "x86/ror/",
      "linked_summary": "Rotates bits right.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rcl",
      "architecture": "x86",
      "full_name": "Rotate Carry Left",
      "summary": "Rotates bits left through Carry Flag.",
      "syntax": "RCL r/m, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xC1 /2",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "Base",
      "slug": "rcl",
      "rel_url": "x86/rcl/",
      "linked_summary": "Rotates bits left through Carry Flag.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rcr",
      "architecture": "x86",
      "full_name": "Rotate Carry Right",
      "summary": "Rotates bits right through Carry Flag.",
      "syntax": "RCR r/m, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xC1 /3",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "Base",
      "slug": "rcr",
      "rel_url": "x86/rcr/",
      "linked_summary": "Rotates bits right through Carry Flag.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bt",
      "architecture": "x86",
      "full_name": "Bit Test",
      "summary": "Selects a bit and stores it in CF.",
      "syntax": "BT r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F A3",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "base",
          "desc": "Reg/Mem"
        },
        {
          "name": "offset",
          "desc": "Reg"
        }
      ],
      "extension": "Base",
      "slug": "bt",
      "rel_url": "x86/bt/",
      "linked_summary": "Selects a <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../armv8-a/and_6/\">and</a> stores <a href=\"../../armv8-a/it/\">it</a> <a href=\"../../x86/in/\">in</a> CF.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bts",
      "architecture": "x86",
      "full_name": "Bit Test and Set",
      "summary": "Stores bit in CF and sets bit to 1.",
      "syntax": "BTS r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F AB",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "base",
          "desc": "Reg/Mem"
        },
        {
          "name": "offset",
          "desc": "Reg"
        }
      ],
      "extension": "Base",
      "slug": "bts",
      "rel_url": "x86/bts/",
      "linked_summary": "Stores <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> CF <a href=\"../../armv8-a/and_6/\">and</a> sets <a href=\"../../armv8-a/bit/\">bit</a> to 1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "btr",
      "architecture": "x86",
      "full_name": "Bit Test and Reset",
      "summary": "Stores bit in CF and clears bit to 0.",
      "syntax": "BTR r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F B3",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "base",
          "desc": "Reg/Mem"
        },
        {
          "name": "offset",
          "desc": "Reg"
        }
      ],
      "extension": "Base",
      "slug": "btr",
      "rel_url": "x86/btr/",
      "linked_summary": "Stores <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> CF <a href=\"../../armv8-a/and_6/\">and</a> clears <a href=\"../../armv8-a/bit/\">bit</a> to 0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "btc",
      "architecture": "x86",
      "full_name": "Bit Test and Complement",
      "summary": "Stores bit in CF and complements the bit.",
      "syntax": "BTC r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F BB",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "base",
          "desc": "Reg/Mem"
        },
        {
          "name": "offset",
          "desc": "Reg"
        }
      ],
      "extension": "Base",
      "slug": "btc",
      "rel_url": "x86/btc/",
      "linked_summary": "Stores <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> CF <a href=\"../../armv8-a/and_6/\">and</a> complements the <a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bsf",
      "architecture": "x86",
      "full_name": "Bit Scan Forward",
      "summary": "Scans for LSB set to 1.",
      "syntax": "BSF r, r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F BC",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "Base",
      "slug": "bsf",
      "rel_url": "x86/bsf/",
      "linked_summary": "Scans for LSB set to 1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bsr",
      "architecture": "x86",
      "full_name": "Bit Scan Reverse",
      "summary": "Scans for MSB set to 1.",
      "syntax": "BSR r, r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F BD",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "Base",
      "slug": "bsr",
      "rel_url": "x86/bsr/",
      "linked_summary": "Scans for MSB set to 1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lzcnt",
      "architecture": "x86",
      "full_name": "Count Leading Zeros",
      "summary": "Counts number of leading zeros.",
      "syntax": "LZCNT r, r/m",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "F3 0F BD",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "ABM/BMI",
      "slug": "lzcnt",
      "rel_url": "x86/lzcnt/",
      "linked_summary": "Counts number of leading zeros.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "popcnt",
      "architecture": "x86",
      "full_name": "Population Count",
      "summary": "Counts number of bits set to 1.",
      "syntax": "POPCNT r, r/m",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "F3 0F B8",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "SSE4.2",
      "slug": "popcnt",
      "rel_url": "x86/popcnt/",
      "linked_summary": "Counts number of bits set to 1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xlat",
      "architecture": "x86",
      "full_name": "Table Look-up Translation",
      "summary": "Replaces AL with byte from table at [EBX+AL].",
      "syntax": "XLAT m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD7",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "xlat",
      "rel_url": "x86/xlat/",
      "linked_summary": "Replaces AL with byte from table <a href=\"../../armv8-a/at_2/\">at</a> [EBX+AL].",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pushf",
      "architecture": "x86",
      "full_name": "Push Flags",
      "summary": "Pushes EFLAGS onto stack.",
      "syntax": "PUSHF",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x9C",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "pushf",
      "rel_url": "x86/pushf/",
      "linked_summary": "Pushes EFLAGS onto stack.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "popf",
      "architecture": "x86",
      "full_name": "Pop Flags",
      "summary": "Pops stack into EFLAGS.",
      "syntax": "POPF",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x9D",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "popf",
      "rel_url": "x86/popf/",
      "linked_summary": "Pops stack into EFLAGS.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pusha",
      "architecture": "x86",
      "full_name": "Push All General-Purpose Registers",
      "summary": "Pushes AX, CX, DX, BX, SP, BP, SI, DI (Invalid in 64-bit).",
      "syntax": "PUSHA",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x60",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base (32-bit only)",
      "slug": "pusha",
      "rel_url": "x86/pusha/",
      "linked_summary": "Pushes AX, CX, DX, BX, SP, BP, SI, DI (Invalid <a href=\"../../x86/in/\">in</a> 64-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "popa",
      "architecture": "x86",
      "full_name": "Pop All General-Purpose Registers",
      "summary": "Pops into DI, SI, BP, SP, BX, DX, CX, AX (Invalid in 64-bit).",
      "syntax": "POPA",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x61",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base (32-bit only)",
      "slug": "popa",
      "rel_url": "x86/popa/",
      "linked_summary": "Pops into DI, SI, BP, SP, BX, DX, CX, AX (Invalid <a href=\"../../x86/in/\">in</a> 64-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bound",
      "architecture": "x86",
      "full_name": "Check Array Index Against Bounds",
      "summary": "Checks if operand is within bounds defined in memory.",
      "syntax": "BOUND r, m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x62",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "idx",
          "desc": "Register"
        },
        {
          "name": "bounds",
          "desc": "Memory"
        }
      ],
      "extension": "Base (32-bit only)",
      "slug": "bound",
      "rel_url": "x86/bound/",
      "linked_summary": "Checks if operand is within bounds defined <a href=\"../../x86/in/\">in</a> memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aaa",
      "architecture": "x86",
      "full_name": "ASCII Adjust After Addition",
      "summary": "Adjusts AL after addition for unpacked BCD.",
      "syntax": "AAA",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x37",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base (Legacy)",
      "slug": "aaa",
      "rel_url": "x86/aaa/",
      "linked_summary": "Adjusts AL after addition for unpacked BCD.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aas",
      "architecture": "x86",
      "full_name": "ASCII Adjust After Subtraction",
      "summary": "Adjusts AL after subtraction for unpacked BCD.",
      "syntax": "AAS",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x3F",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base (Legacy)",
      "slug": "aas",
      "rel_url": "x86/aas/",
      "linked_summary": "Adjusts AL after subtraction for unpacked BCD.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "daa",
      "architecture": "x86",
      "full_name": "Decimal Adjust After Addition",
      "summary": "Adjusts AL after addition for packed BCD.",
      "syntax": "DAA",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x27",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base (Legacy)",
      "slug": "daa",
      "rel_url": "x86/daa/",
      "linked_summary": "Adjusts AL after addition for packed BCD.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "das",
      "architecture": "x86",
      "full_name": "Decimal Adjust After Subtraction",
      "summary": "Adjusts AL after subtraction for packed BCD.",
      "syntax": "DAS",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x2F",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base (Legacy)",
      "slug": "das",
      "rel_url": "x86/das/",
      "linked_summary": "Adjusts AL after subtraction for packed BCD.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aam",
      "architecture": "x86",
      "full_name": "ASCII Adjust After Multiply",
      "summary": "Adjusts AX after multiply for unpacked BCD.",
      "syntax": "AAM imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD4",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base (Legacy)",
      "slug": "aam",
      "rel_url": "x86/aam/",
      "linked_summary": "Adjusts AX after multiply for unpacked BCD.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aad",
      "architecture": "x86",
      "full_name": "ASCII Adjust Before Division",
      "summary": "Adjusts AX before division for unpacked BCD.",
      "syntax": "AAD imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD5",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base (Legacy)",
      "slug": "aad",
      "rel_url": "x86/aad/",
      "linked_summary": "Adjusts AX before division for unpacked BCD.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cbw",
      "architecture": "x86",
      "full_name": "Convert Byte to Word",
      "summary": "Sign-extends AL into AX.",
      "syntax": "CBW",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x98",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "cbw",
      "rel_url": "x86/cbw/",
      "linked_summary": "Sign-extends AL into AX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cwd",
      "architecture": "x86",
      "full_name": "Convert Word to Doubleword",
      "summary": "Sign-extends AX into DX:AX.",
      "syntax": "CWD",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x99",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "cwd",
      "rel_url": "x86/cwd/",
      "linked_summary": "Sign-extends AX into DX:AX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "wait",
      "architecture": "x86",
      "full_name": "Wait",
      "summary": "Wait for FPU (same as FWAIT).",
      "syntax": "WAIT",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x9B",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "wait",
      "rel_url": "x86/wait/",
      "linked_summary": "Wait for FPU (same as FWAIT).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ldtilecfg",
      "architecture": "x86",
      "full_name": "Load Tile Configuration",
      "summary": "Loads AMX tile configuration from memory.",
      "syntax": "LDTILECFG m512",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 49",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Memory"
        }
      ],
      "extension": "AMX-TILE",
      "slug": "ldtilecfg",
      "rel_url": "x86/ldtilecfg/",
      "linked_summary": "Loads AMX tile configuration from memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sttilecfg",
      "architecture": "x86",
      "full_name": "Store Tile Configuration",
      "summary": "Stores AMX tile configuration to memory.",
      "syntax": "STTILECFG m512",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 49",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Memory"
        }
      ],
      "extension": "AMX-TILE",
      "slug": "sttilecfg",
      "rel_url": "x86/sttilecfg/",
      "linked_summary": "Stores AMX tile configuration to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tileloadd",
      "architecture": "x86",
      "full_name": "Load Tile Data",
      "summary": "Loads data into an AMX tile register.",
      "syntax": "TILELOADD tmm1, m",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 4B",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "TMM"
        },
        {
          "name": "src",
          "desc": "Mem"
        }
      ],
      "extension": "AMX-TILE",
      "slug": "tileloadd",
      "rel_url": "x86/tileloadd/",
      "linked_summary": "Loads data into an AMX tile register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tilestored",
      "architecture": "x86",
      "full_name": "Store Tile Data",
      "summary": "Stores data from an AMX tile register to memory.",
      "syntax": "TILESTORED m, tmm1",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 4B",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Mem"
        },
        {
          "name": "src",
          "desc": "TMM"
        }
      ],
      "extension": "AMX-TILE",
      "slug": "tilestored",
      "rel_url": "x86/tilestored/",
      "linked_summary": "Stores data from an AMX tile register to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tilezero",
      "architecture": "x86",
      "full_name": "Zero Tile",
      "summary": "Clears an AMX tile register.",
      "syntax": "TILEZERO tmm1",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 49",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "TMM"
        }
      ],
      "extension": "AMX-TILE",
      "slug": "tilezero",
      "rel_url": "x86/tilezero/",
      "linked_summary": "Clears an AMX tile register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tdpbssd",
      "architecture": "x86",
      "full_name": "Tile Dot Product Byte Signed Signed Doubleword",
      "summary": "Matrix multiply (Signed Int8 * Signed Int8) accumulating to Int32.",
      "syntax": "TDPBSSD tmm1, tmm2, tmm3",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 5E",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "TMM"
        },
        {
          "name": "src1",
          "desc": "TMM"
        },
        {
          "name": "src2",
          "desc": "TMM"
        }
      ],
      "extension": "AMX-INT8",
      "slug": "tdpbssd",
      "rel_url": "x86/tdpbssd/",
      "linked_summary": "Matrix multiply (Signed Int8 * Signed Int8) accumulating to Int32.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tdpbsud",
      "architecture": "x86",
      "full_name": "Tile Dot Product Byte Signed Unsigned Doubleword",
      "summary": "Matrix multiply (Signed * Unsigned) accumulating to Int32.",
      "syntax": "TDPBSUD tmm1, tmm2, tmm3",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 5E",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "TMM"
        },
        {
          "name": "src1",
          "desc": "TMM"
        },
        {
          "name": "src2",
          "desc": "TMM"
        }
      ],
      "extension": "AMX-INT8",
      "slug": "tdpbsud",
      "rel_url": "x86/tdpbsud/",
      "linked_summary": "Matrix multiply (Signed * Unsigned) accumulating to Int32.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tdpbf16ps",
      "architecture": "x86",
      "full_name": "Tile Dot Product BFloat16 Packed Single",
      "summary": "Matrix multiply (BFloat16) accumulating to Float32.",
      "syntax": "TDPBF16PS tmm1, tmm2, tmm3",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 5C",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "TMM"
        },
        {
          "name": "src1",
          "desc": "TMM"
        },
        {
          "name": "src2",
          "desc": "TMM"
        }
      ],
      "extension": "AMX-BF16",
      "slug": "tdpbf16ps",
      "rel_url": "x86/tdpbf16ps/",
      "linked_summary": "Matrix multiply (BFloat16) accumulating to Float32.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "endbr64",
      "architecture": "x86",
      "full_name": "End Branch 64-bit",
      "summary": "Marker instruction for Indirect Branch Tracking (IBT).",
      "syntax": "ENDBR64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 1E FA",
        "length": "4",
        "visual_parts": []
      },
      "operands": [],
      "extension": "CET-IBT",
      "slug": "endbr64",
      "rel_url": "x86/endbr64/",
      "linked_summary": "Marker instruction for Indirect Branch Tracking (IBT).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "endbr32",
      "architecture": "x86",
      "full_name": "End Branch 32-bit",
      "summary": "Marker instruction for Indirect Branch Tracking (IBT).",
      "syntax": "ENDBR32",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 1E FB",
        "length": "4",
        "visual_parts": []
      },
      "operands": [],
      "extension": "CET-IBT",
      "slug": "endbr32",
      "rel_url": "x86/endbr32/",
      "linked_summary": "Marker instruction for Indirect Branch Tracking (IBT).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rdsspq",
      "architecture": "x86",
      "full_name": "Read Shadow Stack Pointer (Quadword)",
      "summary": "Reads the current shadow stack pointer into a register.",
      "syntax": "RDSSPQ r64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 1E /1",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        }
      ],
      "extension": "CET-SS",
      "slug": "rdsspq",
      "rel_url": "x86/rdsspq/",
      "linked_summary": "Reads the current shadow stack pointer into a register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "incsspq",
      "architecture": "x86",
      "full_name": "Increment Shadow Stack Pointer (Quadword)",
      "summary": "Adjusts the shadow stack pointer.",
      "syntax": "INCSSPQ r64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F AE /5",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Reg"
        }
      ],
      "extension": "CET-SS",
      "slug": "incsspq",
      "rel_url": "x86/incsspq/",
      "linked_summary": "Adjusts the shadow stack pointer.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rstorssp",
      "architecture": "x86",
      "full_name": "Restore Shadow Stack Pointer",
      "summary": "Restores SSP from memory token.",
      "syntax": "RSTORSSP m64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 01 /5",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "token",
          "desc": "Mem"
        }
      ],
      "extension": "CET-SS",
      "slug": "rstorssp",
      "rel_url": "x86/rstorssp/",
      "linked_summary": "Restores SSP from memory token.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "saveprevssp",
      "architecture": "x86",
      "full_name": "Save Previous Shadow Stack Pointer",
      "summary": "Saves the previous SSP to the shadow stack token.",
      "syntax": "SAVEPREVSSP",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 01 EA",
        "length": "4",
        "visual_parts": []
      },
      "operands": [],
      "extension": "CET-SS",
      "slug": "saveprevssp",
      "rel_url": "x86/saveprevssp/",
      "linked_summary": "Saves the previous SSP to the shadow stack token.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "clwb",
      "architecture": "x86",
      "full_name": "Cache Line Write Back",
      "summary": "Writes back modified cache line without flushing (Persistent Memory).",
      "syntax": "CLWB m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "66 0F AE /6",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "addr",
          "desc": "Mem"
        }
      ],
      "extension": "CLWB",
      "slug": "clwb",
      "rel_url": "x86/clwb/",
      "linked_summary": "Writes back modified cache line without flushing (Persistent Memory).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "clflushopt",
      "architecture": "x86",
      "full_name": "Optimized Cache Line Flush",
      "summary": "Optimized version of CLFLUSH (Higher throughput).",
      "syntax": "CLFLUSHOPT m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "66 0F AE /7",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "addr",
          "desc": "Mem"
        }
      ],
      "extension": "CLFLUSHOPT",
      "slug": "clflushopt",
      "rel_url": "x86/clflushopt/",
      "linked_summary": "Optimized version of CLFLUSH (Higher throughput).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cldemote",
      "architecture": "x86",
      "full_name": "Cache Line Demote",
      "summary": "Hints to move cache line to lower cache level.",
      "syntax": "CLDEMOTE m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 1C /0",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "addr",
          "desc": "Mem"
        }
      ],
      "extension": "CLDEMOTE",
      "slug": "cldemote",
      "rel_url": "x86/cldemote/",
      "linked_summary": "Hints to move cache line to lower cache level.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movdiri",
      "architecture": "x86",
      "full_name": "Move Direct Store Integer",
      "summary": "Moves 32/64-bit data avoiding cache pollution (Direct IO).",
      "syntax": "MOVDIRI m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 38 F9",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Mem"
        },
        {
          "name": "src",
          "desc": "Reg"
        }
      ],
      "extension": "MOVDIRI",
      "slug": "movdiri",
      "rel_url": "x86/movdiri/",
      "linked_summary": "Moves 32/64-<a href=\"../../armv8-a/bit/\">bit</a> data avoiding cache pollution (Direct IO).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movdir64b",
      "architecture": "x86",
      "full_name": "Move Direct Store 64-Bytes",
      "summary": "Atomically moves 64-byte block avoiding cache pollution.",
      "syntax": "MOVDIR64B m512, m512",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "66 0F 38 F8",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Mem"
        },
        {
          "name": "src",
          "desc": "Mem"
        }
      ],
      "extension": "MOVDIR64B",
      "slug": "movdir64b",
      "rel_url": "x86/movdir64b/",
      "linked_summary": "Atomically moves 64-byte block avoiding cache pollution.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xbegin",
      "architecture": "x86",
      "full_name": "Transaction Begin",
      "summary": "Specifies start of Restricted Transactional Memory region.",
      "syntax": "XBEGIN rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "C7 F8",
        "length": "6",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "fallback",
          "desc": "Offset"
        }
      ],
      "extension": "RTM (TSX)",
      "slug": "xbegin",
      "rel_url": "x86/xbegin/",
      "linked_summary": "Specifies start of Restricted Transactional Memory region.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xend",
      "architecture": "x86",
      "full_name": "Transaction End",
      "summary": "Specifies end of RTM region.",
      "syntax": "XEND",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 D5",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "RTM (TSX)",
      "slug": "xend",
      "rel_url": "x86/xend/",
      "linked_summary": "Specifies end of RTM region.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xabort",
      "architecture": "x86",
      "full_name": "Transaction Abort",
      "summary": "Forces an RTM abort.",
      "syntax": "XABORT imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "C6 F8",
        "length": "3",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "status",
          "desc": "Imm"
        }
      ],
      "extension": "RTM (TSX)",
      "slug": "xabort",
      "rel_url": "x86/xabort/",
      "linked_summary": "Forces an RTM abort.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xtest",
      "architecture": "x86",
      "full_name": "Test If In Transaction",
      "summary": "Sets ZF if processor is in transactional region.",
      "syntax": "XTEST",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 D6",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "TSX",
      "slug": "xtest",
      "rel_url": "x86/xtest/",
      "linked_summary": "Sets ZF if processor is <a href=\"../../x86/in/\">in</a> transactional region.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "umonitor",
      "architecture": "x86",
      "full_name": "User Level Monitor",
      "summary": "Sets up a monitor address for User Wait instructions.",
      "syntax": "UMONITOR r64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F AE /6",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "addr",
          "desc": "Reg"
        }
      ],
      "extension": "WAITPKG",
      "slug": "umonitor",
      "rel_url": "x86/umonitor/",
      "linked_summary": "Sets up a <a href=\"../../x86/monitor/\">monitor</a> address for User Wait instructions.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "umwait",
      "architecture": "x86",
      "full_name": "User Level Monitor Wait",
      "summary": "Waits for store to monitored address (Low power state).",
      "syntax": "UMWAIT r32",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F2 0F AE /6",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "ctrl",
          "desc": "Reg"
        }
      ],
      "extension": "WAITPKG",
      "slug": "umwait",
      "rel_url": "x86/umwait/",
      "linked_summary": "Waits for store to monitored address (Low power state).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tpause",
      "architecture": "x86",
      "full_name": "Timed Pause",
      "summary": "Pauses execution for a specified time or until trigger.",
      "syntax": "TPAUSE r32",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "66 0F AE /6",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "ctrl",
          "desc": "Reg"
        }
      ],
      "extension": "WAITPKG",
      "slug": "tpause",
      "rel_url": "x86/tpause/",
      "linked_summary": "Pauses execution for a specified time <a href=\"../../powerisa/or/\">or</a> until trigger.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vaddph",
      "architecture": "x86",
      "full_name": "Add Packed FP16 Values",
      "summary": "Adds half-precision floating-point values.",
      "syntax": "VADDPH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "58",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX512-FP16",
      "slug": "vaddph",
      "rel_url": "x86/vaddph/",
      "linked_summary": "Adds half-precision floating-point values.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsubph",
      "architecture": "x86",
      "full_name": "Subtract Packed FP16 Values",
      "summary": "Subtracts half-precision floating-point values.",
      "syntax": "VSUBPH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "5C",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX512-FP16",
      "slug": "vsubph",
      "rel_url": "x86/vsubph/",
      "linked_summary": "Subtracts half-precision floating-point values.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmulph",
      "architecture": "x86",
      "full_name": "Multiply Packed FP16 Values",
      "summary": "Multiplies half-precision floating-point values.",
      "syntax": "VMULPH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "59",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX512-FP16",
      "slug": "vmulph",
      "rel_url": "x86/vmulph/",
      "linked_summary": "Multiplies half-precision floating-point values.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vdivph",
      "architecture": "x86",
      "full_name": "Divide Packed FP16 Values",
      "summary": "Divides half-precision floating-point values.",
      "syntax": "VDIVPH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "5E",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX512-FP16",
      "slug": "vdivph",
      "rel_url": "x86/vdivph/",
      "linked_summary": "Divides half-precision floating-point values.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsqrtph",
      "architecture": "x86",
      "full_name": "Square Root Packed FP16 Values",
      "summary": "Square root of half-precision values.",
      "syntax": "VSQRTPH zmm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "51",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX512-FP16",
      "slug": "vsqrtph",
      "rel_url": "x86/vsqrtph/",
      "linked_summary": "Square root of half-precision values.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vminph",
      "architecture": "x86",
      "full_name": "Minimum Packed FP16 Values",
      "summary": "Minimum of half-precision values.",
      "syntax": "VMINPH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "5D",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX512-FP16",
      "slug": "vminph",
      "rel_url": "x86/vminph/",
      "linked_summary": "Minimum of half-precision values.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmaxph",
      "architecture": "x86",
      "full_name": "Maximum Packed FP16 Values",
      "summary": "Maximum of half-precision values.",
      "syntax": "VMAXPH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "5F",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX512-FP16",
      "slug": "vmaxph",
      "rel_url": "x86/vmaxph/",
      "linked_summary": "Maximum of half-precision values.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfmadd132ph",
      "architecture": "x86",
      "full_name": "Fused Multiply-Add (132) Packed FP16",
      "summary": "Computes (Dest * Src2) + Src1 in half-precision.",
      "syntax": "VFMADD132PH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "98",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX512-FP16",
      "slug": "vfmadd132ph",
      "rel_url": "x86/vfmadd132ph/",
      "linked_summary": "Computes (Dest * Src2) + Src1 <a href=\"../../x86/in/\">in</a> half-precision.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfmadd213ph",
      "architecture": "x86",
      "full_name": "Fused Multiply-Add (213) Packed FP16",
      "summary": "Computes (Src1 * Dest) + Src2 in half-precision.",
      "syntax": "VFMADD213PH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "A8",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX512-FP16",
      "slug": "vfmadd213ph",
      "rel_url": "x86/vfmadd213ph/",
      "linked_summary": "Computes (Src1 * Dest) + Src2 <a href=\"../../x86/in/\">in</a> half-precision.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfmadd231ph",
      "architecture": "x86",
      "full_name": "Fused Multiply-Add (231) Packed FP16",
      "summary": "Computes (Src1 * Src2) + Dest in half-precision.",
      "syntax": "VFMADD231PH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "B8",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX512-FP16",
      "slug": "vfmadd231ph",
      "rel_url": "x86/vfmadd231ph/",
      "linked_summary": "Computes (Src1 * Src2) + Dest <a href=\"../../x86/in/\">in</a> half-precision.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcvtne2ps2bf16",
      "architecture": "x86",
      "full_name": "Convert Two Packed Single to Packed BFloat16",
      "summary": "Converts two float vectors to one BFloat16 vector.",
      "syntax": "VCVTNE2PS2BF16 zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "72",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX512-BF16",
      "slug": "vcvtne2ps2bf16",
      "rel_url": "x86/vcvtne2ps2bf16/",
      "linked_summary": "Converts two float vectors to one BFloat16 vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vdpbf16ps",
      "architecture": "x86",
      "full_name": "Dot Product BFloat16 to Packed Single",
      "summary": "BFloat16 dot product accumulating to Float32.",
      "syntax": "VDPBF16PS zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "52",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX512-BF16",
      "slug": "vdpbf16ps",
      "rel_url": "x86/vdpbf16ps/",
      "linked_summary": "BFloat16 dot product accumulating to Float32.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vaesenc",
      "architecture": "x86",
      "full_name": "Vector AES Encrypt (AVX512)",
      "summary": "AES Encrypt on 512-bit vector.",
      "syntax": "VAESENC zmm1, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "DC",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "state",
          "desc": "ZMM"
        },
        {
          "name": "key",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX512-VAES",
      "slug": "vaesenc",
      "rel_url": "x86/vaesenc/",
      "linked_summary": "AES Encrypt on 512-<a href=\"../../armv8-a/bit/\">bit</a> vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vaesdec",
      "architecture": "x86",
      "full_name": "Vector AES Decrypt (AVX512)",
      "summary": "AES Decrypt on 512-bit vector.",
      "syntax": "VAESDEC zmm1, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "DE",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "state",
          "desc": "ZMM"
        },
        {
          "name": "key",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX512-VAES",
      "slug": "vaesdec",
      "rel_url": "x86/vaesdec/",
      "linked_summary": "AES Decrypt on 512-<a href=\"../../armv8-a/bit/\">bit</a> vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpclmulqdq",
      "architecture": "x86",
      "full_name": "Vector Carry-Less Multiplication (AVX512)",
      "summary": "Carry-less multiply on 512-bit vector.",
      "syntax": "VPCLMULQDQ zmm1, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "44",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        },
        {
          "name": "sel",
          "desc": "Imm"
        }
      ],
      "extension": "AVX512-VPCLMULQDQ",
      "slug": "vpclmulqdq",
      "rel_url": "x86/vpclmulqdq/",
      "linked_summary": "Carry-less multiply on 512-<a href=\"../../armv8-a/bit/\">bit</a> vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsha512msg1",
      "architecture": "x86",
      "full_name": "SHA512 Message Schedule 1",
      "summary": "SHA512 intermediate calculation (AVX512).",
      "syntax": "VSHA512MSG1 ymm1, xmm2",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "CC",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "src",
          "desc": "XMM"
        }
      ],
      "extension": "SHA512",
      "slug": "vsha512msg1",
      "rel_url": "x86/vsha512msg1/",
      "linked_summary": "SHA512 intermediate calculation (AVX512).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsha512msg2",
      "architecture": "x86",
      "full_name": "SHA512 Message Schedule 2",
      "summary": "SHA512 final calculation (AVX512).",
      "syntax": "VSHA512MSG2 ymm1, ymm2",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "CD",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "src",
          "desc": "YMM"
        }
      ],
      "extension": "SHA512",
      "slug": "vsha512msg2",
      "rel_url": "x86/vsha512msg2/",
      "linked_summary": "SHA512 final calculation (AVX512).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsha512rnds2",
      "architecture": "x86",
      "full_name": "SHA512 Rounds 2",
      "summary": "SHA512 2 rounds calculation (AVX512).",
      "syntax": "VSHA512RNDS2 ymm1, ymm2, xmm3",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "CB",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "state",
          "desc": "YMM"
        },
        {
          "name": "msg",
          "desc": "XMM"
        }
      ],
      "extension": "SHA512",
      "slug": "vsha512rnds2",
      "rel_url": "x86/vsha512rnds2/",
      "linked_summary": "SHA512 2 rounds calculation (AVX512).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsm3msg1",
      "architecture": "x86",
      "full_name": "SM3 Message Schedule 1",
      "summary": "SM3 crypto message schedule part 1.",
      "syntax": "VSM3MSG1 xmm1, xmm2, xmm3",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "DA",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src1",
          "desc": "XMM"
        },
        {
          "name": "src2",
          "desc": "XMM"
        }
      ],
      "extension": "SM3",
      "slug": "vsm3msg1",
      "rel_url": "x86/vsm3msg1/",
      "linked_summary": "SM3 crypto message schedule part 1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsm3rnds2",
      "architecture": "x86",
      "full_name": "SM3 Rounds 2",
      "summary": "SM3 crypto 2 rounds.",
      "syntax": "VSM3RNDS2 xmm1, xmm2, imm8",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "DE",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM"
        },
        {
          "name": "rcon",
          "desc": "Imm"
        }
      ],
      "extension": "SM3",
      "slug": "vsm3rnds2",
      "rel_url": "x86/vsm3rnds2/",
      "linked_summary": "SM3 crypto 2 rounds.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsm4e",
      "architecture": "x86",
      "full_name": "SM4 Encrypt",
      "summary": "SM4 crypto encryption round.",
      "syntax": "VSM4E xmm1, xmm2",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "DA",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM"
        }
      ],
      "extension": "SM4",
      "slug": "vsm4e",
      "rel_url": "x86/vsm4e/",
      "linked_summary": "SM4 crypto encryption round.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsm4key4",
      "architecture": "x86",
      "full_name": "SM4 Key Generation",
      "summary": "SM4 key generation.",
      "syntax": "VSM4KEY4 xmm1, xmm2",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "DA",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM"
        }
      ],
      "extension": "SM4",
      "slug": "vsm4key4",
      "rel_url": "x86/vsm4key4/",
      "linked_summary": "SM4 key generation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "loadiwkey",
      "architecture": "x86",
      "full_name": "Load Internal Wrapping Key",
      "summary": "Loads the Key Locker internal wrapping key.",
      "syntax": "LOADIWKEY xmm1, xmm2",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 38 DC",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "key",
          "desc": "XMM"
        },
        {
          "name": "integrity",
          "desc": "XMM"
        }
      ],
      "extension": "KEYLOCKER",
      "slug": "loadiwkey",
      "rel_url": "x86/loadiwkey/",
      "linked_summary": "Loads the Key Locker internal wrapping key.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "encodekey128",
      "architecture": "x86",
      "full_name": "Encode 128-bit Key",
      "summary": "Wraps a 128-bit AES key into a handle.",
      "syntax": "ENCODEKEY128 r32, r32",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 38 FA",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "Reg"
        }
      ],
      "extension": "KEYLOCKER",
      "slug": "encodekey128",
      "rel_url": "x86/encodekey128/",
      "linked_summary": "Wraps a 128-<a href=\"../../armv8-a/bit/\">bit</a> AES key into a handle.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aesenc128kl",
      "architecture": "x86",
      "full_name": "AES Encrypt 128-bit Key Locker",
      "summary": "Encrypts data using Key Locker handle.",
      "syntax": "AESENC128KL m128, xmm",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 38 DD",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "handle",
          "desc": "Mem"
        },
        {
          "name": "data",
          "desc": "XMM"
        }
      ],
      "extension": "KEYLOCKER",
      "slug": "aesenc128kl",
      "rel_url": "x86/aesenc128kl/",
      "linked_summary": "Encrypts data using Key Locker handle.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aesdec128kl",
      "architecture": "x86",
      "full_name": "AES Decrypt 128-bit Key Locker",
      "summary": "Decrypts data using Key Locker handle.",
      "syntax": "AESDEC128KL m128, xmm",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 38 DE",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "handle",
          "desc": "Mem"
        },
        {
          "name": "data",
          "desc": "XMM"
        }
      ],
      "extension": "KEYLOCKER",
      "slug": "aesdec128kl",
      "rel_url": "x86/aesdec128kl/",
      "linked_summary": "Decrypts data using Key Locker handle.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "hreset",
      "architecture": "x86",
      "full_name": "History Reset",
      "summary": "Resets processor history (prediction) structures.",
      "syntax": "HRESET imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 3A F0",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "req",
          "desc": "Imm"
        }
      ],
      "extension": "HRESET",
      "slug": "hreset",
      "rel_url": "x86/hreset/",
      "linked_summary": "Resets processor history (prediction) structures.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "serialize",
      "architecture": "x86",
      "full_name": "Serialize Instruction Execution",
      "summary": "Forces serialization of instruction fetch/execution.",
      "syntax": "SERIALIZE",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 E8",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "SERIALIZE",
      "slug": "serialize",
      "rel_url": "x86/serialize/",
      "linked_summary": "Forces serialization of instruction fetch/execution.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rdpid",
      "architecture": "x86",
      "full_name": "Read Processor ID",
      "summary": "Reads the processor ID (TSC_AUX) into register.",
      "syntax": "RDPID r32",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F C7 /7",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        }
      ],
      "extension": "RDPID",
      "slug": "rdpid",
      "rel_url": "x86/rdpid/",
      "linked_summary": "Reads the processor ID (TSC_AUX) into register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsaves",
      "architecture": "x86",
      "full_name": "Save Supervisor States",
      "summary": "Saves supervisor state components to memory (Compact).",
      "syntax": "XSAVES m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F C7 /5",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Mem"
        }
      ],
      "extension": "XSAVES",
      "slug": "xsaves",
      "rel_url": "x86/xsaves/",
      "linked_summary": "Saves supervisor state components to memory (Compact).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xrstors",
      "architecture": "x86",
      "full_name": "Restore Supervisor States",
      "summary": "Restores supervisor state components from memory (Compact).",
      "syntax": "XRSTORS m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F C7 /3",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Mem"
        }
      ],
      "extension": "XSAVES",
      "slug": "xrstors",
      "rel_url": "x86/xrstors/",
      "linked_summary": "Restores supervisor state components from memory (Compact).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ptwrite",
      "architecture": "x86",
      "full_name": "Write Data to Processor Trace",
      "summary": "Writes data to the Intel Processor Trace stream.",
      "syntax": "PTWRITE r32/r64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F AE /4",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Reg"
        }
      ],
      "extension": "PTWRITE",
      "slug": "ptwrite",
      "rel_url": "x86/ptwrite/",
      "linked_summary": "Writes data to the Intel Processor Trace stream.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "uiret",
      "architecture": "x86",
      "full_name": "User Interrupt Return",
      "summary": "Returns from a User Interrupt handler.",
      "syntax": "UIRET",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 01 EC",
        "length": "4",
        "visual_parts": []
      },
      "operands": [],
      "extension": "UINTR",
      "slug": "uiret",
      "rel_url": "x86/uiret/",
      "linked_summary": "Returns from a User Interrupt handler.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "senduipi",
      "architecture": "x86",
      "full_name": "Send User Inter-Processor Interrupt",
      "summary": "Sends a User IPI to another processor.",
      "syntax": "SENDUIPI r64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F C7 /6",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        }
      ],
      "extension": "UINTR",
      "slug": "senduipi",
      "rel_url": "x86/senduipi/",
      "linked_summary": "Sends a User IPI to another processor.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "in",
      "architecture": "x86",
      "full_name": "Input from Port",
      "summary": "Reads data from an I/O port into AL/AX/EAX.",
      "syntax": "IN AL, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "E4",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "AL/AX/EAX"
        },
        {
          "name": "port",
          "desc": "Imm"
        }
      ],
      "extension": "Base",
      "slug": "in",
      "rel_url": "x86/in/",
      "linked_summary": "Reads data from an I/O port into AL/AX/EAX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "out",
      "architecture": "x86",
      "full_name": "Output to Port",
      "summary": "Writes data from AL/AX/EAX to an I/O port.",
      "syntax": "OUT imm8, AL",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "E6",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "port",
          "desc": "Imm"
        },
        {
          "name": "src",
          "desc": "AL/AX/EAX"
        }
      ],
      "extension": "Base",
      "slug": "out",
      "rel_url": "x86/out/",
      "linked_summary": "Writes data from AL/AX/EAX to an I/O port.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ins",
      "architecture": "x86",
      "full_name": "Input String from Port",
      "summary": "Reads string from I/O port to memory at [EDI].",
      "syntax": "INSB",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "6C",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "ins",
      "rel_url": "x86/ins/",
      "linked_summary": "Reads string from I/O port to memory <a href=\"../../armv8-a/at_2/\">at</a> [EDI].",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "outs",
      "architecture": "x86",
      "full_name": "Output String to Port",
      "summary": "Writes string from memory at [ESI] to I/O port.",
      "syntax": "OUTSB",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "6E",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "outs",
      "rel_url": "x86/outs/",
      "linked_summary": "Writes string from memory <a href=\"../../armv8-a/at_2/\">at</a> [ESI] to I/O port.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lods",
      "architecture": "x86",
      "full_name": "Load String",
      "summary": "Loads byte/word/dword from [ESI] into AL/AX/EAX.",
      "syntax": "LODSB",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "AC",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "lods",
      "rel_url": "x86/lods/",
      "linked_summary": "Loads byte/word/dword from [ESI] into AL/AX/EAX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stos",
      "architecture": "x86",
      "full_name": "Store String",
      "summary": "Stores AL/AX/EAX to memory at [EDI].",
      "syntax": "STOSB",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "AA",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "stos",
      "rel_url": "x86/stos/",
      "linked_summary": "Stores AL/AX/EAX to memory <a href=\"../../armv8-a/at_2/\">at</a> [EDI].",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "scas",
      "architecture": "x86",
      "full_name": "Scan String",
      "summary": "Compares AL/AX/EAX with memory at [EDI].",
      "syntax": "SCASB",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "AE",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "scas",
      "rel_url": "x86/scas/",
      "linked_summary": "Compares AL/AX/EAX with memory <a href=\"../../armv8-a/at_2/\">at</a> [EDI].",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmps",
      "architecture": "x86",
      "full_name": "Compare String",
      "summary": "Compares byte/word at [ESI] with [EDI].",
      "syntax": "CMPSB",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "A6",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "cmps",
      "rel_url": "x86/cmps/",
      "linked_summary": "Compares byte/word <a href=\"../../armv8-a/at_2/\">at</a> [ESI] with [EDI].",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lds",
      "architecture": "x86",
      "full_name": "Load Far Pointer using DS",
      "summary": "Loads pointer into DS and register.",
      "syntax": "LDS r, m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "C5",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "Mem"
        }
      ],
      "extension": "Base (Legacy)",
      "slug": "lds",
      "rel_url": "x86/lds/",
      "linked_summary": "Loads pointer into DS <a href=\"../../armv8-a/and_6/\">and</a> register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "les",
      "architecture": "x86",
      "full_name": "Load Far Pointer using ES",
      "summary": "Loads pointer into ES and register.",
      "syntax": "LES r, m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "C4",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "Mem"
        }
      ],
      "extension": "Base (Legacy)",
      "slug": "les",
      "rel_url": "x86/les/",
      "linked_summary": "Loads pointer into ES <a href=\"../../armv8-a/and_6/\">and</a> register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lfs",
      "architecture": "x86",
      "full_name": "Load Far Pointer using FS",
      "summary": "Loads pointer into FS and register.",
      "syntax": "LFS r, m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F B4",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "Mem"
        }
      ],
      "extension": "Base",
      "slug": "lfs",
      "rel_url": "x86/lfs/",
      "linked_summary": "Loads pointer into FS <a href=\"../../armv8-a/and_6/\">and</a> register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lgs",
      "architecture": "x86",
      "full_name": "Load Far Pointer using GS",
      "summary": "Loads pointer into GS and register.",
      "syntax": "LGS r, m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F B5",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "Mem"
        }
      ],
      "extension": "Base",
      "slug": "lgs",
      "rel_url": "x86/lgs/",
      "linked_summary": "Loads pointer into GS <a href=\"../../armv8-a/and_6/\">and</a> register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lss",
      "architecture": "x86",
      "full_name": "Load Far Pointer using SS",
      "summary": "Loads pointer into SS and register.",
      "syntax": "LSS r, m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F B2",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "Mem"
        }
      ],
      "extension": "Base",
      "slug": "lss",
      "rel_url": "x86/lss/",
      "linked_summary": "Loads pointer into SS <a href=\"../../armv8-a/and_6/\">and</a> register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "swapgs",
      "architecture": "x86",
      "full_name": "Swap GS Base Register",
      "summary": "Swaps user/kernel GS base address (System).",
      "syntax": "SWAPGS",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 F8",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base (64-bit System)",
      "slug": "swapgs",
      "rel_url": "x86/swapgs/",
      "linked_summary": "Swaps user/kernel GS base address (System).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rdfsbase",
      "architecture": "x86",
      "full_name": "Read FS Base",
      "summary": "Reads the FS base address into a register.",
      "syntax": "RDFSBASE r64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F AE /0",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        }
      ],
      "extension": "FSGSBASE",
      "slug": "rdfsbase",
      "rel_url": "x86/rdfsbase/",
      "linked_summary": "Reads the FS base address into a register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rdgsbase",
      "architecture": "x86",
      "full_name": "Read GS Base",
      "summary": "Reads the GS base address into a register.",
      "syntax": "RDGSBASE r64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F AE /1",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        }
      ],
      "extension": "FSGSBASE",
      "slug": "rdgsbase",
      "rel_url": "x86/rdgsbase/",
      "linked_summary": "Reads the GS base address into a register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "wrfsbase",
      "architecture": "x86",
      "full_name": "Write FS Base",
      "summary": "Writes a register to the FS base address.",
      "syntax": "WRFSBASE r64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F AE /2",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Reg"
        }
      ],
      "extension": "FSGSBASE",
      "slug": "wrfsbase",
      "rel_url": "x86/wrfsbase/",
      "linked_summary": "Writes a register to the FS base address.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "wrgsbase",
      "architecture": "x86",
      "full_name": "Write GS Base",
      "summary": "Writes a register to the GS base address.",
      "syntax": "WRGSBASE r64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F AE /3",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Reg"
        }
      ],
      "extension": "FSGSBASE",
      "slug": "wrgsbase",
      "rel_url": "x86/wrgsbase/",
      "linked_summary": "Writes a register to the GS base address.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "monitor",
      "architecture": "x86",
      "full_name": "Monitor",
      "summary": "Sets up a linear address range to be monitored.",
      "syntax": "MONITOR",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 C8",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "SSE3",
      "slug": "monitor",
      "rel_url": "x86/monitor/",
      "linked_summary": "Sets up a linear address range to be monitored.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mwait",
      "architecture": "x86",
      "full_name": "Monitor Wait",
      "summary": "Waits for a write to a monitored address.",
      "syntax": "MWAIT",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 C9",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "SSE3",
      "slug": "mwait",
      "rel_url": "x86/mwait/",
      "linked_summary": "Waits for a write to a monitored address.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "getsec",
      "architecture": "x86",
      "full_name": "Get Security Extensions",
      "summary": "Entry point for Safer Mode Extensions (Trusted Execution).",
      "syntax": "GETSEC",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 37",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "SMX",
      "slug": "getsec",
      "rel_url": "x86/getsec/",
      "linked_summary": "Entry point for Safer Mode Extensions (Trusted Execution).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bndmk",
      "architecture": "x86",
      "full_name": "Make Bounds",
      "summary": "Creates bounds data for MPX.",
      "syntax": "BNDMK b, m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 1B",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Bnd"
        },
        {
          "name": "src",
          "desc": "Mem"
        }
      ],
      "extension": "MPX",
      "slug": "bndmk",
      "rel_url": "x86/bndmk/",
      "linked_summary": "Creates bounds data for MPX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bndcl",
      "architecture": "x86",
      "full_name": "Check Lower Bound",
      "summary": "Checks if address is within lower bound.",
      "syntax": "BNDCL b, r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 1A",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "bnd",
          "desc": "Bnd"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "MPX",
      "slug": "bndcl",
      "rel_url": "x86/bndcl/",
      "linked_summary": "Checks if address is within lower <a href=\"../../x86/bound/\">bound</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bndcu",
      "architecture": "x86",
      "full_name": "Check Upper Bound",
      "summary": "Checks if address is within upper bound.",
      "syntax": "BNDCU b, r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F2 0F 1A",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "bnd",
          "desc": "Bnd"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "MPX",
      "slug": "bndcu",
      "rel_url": "x86/bndcu/",
      "linked_summary": "Checks if address is within upper <a href=\"../../x86/bound/\">bound</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bndmov",
      "architecture": "x86",
      "full_name": "Move Bounds",
      "summary": "Moves MPX bounds data.",
      "syntax": "BNDMOV b, b/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "66 0F 1A",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Bnd"
        },
        {
          "name": "src",
          "desc": "Bnd/Mem"
        }
      ],
      "extension": "MPX",
      "slug": "bndmov",
      "rel_url": "x86/bndmov/",
      "linked_summary": "Moves MPX bounds data.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rdpkru",
      "architecture": "x86",
      "full_name": "Read Protection Key Rights",
      "summary": "Reads PKRU register into EAX (User-mode pages).",
      "syntax": "RDPKRU",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 EE",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "PKU",
      "slug": "rdpkru",
      "rel_url": "x86/rdpkru/",
      "linked_summary": "Reads PKRU register into EAX (User-mode pages).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "wrpkru",
      "architecture": "x86",
      "full_name": "Write Protection Key Rights",
      "summary": "Writes EAX/EDX to PKRU register.",
      "syntax": "WRPKRU",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 EF",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "PKU",
      "slug": "wrpkru",
      "rel_url": "x86/wrpkru/",
      "linked_summary": "Writes EAX/EDX to PKRU register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpdpbusd",
      "architecture": "x86",
      "full_name": "Multiply and Add Unsigned and Signed Bytes",
      "summary": "Dot product of unsigned/signed bytes, accum to dword.",
      "syntax": "VPDPBUSD zmm1, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 50",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX512_VNNI",
      "slug": "vpdpbusd",
      "rel_url": "x86/vpdpbusd/",
      "linked_summary": "Dot product of unsigned/signed bytes, accum to dword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpdpbusds",
      "architecture": "x86",
      "full_name": "Multiply and Add Unsigned and Signed Bytes with Saturation",
      "summary": "Dot product of unsigned/signed bytes, accum to dword (Saturate).",
      "syntax": "VPDPBUSDS zmm1, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 51",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX512_VNNI",
      "slug": "vpdpbusds",
      "rel_url": "x86/vpdpbusds/",
      "linked_summary": "Dot product of unsigned/signed bytes, accum to dword (Saturate).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpdpwssd",
      "architecture": "x86",
      "full_name": "Multiply and Add Signed Words",
      "summary": "Dot product of signed words, accum to dword.",
      "syntax": "VPDPWSSD zmm1, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 52",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX512_VNNI",
      "slug": "vpdpwssd",
      "rel_url": "x86/vpdpwssd/",
      "linked_summary": "Dot product of signed words, accum to dword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpdpwssds",
      "architecture": "x86",
      "full_name": "Multiply and Add Signed Words with Saturation",
      "summary": "Dot product of signed words, accum to dword (Saturate).",
      "syntax": "VPDPWSSDS zmm1, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 53",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX512_VNNI",
      "slug": "vpdpwssds",
      "rel_url": "x86/vpdpwssds/",
      "linked_summary": "Dot product of signed words, accum to dword (Saturate).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "gf2p8affineinvqb",
      "architecture": "x86",
      "full_name": "Galois Field Affine Transformation Inverse",
      "summary": "Computes inverse affine transformation in GF(2^8).",
      "syntax": "GF2P8AFFINEINVQB xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "66 0F 3A CF",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        },
        {
          "name": "imm",
          "desc": "Imm"
        }
      ],
      "extension": "GFNI",
      "slug": "gf2p8affineinvqb",
      "rel_url": "x86/gf2p8affineinvqb/",
      "linked_summary": "Computes inverse affine transformation <a href=\"../../x86/in/\">in</a> GF(2^8).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "prefetchw",
      "architecture": "x86",
      "full_name": "Prefetch Data into Caches in Anticipation of a Write",
      "summary": "Prefetches data with intent to write (RFO).",
      "syntax": "PREFETCHW m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 0D /1",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "addr",
          "desc": "Mem"
        }
      ],
      "extension": "PREFETCHW",
      "slug": "prefetchw",
      "rel_url": "x86/prefetchw/",
      "linked_summary": "Prefetches data with intent to write (RFO).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "prefetchwt1",
      "architecture": "x86",
      "full_name": "Prefetch Hint T1 with Intent to Write",
      "summary": "Prefetches data to L2 (T1 hint) with intent to write.",
      "syntax": "PREFETCHWT1 m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 0D /2",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "addr",
          "desc": "Mem"
        }
      ],
      "extension": "PREFETCHWT1",
      "slug": "prefetchwt1",
      "rel_url": "x86/prefetchwt1/",
      "linked_summary": "Prefetches data to L2 (T1 <a href=\"../../armv8-a/hint/\">hint</a>) with intent to write.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vscatterdps",
      "architecture": "x86",
      "full_name": "Scatter Packed Single Precision",
      "summary": "Stores floats to non-contiguous memory locations.",
      "syntax": "VSCATTERDPS [base+zmm_idx*scale] {k1}, zmm1",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 A2",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "mem",
          "desc": "Base+Idx"
        },
        {
          "name": "src",
          "desc": "ZMM"
        }
      ],
      "extension": "AVX512F",
      "slug": "vscatterdps",
      "rel_url": "x86/vscatterdps/",
      "linked_summary": "Stores floats to non-contiguous memory locations.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vscatterdpd",
      "architecture": "x86",
      "full_name": "Scatter Packed Double Precision",
      "summary": "Stores doubles to non-contiguous memory locations.",
      "syntax": "VSCATTERDPD [base+zmm_idx*scale] {k1}, zmm1",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 A2",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "mem",
          "desc": "Base+Idx"
        },
        {
          "name": "src",
          "desc": "ZMM"
        }
      ],
      "extension": "AVX512F",
      "slug": "vscatterdpd",
      "rel_url": "x86/vscatterdpd/",
      "linked_summary": "Stores doubles to non-contiguous memory locations.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vscatterqps",
      "architecture": "x86",
      "full_name": "Scatter Packed Single Precision (Quadword Indices)",
      "summary": "Stores floats using 64-bit indices.",
      "syntax": "VSCATTERQPS [base+zmm_idx*scale] {k1}, zmm1",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 A3",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "mem",
          "desc": "Base+Idx"
        },
        {
          "name": "src",
          "desc": "ZMM"
        }
      ],
      "extension": "AVX512F",
      "slug": "vscatterqps",
      "rel_url": "x86/vscatterqps/",
      "linked_summary": "Stores floats using 64-<a href=\"../../armv8-a/bit/\">bit</a> indices.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vscatterqpd",
      "architecture": "x86",
      "full_name": "Scatter Packed Double Precision (Quadword Indices)",
      "summary": "Stores doubles using 64-bit indices.",
      "syntax": "VSCATTERQPD [base+zmm_idx*scale] {k1}, zmm1",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 A3",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "mem",
          "desc": "Base+Idx"
        },
        {
          "name": "src",
          "desc": "ZMM"
        }
      ],
      "extension": "AVX512F",
      "slug": "vscatterqpd",
      "rel_url": "x86/vscatterqpd/",
      "linked_summary": "Stores doubles using 64-<a href=\"../../armv8-a/bit/\">bit</a> indices.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfpclassps",
      "architecture": "x86",
      "full_name": "Floating-Point Class Single",
      "summary": "Tests for category (NaN, Inf, Denormal) for floats.",
      "syntax": "VFPCLASSPS k1 {k2}, zmm2/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 66",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "k-reg"
        },
        {
          "name": "src",
          "desc": "ZMM"
        },
        {
          "name": "ctrl",
          "desc": "Imm"
        }
      ],
      "extension": "AVX512DQ",
      "slug": "vfpclassps",
      "rel_url": "x86/vfpclassps/",
      "linked_summary": "Tests for category (NaN, Inf, Denormal) for floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfpclasspd",
      "architecture": "x86",
      "full_name": "Floating-Point Class Double",
      "summary": "Tests for category (NaN, Inf, Denormal) for doubles.",
      "syntax": "VFPCLASSPD k1 {k2}, zmm2/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 67",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "k-reg"
        },
        {
          "name": "src",
          "desc": "ZMM"
        },
        {
          "name": "ctrl",
          "desc": "Imm"
        }
      ],
      "extension": "AVX512DQ",
      "slug": "vfpclasspd",
      "rel_url": "x86/vfpclasspd/",
      "linked_summary": "Tests for category (NaN, Inf, Denormal) for doubles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vrangeps",
      "architecture": "x86",
      "full_name": "Range Restriction Calculation Packed Single",
      "summary": "Calculates range (min/max/abs) of float values.",
      "syntax": "VRANGEPS zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 50",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        },
        {
          "name": "ctrl",
          "desc": "Imm"
        }
      ],
      "extension": "AVX512DQ",
      "slug": "vrangeps",
      "rel_url": "x86/vrangeps/",
      "linked_summary": "Calculates range (min/max/<a href=\"../../armv8-a/abs_1/\">abs</a>) of float values.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vreduceps",
      "architecture": "x86",
      "full_name": "Perform Reduction Transformation Packed Single",
      "summary": "Performs reduction on floats (e.g. range reduction for trig).",
      "syntax": "VREDUCEPS zmm1 {k1}, zmm2/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 56",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "ZMM/Mem"
        },
        {
          "name": "ctrl",
          "desc": "Imm"
        }
      ],
      "extension": "AVX512DQ",
      "slug": "vreduceps",
      "rel_url": "x86/vreduceps/",
      "linked_summary": "Performs reduction on floats (e.g. range reduction for trig).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfixupimmps",
      "architecture": "x86",
      "full_name": "Fix Up Special Packed Float32 Values",
      "summary": "Fixes special cases (NaN, Inf) using a table (Float32).",
      "syntax": "VFIXUPIMMPS zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 54",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "table",
          "desc": "ZMM/Mem"
        },
        {
          "name": "imm",
          "desc": "Imm"
        }
      ],
      "extension": "AVX512F",
      "slug": "vfixupimmps",
      "rel_url": "x86/vfixupimmps/",
      "linked_summary": "Fixes special cases (NaN, Inf) using a table (Float32).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vrsqrt14ps",
      "architecture": "x86",
      "full_name": "Compute Approximate Reciprocal Square Root (14-bit)",
      "summary": "Approximate 1/sqrt(x) with 2^-14 error.",
      "syntax": "VRSQRT14PS zmm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 4E",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX512F",
      "slug": "vrsqrt14ps",
      "rel_url": "x86/vrsqrt14ps/",
      "linked_summary": "Approximate 1/sqrt(x) with 2^-14 error.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vrcp14ps",
      "architecture": "x86",
      "full_name": "Compute Approximate Reciprocal (14-bit)",
      "summary": "Approximate 1/x with 2^-14 error.",
      "syntax": "VRCP14PS zmm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 4C",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX512F",
      "slug": "vrcp14ps",
      "rel_url": "x86/vrcp14ps/",
      "linked_summary": "Approximate 1/x with 2^-14 error.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "clui",
      "architecture": "x86",
      "full_name": "Clear User Interrupt Flag",
      "summary": "Clears the User Interrupt Flag (UIF).",
      "syntax": "CLUI",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 01 EE",
        "length": "4",
        "visual_parts": []
      },
      "operands": [],
      "extension": "UINTR",
      "slug": "clui",
      "rel_url": "x86/clui/",
      "linked_summary": "Clears the User Interrupt Flag (UIF).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stui",
      "architecture": "x86",
      "full_name": "Set User Interrupt Flag",
      "summary": "Sets the User Interrupt Flag (UIF).",
      "syntax": "STUI",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 01 EF",
        "length": "4",
        "visual_parts": []
      },
      "operands": [],
      "extension": "UINTR",
      "slug": "stui",
      "rel_url": "x86/stui/",
      "linked_summary": "Sets the User Interrupt Flag (UIF).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "testui",
      "architecture": "x86",
      "full_name": "Test User Interrupt",
      "summary": "Sets CF if UIF is 1, ZF if User Interrupt Pending.",
      "syntax": "TESTUI",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 01 ED",
        "length": "4",
        "visual_parts": []
      },
      "operands": [],
      "extension": "UINTR",
      "slug": "testui",
      "rel_url": "x86/testui/",
      "linked_summary": "Sets CF if UIF is 1, ZF if User Interrupt Pending.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fld",
      "architecture": "x86",
      "full_name": "Load Floating Point Value",
      "summary": "Pushes a floating-point value onto the FPU register stack (ST0).",
      "syntax": "FLD m32fp/m64fp/m80fp",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 /0",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Memory"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fld",
      "rel_url": "x86/fld/",
      "linked_summary": "Pushes a floating-point value onto the FPU register stack (ST0).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fst",
      "architecture": "x86",
      "full_name": "Store Floating Point Value",
      "summary": "Copies the value in ST(0) to memory or another register.",
      "syntax": "FST m32fp/m64fp",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 /2",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Memory"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fst",
      "rel_url": "x86/fst/",
      "linked_summary": "Copies the value <a href=\"../../x86/in/\">in</a> ST(0) to memory <a href=\"../../powerisa/or/\">or</a> another register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fstp",
      "architecture": "x86",
      "full_name": "Store Floating Point Value and Pop",
      "summary": "Copies ST(0) to destination and pops the register stack.",
      "syntax": "FSTP m32fp/m64fp/m80fp",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 /3",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Memory"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fstp",
      "rel_url": "x86/fstp/",
      "linked_summary": "Copies ST(0) to destination <a href=\"../../armv8-a/and_6/\">and</a> pops the register stack.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fild",
      "architecture": "x86",
      "full_name": "Load Integer",
      "summary": "Converts integer in memory to double-extended-precision float and pushes to ST(0).",
      "syntax": "FILD m16int/m32int/m64int",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xDF /0",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Integer Memory"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fild",
      "rel_url": "x86/fild/",
      "linked_summary": "Converts integer <a href=\"../../x86/in/\">in</a> memory to double-extended-precision float <a href=\"../../armv8-a/and_6/\">and</a> pushes to ST(0).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fist",
      "architecture": "x86",
      "full_name": "Store Integer",
      "summary": "Converts ST(0) to integer and stores in memory.",
      "syntax": "FIST m16int/m32int",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xDF /2",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Integer Memory"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fist",
      "rel_url": "x86/fist/",
      "linked_summary": "Converts ST(0) to integer <a href=\"../../armv8-a/and_6/\">and</a> stores <a href=\"../../x86/in/\">in</a> memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fistp",
      "architecture": "x86",
      "full_name": "Store Integer and Pop",
      "summary": "Converts ST(0) to integer, stores in memory, and pops stack.",
      "syntax": "FISTP m16int/m32int/m64int",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xDF /3",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Integer Memory"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fistp",
      "rel_url": "x86/fistp/",
      "linked_summary": "Converts ST(0) to integer, stores <a href=\"../../x86/in/\">in</a> memory, <a href=\"../../armv8-a/and_6/\">and</a> pops stack.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fadd",
      "architecture": "x86",
      "full_name": "Add Floating Point",
      "summary": "Adds src to dest (ST(0) += src).",
      "syntax": "FADD m32fp/m64fp",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD8 /0",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Memory/Reg"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fadd",
      "rel_url": "x86/fadd/",
      "linked_summary": "Adds src to dest (ST(0) += src).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fsub",
      "architecture": "x86",
      "full_name": "Subtract Floating Point",
      "summary": "Subtracts src from dest.",
      "syntax": "FSUB m32fp/m64fp",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD8 /4",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Memory/Reg"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fsub",
      "rel_url": "x86/fsub/",
      "linked_summary": "Subtracts src from dest.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fmul",
      "architecture": "x86",
      "full_name": "Multiply Floating Point",
      "summary": "Multiplies dest by src.",
      "syntax": "FMUL m32fp/m64fp",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD8 /1",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Memory/Reg"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fmul",
      "rel_url": "x86/fmul/",
      "linked_summary": "Multiplies dest by src.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fdiv",
      "architecture": "x86",
      "full_name": "Divide Floating Point",
      "summary": "Divides dest by src.",
      "syntax": "FDIV m32fp/m64fp",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD8 /6",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Memory/Reg"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fdiv",
      "rel_url": "x86/fdiv/",
      "linked_summary": "Divides dest by src.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fprem",
      "architecture": "x86",
      "full_name": "Partial Remainder",
      "summary": "Computes remainder of ST(0) / ST(1).",
      "syntax": "FPREM",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 F8",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fprem",
      "rel_url": "x86/fprem/",
      "linked_summary": "Computes remainder of ST(0) / ST(1).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fabs",
      "architecture": "x86",
      "full_name": "Absolute Value",
      "summary": "Replaces ST(0) with its absolute value.",
      "syntax": "FABS",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 E1",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fabs",
      "rel_url": "x86/fabs/",
      "linked_summary": "Replaces ST(0) with its absolute value.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fchs",
      "architecture": "x86",
      "full_name": "Change Sign",
      "summary": "Reverses the sign of ST(0).",
      "syntax": "FCHS",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 E0",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fchs",
      "rel_url": "x86/fchs/",
      "linked_summary": "Reverses the sign of ST(0).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fsqrt",
      "architecture": "x86",
      "full_name": "Square Root",
      "summary": "Computes square root of ST(0).",
      "syntax": "FSQRT",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 FA",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fsqrt",
      "rel_url": "x86/fsqrt/",
      "linked_summary": "Computes square root of ST(0).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fsin",
      "architecture": "x86",
      "full_name": "Sine",
      "summary": "Computes sine of ST(0) (in radians).",
      "syntax": "FSIN",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 FE",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fsin",
      "rel_url": "x86/fsin/",
      "linked_summary": "Computes sine of ST(0) (<a href=\"../../x86/in/\">in</a> radians).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fcos",
      "architecture": "x86",
      "full_name": "Cosine",
      "summary": "Computes cosine of ST(0) (in radians).",
      "syntax": "FCOS",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 FF",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fcos",
      "rel_url": "x86/fcos/",
      "linked_summary": "Computes cosine of ST(0) (<a href=\"../../x86/in/\">in</a> radians).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fsincos",
      "architecture": "x86",
      "full_name": "Sine and Cosine",
      "summary": "Computes sine and cosine of ST(0), pushing both to stack.",
      "syntax": "FSINCOS",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 FB",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fsincos",
      "rel_url": "x86/fsincos/",
      "linked_summary": "Computes sine <a href=\"../../armv8-a/and_6/\">and</a> cosine of ST(0), pushing both to stack.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fptan",
      "architecture": "x86",
      "full_name": "Partial Tangent",
      "summary": "Computes tangent of ST(0) and pushes 1.0.",
      "syntax": "FPTAN",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 F2",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fptan",
      "rel_url": "x86/fptan/",
      "linked_summary": "Computes tangent of ST(0) <a href=\"../../armv8-a/and_6/\">and</a> pushes 1.0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fpatan",
      "architecture": "x86",
      "full_name": "Partial Arctangent",
      "summary": "Computes arctan(ST(1)/ST(0)).",
      "syntax": "FPATAN",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 F3",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fpatan",
      "rel_url": "x86/fpatan/",
      "linked_summary": "Computes arctan(ST(1)/ST(0)).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fyl2x",
      "architecture": "x86",
      "full_name": "Y * log2(X)",
      "summary": "Computes ST(1) * log2(ST(0)).",
      "syntax": "FYL2X",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 F1",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fyl2x",
      "rel_url": "x86/fyl2x/",
      "linked_summary": "Computes ST(1) * log2(ST(0)).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fxch",
      "architecture": "x86",
      "full_name": "Exchange Register",
      "summary": "Exchanges contents of ST(0) and ST(i).",
      "syntax": "FXCH ST(i)",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 C8+i",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fxch",
      "rel_url": "x86/fxch/",
      "linked_summary": "Exchanges contents of ST(0) <a href=\"../../armv8-a/and_6/\">and</a> ST(i).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fcom",
      "architecture": "x86",
      "full_name": "Compare Real",
      "summary": "Compares ST(0) with source.",
      "syntax": "FCOM m32fp/m64fp",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD8 /2",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Memory/Reg"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fcom",
      "rel_url": "x86/fcom/",
      "linked_summary": "Compares ST(0) with source.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fcomi",
      "architecture": "x86",
      "full_name": "Compare Real and Set EFLAGS",
      "summary": "Compares ST(0) with ST(i) and sets CPU EFLAGS directly.",
      "syntax": "FCOMI ST(0), ST(i)",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xDB F0+i",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "x87 FPU (P6+)",
      "slug": "fcomi",
      "rel_url": "x86/fcomi/",
      "linked_summary": "Compares ST(0) with ST(i) <a href=\"../../armv8-a/and_6/\">and</a> sets CPU EFLAGS directly.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "finit",
      "architecture": "x86",
      "full_name": "Initialize FPU",
      "summary": "Resets FPU to default state.",
      "syntax": "FINIT",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x9B DB E3",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "finit",
      "rel_url": "x86/finit/",
      "linked_summary": "Resets FPU to default state.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fclex",
      "architecture": "x86",
      "full_name": "Clear Exceptions",
      "summary": "Clears floating-point exception flags.",
      "syntax": "FCLEX",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x9B DB E2",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fclex",
      "rel_url": "x86/fclex/",
      "linked_summary": "Clears floating-point exception flags.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fstsw",
      "architecture": "x86",
      "full_name": "Store Status Word",
      "summary": "Stores FPU status word to AX or memory.",
      "syntax": "FSTSW AX",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x9B DF E0",
        "length": "3",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "AX/Mem"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fstsw",
      "rel_url": "x86/fstsw/",
      "linked_summary": "Stores FPU status word to AX <a href=\"../../powerisa/or/\">or</a> memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fldcw",
      "architecture": "x86",
      "full_name": "Load Control Word",
      "summary": "Loads FPU control word from memory.",
      "syntax": "FLDCW m2byte",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 /5",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Memory"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fldcw",
      "rel_url": "x86/fldcw/",
      "linked_summary": "Loads FPU control word from memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fstcw",
      "architecture": "x86",
      "full_name": "Store Control Word",
      "summary": "Stores FPU control word to memory.",
      "syntax": "FSTCW m2byte",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x9B D9 /7",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Memory"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fstcw",
      "rel_url": "x86/fstcw/",
      "linked_summary": "Stores FPU control word to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "frstor",
      "architecture": "x86",
      "full_name": "Restore FPU State",
      "summary": "Loads FPU state from memory.",
      "syntax": "FRSTOR m108byte",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xDD /4",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Memory"
        }
      ],
      "extension": "x87 FPU",
      "slug": "frstor",
      "rel_url": "x86/frstor/",
      "linked_summary": "Loads FPU state from memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fsave",
      "architecture": "x86",
      "full_name": "Save FPU State",
      "summary": "Stores FPU state to memory and re-initializes FPU.",
      "syntax": "FSAVE m108byte",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x9B DD /6",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Memory"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fsave",
      "rel_url": "x86/fsave/",
      "linked_summary": "Stores FPU state to memory <a href=\"../../armv8-a/and_6/\">and</a> re-initializes FPU.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lgdt",
      "architecture": "x86",
      "full_name": "Load Global Descriptor Table Register",
      "summary": "Loads the GDT register (Privileged).",
      "syntax": "LGDT m16&amp;32",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 01 /2",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Memory"
        }
      ],
      "extension": "System",
      "slug": "lgdt",
      "rel_url": "x86/lgdt/",
      "linked_summary": "Loads the GDT register (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lidt",
      "architecture": "x86",
      "full_name": "Load Interrupt Descriptor Table Register",
      "summary": "Loads the IDT register (Privileged).",
      "syntax": "LIDT m16&amp;32",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 01 /3",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Memory"
        }
      ],
      "extension": "System",
      "slug": "lidt",
      "rel_url": "x86/lidt/",
      "linked_summary": "Loads the IDT register (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sgdt",
      "architecture": "x86",
      "full_name": "Store Global Descriptor Table Register",
      "summary": "Stores GDT limit and base address to memory.",
      "syntax": "SGDT m",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 01 /0",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Memory"
        }
      ],
      "extension": "System",
      "slug": "sgdt",
      "rel_url": "x86/sgdt/",
      "linked_summary": "Stores GDT limit <a href=\"../../armv8-a/and_6/\">and</a> base address to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sidt",
      "architecture": "x86",
      "full_name": "Store Interrupt Descriptor Table Register",
      "summary": "Stores IDT limit and base address to memory.",
      "syntax": "SIDT m",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 01 /1",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Memory"
        }
      ],
      "extension": "System",
      "slug": "sidt",
      "rel_url": "x86/sidt/",
      "linked_summary": "Stores IDT limit <a href=\"../../armv8-a/and_6/\">and</a> base address to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lldt",
      "architecture": "x86",
      "full_name": "Load Local Descriptor Table Register",
      "summary": "Loads LDT segment selector (Privileged).",
      "syntax": "LLDT r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 00 /2",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "System",
      "slug": "lldt",
      "rel_url": "x86/lldt/",
      "linked_summary": "Loads LDT segment selector (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sldt",
      "architecture": "x86",
      "full_name": "Store Local Descriptor Table Register",
      "summary": "Stores LDT segment selector.",
      "syntax": "SLDT r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 00 /0",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "System",
      "slug": "sldt",
      "rel_url": "x86/sldt/",
      "linked_summary": "Stores LDT segment selector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ltr",
      "architecture": "x86",
      "full_name": "Load Task Register",
      "summary": "Loads Task Register (Privileged).",
      "syntax": "LTR r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 00 /3",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "System",
      "slug": "ltr",
      "rel_url": "x86/ltr/",
      "linked_summary": "Loads Task Register (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "str",
      "architecture": "x86",
      "full_name": "Store Task Register",
      "summary": "Stores Task Register.",
      "syntax": "STR r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 00 /1",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "System",
      "slug": "str",
      "rel_url": "x86/str/",
      "linked_summary": "Stores Task Register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mov cr",
      "architecture": "x86",
      "full_name": "Move Control Register",
      "summary": "Moves data to/from Control Registers (CR0, CR3, etc.) (Privileged).",
      "syntax": "MOV CRn, r",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 22 /r",
        "length": "3",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "CRn"
        },
        {
          "name": "src",
          "desc": "Reg"
        }
      ],
      "extension": "System",
      "slug": "mov_cr",
      "rel_url": "x86/mov_cr/",
      "linked_summary": "Moves data to/from Control Registers (CR0, CR3, etc.) (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mov dr",
      "architecture": "x86",
      "full_name": "Move Debug Register",
      "summary": "Moves data to/from Debug Registers (DR0-DR7) (Privileged).",
      "syntax": "MOV DRn, r",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 23 /r",
        "length": "3",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "DRn"
        },
        {
          "name": "src",
          "desc": "Reg"
        }
      ],
      "extension": "System",
      "slug": "mov_dr",
      "rel_url": "x86/mov_dr/",
      "linked_summary": "Moves data to/from Debug Registers (DR0-DR7) (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lmsw",
      "architecture": "x86",
      "full_name": "Load Machine Status Word",
      "summary": "Loads Machine Status Word (Legacy CR0 modification).",
      "syntax": "LMSW r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 01 /6",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "System",
      "slug": "lmsw",
      "rel_url": "x86/lmsw/",
      "linked_summary": "Loads Machine Status Word (Legacy CR0 modification).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "smsw",
      "architecture": "x86",
      "full_name": "Store Machine Status Word",
      "summary": "Stores Machine Status Word.",
      "syntax": "SMSW r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 01 /4",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "System",
      "slug": "smsw",
      "rel_url": "x86/smsw/",
      "linked_summary": "Stores Machine Status Word.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "clts",
      "architecture": "x86",
      "full_name": "Clear Task-Switched Flag",
      "summary": "Clears the TS flag in CR0 (Privileged).",
      "syntax": "CLTS",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 06",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "System",
      "slug": "clts",
      "rel_url": "x86/clts/",
      "linked_summary": "Clears the TS flag <a href=\"../../x86/in/\">in</a> CR0 (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "invd",
      "architecture": "x86",
      "full_name": "Invalidate Internal Caches",
      "summary": "Flushes internal caches without writing back data (Privileged).",
      "syntax": "INVD",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 08",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "System",
      "slug": "invd",
      "rel_url": "x86/invd/",
      "linked_summary": "Flushes internal caches without writing back data (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "wbinvd",
      "architecture": "x86",
      "full_name": "Write Back and Invalidate Cache",
      "summary": "Writes back modified data and invalidates caches (Privileged).",
      "syntax": "WBINVD",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 09",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "System",
      "slug": "wbinvd",
      "rel_url": "x86/wbinvd/",
      "linked_summary": "Writes back modified data <a href=\"../../armv8-a/and_6/\">and</a> invalidates caches (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "invlpg",
      "architecture": "x86",
      "full_name": "Invalidate TLB Entry",
      "summary": "Invalidates a specific TLB entry (Privileged).",
      "syntax": "INVLPG m",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 01 /7",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "addr",
          "desc": "Memory"
        }
      ],
      "extension": "System",
      "slug": "invlpg",
      "rel_url": "x86/invlpg/",
      "linked_summary": "Invalidates a specific TLB entry (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rdmsr",
      "architecture": "x86",
      "full_name": "Read Model Specific Register",
      "summary": "Reads MSR specified by ECX into EDX:EAX (Privileged).",
      "syntax": "RDMSR",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 32",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "System",
      "slug": "rdmsr",
      "rel_url": "x86/rdmsr/",
      "linked_summary": "Reads MSR specified by ECX into EDX:EAX (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "wrmsr",
      "architecture": "x86",
      "full_name": "Write Model Specific Register",
      "summary": "Writes EDX:EAX to MSR specified by ECX (Privileged).",
      "syntax": "WRMSR",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 30",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "System",
      "slug": "wrmsr",
      "rel_url": "x86/wrmsr/",
      "linked_summary": "Writes EDX:EAX to MSR specified by ECX (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rdpmc",
      "architecture": "x86",
      "full_name": "Read Performance-Monitoring Counters",
      "summary": "Reads performance counter specified by ECX into EDX:EAX.",
      "syntax": "RDPMC",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 33",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "System",
      "slug": "rdpmc",
      "rel_url": "x86/rdpmc/",
      "linked_summary": "Reads performance counter specified by ECX into EDX:EAX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sysenter",
      "architecture": "x86",
      "full_name": "Fast System Call",
      "summary": "Fast call to level 0 system procedures.",
      "syntax": "SYSENTER",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 34",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "System",
      "slug": "sysenter",
      "rel_url": "x86/sysenter/",
      "linked_summary": "Fast <a href=\"../../x86/call/\">call</a> to level 0 system procedures.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sysexit",
      "architecture": "x86",
      "full_name": "Fast Return from System Call",
      "summary": "Fast return to level 3 user code.",
      "syntax": "SYSEXIT",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 35",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "System",
      "slug": "sysexit",
      "rel_url": "x86/sysexit/",
      "linked_summary": "Fast return to level 3 user code.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lar",
      "architecture": "x86",
      "full_name": "Load Access Rights Byte",
      "summary": "Reads access rights from segment descriptor.",
      "syntax": "LAR r, r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 02",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register"
        },
        {
          "name": "src",
          "desc": "Selector"
        }
      ],
      "extension": "System",
      "slug": "lar",
      "rel_url": "x86/lar/",
      "linked_summary": "Reads access rights from segment descriptor.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lsl",
      "architecture": "x86",
      "full_name": "Load Segment Limit",
      "summary": "Reads segment limit from descriptor.",
      "syntax": "LSL r, r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 03",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register"
        },
        {
          "name": "src",
          "desc": "Selector"
        }
      ],
      "extension": "System",
      "slug": "lsl",
      "rel_url": "x86/lsl/",
      "linked_summary": "Reads segment limit from descriptor.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "verr",
      "architecture": "x86",
      "full_name": "Verify Segment for Reading",
      "summary": "Checks if segment can be read; sets ZF.",
      "syntax": "VERR r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 00 /4",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Selector"
        }
      ],
      "extension": "System",
      "slug": "verr",
      "rel_url": "x86/verr/",
      "linked_summary": "Checks if segment can be read; sets ZF.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "verw",
      "architecture": "x86",
      "full_name": "Verify Segment for Writing",
      "summary": "Checks if segment can be written; sets ZF.",
      "syntax": "VERW r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 00 /5",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Selector"
        }
      ],
      "extension": "System",
      "slug": "verw",
      "rel_url": "x86/verw/",
      "linked_summary": "Checks if segment can be written; sets ZF.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "arpl",
      "architecture": "x86",
      "full_name": "Adjust Requested Privilege Level",
      "summary": "Adjusts RPL of selector to match current CPL (Legacy).",
      "syntax": "ARPL r/m16, r16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x63",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Selector"
        },
        {
          "name": "src",
          "desc": "RPL"
        }
      ],
      "extension": "System (32-bit)",
      "slug": "arpl",
      "rel_url": "x86/arpl/",
      "linked_summary": "Adjusts RPL of selector to <a href=\"../../armv9-a/match_1/\">match</a> current CPL (Legacy).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rsm",
      "architecture": "x86",
      "full_name": "Resume from System Management Mode",
      "summary": "Exits SMM and returns to previous state (Privileged).",
      "syntax": "RSM",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F AA",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "System (SMM)",
      "slug": "rsm",
      "rel_url": "x86/rsm/",
      "linked_summary": "Exits SMM <a href=\"../../armv8-a/and_6/\">and</a> returns to previous state (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bswap",
      "architecture": "x86",
      "full_name": "Byte Swap",
      "summary": "Reverses the byte order of a 32/64-bit register.",
      "syntax": "BSWAP r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F C8",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register"
        }
      ],
      "extension": "Base",
      "slug": "bswap_1",
      "rel_url": "x86/bswap_1/",
      "linked_summary": "Reverses the byte order of a 32/64-<a href=\"../../armv8-a/bit/\">bit</a> register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmpxchg8b",
      "architecture": "x86",
      "full_name": "Compare and Exchange 8 Bytes",
      "summary": "Atomically compares EDX:EAX with memory; swaps if equal.",
      "syntax": "CMPXCHG8B m64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F C7 /1",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Memory"
        }
      ],
      "extension": "Base",
      "slug": "cmpxchg8b",
      "rel_url": "x86/cmpxchg8b/",
      "linked_summary": "Atomically compares EDX:EAX with memory; swaps if equal.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "addsubps",
      "architecture": "x86",
      "full_name": "Packed Single-FP Add/Subtract",
      "summary": "Adds odd elements, subtracts even elements (Complex Math).",
      "syntax": "ADDSUBPS xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE3",
        "hex_opcode": "F2 0F D0",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE3",
      "slug": "addsubps",
      "rel_url": "x86/addsubps/",
      "linked_summary": "Adds odd elements, subtracts even elements (Complex Math).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "haddps",
      "architecture": "x86",
      "full_name": "Horizontal Add Packed Single-Precision",
      "summary": "Adds adjacent float elements horizontally.",
      "syntax": "HADDPS xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE3",
        "hex_opcode": "F2 0F 7C",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE3",
      "slug": "haddps",
      "rel_url": "x86/haddps/",
      "linked_summary": "Adds adjacent float elements horizontally.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movddup",
      "architecture": "x86",
      "full_name": "Move One Double-FP and Duplicate",
      "summary": "Loads 64-bit double and duplicates it to fill 128-bit register.",
      "syntax": "MOVDDUP xmm1, xmm2/m64",
      "encoding": {
        "format": "SSE3",
        "hex_opcode": "F2 0F 12",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE3",
      "slug": "movddup",
      "rel_url": "x86/movddup/",
      "linked_summary": "Loads 64-<a href=\"../../armv8-a/bit/\">bit</a> double <a href=\"../../armv8-a/and_6/\">and</a> duplicates <a href=\"../../armv8-a/it/\">it</a> to fill 128-<a href=\"../../armv8-a/bit/\">bit</a> register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lddqu",
      "architecture": "x86",
      "full_name": "Load Unaligned Integer 128-bit",
      "summary": "Loads unaligned data avoiding split-line penalties.",
      "syntax": "LDDQU xmm1, m128",
      "encoding": {
        "format": "SSE3",
        "hex_opcode": "F2 0F F0",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "Memory"
        }
      ],
      "extension": "SSE3",
      "slug": "lddqu",
      "rel_url": "x86/lddqu/",
      "linked_summary": "Loads unaligned data avoiding split-line penalties.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pshufb",
      "architecture": "x86",
      "full_name": "Packed Shuffle Bytes",
      "summary": "Shuffles bytes according to indices in source operand.",
      "syntax": "PSHUFB xmm1, xmm2/m128",
      "encoding": {
        "format": "SSSE3",
        "hex_opcode": "66 0F 38 00",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "mask",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSSE3",
      "slug": "pshufb",
      "rel_url": "x86/pshufb/",
      "linked_summary": "Shuffles bytes according to indices <a href=\"../../x86/in/\">in</a> source operand.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "phaddw",
      "architecture": "x86",
      "full_name": "Packed Horizontal Add Word",
      "summary": "Adds adjacent 16-bit integers horizontally.",
      "syntax": "PHADDW xmm1, xmm2/m128",
      "encoding": {
        "format": "SSSE3",
        "hex_opcode": "66 0F 38 01",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSSE3",
      "slug": "phaddw",
      "rel_url": "x86/phaddw/",
      "linked_summary": "Adds adjacent 16-<a href=\"../../armv8-a/bit/\">bit</a> integers horizontally.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "palignr",
      "architecture": "x86",
      "full_name": "Packed Align Right",
      "summary": "Concatenates dest and src, extracts 128 bits byte-aligned.",
      "syntax": "PALIGNR xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "SSSE3",
        "hex_opcode": "66 0F 3A 0F",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        },
        {
          "name": "imm",
          "desc": "Shift"
        }
      ],
      "extension": "SSSE3",
      "slug": "palignr",
      "rel_url": "x86/palignr/",
      "linked_summary": "Concatenates dest <a href=\"../../armv8-a/and_6/\">and</a> src, extracts 128 bits byte-aligned.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmulhrsw",
      "architecture": "x86",
      "full_name": "Packed Multiply High with Round and Scale",
      "summary": "Multiplies signed 16-bit words, rounds, and scales.",
      "syntax": "PMULHRSW xmm1, xmm2/m128",
      "encoding": {
        "format": "SSSE3",
        "hex_opcode": "66 0F 38 0B",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSSE3",
      "slug": "pmulhrsw",
      "rel_url": "x86/pmulhrsw/",
      "linked_summary": "Multiplies signed 16-<a href=\"../../armv8-a/bit/\">bit</a> words, rounds, <a href=\"../../armv8-a/and_6/\">and</a> scales.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psignb",
      "architecture": "x86",
      "full_name": "Packed Sign Byte",
      "summary": "Negates/Zeroes bytes in dest based on sign of src.",
      "syntax": "PSIGNB xmm1, xmm2/m128",
      "encoding": {
        "format": "SSSE3",
        "hex_opcode": "66 0F 38 08",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSSE3",
      "slug": "psignb",
      "rel_url": "x86/psignb/",
      "linked_summary": "Negates/Zeroes bytes <a href=\"../../x86/in/\">in</a> dest based on sign of src.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pabsb",
      "architecture": "x86",
      "full_name": "Packed Absolute Value Byte",
      "summary": "Computes absolute value of bytes.",
      "syntax": "PABSB xmm1, xmm2/m128",
      "encoding": {
        "format": "SSSE3",
        "hex_opcode": "66 0F 38 1C",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSSE3",
      "slug": "pabsb",
      "rel_url": "x86/pabsb/",
      "linked_summary": "Computes absolute value of bytes.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "blendps",
      "architecture": "x86",
      "full_name": "Blend Packed Single-Precision",
      "summary": "Selects floats from two sources based on immediate mask.",
      "syntax": "BLENDPS xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 3A 0C",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        },
        {
          "name": "mask",
          "desc": "Imm"
        }
      ],
      "extension": "SSE4.1",
      "slug": "blendps",
      "rel_url": "x86/blendps/",
      "linked_summary": "Selects floats from two sources based on immediate mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pblendw",
      "architecture": "x86",
      "full_name": "Packed Blend Words",
      "summary": "Selects words from two sources based on immediate mask.",
      "syntax": "PBLENDW xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 3A 0E",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        },
        {
          "name": "mask",
          "desc": "Imm"
        }
      ],
      "extension": "SSE4.1",
      "slug": "pblendw",
      "rel_url": "x86/pblendw/",
      "linked_summary": "Selects words from two sources based on immediate mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmulld",
      "architecture": "x86",
      "full_name": "Packed Multiply Low Doubleword",
      "summary": "Multiplies 32-bit integers, stores low 32-bit result.",
      "syntax": "PMULLD xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 40",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE4.1",
      "slug": "pmulld",
      "rel_url": "x86/pmulld/",
      "linked_summary": "Multiplies 32-<a href=\"../../armv8-a/bit/\">bit</a> integers, stores low 32-<a href=\"../../armv8-a/bit/\">bit</a> result.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmovsxbw",
      "architecture": "x86",
      "full_name": "Packed Move with Sign Extend Byte to Word",
      "summary": "Sign extends 8-bit integers to 16-bit.",
      "syntax": "PMOVSXBW xmm1, xmm2/m64",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 20",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE4.1",
      "slug": "pmovsxbw",
      "rel_url": "x86/pmovsxbw/",
      "linked_summary": "Sign extends 8-<a href=\"../../armv8-a/bit/\">bit</a> integers to 16-<a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmovzxbw",
      "architecture": "x86",
      "full_name": "Packed Move with Zero Extend Byte to Word",
      "summary": "Zero extends 8-bit integers to 16-bit.",
      "syntax": "PMOVZXBW xmm1, xmm2/m64",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 30",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE4.1",
      "slug": "pmovzxbw",
      "rel_url": "x86/pmovzxbw/",
      "linked_summary": "Zero extends 8-<a href=\"../../armv8-a/bit/\">bit</a> integers to 16-<a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "extractps",
      "architecture": "x86",
      "full_name": "Extract Packed Single-Precision",
      "summary": "Extracts a single float from XMM to integer register.",
      "syntax": "EXTRACTPS r32/m32, xmm1, imm8",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 3A 17",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        },
        {
          "name": "src",
          "desc": "XMM"
        },
        {
          "name": "idx",
          "desc": "Imm"
        }
      ],
      "extension": "SSE4.1",
      "slug": "extractps",
      "rel_url": "x86/extractps/",
      "linked_summary": "Extracts a single float from XMM to integer register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "insertps",
      "architecture": "x86",
      "full_name": "Insert Packed Single-Precision",
      "summary": "Inserts a float into XMM from another XMM or memory.",
      "syntax": "INSERTPS xmm1, xmm2/m32, imm8",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 3A 21",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        },
        {
          "name": "ctrl",
          "desc": "Imm"
        }
      ],
      "extension": "SSE4.1",
      "slug": "insertps",
      "rel_url": "x86/insertps/",
      "linked_summary": "Inserts a float into XMM from another XMM <a href=\"../../powerisa/or/\">or</a> memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pinsrb",
      "architecture": "x86",
      "full_name": "Packed Insert Byte",
      "summary": "Inserts a byte from integer register into XMM.",
      "syntax": "PINSRB xmm1, r32/m8, imm8",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 3A 20",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        },
        {
          "name": "idx",
          "desc": "Imm"
        }
      ],
      "extension": "SSE4.1",
      "slug": "pinsrb",
      "rel_url": "x86/pinsrb/",
      "linked_summary": "Inserts a byte from integer register into XMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pextrb",
      "architecture": "x86",
      "full_name": "Packed Extract Byte",
      "summary": "Extracts a byte from XMM to integer register.",
      "syntax": "PEXTRB r32/m8, xmm1, imm8",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 3A 14",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        },
        {
          "name": "src",
          "desc": "XMM"
        },
        {
          "name": "idx",
          "desc": "Imm"
        }
      ],
      "extension": "SSE4.1",
      "slug": "pextrb",
      "rel_url": "x86/pextrb/",
      "linked_summary": "Extracts a byte from XMM to integer register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "roundps",
      "architecture": "x86",
      "full_name": "Round Packed Single-Precision",
      "summary": "Rounds floats according to immediate mode (ceil/floor/trunc).",
      "syntax": "ROUNDPS xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 3A 08",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        },
        {
          "name": "mode",
          "desc": "Imm"
        }
      ],
      "extension": "SSE4.1",
      "slug": "roundps",
      "rel_url": "x86/roundps/",
      "linked_summary": "Rounds floats according to immediate mode (ceil/floor/trunc).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dpps",
      "architecture": "x86",
      "full_name": "Dot Product Packed Single-Precision",
      "summary": "Calculates dot product of float vectors.",
      "syntax": "DPPS xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 3A 40",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        },
        {
          "name": "mask",
          "desc": "Imm"
        }
      ],
      "extension": "SSE4.1",
      "slug": "dpps",
      "rel_url": "x86/dpps/",
      "linked_summary": "Calculates dot product of float vectors.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ptest",
      "architecture": "x86",
      "full_name": "Packed Logical Comparison",
      "summary": "Bitwise compare of 128-bit value (AND) setting flags.",
      "syntax": "PTEST xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 17",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src1",
          "desc": "XMM"
        },
        {
          "name": "src2",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE4.1",
      "slug": "ptest",
      "rel_url": "x86/ptest/",
      "linked_summary": "Bitwise compare of 128-<a href=\"../../armv8-a/bit/\">bit</a> value (<a href=\"../../risc-v/and/\">AND</a>) setting flags.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pcmpeqq",
      "architecture": "x86",
      "full_name": "Packed Compare Equal Quadword",
      "summary": "Compares 64-bit integers for equality.",
      "syntax": "PCMPEQQ xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 29",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE4.1",
      "slug": "pcmpeqq",
      "rel_url": "x86/pcmpeqq/",
      "linked_summary": "Compares 64-<a href=\"../../armv8-a/bit/\">bit</a> integers for equality.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "crc32",
      "architecture": "x86",
      "full_name": "Accumulate CRC32 Value",
      "summary": "Accumulates CRC32C (Castagnoli) value.",
      "syntax": "CRC32 r32, r/m",
      "encoding": {
        "format": "SSE4.2",
        "hex_opcode": "F2 0F 38 F1",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "SSE4.2",
      "slug": "crc32",
      "rel_url": "x86/crc32/",
      "linked_summary": "Accumulates CRC32C (Castagnoli) value.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pcmpestri",
      "architecture": "x86",
      "full_name": "Packed Compare Explicit Length Strings, Return Index",
      "summary": "String compare/search, returns index (ECX).",
      "syntax": "PCMPESTRI xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "SSE4.2",
        "hex_opcode": "66 0F 3A 61",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src1",
          "desc": "XMM"
        },
        {
          "name": "src2",
          "desc": "XMM/Mem"
        },
        {
          "name": "ctrl",
          "desc": "Imm"
        }
      ],
      "extension": "SSE4.2",
      "slug": "pcmpestri",
      "rel_url": "x86/pcmpestri/",
      "linked_summary": "String compare/search, returns <a href=\"../../armv8-a/index/\">index</a> (ECX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pcmpestrm",
      "architecture": "x86",
      "full_name": "Packed Compare Explicit Length Strings, Return Mask",
      "summary": "String compare/search, returns mask (XMM0).",
      "syntax": "PCMPESTRM xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "SSE4.2",
        "hex_opcode": "66 0F 3A 60",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src1",
          "desc": "XMM"
        },
        {
          "name": "src2",
          "desc": "XMM/Mem"
        },
        {
          "name": "ctrl",
          "desc": "Imm"
        }
      ],
      "extension": "SSE4.2",
      "slug": "pcmpestrm",
      "rel_url": "x86/pcmpestrm/",
      "linked_summary": "String compare/search, returns mask (XMM0).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aesenc",
      "architecture": "x86",
      "full_name": "AES Encrypt",
      "summary": "Performs one round of AES encryption flow.",
      "syntax": "AESENC xmm1, xmm2/m128",
      "encoding": {
        "format": "AES-NI",
        "hex_opcode": "66 0F 38 DC",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "state",
          "desc": "XMM"
        },
        {
          "name": "key",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "AES-NI",
      "slug": "aesenc",
      "rel_url": "x86/aesenc/",
      "linked_summary": "Performs one round of AES encryption flow.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aesenclast",
      "architecture": "x86",
      "full_name": "AES Encrypt Last Round",
      "summary": "Performs the last round of AES encryption.",
      "syntax": "AESENCLAST xmm1, xmm2/m128",
      "encoding": {
        "format": "AES-NI",
        "hex_opcode": "66 0F 38 DD",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "state",
          "desc": "XMM"
        },
        {
          "name": "key",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "AES-NI",
      "slug": "aesenclast",
      "rel_url": "x86/aesenclast/",
      "linked_summary": "Performs the last round of AES encryption.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aesdec",
      "architecture": "x86",
      "full_name": "AES Decrypt",
      "summary": "Performs one round of AES decryption flow.",
      "syntax": "AESDEC xmm1, xmm2/m128",
      "encoding": {
        "format": "AES-NI",
        "hex_opcode": "66 0F 38 DE",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "state",
          "desc": "XMM"
        },
        {
          "name": "key",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "AES-NI",
      "slug": "aesdec",
      "rel_url": "x86/aesdec/",
      "linked_summary": "Performs one round of AES decryption flow.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aeskeygenassist",
      "architecture": "x86",
      "full_name": "AES Key Generation Assist",
      "summary": "Generates round key for AES encryption.",
      "syntax": "AESKEYGENASSIST xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "AES-NI",
        "hex_opcode": "66 0F 3A DF",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        },
        {
          "name": "rcon",
          "desc": "Imm"
        }
      ],
      "extension": "AES-NI",
      "slug": "aeskeygenassist",
      "rel_url": "x86/aeskeygenassist/",
      "linked_summary": "Generates round key for AES encryption.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pclmulqdq",
      "architecture": "x86",
      "full_name": "Carry-Less Multiplication Quadword",
      "summary": "Performs carry-less multiply (Galois Field math for GCM).",
      "syntax": "PCLMULQDQ xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "PCLMUL",
        "hex_opcode": "66 0F 3A 44",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        },
        {
          "name": "sel",
          "desc": "Imm"
        }
      ],
      "extension": "PCLMULQDQ",
      "slug": "pclmulqdq",
      "rel_url": "x86/pclmulqdq/",
      "linked_summary": "Performs carry-less multiply (Galois Field math for GCM).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vaddps",
      "architecture": "x86",
      "full_name": "Add Packed Single-Precision (AVX)",
      "summary": "Adds packed floats (256-bit YMM support).",
      "syntax": "VADDPS ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C5 /r 58",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "src1",
          "desc": "YMM"
        },
        {
          "name": "src2",
          "desc": "YMM/Mem"
        }
      ],
      "extension": "AVX",
      "slug": "vaddps",
      "rel_url": "x86/vaddps/",
      "linked_summary": "Adds packed floats (256-<a href=\"../../armv8-a/bit/\">bit</a> YMM support).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmulps",
      "architecture": "x86",
      "full_name": "Multiply Packed Single-Precision (AVX)",
      "summary": "Multiplies packed floats (256-bit).",
      "syntax": "VMULPS ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C5 /r 59",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "src1",
          "desc": "YMM"
        },
        {
          "name": "src2",
          "desc": "YMM/Mem"
        }
      ],
      "extension": "AVX",
      "slug": "vmulps",
      "rel_url": "x86/vmulps/",
      "linked_summary": "Multiplies packed floats (256-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfmadd231ps",
      "architecture": "x86",
      "full_name": "Fused Multiply-Add (132)",
      "summary": "Computes (Dest * Src2) + Src1.",
      "syntax": "VFMADD231PS ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... B8",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "src1",
          "desc": "YMM"
        },
        {
          "name": "src2",
          "desc": "YMM/Mem"
        }
      ],
      "extension": "FMA3",
      "slug": "vfmadd231ps",
      "rel_url": "x86/vfmadd231ps/",
      "linked_summary": "Computes (Dest * Src2) + Src1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vinsertf128",
      "architecture": "x86",
      "full_name": "Insert Float 128-bit",
      "summary": "Inserts 128-bits into a YMM register.",
      "syntax": "VINSERTF128 ymm1, ymm2, xmm3/m128, imm8",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 18",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "src1",
          "desc": "YMM"
        },
        {
          "name": "src2",
          "desc": "XMM/Mem"
        },
        {
          "name": "idx",
          "desc": "Imm"
        }
      ],
      "extension": "AVX",
      "slug": "vinsertf128",
      "rel_url": "x86/vinsertf128/",
      "linked_summary": "Inserts 128-bits into a YMM register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vextractf128",
      "architecture": "x86",
      "full_name": "Extract Float 128-bit",
      "summary": "Extracts 128-bits from YMM register.",
      "syntax": "VEXTRACTF128 xmm1/m128, ymm2, imm8",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 19",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM/Mem"
        },
        {
          "name": "src",
          "desc": "YMM"
        },
        {
          "name": "idx",
          "desc": "Imm"
        }
      ],
      "extension": "AVX",
      "slug": "vextractf128",
      "rel_url": "x86/vextractf128/",
      "linked_summary": "Extracts 128-bits from YMM register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vbroadcastss",
      "architecture": "x86",
      "full_name": "Broadcast Scalar Single",
      "summary": "Broadcasts a single float to all elements of YMM.",
      "syntax": "VBROADCASTSS ymm1, m32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 18",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "src",
          "desc": "Memory"
        }
      ],
      "extension": "AVX",
      "slug": "vbroadcastss",
      "rel_url": "x86/vbroadcastss/",
      "linked_summary": "Broadcasts a single float to all elements of YMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vzeroupper",
      "architecture": "x86",
      "full_name": "Zero Upper Bits of YMM Registers",
      "summary": "Clears bits 128-255 of all YMM registers (Avoids AVX-SSE transition penalty).",
      "syntax": "VZEROUPPER",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C5 F8 77",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "AVX",
      "slug": "vzeroupper",
      "rel_url": "x86/vzeroupper/",
      "linked_summary": "Clears bits 128-255 of all YMM registers (Avoids AVX-SSE transition penalty).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vzeroall",
      "architecture": "x86",
      "full_name": "Zero All YMM Registers",
      "summary": "Clears all YMM registers.",
      "syntax": "VZEROALL",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C5 FC 77",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "AVX",
      "slug": "vzeroall",
      "rel_url": "x86/vzeroall/",
      "linked_summary": "Clears all YMM registers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "emms",
      "architecture": "x86",
      "full_name": "Empty MMX Technology State",
      "summary": "Clears the FPU tag word to allow FP instructions after MMX.",
      "syntax": "EMMS",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0x0F 77",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "MMX",
      "slug": "emms",
      "rel_url": "x86/emms/",
      "linked_summary": "Clears the FPU tag word to allow FP instructions after MMX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movd",
      "architecture": "x86",
      "full_name": "Move Doubleword",
      "summary": "Moves 32 bits between GPR and XMM/MMX register.",
      "syntax": "MOVD mm/xmm, r32/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 6E",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM/MM"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "MMX/SSE2",
      "slug": "movd",
      "rel_url": "x86/movd/",
      "linked_summary": "Moves 32 bits between GPR <a href=\"../../armv8-a/and_6/\">and</a> XMM/MMX register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movq",
      "architecture": "x86",
      "full_name": "Move Quadword",
      "summary": "Moves 64 bits between XMM registers or memory.",
      "syntax": "MOVQ xmm, xmm/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0xF3 0F 7E",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "movq",
      "rel_url": "x86/movq/",
      "linked_summary": "Moves 64 bits between XMM registers <a href=\"../../powerisa/or/\">or</a> memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movaps",
      "architecture": "x86",
      "full_name": "Move Aligned Packed Single-Precision",
      "summary": "Moves 128-bit packed float data (Must be 16-byte aligned).",
      "syntax": "MOVAPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 28",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "movaps",
      "rel_url": "x86/movaps/",
      "linked_summary": "Moves 128-<a href=\"../../armv8-a/bit/\">bit</a> packed float data (Must be 16-byte aligned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movups",
      "architecture": "x86",
      "full_name": "Move Unaligned Packed Single-Precision",
      "summary": "Moves 128-bit packed float data (Unaligned).",
      "syntax": "MOVUPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 10",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "movups",
      "rel_url": "x86/movups/",
      "linked_summary": "Moves 128-<a href=\"../../armv8-a/bit/\">bit</a> packed float data (Unaligned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movapd",
      "architecture": "x86",
      "full_name": "Move Aligned Packed Double-Precision",
      "summary": "Moves 128-bit packed double data (Must be 16-byte aligned).",
      "syntax": "MOVAPD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 28",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "movapd",
      "rel_url": "x86/movapd/",
      "linked_summary": "Moves 128-<a href=\"../../armv8-a/bit/\">bit</a> packed double data (Must be 16-byte aligned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movupd",
      "architecture": "x86",
      "full_name": "Move Unaligned Packed Double-Precision",
      "summary": "Moves 128-bit packed double data (Unaligned).",
      "syntax": "MOVUPD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 10",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "movupd",
      "rel_url": "x86/movupd/",
      "linked_summary": "Moves 128-<a href=\"../../armv8-a/bit/\">bit</a> packed double data (Unaligned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movdqa",
      "architecture": "x86",
      "full_name": "Move Aligned Packed Integer",
      "summary": "Moves 128-bit integer data (Aligned).",
      "syntax": "MOVDQA xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 6F",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "movdqa",
      "rel_url": "x86/movdqa/",
      "linked_summary": "Moves 128-<a href=\"../../armv8-a/bit/\">bit</a> integer data (Aligned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movdqu",
      "architecture": "x86",
      "full_name": "Move Unaligned Packed Integer",
      "summary": "Moves 128-bit integer data (Unaligned).",
      "syntax": "MOVDQU xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0xF3 0F 6F",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "movdqu",
      "rel_url": "x86/movdqu/",
      "linked_summary": "Moves 128-<a href=\"../../armv8-a/bit/\">bit</a> integer data (Unaligned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "addps",
      "architecture": "x86",
      "full_name": "Add Packed Single-Precision",
      "summary": "Adds four 32-bit floats.",
      "syntax": "ADDPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 58",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "addps",
      "rel_url": "x86/addps/",
      "linked_summary": "Adds four 32-<a href=\"../../armv8-a/bit/\">bit</a> floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "addpd",
      "architecture": "x86",
      "full_name": "Add Packed Double-Precision",
      "summary": "Adds two 64-bit doubles.",
      "syntax": "ADDPD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 58",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "addpd",
      "rel_url": "x86/addpd/",
      "linked_summary": "Adds two 64-<a href=\"../../armv8-a/bit/\">bit</a> doubles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "addss",
      "architecture": "x86",
      "full_name": "Add Scalar Single-Precision",
      "summary": "Adds the low 32-bit float.",
      "syntax": "ADDSS xmm, xmm/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0xF3 0F 58",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "addss",
      "rel_url": "x86/addss/",
      "linked_summary": "Adds the low 32-<a href=\"../../armv8-a/bit/\">bit</a> float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "addsd",
      "architecture": "x86",
      "full_name": "Add Scalar Double-Precision",
      "summary": "Adds the low 64-bit double.",
      "syntax": "ADDSD xmm, xmm/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0xF2 0F 58",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "addsd",
      "rel_url": "x86/addsd/",
      "linked_summary": "Adds the low 64-<a href=\"../../armv8-a/bit/\">bit</a> double.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "subps",
      "architecture": "x86",
      "full_name": "Subtract Packed Single-Precision",
      "summary": "Subtracts four 32-bit floats.",
      "syntax": "SUBPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 5C",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "subps",
      "rel_url": "x86/subps/",
      "linked_summary": "Subtracts four 32-<a href=\"../../armv8-a/bit/\">bit</a> floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "subpd",
      "architecture": "x86",
      "full_name": "Subtract Packed Double-Precision",
      "summary": "Subtracts two 64-bit doubles.",
      "syntax": "SUBPD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 5C",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "subpd",
      "rel_url": "x86/subpd/",
      "linked_summary": "Subtracts two 64-<a href=\"../../armv8-a/bit/\">bit</a> doubles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mulps",
      "architecture": "x86",
      "full_name": "Multiply Packed Single-Precision",
      "summary": "Multiplies four 32-bit floats.",
      "syntax": "MULPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 59",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "mulps",
      "rel_url": "x86/mulps/",
      "linked_summary": "Multiplies four 32-<a href=\"../../armv8-a/bit/\">bit</a> floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mulpd",
      "architecture": "x86",
      "full_name": "Multiply Packed Double-Precision",
      "summary": "Multiplies two 64-bit doubles.",
      "syntax": "MULPD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 59",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "mulpd",
      "rel_url": "x86/mulpd/",
      "linked_summary": "Multiplies two 64-<a href=\"../../armv8-a/bit/\">bit</a> doubles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "divps",
      "architecture": "x86",
      "full_name": "Divide Packed Single-Precision",
      "summary": "Divides four 32-bit floats.",
      "syntax": "DIVPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 5E",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "divps",
      "rel_url": "x86/divps/",
      "linked_summary": "Divides four 32-<a href=\"../../armv8-a/bit/\">bit</a> floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "divpd",
      "architecture": "x86",
      "full_name": "Divide Packed Double-Precision",
      "summary": "Divides two 64-bit doubles.",
      "syntax": "DIVPD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 5E",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "divpd",
      "rel_url": "x86/divpd/",
      "linked_summary": "Divides two 64-<a href=\"../../armv8-a/bit/\">bit</a> doubles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sqrtps",
      "architecture": "x86",
      "full_name": "Square Root Packed Single-Precision",
      "summary": "Computes square root of four 32-bit floats.",
      "syntax": "SQRTPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 51",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "sqrtps",
      "rel_url": "x86/sqrtps/",
      "linked_summary": "Computes square root of four 32-<a href=\"../../armv8-a/bit/\">bit</a> floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sqrtpd",
      "architecture": "x86",
      "full_name": "Square Root Packed Double-Precision",
      "summary": "Computes square root of two 64-bit doubles.",
      "syntax": "SQRTPD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 51",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "sqrtpd",
      "rel_url": "x86/sqrtpd/",
      "linked_summary": "Computes square root of two 64-<a href=\"../../armv8-a/bit/\">bit</a> doubles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rcpps",
      "architecture": "x86",
      "full_name": "Reciprocal Packed Single-Precision",
      "summary": "Approximate reciprocal (1/x) of four 32-bit floats.",
      "syntax": "RCPPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 53",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "rcpps",
      "rel_url": "x86/rcpps/",
      "linked_summary": "Approximate reciprocal (1/x) of four 32-<a href=\"../../armv8-a/bit/\">bit</a> floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rsqrtps",
      "architecture": "x86",
      "full_name": "Reciprocal Square Root Packed Single-Precision",
      "summary": "Approximate reciprocal sqrt (1/sqrt(x)) of four 32-bit floats.",
      "syntax": "RSQRTPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 52",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "rsqrtps",
      "rel_url": "x86/rsqrtps/",
      "linked_summary": "Approximate reciprocal sqrt (1/sqrt(x)) of four 32-<a href=\"../../armv8-a/bit/\">bit</a> floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "maxps",
      "architecture": "x86",
      "full_name": "Maximum Packed Single-Precision",
      "summary": "Returns maximum of packed floats.",
      "syntax": "MAXPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 5F",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "maxps",
      "rel_url": "x86/maxps/",
      "linked_summary": "Returns maximum of packed floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "minps",
      "architecture": "x86",
      "full_name": "Minimum Packed Single-Precision",
      "summary": "Returns minimum of packed floats.",
      "syntax": "MINPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 5D",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "minps",
      "rel_url": "x86/minps/",
      "linked_summary": "Returns minimum of packed floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "andps",
      "architecture": "x86",
      "full_name": "Bitwise Logical AND Packed Single-Precision",
      "summary": "Bitwise AND of 128 bits.",
      "syntax": "ANDPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 54",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "andps",
      "rel_url": "x86/andps/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/and/\">AND</a> of 128 bits.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "andpd",
      "architecture": "x86",
      "full_name": "Bitwise Logical AND Packed Double-Precision",
      "summary": "Bitwise AND of 128 bits.",
      "syntax": "ANDPD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 54",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "andpd",
      "rel_url": "x86/andpd/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/and/\">AND</a> of 128 bits.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "orps",
      "architecture": "x86",
      "full_name": "Bitwise Logical OR Packed Single-Precision",
      "summary": "Bitwise OR of 128 bits.",
      "syntax": "ORPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 56",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "orps",
      "rel_url": "x86/orps/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/or/\">OR</a> of 128 bits.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xorps",
      "architecture": "x86",
      "full_name": "Bitwise Logical XOR Packed Single-Precision",
      "summary": "Bitwise XOR of 128 bits (Used to clear registers).",
      "syntax": "XORPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 57",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "xorps",
      "rel_url": "x86/xorps/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/xor/\">XOR</a> of 128 bits (Used to clear registers).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "paddb",
      "architecture": "x86",
      "full_name": "Packed Add Bytes",
      "summary": "Adds 16 bytes (Wraparound).",
      "syntax": "PADDB xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F FC",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "paddb",
      "rel_url": "x86/paddb/",
      "linked_summary": "Adds 16 bytes (Wraparound).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "paddw",
      "architecture": "x86",
      "full_name": "Packed Add Words",
      "summary": "Adds 8 words (Wraparound).",
      "syntax": "PADDW xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F FD",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "paddw",
      "rel_url": "x86/paddw/",
      "linked_summary": "Adds 8 words (Wraparound).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "paddd",
      "architecture": "x86",
      "full_name": "Packed Add Doublewords",
      "summary": "Adds 4 doublewords (Wraparound).",
      "syntax": "PADDD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F FE",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "paddd",
      "rel_url": "x86/paddd/",
      "linked_summary": "Adds 4 doublewords (Wraparound).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "paddq",
      "architecture": "x86",
      "full_name": "Packed Add Quadwords",
      "summary": "Adds 2 quadwords (Wraparound).",
      "syntax": "PADDQ xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F D4",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "paddq",
      "rel_url": "x86/paddq/",
      "linked_summary": "Adds 2 quadwords (Wraparound).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "paddsb",
      "architecture": "x86",
      "full_name": "Packed Add Bytes Signed Saturate",
      "summary": "Adds 16 signed bytes with saturation.",
      "syntax": "PADDSB xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F EC",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "paddsb",
      "rel_url": "x86/paddsb/",
      "linked_summary": "Adds 16 signed bytes with saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "paddusb",
      "architecture": "x86",
      "full_name": "Packed Add Bytes Unsigned Saturate",
      "summary": "Adds 16 unsigned bytes with saturation.",
      "syntax": "PADDUSB xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F DC",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "paddusb",
      "rel_url": "x86/paddusb/",
      "linked_summary": "Adds 16 unsigned bytes with saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psubb",
      "architecture": "x86",
      "full_name": "Packed Subtract Bytes",
      "summary": "Subtracts 16 bytes.",
      "syntax": "PSUBB xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F F8",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "psubb",
      "rel_url": "x86/psubb/",
      "linked_summary": "Subtracts 16 bytes.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psubw",
      "architecture": "x86",
      "full_name": "Packed Subtract Words",
      "summary": "Subtracts 8 words.",
      "syntax": "PSUBW xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F F9",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "psubw",
      "rel_url": "x86/psubw/",
      "linked_summary": "Subtracts 8 words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psubd",
      "architecture": "x86",
      "full_name": "Packed Subtract Doublewords",
      "summary": "Subtracts 4 doublewords.",
      "syntax": "PSUBD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F FA",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "psubd",
      "rel_url": "x86/psubd/",
      "linked_summary": "Subtracts 4 doublewords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pand",
      "architecture": "x86",
      "full_name": "Packed Logical AND",
      "summary": "Bitwise AND of 128-bit integers.",
      "syntax": "PAND xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F DB",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "pand",
      "rel_url": "x86/pand/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/and/\">AND</a> of 128-<a href=\"../../armv8-a/bit/\">bit</a> integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "por",
      "architecture": "x86",
      "full_name": "Packed Logical OR",
      "summary": "Bitwise OR of 128-bit integers.",
      "syntax": "POR xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F EB",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "por",
      "rel_url": "x86/por/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/or/\">OR</a> of 128-<a href=\"../../armv8-a/bit/\">bit</a> integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pxor",
      "architecture": "x86",
      "full_name": "Packed Logical Exclusive OR",
      "summary": "Bitwise XOR of 128-bit integers.",
      "syntax": "PXOR xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F EF",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "pxor",
      "rel_url": "x86/pxor/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/xor/\">XOR</a> of 128-<a href=\"../../armv8-a/bit/\">bit</a> integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psllw",
      "architecture": "x86",
      "full_name": "Packed Shift Left Logical Word",
      "summary": "Shifts words left.",
      "syntax": "PSLLW xmm, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 71 /6",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "SSE2",
      "slug": "psllw",
      "rel_url": "x86/psllw/",
      "linked_summary": "Shifts words left.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pslld",
      "architecture": "x86",
      "full_name": "Packed Shift Left Logical Doubleword",
      "summary": "Shifts doublewords left.",
      "syntax": "PSLLD xmm, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 72 /6",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "SSE2",
      "slug": "pslld",
      "rel_url": "x86/pslld/",
      "linked_summary": "Shifts doublewords left.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psrlw",
      "architecture": "x86",
      "full_name": "Packed Shift Right Logical Word",
      "summary": "Shifts words right logical.",
      "syntax": "PSRLW xmm, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 71 /2",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "SSE2",
      "slug": "psrlw",
      "rel_url": "x86/psrlw/",
      "linked_summary": "Shifts words right logical.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psrld",
      "architecture": "x86",
      "full_name": "Packed Shift Right Logical Doubleword",
      "summary": "Shifts doublewords right logical.",
      "syntax": "PSRLD xmm, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 72 /2",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "SSE2",
      "slug": "psrld",
      "rel_url": "x86/psrld/",
      "linked_summary": "Shifts doublewords right logical.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psraw",
      "architecture": "x86",
      "full_name": "Packed Shift Right Arithmetic Word",
      "summary": "Shifts words right arithmetic (sign bit).",
      "syntax": "PSRAW xmm, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 71 /4",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "SSE2",
      "slug": "psraw",
      "rel_url": "x86/psraw/",
      "linked_summary": "Shifts words right arithmetic (sign <a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psrad",
      "architecture": "x86",
      "full_name": "Packed Shift Right Arithmetic Doubleword",
      "summary": "Shifts doublewords right arithmetic.",
      "syntax": "PSRAD xmm, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 72 /4",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "SSE2",
      "slug": "psrad",
      "rel_url": "x86/psrad/",
      "linked_summary": "Shifts doublewords right arithmetic.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pcmpeqb",
      "architecture": "x86",
      "full_name": "Packed Compare Equal Byte",
      "summary": "Compares bytes for equality (Result mask 0xFF or 0x00).",
      "syntax": "PCMPEQB xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 74",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "pcmpeqb",
      "rel_url": "x86/pcmpeqb/",
      "linked_summary": "Compares bytes for equality (Result mask 0xFF <a href=\"../../powerisa/or/\">or</a> 0x00).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pcmpeqw",
      "architecture": "x86",
      "full_name": "Packed Compare Equal Word",
      "summary": "Compares words for equality.",
      "syntax": "PCMPEQW xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 75",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "pcmpeqw",
      "rel_url": "x86/pcmpeqw/",
      "linked_summary": "Compares words for equality.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pcmpeqd",
      "architecture": "x86",
      "full_name": "Packed Compare Equal Doubleword",
      "summary": "Compares doublewords for equality.",
      "syntax": "PCMPEQD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 76",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "pcmpeqd",
      "rel_url": "x86/pcmpeqd/",
      "linked_summary": "Compares doublewords for equality.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "shufps",
      "architecture": "x86",
      "full_name": "Shuffle Packed Single-Precision",
      "summary": "Shuffles 32-bit floats based on immediate mask.",
      "syntax": "SHUFPS xmm, xmm/m128, imm8",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F C6",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        },
        {
          "name": "mask",
          "desc": "Imm"
        }
      ],
      "extension": "SSE",
      "slug": "shufps",
      "rel_url": "x86/shufps/",
      "linked_summary": "Shuffles 32-<a href=\"../../armv8-a/bit/\">bit</a> floats based on immediate mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "shufpd",
      "architecture": "x86",
      "full_name": "Shuffle Packed Double-Precision",
      "summary": "Shuffles 64-bit doubles based on immediate mask.",
      "syntax": "SHUFPD xmm, xmm/m128, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F C6",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        },
        {
          "name": "mask",
          "desc": "Imm"
        }
      ],
      "extension": "SSE2",
      "slug": "shufpd",
      "rel_url": "x86/shufpd/",
      "linked_summary": "Shuffles 64-<a href=\"../../armv8-a/bit/\">bit</a> doubles based on immediate mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pshufd",
      "architecture": "x86",
      "full_name": "Packed Shuffle Doubleword",
      "summary": "Shuffles 32-bit integers.",
      "syntax": "PSHUFD xmm, xmm/m128, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 70",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        },
        {
          "name": "mask",
          "desc": "Imm"
        }
      ],
      "extension": "SSE2",
      "slug": "pshufd",
      "rel_url": "x86/pshufd/",
      "linked_summary": "Shuffles 32-<a href=\"../../armv8-a/bit/\">bit</a> integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvtsi2ss",
      "architecture": "x86",
      "full_name": "Convert Doubleword Integer to Scalar Single-Precision",
      "summary": "Converts 32-bit int to float.",
      "syntax": "CVTSI2SS xmm, r/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0xF3 0F 2A",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "cvtsi2ss",
      "rel_url": "x86/cvtsi2ss/",
      "linked_summary": "Converts 32-<a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/int/\">int</a> to float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvtsi2sd",
      "architecture": "x86",
      "full_name": "Convert Doubleword Integer to Scalar Double-Precision",
      "summary": "Converts 32-bit int to double.",
      "syntax": "CVTSI2SD xmm, r/m32",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0xF2 0F 2A",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "cvtsi2sd",
      "rel_url": "x86/cvtsi2sd/",
      "linked_summary": "Converts 32-<a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/int/\">int</a> to double.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvttss2si",
      "architecture": "x86",
      "full_name": "Convert with Truncation Scalar Single to Integer",
      "summary": "Converts float to 32-bit int (Truncate).",
      "syntax": "CVTTSS2SI r32, xmm/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0xF3 0F 2C",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "cvttss2si",
      "rel_url": "x86/cvttss2si/",
      "linked_summary": "Converts float to 32-<a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/int/\">int</a> (Truncate).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvttsd2si",
      "architecture": "x86",
      "full_name": "Convert with Truncation Scalar Double to Integer",
      "summary": "Converts double to 32-bit int (Truncate).",
      "syntax": "CVTTSD2SI r32, xmm/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0xF2 0F 2C",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "cvttsd2si",
      "rel_url": "x86/cvttsd2si/",
      "linked_summary": "Converts double to 32-<a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/int/\">int</a> (Truncate).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvtss2sd",
      "architecture": "x86",
      "full_name": "Convert Scalar Single to Scalar Double",
      "summary": "Converts float to double.",
      "syntax": "CVTSS2SD xmm, xmm/m32",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0xF3 0F 5A",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "cvtss2sd",
      "rel_url": "x86/cvtss2sd/",
      "linked_summary": "Converts float to double.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvtsd2ss",
      "architecture": "x86",
      "full_name": "Convert Scalar Double to Scalar Single",
      "summary": "Converts double to float.",
      "syntax": "CVTSD2SS xmm, xmm/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0xF2 0F 5A",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "cvtsd2ss",
      "rel_url": "x86/cvtsd2ss/",
      "linked_summary": "Converts double to float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ucomiss",
      "architecture": "x86",
      "full_name": "Unordered Compare Scalar Single-Precision",
      "summary": "Compares low float and sets EFLAGS.",
      "syntax": "UCOMISS xmm, xmm/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 2E",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src1",
          "desc": "XMM"
        },
        {
          "name": "src2",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "ucomiss",
      "rel_url": "x86/ucomiss/",
      "linked_summary": "Compares low float <a href=\"../../armv8-a/and_6/\">and</a> sets EFLAGS.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ucomisd",
      "architecture": "x86",
      "full_name": "Unordered Compare Scalar Double-Precision",
      "summary": "Compares low double and sets EFLAGS.",
      "syntax": "UCOMISD xmm, xmm/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 2E",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src1",
          "desc": "XMM"
        },
        {
          "name": "src2",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "ucomisd",
      "rel_url": "x86/ucomisd/",
      "linked_summary": "Compares low double <a href=\"../../armv8-a/and_6/\">and</a> sets EFLAGS.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "punpcklbw",
      "architecture": "x86",
      "full_name": "Unpack Low Data Bytes",
      "summary": "Interleaves low bytes from two sources.",
      "syntax": "PUNPCKLBW xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 60",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "punpcklbw",
      "rel_url": "x86/punpcklbw/",
      "linked_summary": "Interleaves low bytes from two sources.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "punpcklwd",
      "architecture": "x86",
      "full_name": "Unpack Low Data Words",
      "summary": "Interleaves low words.",
      "syntax": "PUNPCKLWD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 61",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "punpcklwd",
      "rel_url": "x86/punpcklwd/",
      "linked_summary": "Interleaves low words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "punpckldq",
      "architecture": "x86",
      "full_name": "Unpack Low Data Doublewords",
      "summary": "Interleaves low doublewords.",
      "syntax": "PUNPCKLDQ xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 62",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "punpckldq",
      "rel_url": "x86/punpckldq/",
      "linked_summary": "Interleaves low doublewords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "punpcklqdq",
      "architecture": "x86",
      "full_name": "Unpack Low Data Quadwords",
      "summary": "Interleaves low quadwords.",
      "syntax": "PUNPCKLQDQ xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 6C",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "punpcklqdq",
      "rel_url": "x86/punpcklqdq/",
      "linked_summary": "Interleaves low quadwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "packsswb",
      "architecture": "x86",
      "full_name": "Pack with Signed Saturation Word to Byte",
      "summary": "Converts words to bytes with saturation.",
      "syntax": "PACKSSWB xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 63",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "packsswb",
      "rel_url": "x86/packsswb/",
      "linked_summary": "Converts words to bytes with saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "packssdw",
      "architecture": "x86",
      "full_name": "Pack with Signed Saturation Doubleword to Word",
      "summary": "Converts doublewords to words with saturation.",
      "syntax": "PACKSSDW xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 6B",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "packssdw",
      "rel_url": "x86/packssdw/",
      "linked_summary": "Converts doublewords to words with saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmovmskb",
      "architecture": "x86",
      "full_name": "Move Byte Mask",
      "summary": "Creates a mask from the MSB of each byte in XMM.",
      "syntax": "PMOVMSKB r32, xmm",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F D7",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "XMM"
        }
      ],
      "extension": "SSE2",
      "slug": "pmovmskb",
      "rel_url": "x86/pmovmskb/",
      "linked_summary": "Creates a mask from the MSB of each byte <a href=\"../../x86/in/\">in</a> XMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "maskmovdqu",
      "architecture": "x86",
      "full_name": "Store Selected Bytes of Double Quadword",
      "summary": "Non-temporal store of selected bytes (masked).",
      "syntax": "MASKMOVDQU xmm, xmm",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F F7",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "XMM"
        },
        {
          "name": "mask",
          "desc": "XMM"
        }
      ],
      "extension": "SSE2",
      "slug": "maskmovdqu",
      "rel_url": "x86/maskmovdqu/",
      "linked_summary": "Non-temporal store of selected bytes (masked).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ldmxcsr",
      "architecture": "x86",
      "full_name": "Load MXCSR Register",
      "summary": "Loads the MXCSR control/status register from memory.",
      "syntax": "LDMXCSR m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F AE /2",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Memory"
        }
      ],
      "extension": "SSE",
      "slug": "ldmxcsr",
      "rel_url": "x86/ldmxcsr/",
      "linked_summary": "Loads the MXCSR control/status register from memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stmxcsr",
      "architecture": "x86",
      "full_name": "Store MXCSR Register",
      "summary": "Stores the MXCSR register to memory.",
      "syntax": "STMXCSR m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F AE /3",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Memory"
        }
      ],
      "extension": "SSE",
      "slug": "stmxcsr",
      "rel_url": "x86/stmxcsr/",
      "linked_summary": "Stores the MXCSR register to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "prefetcht0",
      "architecture": "x86",
      "full_name": "Prefetch Data into all Cache Levels",
      "summary": "Prefetches data to L1 cache.",
      "syntax": "PREFETCHT0 m8",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 18 /1",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "mem",
          "desc": "Address"
        }
      ],
      "extension": "SSE",
      "slug": "prefetcht0",
      "rel_url": "x86/prefetcht0/",
      "linked_summary": "Prefetches data to L1 cache.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "prefetchnta",
      "architecture": "x86",
      "full_name": "Prefetch Data using Non-Temporal Access",
      "summary": "Prefetches data to non-temporal cache structure (minimize pollution).",
      "syntax": "PREFETCHNTA m8",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 18 /0",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "mem",
          "desc": "Address"
        }
      ],
      "extension": "SSE",
      "slug": "prefetchnta",
      "rel_url": "x86/prefetchnta/",
      "linked_summary": "Prefetches data to non-temporal cache structure (minimize pollution).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sfence",
      "architecture": "x86",
      "full_name": "Store Fence",
      "summary": "Serializes all store operations.",
      "syntax": "SFENCE",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F AE F8",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "SSE",
      "slug": "sfence",
      "rel_url": "x86/sfence/",
      "linked_summary": "Serializes all store operations.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lfence",
      "architecture": "x86",
      "full_name": "Load Fence",
      "summary": "Serializes all load operations.",
      "syntax": "LFENCE",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x0F AE E8",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "SSE2",
      "slug": "lfence",
      "rel_url": "x86/lfence/",
      "linked_summary": "Serializes all load operations.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mfence",
      "architecture": "x86",
      "full_name": "Memory Fence",
      "summary": "Serializes all load and store operations.",
      "syntax": "MFENCE",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x0F AE F0",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "SSE2",
      "slug": "mfence",
      "rel_url": "x86/mfence/",
      "linked_summary": "Serializes all load <a href=\"../../armv8-a/and_6/\">and</a> store operations.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "clflush",
      "architecture": "x86",
      "full_name": "Flush Cache Line",
      "summary": "Flushes cache line containing address.",
      "syntax": "CLFLUSH m8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x0F AE /7",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "mem",
          "desc": "Address"
        }
      ],
      "extension": "SSE2",
      "slug": "clflush",
      "rel_url": "x86/clflush/",
      "linked_summary": "Flushes cache line containing address.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfmadd132ps",
      "architecture": "x86",
      "full_name": "Fused Multiply-Add (132) Packed Single",
      "summary": "Computes (Dest * Src2) + Src1.",
      "syntax": "VFMADD132PS ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 98",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "src1",
          "desc": "YMM"
        },
        {
          "name": "src2",
          "desc": "YMM/Mem"
        }
      ],
      "extension": "FMA3",
      "slug": "vfmadd132ps",
      "rel_url": "x86/vfmadd132ps/",
      "linked_summary": "Computes (Dest * Src2) + Src1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfmadd213ps",
      "architecture": "x86",
      "full_name": "Fused Multiply-Add (213) Packed Single",
      "summary": "Computes (Src1 * Dest) + Src2.",
      "syntax": "VFMADD213PS ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... A8",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "src1",
          "desc": "YMM"
        },
        {
          "name": "src2",
          "desc": "YMM/Mem"
        }
      ],
      "extension": "FMA3",
      "slug": "vfmadd213ps",
      "rel_url": "x86/vfmadd213ps/",
      "linked_summary": "Computes (Src1 * Dest) + Src2.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfmsub132ps",
      "architecture": "x86",
      "full_name": "Fused Multiply-Subtract (132) Packed Single",
      "summary": "Computes (Dest * Src2) - Src1.",
      "syntax": "VFMSUB132PS ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 9A",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "src1",
          "desc": "YMM"
        },
        {
          "name": "src2",
          "desc": "YMM/Mem"
        }
      ],
      "extension": "FMA3",
      "slug": "vfmsub132ps",
      "rel_url": "x86/vfmsub132ps/",
      "linked_summary": "Computes (Dest * Src2) - Src1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfnmadd132ps",
      "architecture": "x86",
      "full_name": "Fused Negative Multiply-Add (132) Packed Single",
      "summary": "Computes -(Dest * Src2) + Src1.",
      "syntax": "VFNMADD132PS ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 9C",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "src1",
          "desc": "YMM"
        },
        {
          "name": "src2",
          "desc": "YMM/Mem"
        }
      ],
      "extension": "FMA3",
      "slug": "vfnmadd132ps",
      "rel_url": "x86/vfnmadd132ps/",
      "linked_summary": "Computes -(Dest * Src2) + Src1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpaddd",
      "architecture": "x86",
      "full_name": "Packed Add Doubleword (AVX2)",
      "summary": "Adds 8 integers (256-bit).",
      "syntax": "VPADDD ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C5 ... FE",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "src1",
          "desc": "YMM"
        },
        {
          "name": "src2",
          "desc": "YMM/Mem"
        }
      ],
      "extension": "AVX2",
      "slug": "vpaddd",
      "rel_url": "x86/vpaddd/",
      "linked_summary": "Adds 8 integers (256-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpaddb",
      "architecture": "x86",
      "full_name": "Packed Add Byte (AVX2)",
      "summary": "Adds 32 bytes (256-bit).",
      "syntax": "VPADDB ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C5 ... FC",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "src1",
          "desc": "YMM"
        },
        {
          "name": "src2",
          "desc": "YMM/Mem"
        }
      ],
      "extension": "AVX2",
      "slug": "vpaddb",
      "rel_url": "x86/vpaddb/",
      "linked_summary": "Adds 32 bytes (256-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpsubd",
      "architecture": "x86",
      "full_name": "Packed Subtract Doubleword (AVX2)",
      "summary": "Subtracts 8 integers (256-bit).",
      "syntax": "VPSUBD ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C5 ... FA",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "src1",
          "desc": "YMM"
        },
        {
          "name": "src2",
          "desc": "YMM/Mem"
        }
      ],
      "extension": "AVX2",
      "slug": "vpsubd",
      "rel_url": "x86/vpsubd/",
      "linked_summary": "Subtracts 8 integers (256-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmulld",
      "architecture": "x86",
      "full_name": "Packed Multiply Low Doubleword (AVX2)",
      "summary": "Multiplies 8 integers (256-bit).",
      "syntax": "VPMULLD ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 40",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "src1",
          "desc": "YMM"
        },
        {
          "name": "src2",
          "desc": "YMM/Mem"
        }
      ],
      "extension": "AVX2",
      "slug": "vpmulld",
      "rel_url": "x86/vpmulld/",
      "linked_summary": "Multiplies 8 integers (256-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpshufb",
      "architecture": "x86",
      "full_name": "Packed Shuffle Bytes (AVX2)",
      "summary": "Shuffles 32 bytes based on indices.",
      "syntax": "VPSHUFB ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 00",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "src",
          "desc": "YMM"
        },
        {
          "name": "mask",
          "desc": "YMM/Mem"
        }
      ],
      "extension": "AVX2",
      "slug": "vpshufb",
      "rel_url": "x86/vpshufb/",
      "linked_summary": "Shuffles 32 bytes based on indices.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vperm2i128",
      "architecture": "x86",
      "full_name": "Permute 128-bit Integer Blocks",
      "summary": "Shuffles two 128-bit lanes between registers.",
      "syntax": "VPERM2I128 ymm1, ymm2, ymm3/m256, imm8",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 46",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "src1",
          "desc": "YMM"
        },
        {
          "name": "src2",
          "desc": "YMM/Mem"
        },
        {
          "name": "ctrl",
          "desc": "Imm"
        }
      ],
      "extension": "AVX2",
      "slug": "vperm2i128",
      "rel_url": "x86/vperm2i128/",
      "linked_summary": "Shuffles two 128-<a href=\"../../armv8-a/bit/\">bit</a> lanes between registers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpermd",
      "architecture": "x86",
      "full_name": "Permute Doublewords",
      "summary": "Full permutation of 8 integers using indices from a register.",
      "syntax": "VPERMD ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 36",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "indices",
          "desc": "YMM"
        },
        {
          "name": "src",
          "desc": "YMM/Mem"
        }
      ],
      "extension": "AVX2",
      "slug": "vpermd",
      "rel_url": "x86/vpermd/",
      "linked_summary": "Full permutation of 8 integers using indices from a register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpermps",
      "architecture": "x86",
      "full_name": "Permute Single-Precision Floating-Point",
      "summary": "Full permutation of 8 floats using indices.",
      "syntax": "VPERMPS ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 16",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "indices",
          "desc": "YMM"
        },
        {
          "name": "src",
          "desc": "YMM/Mem"
        }
      ],
      "extension": "AVX2",
      "slug": "vpermps",
      "rel_url": "x86/vpermps/",
      "linked_summary": "Full permutation of 8 floats using indices.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpbroadcastb",
      "architecture": "x86",
      "full_name": "Broadcast Byte",
      "summary": "Broadcasts a byte from memory/register to all elements of YMM.",
      "syntax": "VPBROADCASTB ymm1, xmm2/m8",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 78",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "AVX2",
      "slug": "vpbroadcastb",
      "rel_url": "x86/vpbroadcastb/",
      "linked_summary": "Broadcasts a byte from memory/register to all elements of YMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpbroadcastd",
      "architecture": "x86",
      "full_name": "Broadcast Doubleword",
      "summary": "Broadcasts an integer to all elements of YMM.",
      "syntax": "VPBROADCASTD ymm1, xmm2/m32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 58",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "AVX2",
      "slug": "vpbroadcastd",
      "rel_url": "x86/vpbroadcastd/",
      "linked_summary": "Broadcasts an integer to all elements of YMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vgatherdps",
      "architecture": "x86",
      "full_name": "Gather Packed Single Precision",
      "summary": "Loads floats from non-contiguous memory using indices.",
      "syntax": "VGATHERDPS ymm1, [base+ymm_idx*scale], ymm_mask",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 92",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "mem",
          "desc": "Base+Idx"
        },
        {
          "name": "mask",
          "desc": "YMM"
        }
      ],
      "extension": "AVX2",
      "slug": "vgatherdps",
      "rel_url": "x86/vgatherdps/",
      "linked_summary": "Loads floats from non-contiguous memory using indices.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vgatherdpd",
      "architecture": "x86",
      "full_name": "Gather Packed Double Precision",
      "summary": "Loads doubles from non-contiguous memory using indices.",
      "syntax": "VGATHERDPD ymm1, [base+xmm_idx*scale], ymm_mask",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 92",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "mem",
          "desc": "Base+Idx"
        },
        {
          "name": "mask",
          "desc": "YMM"
        }
      ],
      "extension": "AVX2",
      "slug": "vgatherdpd",
      "rel_url": "x86/vgatherdpd/",
      "linked_summary": "Loads doubles from non-contiguous memory using indices.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "andn",
      "architecture": "x86",
      "full_name": "Logical AND NOT",
      "summary": "Calculates (NOT src1) AND src2. Non-destructive.",
      "syntax": "ANDN r32, r32, r/m32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... F2",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src1",
          "desc": "Reg"
        },
        {
          "name": "src2",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "BMI1",
      "slug": "andn",
      "rel_url": "x86/andn/",
      "linked_summary": "Calculates (<a href=\"../../risc-v/not/\">NOT</a> src1) <a href=\"../../risc-v/and/\">AND</a> src2. Non-destructive.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bextr",
      "architecture": "x86",
      "full_name": "Bit Field Extract",
      "summary": "Extracts sequence of bits from source using index/length.",
      "syntax": "BEXTR r32, r/m32, r32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... F7",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        },
        {
          "name": "ctrl",
          "desc": "Reg"
        }
      ],
      "extension": "BMI1",
      "slug": "bextr",
      "rel_url": "x86/bextr/",
      "linked_summary": "Extracts sequence of bits from source using <a href=\"../../armv8-a/index/\">index</a>/length.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "blsi",
      "architecture": "x86",
      "full_name": "Extract Lowest Set Isolated Bit",
      "summary": "Extracts the lowest set bit (x & -x).",
      "syntax": "BLSI r32, r/m32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... F3 /3",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "BMI1",
      "slug": "blsi",
      "rel_url": "x86/blsi/",
      "linked_summary": "Extracts the lowest set <a href=\"../../armv8-a/bit/\">bit</a> (x & -x).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "blsmsk",
      "architecture": "x86",
      "full_name": "Get Mask Up to Lowest Set Bit",
      "summary": "Creates mask up to lowest set bit (x ^ (x-1)).",
      "syntax": "BLSMSK r32, r/m32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... F3 /2",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "BMI1",
      "slug": "blsmsk",
      "rel_url": "x86/blsmsk/",
      "linked_summary": "Creates mask up to lowest set <a href=\"../../armv8-a/bit/\">bit</a> (x ^ (x-1)).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "blsr",
      "architecture": "x86",
      "full_name": "Reset Lowest Set Bit",
      "summary": "Clears the lowest set bit (x & (x-1)).",
      "syntax": "BLSR r32, r/m32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... F3 /1",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "BMI1",
      "slug": "blsr",
      "rel_url": "x86/blsr/",
      "linked_summary": "Clears the lowest set <a href=\"../../armv8-a/bit/\">bit</a> (x & (x-1)).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tzcnt",
      "architecture": "x86",
      "full_name": "Count Trailing Zeros",
      "summary": "Counts the number of trailing zeros.",
      "syntax": "TZCNT r32, r/m32",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F BC",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "BMI1",
      "slug": "tzcnt",
      "rel_url": "x86/tzcnt/",
      "linked_summary": "Counts the number of trailing zeros.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bzhi",
      "architecture": "x86",
      "full_name": "Zero High Bits Starting with Specified Bit Position",
      "summary": "Clears high bits starting at index.",
      "syntax": "BZHI r32, r/m32, r32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... F5",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        },
        {
          "name": "idx",
          "desc": "Reg"
        }
      ],
      "extension": "BMI2",
      "slug": "bzhi",
      "rel_url": "x86/bzhi/",
      "linked_summary": "Clears high bits starting <a href=\"../../armv8-a/at_2/\">at</a> <a href=\"../../armv8-a/index/\">index</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pext",
      "architecture": "x86",
      "full_name": "Parallel Bits Extract",
      "summary": "Extracts bits from source using mask and packs them to LSB.",
      "syntax": "PEXT r32, r32, r/m32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... F5",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "Reg"
        },
        {
          "name": "mask",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "BMI2",
      "slug": "pext",
      "rel_url": "x86/pext/",
      "linked_summary": "Extracts bits from source using mask <a href=\"../../armv8-a/and_6/\">and</a> packs them to LSB.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pdep",
      "architecture": "x86",
      "full_name": "Parallel Bits Deposit",
      "summary": "Scatters bits from LSB of source to positions marked in mask.",
      "syntax": "PDEP r32, r32, r/m32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... F5",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "Reg"
        },
        {
          "name": "mask",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "BMI2",
      "slug": "pdep",
      "rel_url": "x86/pdep/",
      "linked_summary": "Scatters bits from LSB of source to positions marked <a href=\"../../x86/in/\">in</a> mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mulx",
      "architecture": "x86",
      "full_name": "Unsigned Multiply Without Affecting Flags",
      "summary": "Unsigned multiply of RDX * Src. Result in Hi:Lo. No flags.",
      "syntax": "MULX r32, r32, r/m32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... F6",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "hi",
          "desc": "Reg"
        },
        {
          "name": "lo",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "BMI2",
      "slug": "mulx",
      "rel_url": "x86/mulx/",
      "linked_summary": "Unsigned multiply of RDX * Src. Result <a href=\"../../x86/in/\">in</a> Hi:Lo. No flags.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "shlx",
      "architecture": "x86",
      "full_name": "Shift Logical Left Without Affecting Flags",
      "summary": "Logical left shift, count in register. No flags update.",
      "syntax": "SHLX r32, r/m32, r32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... F7",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        },
        {
          "name": "cnt",
          "desc": "Reg"
        }
      ],
      "extension": "BMI2",
      "slug": "shlx",
      "rel_url": "x86/shlx/",
      "linked_summary": "Logical left shift, count <a href=\"../../x86/in/\">in</a> register. No flags update.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "shrx",
      "architecture": "x86",
      "full_name": "Shift Logical Right Without Affecting Flags",
      "summary": "Logical right shift, count in register. No flags update.",
      "syntax": "SHRX r32, r/m32, r32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... F7",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        },
        {
          "name": "cnt",
          "desc": "Reg"
        }
      ],
      "extension": "BMI2",
      "slug": "shrx",
      "rel_url": "x86/shrx/",
      "linked_summary": "Logical right shift, count <a href=\"../../x86/in/\">in</a> register. No flags update.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sarx",
      "architecture": "x86",
      "full_name": "Shift Arithmetic Right Without Affecting Flags",
      "summary": "Arithmetic right shift, count in register. No flags update.",
      "syntax": "SARX r32, r/m32, r32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... F7",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        },
        {
          "name": "cnt",
          "desc": "Reg"
        }
      ],
      "extension": "BMI2",
      "slug": "sarx",
      "rel_url": "x86/sarx/",
      "linked_summary": "Arithmetic right shift, count <a href=\"../../x86/in/\">in</a> register. No flags update.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rorx",
      "architecture": "x86",
      "full_name": "Rotate Right Logical Without Affecting Flags",
      "summary": "Rotate right with immediate. No flags update.",
      "syntax": "RORX r32, r/m32, imm8",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... F0",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        },
        {
          "name": "imm",
          "desc": "Imm"
        }
      ],
      "extension": "BMI2",
      "slug": "rorx",
      "rel_url": "x86/rorx/",
      "linked_summary": "Rotate right with immediate. No flags update.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rdrand",
      "architecture": "x86",
      "full_name": "Read Random Number",
      "summary": "Retrieves a hardware-generated random number.",
      "syntax": "RDRAND r32",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F C7 /6",
        "length": "3",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register"
        }
      ],
      "extension": "RDRAND",
      "slug": "rdrand",
      "rel_url": "x86/rdrand/",
      "linked_summary": "Retrieves a hardware-generated random number.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rdseed",
      "architecture": "x86",
      "full_name": "Read Random Seed",
      "summary": "Retrieves a random seed from hardware entropy source.",
      "syntax": "RDSEED r32",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F C7 /7",
        "length": "3",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register"
        }
      ],
      "extension": "RDSEED",
      "slug": "rdseed",
      "rel_url": "x86/rdseed/",
      "linked_summary": "Retrieves a random seed from hardware entropy source.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsave",
      "architecture": "x86",
      "full_name": "Save Processor Extended States",
      "summary": "Saves state components (AVX/SSE) to memory.",
      "syntax": "XSAVE m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F AE /4",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Memory"
        }
      ],
      "extension": "XSAVE",
      "slug": "xsave",
      "rel_url": "x86/xsave/",
      "linked_summary": "Saves state components (AVX/SSE) to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xrstor",
      "architecture": "x86",
      "full_name": "Restore Processor Extended States",
      "summary": "Restores state components from memory.",
      "syntax": "XRSTOR m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F AE /5",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Memory"
        }
      ],
      "extension": "XSAVE",
      "slug": "xrstor",
      "rel_url": "x86/xrstor/",
      "linked_summary": "Restores state components from memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xgetbv",
      "architecture": "x86",
      "full_name": "Get Value of Extended Control Register",
      "summary": "Reads an XCR specified by ECX into EDX:EAX.",
      "syntax": "XGETBV",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 D0",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "XSAVE",
      "slug": "xgetbv",
      "rel_url": "x86/xgetbv/",
      "linked_summary": "Reads an XCR specified by ECX into EDX:EAX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsetbv",
      "architecture": "x86",
      "full_name": "Set Value of Extended Control Register",
      "summary": "Writes EDX:EAX to XCR specified by ECX (Privileged).",
      "syntax": "XSETBV",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 D1",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "XSAVE",
      "slug": "xsetbv",
      "rel_url": "x86/xsetbv/",
      "linked_summary": "Writes EDX:EAX to XCR specified by ECX (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "invpcid",
      "architecture": "x86",
      "full_name": "Invalidate Process-Context Identifier",
      "summary": "Invalidates TLB entries based on PCID.",
      "syntax": "INVPCID r32, m128",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "66 0F 38 82",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "type",
          "desc": "Reg"
        },
        {
          "name": "desc",
          "desc": "Mem"
        }
      ],
      "extension": "INVPCID",
      "slug": "invpcid",
      "rel_url": "x86/invpcid/",
      "linked_summary": "Invalidates TLB entries based on PCID.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "adcx",
      "architecture": "x86",
      "full_name": "Unsigned Integer Addition of Two Operands with Carry Flag",
      "summary": "Adds with Carry Flag (distinct from ADC, affects CF only).",
      "syntax": "ADCX r32, r/m32",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "66 0F 38 F6",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "ADX",
      "slug": "adcx",
      "rel_url": "x86/adcx/",
      "linked_summary": "Adds with Carry Flag (distinct from ADC, affects CF only).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "adox",
      "architecture": "x86",
      "full_name": "Unsigned Integer Addition of Two Operands with Overflow Flag",
      "summary": "Adds with Overflow Flag (Parallel addition with ADCX).",
      "syntax": "ADOX r32, r/m32",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 38 F6",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "ADX",
      "slug": "adox",
      "rel_url": "x86/adox/",
      "linked_summary": "Adds with Overflow Flag (Parallel addition with ADCX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rdtscp",
      "architecture": "x86",
      "full_name": "Read Time-Stamp Counter and Processor ID",
      "summary": "Reads TSC and IA32_TSC_AUX into EDX:EAX and ECX.",
      "syntax": "RDTSCP",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 F9",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "rdtscp",
      "rel_url": "x86/rdtscp/",
      "linked_summary": "Reads TSC <a href=\"../../armv8-a/and_6/\">and</a> IA32_TSC_AUX into EDX:EAX <a href=\"../../armv8-a/and_6/\">and</a> ECX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vinserti128",
      "architecture": "x86",
      "full_name": "Insert Integer 128-bit",
      "summary": "Inserts 128-bits of integer data into a YMM register.",
      "syntax": "VINSERTI128 ymm1, ymm2, xmm3/m128, imm8",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 38",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "src1",
          "desc": "YMM"
        },
        {
          "name": "src2",
          "desc": "XMM/Mem"
        },
        {
          "name": "idx",
          "desc": "Imm"
        }
      ],
      "extension": "AVX2",
      "slug": "vinserti128",
      "rel_url": "x86/vinserti128/",
      "linked_summary": "Inserts 128-bits of integer data into a YMM register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vextracti128",
      "architecture": "x86",
      "full_name": "Extract Integer 128-bit",
      "summary": "Extracts 128-bits of integer data from YMM.",
      "syntax": "VEXTRACTI128 xmm1/m128, ymm2, imm8",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 39",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM/Mem"
        },
        {
          "name": "src",
          "desc": "YMM"
        },
        {
          "name": "idx",
          "desc": "Imm"
        }
      ],
      "extension": "AVX2",
      "slug": "vextracti128",
      "rel_url": "x86/vextracti128/",
      "linked_summary": "Extracts 128-bits of integer data from YMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "clac",
      "architecture": "x86",
      "full_name": "Clear AC Flag in EFLAGS",
      "summary": "Clears Alignment Check flag (SMAP prevention).",
      "syntax": "CLAC",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 CA",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "SMAP",
      "slug": "clac",
      "rel_url": "x86/clac/",
      "linked_summary": "Clears Alignment Check flag (SMAP prevention).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stac",
      "architecture": "x86",
      "full_name": "Set AC Flag in EFLAGS",
      "summary": "Sets Alignment Check flag (Allow user memory access).",
      "syntax": "STAC",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 CB",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "SMAP",
      "slug": "stac",
      "rel_url": "x86/stac/",
      "linked_summary": "Sets Alignment Check flag (Allow user memory access).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "gf2p8affineqb",
      "architecture": "x86",
      "full_name": "Galois Field Affine Transformation",
      "summary": "Computes affine transformation in GF(2^8).",
      "syntax": "GF2P8AFFINEQB xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "66 0F 3A CE",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        },
        {
          "name": "imm",
          "desc": "Imm"
        }
      ],
      "extension": "GFNI",
      "slug": "gf2p8affineqb",
      "rel_url": "x86/gf2p8affineqb/",
      "linked_summary": "Computes affine transformation <a href=\"../../x86/in/\">in</a> GF(2^8).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "gf2p8mulb",
      "architecture": "x86",
      "full_name": "Galois Field Multiply Bytes",
      "summary": "Multiplies bytes in GF(2^8).",
      "syntax": "GF2P8MULB xmm1, xmm2/m128",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "66 0F 38 CF",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "GFNI",
      "slug": "gf2p8mulb",
      "rel_url": "x86/gf2p8mulb/",
      "linked_summary": "Multiplies bytes <a href=\"../../x86/in/\">in</a> GF(2^8).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sha1msg1",
      "architecture": "x86",
      "full_name": "SHA1 Message Schedule 1",
      "summary": "Performs intermediate calculation for SHA1 message schedule.",
      "syntax": "SHA1MSG1 xmm1, xmm2/m128",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 38 C9",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SHA",
      "slug": "sha1msg1",
      "rel_url": "x86/sha1msg1/",
      "linked_summary": "Performs intermediate calculation for SHA1 message schedule.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sha1msg2",
      "architecture": "x86",
      "full_name": "SHA1 Message Schedule 2",
      "summary": "Performs final calculation for SHA1 message schedule.",
      "syntax": "SHA1MSG2 xmm1, xmm2/m128",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 38 CA",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SHA",
      "slug": "sha1msg2",
      "rel_url": "x86/sha1msg2/",
      "linked_summary": "Performs final calculation for SHA1 message schedule.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sha1nexte",
      "architecture": "x86",
      "full_name": "SHA1 State Variable E",
      "summary": "Calculates SHA1 state variable E.",
      "syntax": "SHA1NEXTE xmm1, xmm2/m128",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 38 C8",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SHA",
      "slug": "sha1nexte",
      "rel_url": "x86/sha1nexte/",
      "linked_summary": "Calculates SHA1 state variable E.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sha1rnds4",
      "architecture": "x86",
      "full_name": "SHA1 Rounds 4",
      "summary": "Performs 4 rounds of SHA1 operation.",
      "syntax": "SHA1RNDS4 xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 3A CC",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        },
        {
          "name": "imm",
          "desc": "Imm"
        }
      ],
      "extension": "SHA",
      "slug": "sha1rnds4",
      "rel_url": "x86/sha1rnds4/",
      "linked_summary": "Performs 4 rounds of SHA1 operation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sha256msg1",
      "architecture": "x86",
      "full_name": "SHA256 Message Schedule 1",
      "summary": "Performs intermediate calculation for SHA256 message schedule.",
      "syntax": "SHA256MSG1 xmm1, xmm2/m128",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 38 CC",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SHA",
      "slug": "sha256msg1",
      "rel_url": "x86/sha256msg1/",
      "linked_summary": "Performs intermediate calculation for SHA256 message schedule.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sha256msg2",
      "architecture": "x86",
      "full_name": "SHA256 Message Schedule 2",
      "summary": "Performs final calculation for SHA256 message schedule.",
      "syntax": "SHA256MSG2 xmm1, xmm2/m128",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 38 CD",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SHA",
      "slug": "sha256msg2",
      "rel_url": "x86/sha256msg2/",
      "linked_summary": "Performs final calculation for SHA256 message schedule.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sha256rnds2",
      "architecture": "x86",
      "full_name": "SHA256 Rounds 2",
      "summary": "Performs 2 rounds of SHA256 operation.",
      "syntax": "SHA256RNDS2 xmm1, xmm2/m128, xmm0",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 38 CB",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        },
        {
          "name": "state",
          "desc": "XMM0"
        }
      ],
      "extension": "SHA",
      "slug": "sha256rnds2",
      "rel_url": "x86/sha256rnds2/",
      "linked_summary": "Performs 2 rounds of SHA256 operation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmxon",
      "architecture": "x86",
      "full_name": "Enter VMX Operation",
      "summary": "Enters VMX root operation (Host Mode).",
      "syntax": "VMXON m64",
      "encoding": {
        "format": "VMX",
        "hex_opcode": "F3 0F C7 /6",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "ptr",
          "desc": "Memory"
        }
      ],
      "extension": "VMX",
      "slug": "vmxon",
      "rel_url": "x86/vmxon/",
      "linked_summary": "Enters VMX root operation (Host Mode).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmcall",
      "architecture": "x86",
      "full_name": "Call to VM Monitor",
      "summary": "Guest VM calls the Hypervisor (VM Exit).",
      "syntax": "VMCALL",
      "encoding": {
        "format": "VMX",
        "hex_opcode": "0F 01 C1",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "VMX",
      "slug": "vmcall",
      "rel_url": "x86/vmcall/",
      "linked_summary": "Guest VM calls the Hypervisor (VM Exit).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmclear",
      "architecture": "x86",
      "full_name": "Clear Virtual-Machine Control Structure",
      "summary": "Initializes a VMCS region in memory.",
      "syntax": "VMCLEAR m64",
      "encoding": {
        "format": "VMX",
        "hex_opcode": "66 0F C7 /6",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "ptr",
          "desc": "Memory"
        }
      ],
      "extension": "VMX",
      "slug": "vmclear",
      "rel_url": "x86/vmclear/",
      "linked_summary": "Initializes a VMCS region <a href=\"../../x86/in/\">in</a> memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmlaunch",
      "architecture": "x86",
      "full_name": "Launch Virtual Machine",
      "summary": "Launches a VM managed by the current VMCS.",
      "syntax": "VMLAUNCH",
      "encoding": {
        "format": "VMX",
        "hex_opcode": "0F 01 C2",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "VMX",
      "slug": "vmlaunch",
      "rel_url": "x86/vmlaunch/",
      "linked_summary": "Launches a VM managed by the current VMCS.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmresume",
      "architecture": "x86",
      "full_name": "Resume Virtual Machine",
      "summary": "Resumes a VM from the current VMCS.",
      "syntax": "VMRESUME",
      "encoding": {
        "format": "VMX",
        "hex_opcode": "0F 01 C3",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "VMX",
      "slug": "vmresume",
      "rel_url": "x86/vmresume/",
      "linked_summary": "Resumes a VM from the current VMCS.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmptrld",
      "architecture": "x86",
      "full_name": "Load Pointer to VMCS",
      "summary": "Loads the current VMCS pointer from memory.",
      "syntax": "VMPTRLD m64",
      "encoding": {
        "format": "VMX",
        "hex_opcode": "0F C7 /6",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "ptr",
          "desc": "Memory"
        }
      ],
      "extension": "VMX",
      "slug": "vmptrld",
      "rel_url": "x86/vmptrld/",
      "linked_summary": "Loads the current VMCS pointer from memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmptrst",
      "architecture": "x86",
      "full_name": "Store Pointer to VMCS",
      "summary": "Stores the current VMCS pointer to memory.",
      "syntax": "VMPTRST m64",
      "encoding": {
        "format": "VMX",
        "hex_opcode": "0F C7 /7",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Memory"
        }
      ],
      "extension": "VMX",
      "slug": "vmptrst",
      "rel_url": "x86/vmptrst/",
      "linked_summary": "Stores the current VMCS pointer to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmread",
      "architecture": "x86",
      "full_name": "Read Field from VMCS",
      "summary": "Reads a field from the Virtual Machine Control Structure.",
      "syntax": "VMREAD r/m64, r64",
      "encoding": {
        "format": "VMX",
        "hex_opcode": "0F 78",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        },
        {
          "name": "field",
          "desc": "Reg"
        }
      ],
      "extension": "VMX",
      "slug": "vmread",
      "rel_url": "x86/vmread/",
      "linked_summary": "Reads a field from the Virtual Machine Control Structure.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmwrite",
      "architecture": "x86",
      "full_name": "Write Field to VMCS",
      "summary": "Writes a field to the Virtual Machine Control Structure.",
      "syntax": "VMWRITE r64, r/m64",
      "encoding": {
        "format": "VMX",
        "hex_opcode": "0F 79",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "field",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "VMX",
      "slug": "vmwrite",
      "rel_url": "x86/vmwrite/",
      "linked_summary": "Writes a field to the Virtual Machine Control Structure.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmoff",
      "architecture": "x86",
      "full_name": "Leave VMX Operation",
      "summary": "Leaves VMX root operation.",
      "syntax": "VMOFF",
      "encoding": {
        "format": "VMX",
        "hex_opcode": "0F 01 C4",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "VMX",
      "slug": "vmoff",
      "rel_url": "x86/vmoff/",
      "linked_summary": "Leaves VMX root operation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "invept",
      "architecture": "x86",
      "full_name": "Invalidate Translations Derived from EPT",
      "summary": "Invalidates Extended Page Table entries.",
      "syntax": "INVEPT r64, m128",
      "encoding": {
        "format": "VMX",
        "hex_opcode": "66 0F 38 80",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "type",
          "desc": "Reg"
        },
        {
          "name": "desc",
          "desc": "Mem"
        }
      ],
      "extension": "VMX (EPT)",
      "slug": "invept",
      "rel_url": "x86/invept/",
      "linked_summary": "Invalidates Extended Page Table entries.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "invvpid",
      "architecture": "x86",
      "full_name": "Invalidate Translations Based on VPID",
      "summary": "Invalidates TLB entries based on Virtual Processor ID.",
      "syntax": "INVVPID r64, m128",
      "encoding": {
        "format": "VMX",
        "hex_opcode": "66 0F 38 81",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "type",
          "desc": "Reg"
        },
        {
          "name": "desc",
          "desc": "Mem"
        }
      ],
      "extension": "VMX (VPID)",
      "slug": "invvpid",
      "rel_url": "x86/invvpid/",
      "linked_summary": "Invalidates TLB entries based on Virtual Processor ID.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kmovw",
      "architecture": "x86",
      "full_name": "Move Word Mask Register",
      "summary": "Moves 16-bit mask to/from k-register.",
      "syntax": "KMOVW k1, k2/m16",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 90",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "k-reg"
        },
        {
          "name": "src",
          "desc": "k-reg/Mem"
        }
      ],
      "extension": "AVX-512",
      "slug": "kmovw",
      "rel_url": "x86/kmovw/",
      "linked_summary": "Moves 16-<a href=\"../../armv8-a/bit/\">bit</a> mask to/from k-register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kmovq",
      "architecture": "x86",
      "full_name": "Move Quadword Mask Register",
      "summary": "Moves 64-bit mask to/from k-register.",
      "syntax": "KMOVQ k1, k2/m64",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 90",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "k-reg"
        },
        {
          "name": "src",
          "desc": "k-reg/Mem"
        }
      ],
      "extension": "AVX-512BW",
      "slug": "kmovq",
      "rel_url": "x86/kmovq/",
      "linked_summary": "Moves 64-<a href=\"../../armv8-a/bit/\">bit</a> mask to/from k-register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kandw",
      "architecture": "x86",
      "full_name": "Bitwise Logical AND Masks Word",
      "summary": "Bitwise AND of 16-bit masks.",
      "syntax": "KANDW k1, k2, k3",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 41",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "k-reg"
        },
        {
          "name": "src1",
          "desc": "k-reg"
        },
        {
          "name": "src2",
          "desc": "k-reg"
        }
      ],
      "extension": "AVX-512",
      "slug": "kandw",
      "rel_url": "x86/kandw/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/and/\">AND</a> of 16-<a href=\"../../armv8-a/bit/\">bit</a> masks.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kandnw",
      "architecture": "x86",
      "full_name": "Bitwise Logical AND NOT Masks Word",
      "summary": "Bitwise AND NOT of 16-bit masks.",
      "syntax": "KANDNW k1, k2, k3",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 42",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "k-reg"
        },
        {
          "name": "src1",
          "desc": "k-reg"
        },
        {
          "name": "src2",
          "desc": "k-reg"
        }
      ],
      "extension": "AVX-512",
      "slug": "kandnw",
      "rel_url": "x86/kandnw/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/and/\">AND</a> <a href=\"../../risc-v/not/\">NOT</a> of 16-<a href=\"../../armv8-a/bit/\">bit</a> masks.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "korw",
      "architecture": "x86",
      "full_name": "Bitwise Logical OR Masks Word",
      "summary": "Bitwise OR of 16-bit masks.",
      "syntax": "KORW k1, k2, k3",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 45",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "k-reg"
        },
        {
          "name": "src1",
          "desc": "k-reg"
        },
        {
          "name": "src2",
          "desc": "k-reg"
        }
      ],
      "extension": "AVX-512",
      "slug": "korw",
      "rel_url": "x86/korw/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/or/\">OR</a> of 16-<a href=\"../../armv8-a/bit/\">bit</a> masks.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kxorw",
      "architecture": "x86",
      "full_name": "Bitwise Logical XOR Masks Word",
      "summary": "Bitwise XOR of 16-bit masks.",
      "syntax": "KXORW k1, k2, k3",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 47",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "k-reg"
        },
        {
          "name": "src1",
          "desc": "k-reg"
        },
        {
          "name": "src2",
          "desc": "k-reg"
        }
      ],
      "extension": "AVX-512",
      "slug": "kxorw",
      "rel_url": "x86/kxorw/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/xor/\">XOR</a> of 16-<a href=\"../../armv8-a/bit/\">bit</a> masks.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "knotw",
      "architecture": "x86",
      "full_name": "Bitwise Logical NOT Masks Word",
      "summary": "Bitwise NOT of 16-bit mask.",
      "syntax": "KNOTW k1, k2",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 44",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "k-reg"
        },
        {
          "name": "src",
          "desc": "k-reg"
        }
      ],
      "extension": "AVX-512",
      "slug": "knotw",
      "rel_url": "x86/knotw/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/not/\">NOT</a> of 16-<a href=\"../../armv8-a/bit/\">bit</a> mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kortestw",
      "architecture": "x86",
      "full_name": "OR Masks And Set Flags Word",
      "summary": "ORs two masks and sets EFLAGS (ZF, CF) based on result.",
      "syntax": "KORTESTW k1, k2",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 98",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src1",
          "desc": "k-reg"
        },
        {
          "name": "src2",
          "desc": "k-reg"
        }
      ],
      "extension": "AVX-512",
      "slug": "kortestw",
      "rel_url": "x86/kortestw/",
      "linked_summary": "ORs two masks <a href=\"../../armv8-a/and_6/\">and</a> sets EFLAGS (ZF, CF) based on result.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpternlogd",
      "architecture": "x86",
      "full_name": "Packed Doubleword Ternary Logic",
      "summary": "Performs one of 256 logical operations on 3 inputs.",
      "syntax": "VPTERNLOGD zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 25",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM"
        },
        {
          "name": "src3",
          "desc": "ZMM/Mem"
        },
        {
          "name": "func",
          "desc": "Imm"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vpternlogd",
      "rel_url": "x86/vpternlogd/",
      "linked_summary": "Performs one of 256 logical operations on 3 inputs.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpternlogq",
      "architecture": "x86",
      "full_name": "Packed Quadword Ternary Logic",
      "summary": "Performs one of 256 logical operations on 3 quadwords.",
      "syntax": "VPTERNLOGQ zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 25",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM"
        },
        {
          "name": "src3",
          "desc": "ZMM/Mem"
        },
        {
          "name": "func",
          "desc": "Imm"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vpternlogq",
      "rel_url": "x86/vpternlogq/",
      "linked_summary": "Performs one of 256 logical operations on 3 quadwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcompresspd",
      "architecture": "x86",
      "full_name": "Store Sparse Packed Double-Precision Floating-Point Values",
      "summary": "Compresses active elements from ZMM to memory.",
      "syntax": "VCOMPRESSPD m512 {k1}, zmm1",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 8A",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Mem"
        },
        {
          "name": "src",
          "desc": "ZMM"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vcompresspd",
      "rel_url": "x86/vcompresspd/",
      "linked_summary": "Compresses active elements from ZMM to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcompressps",
      "architecture": "x86",
      "full_name": "Store Sparse Packed Single-Precision Floating-Point Values",
      "summary": "Compresses active elements from ZMM to memory.",
      "syntax": "VCOMPRESSPS m512 {k1}, zmm1",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 8A",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Mem"
        },
        {
          "name": "src",
          "desc": "ZMM"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vcompressps",
      "rel_url": "x86/vcompressps/",
      "linked_summary": "Compresses active elements from ZMM to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vexpandpd",
      "architecture": "x86",
      "full_name": "Load Sparse Packed Double-Precision Floating-Point Values",
      "summary": "Expands data from memory into sparse locations in ZMM.",
      "syntax": "VEXPANDPD zmm1 {k1}, m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 88",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "Mem"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vexpandpd",
      "rel_url": "x86/vexpandpd/",
      "linked_summary": "Expands data from memory into sparse locations <a href=\"../../x86/in/\">in</a> ZMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vexpandps",
      "architecture": "x86",
      "full_name": "Load Sparse Packed Single-Precision Floating-Point Values",
      "summary": "Expands data from memory into sparse locations in ZMM.",
      "syntax": "VEXPANDPS zmm1 {k1}, m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 88",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "Mem"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vexpandps",
      "rel_url": "x86/vexpandps/",
      "linked_summary": "Expands data from memory into sparse locations <a href=\"../../x86/in/\">in</a> ZMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpermi2d",
      "architecture": "x86",
      "full_name": "Permute Two-Source Doublewords",
      "summary": "Shuffles doublewords from two ZMM registers into destination.",
      "syntax": "VPERMI2D zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 76",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "idx",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vpermi2d",
      "rel_url": "x86/vpermi2d/",
      "linked_summary": "Shuffles doublewords from two ZMM registers into destination.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpermt2d",
      "architecture": "x86",
      "full_name": "Permute Two-Source Doublewords (Overwrite)",
      "summary": "Shuffles 2 sources, overwriting the index register.",
      "syntax": "VPERMT2D zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 7F",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "idx",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vpermt2d",
      "rel_url": "x86/vpermt2d/",
      "linked_summary": "Shuffles 2 sources, overwriting the <a href=\"../../armv8-a/index/\">index</a> register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vshuff32x4",
      "architecture": "x86",
      "full_name": "Shuffle Packed Float32x4",
      "summary": "Shuffles 128-bit blocks of single-precision floats.",
      "syntax": "VSHUFF32X4 zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 23",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        },
        {
          "name": "ctrl",
          "desc": "Imm"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vshuff32x4",
      "rel_url": "x86/vshuff32x4/",
      "linked_summary": "Shuffles 128-<a href=\"../../armv8-a/bit/\">bit</a> blocks of single-precision floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmovdb",
      "architecture": "x86",
      "full_name": "Truncate Doubleword to Byte",
      "summary": "Down-converts 32-bit integers to 8-bit.",
      "syntax": "VPMOVDB xmm1/m128 {k1}, zmm2",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "F3 0F 38 31",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM/Mem"
        },
        {
          "name": "src",
          "desc": "ZMM"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vpmovdb",
      "rel_url": "x86/vpmovdb/",
      "linked_summary": "Down-converts 32-<a href=\"../../armv8-a/bit/\">bit</a> integers to 8-<a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmovusdb",
      "architecture": "x86",
      "full_name": "Saturate Unsigned Doubleword to Byte",
      "summary": "Down-converts 32-bit to 8-bit with unsigned saturation.",
      "syntax": "VPMOVUSDB xmm1/m128 {k1}, zmm2",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "F3 0F 38 11",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM/Mem"
        },
        {
          "name": "src",
          "desc": "ZMM"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vpmovusdb",
      "rel_url": "x86/vpmovusdb/",
      "linked_summary": "Down-converts 32-<a href=\"../../armv8-a/bit/\">bit</a> to 8-<a href=\"../../armv8-a/bit/\">bit</a> with unsigned saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vrndscalepd",
      "architecture": "x86",
      "full_name": "Round Packed Double-Precision Floating-Point with Scale",
      "summary": "Rounds doubles to integer values using imm8 control.",
      "syntax": "VRNDSCALEPD zmm1 {k1}, zmm2/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 09",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "ZMM/Mem"
        },
        {
          "name": "ctrl",
          "desc": "Imm"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vrndscalepd",
      "rel_url": "x86/vrndscalepd/",
      "linked_summary": "Rounds doubles to integer values using imm8 control.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfixupimmpd",
      "architecture": "x86",
      "full_name": "Fix Up Special Packed Float64 Values",
      "summary": "Fixes special cases (NaN, Inf) using a table.",
      "syntax": "VFIXUPIMMPD zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 54",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "table",
          "desc": "ZMM/Mem"
        },
        {
          "name": "imm",
          "desc": "Imm"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vfixupimmpd",
      "rel_url": "x86/vfixupimmpd/",
      "linked_summary": "Fixes special cases (NaN, Inf) using a table.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vgetmantpd",
      "architecture": "x86",
      "full_name": "Get Mantissa Packed Double-Precision",
      "summary": "Extracts mantissas from doubles.",
      "syntax": "VGETMANTPD zmm1 {k1}, zmm2/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 26",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "ZMM/Mem"
        },
        {
          "name": "ctrl",
          "desc": "Imm"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vgetmantpd",
      "rel_url": "x86/vgetmantpd/",
      "linked_summary": "Extracts mantissas from doubles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vgetexppd",
      "architecture": "x86",
      "full_name": "Get Exponent Packed Double-Precision",
      "summary": "Extracts exponents from doubles as float values.",
      "syntax": "VGETEXPPD zmm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 42",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vgetexppd",
      "rel_url": "x86/vgetexppd/",
      "linked_summary": "Extracts exponents from doubles as float values.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vscalefpd",
      "architecture": "x86",
      "full_name": "Scale Packed Float64 Values with Float64 Exponents",
      "summary": "Scales doubles by exponents (x * 2^n).",
      "syntax": "VSCALEFPD zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 2C",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "ZMM"
        },
        {
          "name": "exp",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vscalefpd",
      "rel_url": "x86/vscalefpd/",
      "linked_summary": "Scales doubles by exponents (x * 2^n).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "valignd",
      "architecture": "x86",
      "full_name": "Align Doubleword Vectors",
      "summary": "Extracts 512-bits from two concatenated ZMMs shifted by count.",
      "syntax": "VALIGND zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 03",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "AVX-512F",
      "slug": "valignd",
      "rel_url": "x86/valignd/",
      "linked_summary": "Extracts 512-bits from two concatenated ZMMs shifted by count.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpconflictd",
      "architecture": "x86",
      "full_name": "Detect Conflicts Within a Vector of Packed Dword Values",
      "summary": "Detects duplicate values in a vector (Conflict Detection).",
      "syntax": "VPCONFLICTD zmm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 C4",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512CD",
      "slug": "vpconflictd",
      "rel_url": "x86/vpconflictd/",
      "linked_summary": "Detects duplicate values <a href=\"../../x86/in/\">in</a> a vector (Conflict Detection).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vplzcntd",
      "architecture": "x86",
      "full_name": "Count Leading Zero Bits",
      "summary": "Counts leading zeros for each doubleword element.",
      "syntax": "VPLZCNTD zmm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 44",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512CD",
      "slug": "vplzcntd",
      "rel_url": "x86/vplzcntd/",
      "linked_summary": "Counts leading zeros for each doubleword element.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcvtudq2ps",
      "architecture": "x86",
      "full_name": "Convert Packed Unsigned Doubleword Integers to Packed Single-Precision Floating-Point",
      "summary": "Converts unsigned int32 to float.",
      "syntax": "VCVTUDQ2PS zmm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "F2 0F 5B",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vcvtudq2ps",
      "rel_url": "x86/vcvtudq2ps/",
      "linked_summary": "Converts unsigned int32 to float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vprolvd",
      "architecture": "x86",
      "full_name": "Rotate Left Doubleword Variable",
      "summary": "Rotates doublewords left by amounts in second vector.",
      "syntax": "VPROLVD zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 15",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "ZMM"
        },
        {
          "name": "counts",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vprolvd",
      "rel_url": "x86/vprolvd/",
      "linked_summary": "Rotates doublewords left by amounts <a href=\"../../x86/in/\">in</a> second vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpopcntd",
      "architecture": "x86",
      "full_name": "Packed Population Count Doubleword",
      "summary": "Counts set bits in each doubleword element.",
      "syntax": "VPOPCNTD zmm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 55",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512_VPOPCNTDQ",
      "slug": "vpopcntd",
      "rel_url": "x86/vpopcntd/",
      "linked_summary": "Counts set bits <a href=\"../../x86/in/\">in</a> each doubleword element.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "encls",
      "architecture": "x86",
      "full_name": "Execute Enclave Supervisor Leaf",
      "summary": "Executes an SGX supervisor function specified by EAX.",
      "syntax": "ENCLS",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 CF",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "SGX",
      "slug": "encls",
      "rel_url": "x86/encls/",
      "linked_summary": "Executes an SGX supervisor function specified by EAX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "enclu",
      "architecture": "x86",
      "full_name": "Execute Enclave User Leaf",
      "summary": "Executes an SGX user function specified by EAX.",
      "syntax": "ENCLU",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 D7",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "SGX",
      "slug": "enclu",
      "rel_url": "x86/enclu/",
      "linked_summary": "Executes an SGX user function specified by EAX.",
      "linked_pseudocode": ""
    }
  ]
}