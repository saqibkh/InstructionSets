{
  "instructions": [
    {
      "mnemonic": "mov",
      "architecture": "x86",
      "full_name": "Move",
      "summary": "Copies data from source to destination.",
      "syntax": "MOV r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "88/89/8A/8B",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "mov",
      "rel_url": "x86/mov/",
      "operands": [],
      "linked_summary": "Copies data from source to destination.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "add",
      "architecture": "x86",
      "full_name": "Add",
      "summary": "Adds source to destination.",
      "syntax": "ADD r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "00-05",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "add",
      "rel_url": "x86/add/",
      "operands": [],
      "linked_summary": "Adds source to destination.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sub",
      "architecture": "x86",
      "full_name": "Subtract",
      "summary": "Subtracts source from destination.",
      "syntax": "SUB r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "28-2D",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "sub",
      "rel_url": "x86/sub/",
      "operands": [],
      "linked_summary": "Subtracts source from destination.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "inc",
      "architecture": "x86",
      "full_name": "Increment",
      "summary": "Increments operand by 1.",
      "syntax": "INC r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "FF /0",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "inc",
      "rel_url": "x86/inc/",
      "operands": [],
      "linked_summary": "Increments operand by 1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dec",
      "architecture": "x86",
      "full_name": "Decrement",
      "summary": "Decrements operand by 1.",
      "syntax": "DEC r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "FF /1",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "dec",
      "rel_url": "x86/dec/",
      "operands": [],
      "linked_summary": "Decrements operand by 1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mul",
      "architecture": "x86",
      "full_name": "Unsigned Multiply",
      "summary": "Unsigned multiply (AX = AL * src).",
      "syntax": "MUL r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F7 /4",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "mul",
      "rel_url": "x86/mul/",
      "operands": [],
      "linked_summary": "Unsigned multiply (AX = AL * src).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "imul",
      "architecture": "x86",
      "full_name": "Signed Multiply",
      "summary": "Signed multiply.",
      "syntax": "IMUL r, r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F AF",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "imul",
      "rel_url": "x86/imul/",
      "operands": [],
      "linked_summary": "Signed multiply.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "div",
      "architecture": "x86",
      "full_name": "Unsigned Divide",
      "summary": "Unsigned divide (AX / src).",
      "syntax": "DIV r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F7 /6",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "div",
      "rel_url": "x86/div/",
      "operands": [],
      "linked_summary": "Unsigned divide (AX / src).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "idiv",
      "architecture": "x86",
      "full_name": "Signed Divide",
      "summary": "Signed divide (AX / src).",
      "syntax": "IDIV r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F7 /7",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "idiv",
      "rel_url": "x86/idiv/",
      "operands": [],
      "linked_summary": "Signed divide (AX / src).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "and",
      "architecture": "x86",
      "full_name": "Logical AND",
      "summary": "Performs bitwise AND.",
      "syntax": "AND r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "20-25",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "and",
      "rel_url": "x86/and/",
      "operands": [],
      "linked_summary": "Performs bitwise <a href=\"../../armv9-a/and_1/\">AND</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "or",
      "architecture": "x86",
      "full_name": "Logical OR",
      "summary": "Performs bitwise OR.",
      "syntax": "OR r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "08-0D",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "or",
      "rel_url": "x86/or/",
      "operands": [],
      "linked_summary": "Performs bitwise <a href=\"../../risc-v/or/\">OR</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xor",
      "architecture": "x86",
      "full_name": "Logical Exclusive OR",
      "summary": "Performs bitwise XOR.",
      "syntax": "XOR r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "30-35",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "xor",
      "rel_url": "x86/xor/",
      "operands": [],
      "linked_summary": "Performs bitwise <a href=\"../../risc-v/xor/\">XOR</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "not",
      "architecture": "x86",
      "full_name": "One's Complement Negation",
      "summary": "Reverses bits of operand.",
      "syntax": "NOT r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F7 /2",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "not",
      "rel_url": "x86/not/",
      "operands": [],
      "linked_summary": "Reverses bits of operand.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "neg",
      "architecture": "x86",
      "full_name": "Two's Complement Negation",
      "summary": "Negates value (0 - operand).",
      "syntax": "NEG r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F7 /3",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "neg",
      "rel_url": "x86/neg/",
      "operands": [],
      "linked_summary": "Negates value (0 - operand).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "shl",
      "architecture": "x86",
      "full_name": "Shift Logical Left",
      "summary": "Shifts bits left (same as SAL).",
      "syntax": "SHL r/m, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "C1 /4",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "shl",
      "rel_url": "x86/shl/",
      "operands": [],
      "linked_summary": "Shifts bits left (same as SAL).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "shr",
      "architecture": "x86",
      "full_name": "Shift Logical Right",
      "summary": "Shifts bits right, filling with zeros.",
      "syntax": "SHR r/m, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "C1 /5",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "shr",
      "rel_url": "x86/shr/",
      "operands": [],
      "linked_summary": "Shifts bits right, filling with zeros.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sar",
      "architecture": "x86",
      "full_name": "Shift Arithmetic Right",
      "summary": "Shifts bits right, preserving sign bit.",
      "syntax": "SAR r/m, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "C1 /7",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "sar",
      "rel_url": "x86/sar/",
      "operands": [],
      "linked_summary": "Shifts bits right, preserving sign <a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmp",
      "architecture": "x86",
      "full_name": "Compare Two Operands",
      "summary": "Subtracts src from dest and updates flags (dest not modified).",
      "syntax": "CMP r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "38-3D",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "cmp",
      "rel_url": "x86/cmp/",
      "operands": [],
      "linked_summary": "Subtracts src from dest <a href=\"../../armv8-a/and_6/\">and</a> updates flags (dest <a href=\"../../armv8-a/not_1/\">not</a> modified).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "test",
      "architecture": "x86",
      "full_name": "Logical Compare",
      "summary": "ANDs operands and updates flags (result discarded).",
      "syntax": "TEST r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "84-85",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "test",
      "rel_url": "x86/test/",
      "operands": [],
      "linked_summary": "ANDs operands <a href=\"../../armv8-a/and_6/\">and</a> updates flags (result discarded).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "jmp",
      "architecture": "x86",
      "full_name": "Jump",
      "summary": "Unconditional jump to target.",
      "syntax": "JMP rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "EB / E9",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "jmp",
      "rel_url": "x86/jmp/",
      "operands": [],
      "linked_summary": "Unconditional jump to target.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "je",
      "architecture": "x86",
      "full_name": "Jump if Equal",
      "summary": "Jump if ZF=1 (Same as JZ).",
      "syntax": "JE rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "74",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "je",
      "rel_url": "x86/je/",
      "operands": [],
      "linked_summary": "Jump if ZF=1 (Same as JZ).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "jne",
      "architecture": "x86",
      "full_name": "Jump if Not Equal",
      "summary": "Jump if ZF=0 (Same as JNZ).",
      "syntax": "JNE rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "75",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "jne",
      "rel_url": "x86/jne/",
      "operands": [],
      "linked_summary": "Jump if ZF=0 (Same as JNZ).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "jg",
      "architecture": "x86",
      "full_name": "Jump if Greater",
      "summary": "Jump if ZF=0 and SF=OF (Signed >).",
      "syntax": "JG rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "7F",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "jg",
      "rel_url": "x86/jg/",
      "operands": [],
      "linked_summary": "Jump if ZF=0 <a href=\"../../armv8-a/and_6/\">and</a> SF=OF (Signed >).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "jl",
      "architecture": "x86",
      "full_name": "Jump if Less",
      "summary": "Jump if SF!=OF (Signed <).",
      "syntax": "JL rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "7C",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "jl",
      "rel_url": "x86/jl/",
      "operands": [],
      "linked_summary": "Jump if SF!=OF (Signed <).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ja",
      "architecture": "x86",
      "full_name": "Jump if Above",
      "summary": "Jump if CF=0 and ZF=0 (Unsigned >).",
      "syntax": "JA rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "77",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "ja",
      "rel_url": "x86/ja/",
      "operands": [],
      "linked_summary": "Jump if CF=0 <a href=\"../../armv8-a/and_6/\">and</a> ZF=0 (Unsigned >).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "jb",
      "architecture": "x86",
      "full_name": "Jump if Below",
      "summary": "Jump if CF=1 (Unsigned <).",
      "syntax": "JB rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "72",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "jb",
      "rel_url": "x86/jb/",
      "operands": [],
      "linked_summary": "Jump if CF=1 (Unsigned <).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "call",
      "architecture": "x86",
      "full_name": "Call Procedure",
      "summary": "Push EIP/RIP and jump to target.",
      "syntax": "CALL rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "E8",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "call",
      "rel_url": "x86/call/",
      "operands": [],
      "linked_summary": "Push EIP/RIP <a href=\"../../armv8-a/and_6/\">and</a> jump to target.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ret",
      "architecture": "x86",
      "full_name": "Return from Procedure",
      "summary": "Pop EIP/RIP and resume execution.",
      "syntax": "RET",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "C3",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "ret",
      "rel_url": "x86/ret/",
      "operands": [],
      "linked_summary": "Pop EIP/RIP <a href=\"../../armv8-a/and_6/\">and</a> resume execution.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "push",
      "architecture": "x86",
      "full_name": "Push Value Onto Stack",
      "summary": "Decrements SP and stores operand on stack.",
      "syntax": "PUSH r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "FF /6",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "push",
      "rel_url": "x86/push/",
      "operands": [],
      "linked_summary": "Decrements SP <a href=\"../../armv8-a/and_6/\">and</a> stores operand on stack.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pop",
      "architecture": "x86",
      "full_name": "Pop Value from Stack",
      "summary": "Loads operand from stack and increments SP.",
      "syntax": "POP r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "8F /0",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "pop",
      "rel_url": "x86/pop/",
      "operands": [],
      "linked_summary": "Loads operand from stack <a href=\"../../armv8-a/and_6/\">and</a> increments SP.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lea",
      "architecture": "x86",
      "full_name": "Load Effective Address",
      "summary": "Computes effective address and stores in register.",
      "syntax": "LEA r, m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "8D",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "lea",
      "rel_url": "x86/lea/",
      "operands": [],
      "linked_summary": "Computes effective address <a href=\"../../armv8-a/and_6/\">and</a> stores <a href=\"../../x86/in/\">in</a> register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "nop",
      "architecture": "x86",
      "full_name": "No Operation",
      "summary": "Does nothing (alias for XCHG EAX, EAX).",
      "syntax": "NOP",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "90",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "nop",
      "rel_url": "x86/nop/",
      "operands": [],
      "linked_summary": "Does nothing (alias for XCHG EAX, EAX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xchg",
      "architecture": "x86",
      "full_name": "Exchange Register/Memory with Register",
      "summary": "Exchanges content of two operands.",
      "syntax": "XCHG r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "87",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "xchg",
      "rel_url": "x86/xchg/",
      "operands": [],
      "linked_summary": "Exchanges content of two operands.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cpuid",
      "architecture": "x86",
      "full_name": "CPU Identification",
      "summary": "Returns processor information based on EAX value.",
      "syntax": "CPUID",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F A2",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "cpuid",
      "rel_url": "x86/cpuid/",
      "operands": [],
      "linked_summary": "Returns processor information based on EAX value.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rdtsc",
      "architecture": "x86",
      "full_name": "Read Time-Stamp Counter",
      "summary": "Reads the time-stamp counter into EDX:EAX.",
      "syntax": "RDTSC",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 31",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "rdtsc",
      "rel_url": "x86/rdtsc/",
      "operands": [],
      "linked_summary": "Reads the time-stamp counter into EDX:EAX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movsx",
      "architecture": "x86",
      "full_name": "Move with Sign-Extension",
      "summary": "Copies and sign-extends a smaller value to a larger register.",
      "syntax": "MOVSX r, r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F BE",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "movsx",
      "rel_url": "x86/movsx/",
      "operands": [],
      "linked_summary": "Copies <a href=\"../../armv8-a/and_6/\">and</a> sign-extends a smaller value to a larger register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movzx",
      "architecture": "x86",
      "full_name": "Move with Zero-Extension",
      "summary": "Copies and zero-extends a smaller value to a larger register.",
      "syntax": "MOVZX r, r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F B6",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "movzx",
      "rel_url": "x86/movzx/",
      "operands": [],
      "linked_summary": "Copies <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../armv9-a/zero_2/\">zero</a>-extends a smaller value to a larger register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cwtl",
      "architecture": "x86",
      "full_name": "Convert Word to Long",
      "summary": "Sign-extends AX into EAX (also CWDE).",
      "syntax": "CWTL",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "98",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "cwtl",
      "rel_url": "x86/cwtl/",
      "operands": [],
      "linked_summary": "Sign-extends AX into EAX (also CWDE).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cltd",
      "architecture": "x86",
      "full_name": "Convert Long to Double Long",
      "summary": "Sign-extends EAX into EDX:EAX (also CDQ).",
      "syntax": "CLTD",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "99",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "cltd",
      "rel_url": "x86/cltd/",
      "operands": [],
      "linked_summary": "Sign-extends EAX into EDX:EAX (also CDQ).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cqto",
      "architecture": "x86",
      "full_name": "Convert Quadword to Octoword",
      "summary": "Sign-extends RAX into RDX:RAX (also CQO).",
      "syntax": "CQTO",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "48 99",
        "visual_parts": []
      },
      "extension": "Base (64-bit)",
      "slug": "cqto",
      "rel_url": "x86/cqto/",
      "operands": [],
      "linked_summary": "Sign-extends RAX into RDX:RAX (also CQO).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bswap",
      "architecture": "x86",
      "full_name": "Byte Swap",
      "summary": "Reverses the byte order of a register (Endian swap).",
      "syntax": "BSWAP r32",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F C8+rd",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "bswap",
      "rel_url": "x86/bswap/",
      "operands": [],
      "linked_summary": "Reverses the byte order of a register (Endian swap).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xadd",
      "architecture": "x86",
      "full_name": "Exchange and Add",
      "summary": "Exchanges dest and src, then loads sum into dest.",
      "syntax": "XADD r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F C1",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "xadd",
      "rel_url": "x86/xadd/",
      "operands": [],
      "linked_summary": "Exchanges dest <a href=\"../../armv8-a/and_6/\">and</a> src, then loads sum into dest.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmpxchg",
      "architecture": "x86",
      "full_name": "Compare and Exchange",
      "summary": "Compares accumulator with dest; if equal, dest = src; else accumulator = dest.",
      "syntax": "CMPXCHG r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F B1",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "cmpxchg",
      "rel_url": "x86/cmpxchg/",
      "operands": [],
      "linked_summary": "Compares accumulator with dest; if equal, dest = src; else accumulator = dest.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmovcc",
      "architecture": "x86",
      "full_name": "Conditional Move",
      "summary": "Moves data if condition code is met (e.g., CMOVE, CMOVNE).",
      "syntax": "CMOVcc r, r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 4x",
        "visual_parts": []
      },
      "extension": "CMOV",
      "slug": "cmovcc",
      "rel_url": "x86/cmovcc/",
      "operands": [],
      "linked_summary": "Moves data if condition code is met (e.g., CMOVE, CMOVNE).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "setcc",
      "architecture": "x86",
      "full_name": "Set Byte on Condition",
      "summary": "Sets byte to 1 if condition met, else 0 (e.g., SETE, SETZ).",
      "syntax": "SETcc r/m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 9x",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "setcc",
      "rel_url": "x86/setcc/",
      "operands": [],
      "linked_summary": "Sets byte to 1 if condition met, else 0 (e.g., SETE, SETZ).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "hlt",
      "architecture": "x86",
      "full_name": "Halt",
      "summary": "Stops instruction execution and places processor in HALT state.",
      "syntax": "HLT",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F4",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "hlt",
      "rel_url": "x86/hlt/",
      "operands": [],
      "linked_summary": "Stops instruction execution <a href=\"../../armv8-a/and_6/\">and</a> places processor <a href=\"../../x86/in/\">in</a> HALT state.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "int",
      "architecture": "x86",
      "full_name": "Interrupt",
      "summary": "Calls to interrupt procedure.",
      "syntax": "INT imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "CD",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "int",
      "rel_url": "x86/int/",
      "operands": [],
      "linked_summary": "Calls to interrupt procedure.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "int3",
      "architecture": "x86",
      "full_name": "Breakpoint",
      "summary": "Calls to interrupt vector 3 (Debugger breakpoint).",
      "syntax": "INT3",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "CC",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "int3",
      "rel_url": "x86/int3/",
      "operands": [],
      "linked_summary": "Calls to interrupt vector 3 (Debugger breakpoint).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ud2",
      "architecture": "x86",
      "full_name": "Undefined Instruction",
      "summary": "Generates an invalid opcode exception.",
      "syntax": "UD2",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 0B",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "ud2",
      "rel_url": "x86/ud2/",
      "operands": [],
      "linked_summary": "Generates an invalid opcode exception.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pause",
      "architecture": "x86",
      "full_name": "Spin Loop Hint",
      "summary": "Improves performance of spin-wait loops (alias for REP NOP).",
      "syntax": "PAUSE",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 90",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "pause",
      "rel_url": "x86/pause/",
      "operands": [],
      "linked_summary": "Improves performance of spin-<a href=\"../../powerisa/wait_1/\">wait</a> loops (alias for REP <a href=\"../../risc-v/nop/\">NOP</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "clc",
      "architecture": "x86",
      "full_name": "Clear Carry Flag",
      "summary": "Sets the CF flag to 0.",
      "syntax": "CLC",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F8",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "clc",
      "rel_url": "x86/clc/",
      "operands": [],
      "linked_summary": "Sets the CF flag to 0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stc",
      "architecture": "x86",
      "full_name": "Set Carry Flag",
      "summary": "Sets the CF flag to 1.",
      "syntax": "STC",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F9",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "stc",
      "rel_url": "x86/stc/",
      "operands": [],
      "linked_summary": "Sets the CF flag to 1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmc",
      "architecture": "x86",
      "full_name": "Complement Carry Flag",
      "summary": "Toggles the CF flag.",
      "syntax": "CMC",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F5",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "cmc",
      "rel_url": "x86/cmc/",
      "operands": [],
      "linked_summary": "Toggles the CF flag.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cld",
      "architecture": "x86",
      "full_name": "Clear Direction Flag",
      "summary": "Sets DF to 0 (String operations increment).",
      "syntax": "CLD",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "FC",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "cld",
      "rel_url": "x86/cld/",
      "operands": [],
      "linked_summary": "Sets DF to 0 (String operations increment).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "std",
      "architecture": "x86",
      "full_name": "Set Direction Flag",
      "summary": "Sets DF to 1 (String operations decrement).",
      "syntax": "STD",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "FD",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "std",
      "rel_url": "x86/std/",
      "operands": [],
      "linked_summary": "Sets DF to 1 (String operations decrement).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cli",
      "architecture": "x86",
      "full_name": "Clear Interrupt Flag",
      "summary": "Disables maskable hardware interrupts.",
      "syntax": "CLI",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "FA",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "cli",
      "rel_url": "x86/cli/",
      "operands": [],
      "linked_summary": "Disables maskable hardware interrupts.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sti",
      "architecture": "x86",
      "full_name": "Set Interrupt Flag",
      "summary": "Enables maskable hardware interrupts.",
      "syntax": "STI",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "FB",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "sti",
      "rel_url": "x86/sti/",
      "operands": [],
      "linked_summary": "Enables maskable hardware interrupts.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sahf",
      "architecture": "x86",
      "full_name": "Store AH into Flags",
      "summary": "Loads SF, ZF, AF, PF, and CF from AH.",
      "syntax": "SAHF",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "9E",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "sahf",
      "rel_url": "x86/sahf/",
      "operands": [],
      "linked_summary": "Loads SF, ZF, AF, PF, <a href=\"../../armv8-a/and_6/\">and</a> CF from AH.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lahf",
      "architecture": "x86",
      "full_name": "Load Flags into AH",
      "summary": "Loads bits 0, 2, 4, 6, and 7 of EFLAGS into AH.",
      "syntax": "LAHF",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "9F",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "lahf",
      "rel_url": "x86/lahf/",
      "operands": [],
      "linked_summary": "Loads bits 0, 2, 4, 6, <a href=\"../../armv8-a/and_6/\">and</a> 7 of EFLAGS into AH.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "loop",
      "architecture": "x86",
      "full_name": "Loop",
      "summary": "Decrements ECX/RCX and jumps if not zero.",
      "syntax": "LOOP rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "E2",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "loop",
      "rel_url": "x86/loop/",
      "operands": [],
      "linked_summary": "Decrements ECX/RCX <a href=\"../../armv8-a/and_6/\">and</a> jumps if <a href=\"../../armv8-a/not_1/\">not</a> <a href=\"../../armv9-a/zero_2/\">zero</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "loope",
      "architecture": "x86",
      "full_name": "Loop if Equal",
      "summary": "Decrements count; jumps if count!=0 and ZF=1.",
      "syntax": "LOOPE rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "E1",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "loope",
      "rel_url": "x86/loope/",
      "operands": [],
      "linked_summary": "Decrements count; jumps if count!=0 <a href=\"../../armv8-a/and_6/\">and</a> ZF=1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "loopne",
      "architecture": "x86",
      "full_name": "Loop if Not Equal",
      "summary": "Decrements count; jumps if count!=0 and ZF=0.",
      "syntax": "LOOPNE rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "E0",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "loopne",
      "rel_url": "x86/loopne/",
      "operands": [],
      "linked_summary": "Decrements count; jumps if count!=0 <a href=\"../../armv8-a/and_6/\">and</a> ZF=0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "jecxz",
      "architecture": "x86",
      "full_name": "Jump if ECX is Zero",
      "summary": "Jumps if ECX register is 0.",
      "syntax": "JECXZ rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "E3",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "jecxz",
      "rel_url": "x86/jecxz/",
      "operands": [],
      "linked_summary": "Jumps if ECX register is 0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "enter",
      "architecture": "x86",
      "full_name": "Make Stack Frame",
      "summary": "Creates a stack frame for procedure parameters.",
      "syntax": "ENTER imm16, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "C8",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "enter",
      "rel_url": "x86/enter/",
      "operands": [],
      "linked_summary": "Creates a stack frame for procedure parameters.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "leave",
      "architecture": "x86",
      "full_name": "High Level Procedure Exit",
      "summary": "Releases stack frame (MOV ESP, EBP; POP EBP).",
      "syntax": "LEAVE",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "C9",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "leave",
      "rel_url": "x86/leave/",
      "operands": [],
      "linked_summary": "Releases stack frame (<a href=\"../../armv9-a/mov/\">MOV</a> ESP, EBP; POP EBP).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rep movs",
      "architecture": "x86",
      "full_name": "Repeat Move String",
      "summary": "Moves ECX bytes/words from [ESI] to [EDI].",
      "syntax": "REP MOVS m, m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 A4/A5",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "rep_movs",
      "rel_url": "x86/rep_movs/",
      "operands": [],
      "linked_summary": "Moves ECX bytes/words from [ESI] to [EDI].",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rep stos",
      "architecture": "x86",
      "full_name": "Repeat Store String",
      "summary": "Fills [EDI] with AL/AX/EAX for ECX repeats.",
      "syntax": "REP STOS m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 AA/AB",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "rep_stos",
      "rel_url": "x86/rep_stos/",
      "operands": [],
      "linked_summary": "Fills [EDI] with AL/AX/EAX for ECX repeats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "repe cmps",
      "architecture": "x86",
      "full_name": "Repeat Compare String Equal",
      "summary": "Compares [ESI] and [EDI] until mismatch or ECX=0.",
      "syntax": "REPE CMPS m, m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 A6/A7",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "repe_cmps",
      "rel_url": "x86/repe_cmps/",
      "operands": [],
      "linked_summary": "Compares [ESI] <a href=\"../../armv8-a/and_6/\">and</a> [EDI] until mismatch <a href=\"../../powerisa/or/\">or</a> ECX=0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "repne scas",
      "architecture": "x86",
      "full_name": "Repeat Scan String Not Equal",
      "summary": "Scans [EDI] for AL/AX/EAX until match or ECX=0.",
      "syntax": "REPNE SCAS m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F2 AE/AF",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "repne_scas",
      "rel_url": "x86/repne_scas/",
      "operands": [],
      "linked_summary": "Scans [EDI] for AL/AX/EAX until <a href=\"../../armv9-a/match_2/\">match</a> <a href=\"../../powerisa/or/\">or</a> ECX=0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rol",
      "architecture": "x86",
      "full_name": "Rotate Left",
      "summary": "Rotates bits left.",
      "syntax": "ROL r/m, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "C1 /0",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "rol",
      "rel_url": "x86/rol/",
      "operands": [],
      "linked_summary": "Rotates bits left.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ror",
      "architecture": "x86",
      "full_name": "Rotate Right",
      "summary": "Rotates bits right.",
      "syntax": "ROR r/m, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "C1 /1",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "ror",
      "rel_url": "x86/ror/",
      "operands": [],
      "linked_summary": "Rotates bits right.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rcl",
      "architecture": "x86",
      "full_name": "Rotate Carry Left",
      "summary": "Rotates bits left through Carry Flag.",
      "syntax": "RCL r/m, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "C1 /2",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "rcl",
      "rel_url": "x86/rcl/",
      "operands": [],
      "linked_summary": "Rotates bits left through Carry Flag.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rcr",
      "architecture": "x86",
      "full_name": "Rotate Carry Right",
      "summary": "Rotates bits right through Carry Flag.",
      "syntax": "RCR r/m, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "C1 /3",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "rcr",
      "rel_url": "x86/rcr/",
      "operands": [],
      "linked_summary": "Rotates bits right through Carry Flag.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bt",
      "architecture": "x86",
      "full_name": "Bit Test",
      "summary": "Selects a bit and stores it in CF.",
      "syntax": "BT r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F A3",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "bt",
      "rel_url": "x86/bt/",
      "operands": [],
      "linked_summary": "Selects a <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../armv8-a/and_6/\">and</a> stores <a href=\"../../armv8-a/it/\">it</a> <a href=\"../../x86/in/\">in</a> CF.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bts",
      "architecture": "x86",
      "full_name": "Bit Test and Set",
      "summary": "Stores bit in CF and sets bit to 1.",
      "syntax": "BTS r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F AB",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "bts",
      "rel_url": "x86/bts/",
      "operands": [],
      "linked_summary": "Stores <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> CF <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../x86/sets/\">sets</a> <a href=\"../../armv8-a/bit/\">bit</a> to 1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "btr",
      "architecture": "x86",
      "full_name": "Bit Test and Reset",
      "summary": "Stores bit in CF and clears bit to 0.",
      "syntax": "BTR r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F B3",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "btr",
      "rel_url": "x86/btr/",
      "operands": [],
      "linked_summary": "Stores <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> CF <a href=\"../../armv8-a/and_6/\">and</a> clears <a href=\"../../armv8-a/bit/\">bit</a> to 0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "btc",
      "architecture": "x86",
      "full_name": "Bit Test and Complement",
      "summary": "Stores bit in CF and complements the bit.",
      "syntax": "BTC r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F BB",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "btc",
      "rel_url": "x86/btc/",
      "operands": [],
      "linked_summary": "Stores <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> CF <a href=\"../../armv8-a/and_6/\">and</a> complements the <a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bsf",
      "architecture": "x86",
      "full_name": "Bit Scan Forward",
      "summary": "Scans for LSB set to 1.",
      "syntax": "BSF r, r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F BC",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "bsf",
      "rel_url": "x86/bsf/",
      "operands": [],
      "linked_summary": "Scans for LSB set to 1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bsr",
      "architecture": "x86",
      "full_name": "Bit Scan Reverse",
      "summary": "Scans for MSB set to 1.",
      "syntax": "BSR r, r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F BD",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "bsr",
      "rel_url": "x86/bsr/",
      "operands": [],
      "linked_summary": "Scans for <a href=\"../../armv9-a/msb/\">MSB</a> set to 1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lzcnt",
      "architecture": "x86",
      "full_name": "Count Leading Zeros",
      "summary": "Counts number of leading zeros.",
      "syntax": "LZCNT r, r/m",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "F3 0F BD",
        "visual_parts": []
      },
      "extension": "ABM/BMI",
      "slug": "lzcnt",
      "rel_url": "x86/lzcnt/",
      "operands": [],
      "linked_summary": "Counts number of leading zeros.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "popcnt",
      "architecture": "x86",
      "full_name": "Population Count",
      "summary": "Counts number of bits set to 1.",
      "syntax": "POPCNT r, r/m",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "F3 0F B8",
        "visual_parts": []
      },
      "extension": "SSE4.2",
      "slug": "popcnt",
      "rel_url": "x86/popcnt/",
      "operands": [],
      "linked_summary": "Counts number of bits set to 1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xlat",
      "architecture": "x86",
      "full_name": "Table Look-up Translation",
      "summary": "Replaces AL with byte from table at [EBX+AL].",
      "syntax": "XLAT m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D7",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "xlat",
      "rel_url": "x86/xlat/",
      "operands": [],
      "linked_summary": "Replaces AL with byte from table <a href=\"../../armv8-a/at_2/\">at</a> [EBX+AL].",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pushf",
      "architecture": "x86",
      "full_name": "Push Flags",
      "summary": "Pushes EFLAGS onto stack.",
      "syntax": "PUSHF",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "9C",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "pushf",
      "rel_url": "x86/pushf/",
      "operands": [],
      "linked_summary": "Pushes EFLAGS onto stack.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "popf",
      "architecture": "x86",
      "full_name": "Pop Flags",
      "summary": "Pops stack into EFLAGS.",
      "syntax": "POPF",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "9D",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "popf",
      "rel_url": "x86/popf/",
      "operands": [],
      "linked_summary": "Pops stack into EFLAGS.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pusha",
      "architecture": "x86",
      "full_name": "Push All General-Purpose Registers",
      "summary": "Pushes AX, CX, DX, BX, SP, BP, SI, DI (Invalid in 64-bit).",
      "syntax": "PUSHA",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "60",
        "visual_parts": []
      },
      "extension": "Base (32-bit only)",
      "slug": "pusha",
      "rel_url": "x86/pusha/",
      "operands": [],
      "linked_summary": "Pushes AX, CX, DX, BX, SP, BP, SI, DI (Invalid <a href=\"../../x86/in/\">in</a> 64-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "popa",
      "architecture": "x86",
      "full_name": "Pop All General-Purpose Registers",
      "summary": "Pops into DI, SI, BP, SP, BX, DX, CX, AX (Invalid in 64-bit).",
      "syntax": "POPA",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "61",
        "visual_parts": []
      },
      "extension": "Base (32-bit only)",
      "slug": "popa",
      "rel_url": "x86/popa/",
      "operands": [],
      "linked_summary": "Pops into DI, SI, BP, SP, BX, DX, CX, AX (Invalid <a href=\"../../x86/in/\">in</a> 64-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bound",
      "architecture": "x86",
      "full_name": "Check Array Index Against Bounds",
      "summary": "Checks if operand is within bounds defined in memory.",
      "syntax": "BOUND r, m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "62",
        "visual_parts": []
      },
      "extension": "Base (32-bit only)",
      "slug": "bound",
      "rel_url": "x86/bound/",
      "operands": [],
      "linked_summary": "Checks if operand is within bounds defined <a href=\"../../x86/in/\">in</a> memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aaa",
      "architecture": "x86",
      "full_name": "ASCII Adjust After Addition",
      "summary": "Adjusts AL after addition for unpacked BCD.",
      "syntax": "AAA",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "37",
        "visual_parts": []
      },
      "extension": "Base (Legacy)",
      "slug": "aaa",
      "rel_url": "x86/aaa/",
      "operands": [],
      "linked_summary": "Adjusts AL after addition for unpacked BCD.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aas",
      "architecture": "x86",
      "full_name": "ASCII Adjust After Subtraction",
      "summary": "Adjusts AL after subtraction for unpacked BCD.",
      "syntax": "AAS",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "3F",
        "visual_parts": []
      },
      "extension": "Base (Legacy)",
      "slug": "aas",
      "rel_url": "x86/aas/",
      "operands": [],
      "linked_summary": "Adjusts AL after subtraction for unpacked BCD.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "daa",
      "architecture": "x86",
      "full_name": "Decimal Adjust After Addition",
      "summary": "Adjusts AL after addition for packed BCD.",
      "syntax": "DAA",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "27",
        "visual_parts": []
      },
      "extension": "Base (Legacy)",
      "slug": "daa",
      "rel_url": "x86/daa/",
      "operands": [],
      "linked_summary": "Adjusts AL after addition for packed BCD.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "das",
      "architecture": "x86",
      "full_name": "Decimal Adjust After Subtraction",
      "summary": "Adjusts AL after subtraction for packed BCD.",
      "syntax": "DAS",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "2F",
        "visual_parts": []
      },
      "extension": "Base (Legacy)",
      "slug": "das",
      "rel_url": "x86/das/",
      "operands": [],
      "linked_summary": "Adjusts AL after subtraction for packed BCD.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aam",
      "architecture": "x86",
      "full_name": "ASCII Adjust After Multiply",
      "summary": "Adjusts AX after multiply for unpacked BCD.",
      "syntax": "AAM imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D4",
        "visual_parts": []
      },
      "extension": "Base (Legacy)",
      "slug": "aam",
      "rel_url": "x86/aam/",
      "operands": [],
      "linked_summary": "Adjusts AX after multiply for unpacked BCD.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aad",
      "architecture": "x86",
      "full_name": "ASCII Adjust Before Division",
      "summary": "Adjusts AX before division for unpacked BCD.",
      "syntax": "AAD imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D5",
        "visual_parts": []
      },
      "extension": "Base (Legacy)",
      "slug": "aad",
      "rel_url": "x86/aad/",
      "operands": [],
      "linked_summary": "Adjusts AX before division for unpacked BCD.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cbw",
      "architecture": "x86",
      "full_name": "Convert Byte to Word",
      "summary": "Sign-extends AL into AX.",
      "syntax": "CBW",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "98",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "cbw",
      "rel_url": "x86/cbw/",
      "operands": [],
      "linked_summary": "Sign-extends AL into AX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cwd",
      "architecture": "x86",
      "full_name": "Convert Word to Doubleword",
      "summary": "Sign-extends AX into DX:AX.",
      "syntax": "CWD",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "99",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "cwd",
      "rel_url": "x86/cwd/",
      "operands": [],
      "linked_summary": "Sign-extends AX into DX:AX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "wait",
      "architecture": "x86",
      "full_name": "Wait",
      "summary": "Wait for FPU (same as FWAIT).",
      "syntax": "WAIT",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "9B",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "wait",
      "rel_url": "x86/wait/",
      "operands": [],
      "linked_summary": "Wait for FPU (same as FWAIT).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ldtilecfg",
      "architecture": "x86",
      "full_name": "Load Tile Configuration",
      "summary": "Loads AMX tile configuration from memory.",
      "syntax": "LDTILECFG m512",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 49",
        "visual_parts": []
      },
      "extension": "AMX-TILE",
      "slug": "ldtilecfg",
      "rel_url": "x86/ldtilecfg/",
      "operands": [],
      "linked_summary": "Loads AMX tile configuration from memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sttilecfg",
      "architecture": "x86",
      "full_name": "Store Tile Configuration",
      "summary": "Stores AMX tile configuration to memory.",
      "syntax": "STTILECFG m512",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 49",
        "visual_parts": []
      },
      "extension": "AMX-TILE",
      "slug": "sttilecfg",
      "rel_url": "x86/sttilecfg/",
      "operands": [],
      "linked_summary": "Stores AMX tile configuration to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tileloadd",
      "architecture": "x86",
      "full_name": "Load Tile Data",
      "summary": "Loads data into an AMX tile register.",
      "syntax": "TILELOADD tmm1, m",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 4B",
        "visual_parts": []
      },
      "extension": "AMX-TILE",
      "slug": "tileloadd",
      "rel_url": "x86/tileloadd/",
      "operands": [],
      "linked_summary": "Loads data into an AMX tile register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tilestored",
      "architecture": "x86",
      "full_name": "Store Tile Data",
      "summary": "Stores data from an AMX tile register to memory.",
      "syntax": "TILESTORED m, tmm1",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 4B",
        "visual_parts": []
      },
      "extension": "AMX-TILE",
      "slug": "tilestored",
      "rel_url": "x86/tilestored/",
      "operands": [],
      "linked_summary": "Stores data from an AMX tile register to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tilezero",
      "architecture": "x86",
      "full_name": "Zero Tile",
      "summary": "Clears an AMX tile register.",
      "syntax": "TILEZERO tmm1",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 49",
        "visual_parts": []
      },
      "extension": "AMX-TILE",
      "slug": "tilezero",
      "rel_url": "x86/tilezero/",
      "operands": [],
      "linked_summary": "Clears an AMX tile register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tdpbssd",
      "architecture": "x86",
      "full_name": "Tile Dot Product Byte Signed Signed Doubleword",
      "summary": "Matrix multiply (Signed Int8 * Signed Int8) accumulating to Int32.",
      "syntax": "TDPBSSD tmm1, tmm2, tmm3",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 5E",
        "visual_parts": []
      },
      "extension": "AMX-INT8",
      "slug": "tdpbssd",
      "rel_url": "x86/tdpbssd/",
      "operands": [],
      "linked_summary": "Matrix multiply (Signed Int8 * Signed Int8) accumulating to Int32.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tdpbsud",
      "architecture": "x86",
      "full_name": "Tile Dot Product Byte Signed Unsigned Doubleword",
      "summary": "Matrix multiply (Signed * Unsigned) accumulating to Int32.",
      "syntax": "TDPBSUD tmm1, tmm2, tmm3",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 5E",
        "visual_parts": []
      },
      "extension": "AMX-INT8",
      "slug": "tdpbsud",
      "rel_url": "x86/tdpbsud/",
      "operands": [],
      "linked_summary": "Matrix multiply (Signed * Unsigned) accumulating to Int32.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tdpbf16ps",
      "architecture": "x86",
      "full_name": "Tile Dot Product BFloat16 Packed Single",
      "summary": "Matrix multiply (BFloat16) accumulating to Float32.",
      "syntax": "TDPBF16PS tmm1, tmm2, tmm3",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 5C",
        "visual_parts": []
      },
      "extension": "AMX-BF16",
      "slug": "tdpbf16ps",
      "rel_url": "x86/tdpbf16ps/",
      "operands": [],
      "linked_summary": "Matrix multiply (BFloat16) accumulating to Float32.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "endbr64",
      "architecture": "x86",
      "full_name": "End Branch 64-bit",
      "summary": "Marker instruction for Indirect Branch Tracking (IBT).",
      "syntax": "ENDBR64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 1E FA",
        "visual_parts": []
      },
      "extension": "CET-IBT",
      "slug": "endbr64",
      "rel_url": "x86/endbr64/",
      "operands": [],
      "linked_summary": "Marker instruction for Indirect Branch Tracking (IBT).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "endbr32",
      "architecture": "x86",
      "full_name": "End Branch 32-bit",
      "summary": "Marker instruction for Indirect Branch Tracking (IBT).",
      "syntax": "ENDBR32",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 1E FB",
        "visual_parts": []
      },
      "extension": "CET-IBT",
      "slug": "endbr32",
      "rel_url": "x86/endbr32/",
      "operands": [],
      "linked_summary": "Marker instruction for Indirect Branch Tracking (IBT).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rdsspq",
      "architecture": "x86",
      "full_name": "Read Shadow Stack Pointer (Quadword)",
      "summary": "Reads the current shadow stack pointer into a register.",
      "syntax": "RDSSPQ r64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 1E /1",
        "visual_parts": []
      },
      "extension": "CET-SS",
      "slug": "rdsspq",
      "rel_url": "x86/rdsspq/",
      "operands": [],
      "linked_summary": "Reads the current shadow stack pointer into a register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "incsspq",
      "architecture": "x86",
      "full_name": "Increment Shadow Stack Pointer (Quadword)",
      "summary": "Adjusts the shadow stack pointer.",
      "syntax": "INCSSPQ r64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F AE /5",
        "visual_parts": []
      },
      "extension": "CET-SS",
      "slug": "incsspq",
      "rel_url": "x86/incsspq/",
      "operands": [],
      "linked_summary": "Adjusts the shadow stack pointer.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rstorssp",
      "architecture": "x86",
      "full_name": "Restore Shadow Stack Pointer",
      "summary": "Restores SSP from memory token.",
      "syntax": "RSTORSSP m64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 01 /5",
        "visual_parts": []
      },
      "extension": "CET-SS",
      "slug": "rstorssp",
      "rel_url": "x86/rstorssp/",
      "operands": [],
      "linked_summary": "Restores SSP from memory token.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "saveprevssp",
      "architecture": "x86",
      "full_name": "Save Previous Shadow Stack Pointer",
      "summary": "Saves the previous SSP to the shadow stack token.",
      "syntax": "SAVEPREVSSP",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 01 EA",
        "visual_parts": []
      },
      "extension": "CET-SS",
      "slug": "saveprevssp",
      "rel_url": "x86/saveprevssp/",
      "operands": [],
      "linked_summary": "Saves the previous SSP to the shadow stack token.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "clwb",
      "architecture": "x86",
      "full_name": "Cache Line Write Back",
      "summary": "Writes back modified cache line without flushing (Persistent Memory).",
      "syntax": "CLWB m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "66 0F AE /6",
        "visual_parts": []
      },
      "extension": "CLWB",
      "slug": "clwb",
      "rel_url": "x86/clwb/",
      "operands": [],
      "linked_summary": "Writes back modified cache line without flushing (Persistent Memory).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "clflushopt",
      "architecture": "x86",
      "full_name": "Optimized Cache Line Flush",
      "summary": "Optimized version of CLFLUSH (Higher throughput).",
      "syntax": "CLFLUSHOPT m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "66 0F AE /7",
        "visual_parts": []
      },
      "extension": "CLFLUSHOPT",
      "slug": "clflushopt",
      "rel_url": "x86/clflushopt/",
      "operands": [],
      "linked_summary": "Optimized version of CLFLUSH (Higher throughput).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cldemote",
      "architecture": "x86",
      "full_name": "Cache Line Demote",
      "summary": "Hints to move cache line to lower cache level.",
      "syntax": "CLDEMOTE m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 1C /0",
        "visual_parts": []
      },
      "extension": "CLDEMOTE",
      "slug": "cldemote",
      "rel_url": "x86/cldemote/",
      "operands": [],
      "linked_summary": "Hints to move cache line to lower cache level.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movdiri",
      "architecture": "x86",
      "full_name": "Move Direct Store Integer",
      "summary": "Moves 32/64-bit data avoiding cache pollution (Direct IO).",
      "syntax": "MOVDIRI m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 38 F9",
        "visual_parts": []
      },
      "extension": "MOVDIRI",
      "slug": "movdiri",
      "rel_url": "x86/movdiri/",
      "operands": [],
      "linked_summary": "Moves 32/64-<a href=\"../../armv8-a/bit/\">bit</a> data avoiding cache pollution (Direct IO).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movdir64b",
      "architecture": "x86",
      "full_name": "Move Direct Store 64-Bytes",
      "summary": "Atomically moves 64-byte block avoiding cache pollution.",
      "syntax": "MOVDIR64B m512, m512",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "66 0F 38 F8",
        "visual_parts": []
      },
      "extension": "MOVDIR64B",
      "slug": "movdir64b",
      "rel_url": "x86/movdir64b/",
      "operands": [],
      "linked_summary": "Atomically moves 64-byte block avoiding cache pollution.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xbegin",
      "architecture": "x86",
      "full_name": "Transaction Begin",
      "summary": "Specifies start of Restricted Transactional Memory region.",
      "syntax": "XBEGIN rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "C7 F8",
        "visual_parts": []
      },
      "extension": "RTM (TSX)",
      "slug": "xbegin",
      "rel_url": "x86/xbegin/",
      "operands": [],
      "linked_summary": "Specifies start of Restricted Transactional Memory region.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xend",
      "architecture": "x86",
      "full_name": "Transaction End",
      "summary": "Specifies end of RTM region.",
      "syntax": "XEND",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 D5",
        "visual_parts": []
      },
      "extension": "RTM (TSX)",
      "slug": "xend",
      "rel_url": "x86/xend/",
      "operands": [],
      "linked_summary": "Specifies end of RTM region.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xabort",
      "architecture": "x86",
      "full_name": "Transaction Abort",
      "summary": "Forces an RTM abort.",
      "syntax": "XABORT imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "C6 F8",
        "visual_parts": []
      },
      "extension": "RTM (TSX)",
      "slug": "xabort",
      "rel_url": "x86/xabort/",
      "operands": [],
      "linked_summary": "Forces an RTM abort.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xtest",
      "architecture": "x86",
      "full_name": "Test If In Transaction",
      "summary": "Sets ZF if processor is in transactional region.",
      "syntax": "XTEST",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 D6",
        "visual_parts": []
      },
      "extension": "TSX",
      "slug": "xtest",
      "rel_url": "x86/xtest/",
      "operands": [],
      "linked_summary": "Sets ZF if processor is <a href=\"../../x86/in/\">in</a> transactional region.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "umonitor",
      "architecture": "x86",
      "full_name": "User Level Monitor",
      "summary": "Sets up a monitor address for User Wait instructions.",
      "syntax": "UMONITOR r64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F AE /6",
        "visual_parts": []
      },
      "extension": "WAITPKG",
      "slug": "umonitor",
      "rel_url": "x86/umonitor/",
      "operands": [],
      "linked_summary": "Sets up a <a href=\"../../x86/monitor/\">monitor</a> address for User Wait instructions.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "umwait",
      "architecture": "x86",
      "full_name": "User Level Monitor Wait",
      "summary": "Waits for store to monitored address (Low power state).",
      "syntax": "UMWAIT r32",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F2 0F AE /6",
        "visual_parts": []
      },
      "extension": "WAITPKG",
      "slug": "umwait",
      "rel_url": "x86/umwait/",
      "operands": [],
      "linked_summary": "Waits for store to monitored address (Low power state).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tpause",
      "architecture": "x86",
      "full_name": "Timed Pause",
      "summary": "Pauses execution for a specified time or until trigger.",
      "syntax": "TPAUSE r32",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "66 0F AE /6",
        "visual_parts": []
      },
      "extension": "WAITPKG",
      "slug": "tpause",
      "rel_url": "x86/tpause/",
      "operands": [],
      "linked_summary": "Pauses execution for a specified time <a href=\"../../powerisa/or/\">or</a> until trigger.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vaddph",
      "architecture": "x86",
      "full_name": "Add Packed FP16 Values",
      "summary": "Adds half-precision floating-point values.",
      "syntax": "VADDPH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "58",
        "visual_parts": []
      },
      "extension": "AVX512-FP16",
      "slug": "vaddph",
      "rel_url": "x86/vaddph/",
      "operands": [],
      "linked_summary": "Adds half-precision floating-point values.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsubph",
      "architecture": "x86",
      "full_name": "Subtract Packed FP16 Values",
      "summary": "Subtracts half-precision floating-point values.",
      "syntax": "VSUBPH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "5C",
        "visual_parts": []
      },
      "extension": "AVX512-FP16",
      "slug": "vsubph",
      "rel_url": "x86/vsubph/",
      "operands": [],
      "linked_summary": "Subtracts half-precision floating-point values.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmulph",
      "architecture": "x86",
      "full_name": "Multiply Packed FP16 Values",
      "summary": "Multiplies half-precision floating-point values.",
      "syntax": "VMULPH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "59",
        "visual_parts": []
      },
      "extension": "AVX512-FP16",
      "slug": "vmulph",
      "rel_url": "x86/vmulph/",
      "operands": [],
      "linked_summary": "Multiplies half-precision floating-point values.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vdivph",
      "architecture": "x86",
      "full_name": "Divide Packed FP16 Values",
      "summary": "Divides half-precision floating-point values.",
      "syntax": "VDIVPH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "5E",
        "visual_parts": []
      },
      "extension": "AVX512-FP16",
      "slug": "vdivph",
      "rel_url": "x86/vdivph/",
      "operands": [],
      "linked_summary": "Divides half-precision floating-point values.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsqrtph",
      "architecture": "x86",
      "full_name": "Square Root Packed FP16 Values",
      "summary": "Square root of half-precision values.",
      "syntax": "VSQRTPH zmm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "51",
        "visual_parts": []
      },
      "extension": "AVX512-FP16",
      "slug": "vsqrtph",
      "rel_url": "x86/vsqrtph/",
      "operands": [],
      "linked_summary": "Square root of half-precision values.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vminph",
      "architecture": "x86",
      "full_name": "Minimum Packed FP16 Values",
      "summary": "Minimum of half-precision values.",
      "syntax": "VMINPH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "5D",
        "visual_parts": []
      },
      "extension": "AVX512-FP16",
      "slug": "vminph",
      "rel_url": "x86/vminph/",
      "operands": [],
      "linked_summary": "Minimum of half-precision values.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmaxph",
      "architecture": "x86",
      "full_name": "Maximum Packed FP16 Values",
      "summary": "Maximum of half-precision values.",
      "syntax": "VMAXPH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "5F",
        "visual_parts": []
      },
      "extension": "AVX512-FP16",
      "slug": "vmaxph",
      "rel_url": "x86/vmaxph/",
      "operands": [],
      "linked_summary": "Maximum of half-precision values.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfmadd132ph",
      "architecture": "x86",
      "full_name": "Fused Multiply-Add (132) Packed FP16",
      "summary": "Computes (Dest * Src2) + Src1 in half-precision.",
      "syntax": "VFMADD132PH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "98",
        "visual_parts": []
      },
      "extension": "AVX512-FP16",
      "slug": "vfmadd132ph",
      "rel_url": "x86/vfmadd132ph/",
      "operands": [],
      "linked_summary": "Computes (Dest * Src2) + Src1 <a href=\"../../x86/in/\">in</a> half-precision.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfmadd213ph",
      "architecture": "x86",
      "full_name": "Fused Multiply-Add (213) Packed FP16",
      "summary": "Computes (Src1 * Dest) + Src2 in half-precision.",
      "syntax": "VFMADD213PH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "A8",
        "visual_parts": []
      },
      "extension": "AVX512-FP16",
      "slug": "vfmadd213ph",
      "rel_url": "x86/vfmadd213ph/",
      "operands": [],
      "linked_summary": "Computes (Src1 * Dest) + Src2 <a href=\"../../x86/in/\">in</a> half-precision.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfmadd231ph",
      "architecture": "x86",
      "full_name": "Fused Multiply-Add (231) Packed FP16",
      "summary": "Computes (Src1 * Src2) + Dest in half-precision.",
      "syntax": "VFMADD231PH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "B8",
        "visual_parts": []
      },
      "extension": "AVX512-FP16",
      "slug": "vfmadd231ph",
      "rel_url": "x86/vfmadd231ph/",
      "operands": [],
      "linked_summary": "Computes (Src1 * Src2) + Dest <a href=\"../../x86/in/\">in</a> half-precision.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcvtne2ps2bf16",
      "architecture": "x86",
      "full_name": "Convert Two Packed Single to Packed BFloat16",
      "summary": "Converts two float vectors to one BFloat16 vector.",
      "syntax": "VCVTNE2PS2BF16 zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "72",
        "visual_parts": []
      },
      "extension": "AVX512-BF16",
      "slug": "vcvtne2ps2bf16",
      "rel_url": "x86/vcvtne2ps2bf16/",
      "operands": [],
      "linked_summary": "Converts two float vectors to one BFloat16 vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vdpbf16ps",
      "architecture": "x86",
      "full_name": "Dot Product BFloat16 to Packed Single",
      "summary": "BFloat16 dot product accumulating to Float32.",
      "syntax": "VDPBF16PS zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "52",
        "visual_parts": []
      },
      "extension": "AVX512-BF16",
      "slug": "vdpbf16ps",
      "rel_url": "x86/vdpbf16ps/",
      "operands": [],
      "linked_summary": "BFloat16 dot product accumulating to Float32.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vaesenc",
      "architecture": "x86",
      "full_name": "Vector AES Encrypt (AVX512)",
      "summary": "AES Encrypt on 512-bit vector.",
      "syntax": "VAESENC zmm1, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "DC",
        "visual_parts": []
      },
      "extension": "AVX512-VAES",
      "slug": "vaesenc",
      "rel_url": "x86/vaesenc/",
      "operands": [],
      "linked_summary": "AES Encrypt on 512-<a href=\"../../armv8-a/bit/\">bit</a> vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vaesdec",
      "architecture": "x86",
      "full_name": "Vector AES Decrypt (AVX512)",
      "summary": "AES Decrypt on 512-bit vector.",
      "syntax": "VAESDEC zmm1, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "DE",
        "visual_parts": []
      },
      "extension": "AVX512-VAES",
      "slug": "vaesdec",
      "rel_url": "x86/vaesdec/",
      "operands": [],
      "linked_summary": "AES Decrypt on 512-<a href=\"../../armv8-a/bit/\">bit</a> vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpclmulqdq",
      "architecture": "x86",
      "full_name": "Vector Carry-Less Multiplication (AVX512)",
      "summary": "Carry-less multiply on 512-bit vector.",
      "syntax": "VPCLMULQDQ zmm1, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "44",
        "visual_parts": []
      },
      "extension": "AVX512-VPCLMULQDQ",
      "slug": "vpclmulqdq",
      "rel_url": "x86/vpclmulqdq/",
      "operands": [],
      "linked_summary": "Carry-less multiply on 512-<a href=\"../../armv8-a/bit/\">bit</a> vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsha512msg1",
      "architecture": "x86",
      "full_name": "SHA512 Message Schedule 1",
      "summary": "SHA512 intermediate calculation (AVX512).",
      "syntax": "VSHA512MSG1 ymm1, xmm2",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "CC",
        "visual_parts": []
      },
      "extension": "SHA512",
      "slug": "vsha512msg1",
      "rel_url": "x86/vsha512msg1/",
      "operands": [],
      "linked_summary": "SHA512 intermediate calculation (AVX512).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsha512msg2",
      "architecture": "x86",
      "full_name": "SHA512 Message Schedule 2",
      "summary": "SHA512 final calculation (AVX512).",
      "syntax": "VSHA512MSG2 ymm1, ymm2",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "CD",
        "visual_parts": []
      },
      "extension": "SHA512",
      "slug": "vsha512msg2",
      "rel_url": "x86/vsha512msg2/",
      "operands": [],
      "linked_summary": "SHA512 final calculation (AVX512).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsha512rnds2",
      "architecture": "x86",
      "full_name": "SHA512 Rounds 2",
      "summary": "SHA512 2 rounds calculation (AVX512).",
      "syntax": "VSHA512RNDS2 ymm1, ymm2, xmm3",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "CB",
        "visual_parts": []
      },
      "extension": "SHA512",
      "slug": "vsha512rnds2",
      "rel_url": "x86/vsha512rnds2/",
      "operands": [],
      "linked_summary": "SHA512 2 rounds calculation (AVX512).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsm3msg1",
      "architecture": "x86",
      "full_name": "SM3 Message Schedule 1",
      "summary": "SM3 crypto message schedule part 1.",
      "syntax": "VSM3MSG1 xmm1, xmm2, xmm3",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "DA",
        "visual_parts": []
      },
      "extension": "SM3",
      "slug": "vsm3msg1",
      "rel_url": "x86/vsm3msg1/",
      "operands": [],
      "linked_summary": "SM3 crypto message schedule part 1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsm3rnds2",
      "architecture": "x86",
      "full_name": "SM3 Rounds 2",
      "summary": "SM3 crypto 2 rounds.",
      "syntax": "VSM3RNDS2 xmm1, xmm2, imm8",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "DE",
        "visual_parts": []
      },
      "extension": "SM3",
      "slug": "vsm3rnds2",
      "rel_url": "x86/vsm3rnds2/",
      "operands": [],
      "linked_summary": "SM3 crypto 2 rounds.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsm4e",
      "architecture": "x86",
      "full_name": "SM4 Encrypt",
      "summary": "SM4 crypto encryption round.",
      "syntax": "VSM4E xmm1, xmm2",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "DA",
        "visual_parts": []
      },
      "extension": "SM4",
      "slug": "vsm4e",
      "rel_url": "x86/vsm4e/",
      "operands": [],
      "linked_summary": "SM4 crypto encryption round.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsm4key4",
      "architecture": "x86",
      "full_name": "SM4 Key Generation",
      "summary": "SM4 key generation.",
      "syntax": "VSM4KEY4 xmm1, xmm2",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "DA",
        "visual_parts": []
      },
      "extension": "SM4",
      "slug": "vsm4key4",
      "rel_url": "x86/vsm4key4/",
      "operands": [],
      "linked_summary": "SM4 key generation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "loadiwkey",
      "architecture": "x86",
      "full_name": "Load Internal Wrapping Key",
      "summary": "Loads the Key Locker internal wrapping key.",
      "syntax": "LOADIWKEY xmm1, xmm2",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 38 DC",
        "visual_parts": []
      },
      "extension": "KEYLOCKER",
      "slug": "loadiwkey",
      "rel_url": "x86/loadiwkey/",
      "operands": [],
      "linked_summary": "Loads the Key Locker internal wrapping key.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "encodekey128",
      "architecture": "x86",
      "full_name": "Encode 128-bit Key",
      "summary": "Wraps a 128-bit AES key into a handle.",
      "syntax": "ENCODEKEY128 r32, r32",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 38 FA",
        "visual_parts": []
      },
      "extension": "KEYLOCKER",
      "slug": "encodekey128",
      "rel_url": "x86/encodekey128/",
      "operands": [],
      "linked_summary": "Wraps a 128-<a href=\"../../armv8-a/bit/\">bit</a> AES key into a handle.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aesenc128kl",
      "architecture": "x86",
      "full_name": "AES Encrypt 128-bit Key Locker",
      "summary": "Encrypts data using Key Locker handle.",
      "syntax": "AESENC128KL m128, xmm",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 38 DD",
        "visual_parts": []
      },
      "extension": "KEYLOCKER",
      "slug": "aesenc128kl",
      "rel_url": "x86/aesenc128kl/",
      "operands": [],
      "linked_summary": "Encrypts data using Key Locker handle.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aesdec128kl",
      "architecture": "x86",
      "full_name": "AES Decrypt 128-bit Key Locker",
      "summary": "Decrypts data using Key Locker handle.",
      "syntax": "AESDEC128KL m128, xmm",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 38 DE",
        "visual_parts": []
      },
      "extension": "KEYLOCKER",
      "slug": "aesdec128kl",
      "rel_url": "x86/aesdec128kl/",
      "operands": [],
      "linked_summary": "Decrypts data using Key Locker handle.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "hreset",
      "architecture": "x86",
      "full_name": "History Reset",
      "summary": "Resets processor history (prediction) structures.",
      "syntax": "HRESET imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 3A F0",
        "visual_parts": []
      },
      "extension": "HRESET",
      "slug": "hreset",
      "rel_url": "x86/hreset/",
      "operands": [],
      "linked_summary": "Resets processor history (prediction) structures.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "serialize",
      "architecture": "x86",
      "full_name": "Serialize Instruction Execution",
      "summary": "Forces serialization of instruction fetch/execution.",
      "syntax": "SERIALIZE",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 E8",
        "visual_parts": []
      },
      "extension": "SERIALIZE",
      "slug": "serialize",
      "rel_url": "x86/serialize/",
      "operands": [],
      "linked_summary": "Forces serialization of instruction fetch/execution.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rdpid",
      "architecture": "x86",
      "full_name": "Read Processor ID",
      "summary": "Reads the processor ID (TSC_AUX) into register.",
      "syntax": "RDPID r32",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F C7 /7",
        "visual_parts": []
      },
      "extension": "RDPID",
      "slug": "rdpid",
      "rel_url": "x86/rdpid/",
      "operands": [],
      "linked_summary": "Reads the processor ID (TSC_AUX) into register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsaves",
      "architecture": "x86",
      "full_name": "Save Supervisor States",
      "summary": "Saves supervisor state components to memory (Compact).",
      "syntax": "XSAVES m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F C7 /5",
        "visual_parts": []
      },
      "extension": "XSAVES",
      "slug": "xsaves",
      "rel_url": "x86/xsaves/",
      "operands": [],
      "linked_summary": "Saves supervisor state components to memory (Compact).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xrstors",
      "architecture": "x86",
      "full_name": "Restore Supervisor States",
      "summary": "Restores supervisor state components from memory (Compact).",
      "syntax": "XRSTORS m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F C7 /3",
        "visual_parts": []
      },
      "extension": "XSAVES",
      "slug": "xrstors",
      "rel_url": "x86/xrstors/",
      "operands": [],
      "linked_summary": "Restores supervisor state components from memory (Compact).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ptwrite",
      "architecture": "x86",
      "full_name": "Write Data to Processor Trace",
      "summary": "Writes data to the Intel Processor Trace stream.",
      "syntax": "PTWRITE r32/r64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F AE /4",
        "visual_parts": []
      },
      "extension": "PTWRITE",
      "slug": "ptwrite",
      "rel_url": "x86/ptwrite/",
      "operands": [],
      "linked_summary": "Writes data to the Intel Processor Trace stream.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "uiret",
      "architecture": "x86",
      "full_name": "User Interrupt Return",
      "summary": "Returns from a User Interrupt handler.",
      "syntax": "UIRET",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 01 EC",
        "visual_parts": []
      },
      "extension": "UINTR",
      "slug": "uiret",
      "rel_url": "x86/uiret/",
      "operands": [],
      "linked_summary": "Returns from a User Interrupt handler.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "senduipi",
      "architecture": "x86",
      "full_name": "Send User Inter-Processor Interrupt",
      "summary": "Sends a User IPI to another processor.",
      "syntax": "SENDUIPI r64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F C7 /6",
        "visual_parts": []
      },
      "extension": "UINTR",
      "slug": "senduipi",
      "rel_url": "x86/senduipi/",
      "operands": [],
      "linked_summary": "Sends a User IPI to another processor.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "in",
      "architecture": "x86",
      "full_name": "Input from Port",
      "summary": "Reads data from an I/O port into AL/AX/EAX.",
      "syntax": "IN AL, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "E4",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "in",
      "rel_url": "x86/in/",
      "operands": [],
      "linked_summary": "Reads data from an I/O port into AL/AX/EAX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "out",
      "architecture": "x86",
      "full_name": "Output to Port",
      "summary": "Writes data from AL/AX/EAX to an I/O port.",
      "syntax": "OUT imm8, AL",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "E6",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "out",
      "rel_url": "x86/out/",
      "operands": [],
      "linked_summary": "Writes data from AL/AX/EAX to an I/O port.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ins",
      "architecture": "x86",
      "full_name": "Input String from Port",
      "summary": "Reads string from I/O port to memory at [EDI].",
      "syntax": "INSB",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "6C",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "ins",
      "rel_url": "x86/ins/",
      "operands": [],
      "linked_summary": "Reads string from I/O port to memory <a href=\"../../armv8-a/at_2/\">at</a> [EDI].",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "outs",
      "architecture": "x86",
      "full_name": "Output String to Port",
      "summary": "Writes string from memory at [ESI] to I/O port.",
      "syntax": "OUTSB",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "6E",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "outs",
      "rel_url": "x86/outs/",
      "operands": [],
      "linked_summary": "Writes string from memory <a href=\"../../armv8-a/at_2/\">at</a> [ESI] to I/O port.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lods",
      "architecture": "x86",
      "full_name": "Load String",
      "summary": "Loads byte/word/dword from [ESI] into AL/AX/EAX.",
      "syntax": "LODSB",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "AC",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "lods",
      "rel_url": "x86/lods/",
      "operands": [],
      "linked_summary": "Loads byte/word/dword from [ESI] into AL/AX/EAX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stos",
      "architecture": "x86",
      "full_name": "Store String",
      "summary": "Stores AL/AX/EAX to memory at [EDI].",
      "syntax": "STOSB",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "AA",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "stos",
      "rel_url": "x86/stos/",
      "operands": [],
      "linked_summary": "Stores AL/AX/EAX to memory <a href=\"../../armv8-a/at_2/\">at</a> [EDI].",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "scas",
      "architecture": "x86",
      "full_name": "Scan String",
      "summary": "Compares AL/AX/EAX with memory at [EDI].",
      "syntax": "SCASB",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "AE",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "scas",
      "rel_url": "x86/scas/",
      "operands": [],
      "linked_summary": "Compares AL/AX/EAX with memory <a href=\"../../armv8-a/at_2/\">at</a> [EDI].",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmps",
      "architecture": "x86",
      "full_name": "Compare String",
      "summary": "Compares byte/word at [ESI] with [EDI].",
      "syntax": "CMPSB",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "A6",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "cmps",
      "rel_url": "x86/cmps/",
      "operands": [],
      "linked_summary": "Compares byte/word <a href=\"../../armv8-a/at_2/\">at</a> [ESI] with [EDI].",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lds",
      "architecture": "x86",
      "full_name": "Load Far Pointer using DS",
      "summary": "Loads pointer into DS and register.",
      "syntax": "LDS r, m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "C5",
        "visual_parts": []
      },
      "extension": "Base (Legacy)",
      "slug": "lds",
      "rel_url": "x86/lds/",
      "operands": [],
      "linked_summary": "Loads pointer into DS <a href=\"../../armv8-a/and_6/\">and</a> register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "les",
      "architecture": "x86",
      "full_name": "Load Far Pointer using ES",
      "summary": "Loads pointer into ES and register.",
      "syntax": "LES r, m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "C4",
        "visual_parts": []
      },
      "extension": "Base (Legacy)",
      "slug": "les",
      "rel_url": "x86/les/",
      "operands": [],
      "linked_summary": "Loads pointer into ES <a href=\"../../armv8-a/and_6/\">and</a> register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lfs",
      "architecture": "x86",
      "full_name": "Load Far Pointer using FS",
      "summary": "Loads pointer into FS and register.",
      "syntax": "LFS r, m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F B4",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "lfs",
      "rel_url": "x86/lfs/",
      "operands": [],
      "linked_summary": "Loads pointer into FS <a href=\"../../armv8-a/and_6/\">and</a> register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lgs",
      "architecture": "x86",
      "full_name": "Load Far Pointer using GS",
      "summary": "Loads pointer into GS and register.",
      "syntax": "LGS r, m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F B5",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "lgs",
      "rel_url": "x86/lgs/",
      "operands": [],
      "linked_summary": "Loads pointer into GS <a href=\"../../armv8-a/and_6/\">and</a> register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lss",
      "architecture": "x86",
      "full_name": "Load Far Pointer using SS",
      "summary": "Loads pointer into SS and register.",
      "syntax": "LSS r, m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F B2",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "lss",
      "rel_url": "x86/lss/",
      "operands": [],
      "linked_summary": "Loads pointer into SS <a href=\"../../armv8-a/and_6/\">and</a> register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "swapgs",
      "architecture": "x86",
      "full_name": "Swap GS Base Register",
      "summary": "Swaps user/kernel GS base address (System).",
      "syntax": "SWAPGS",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 F8",
        "visual_parts": []
      },
      "extension": "Base (64-bit System)",
      "slug": "swapgs",
      "rel_url": "x86/swapgs/",
      "operands": [],
      "linked_summary": "Swaps user/kernel GS base address (System).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rdfsbase",
      "architecture": "x86",
      "full_name": "Read FS Base",
      "summary": "Reads the FS base address into a register.",
      "syntax": "RDFSBASE r64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F AE /0",
        "visual_parts": []
      },
      "extension": "FSGSBASE",
      "slug": "rdfsbase",
      "rel_url": "x86/rdfsbase/",
      "operands": [],
      "linked_summary": "Reads the FS base address into a register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rdgsbase",
      "architecture": "x86",
      "full_name": "Read GS Base",
      "summary": "Reads the GS base address into a register.",
      "syntax": "RDGSBASE r64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F AE /1",
        "visual_parts": []
      },
      "extension": "FSGSBASE",
      "slug": "rdgsbase",
      "rel_url": "x86/rdgsbase/",
      "operands": [],
      "linked_summary": "Reads the GS base address into a register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "wrfsbase",
      "architecture": "x86",
      "full_name": "Write FS Base",
      "summary": "Writes a register to the FS base address.",
      "syntax": "WRFSBASE r64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F AE /2",
        "visual_parts": []
      },
      "extension": "FSGSBASE",
      "slug": "wrfsbase",
      "rel_url": "x86/wrfsbase/",
      "operands": [],
      "linked_summary": "Writes a register to the FS base address.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "wrgsbase",
      "architecture": "x86",
      "full_name": "Write GS Base",
      "summary": "Writes a register to the GS base address.",
      "syntax": "WRGSBASE r64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F AE /3",
        "visual_parts": []
      },
      "extension": "FSGSBASE",
      "slug": "wrgsbase",
      "rel_url": "x86/wrgsbase/",
      "operands": [],
      "linked_summary": "Writes a register to the GS base address.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "monitor",
      "architecture": "x86",
      "full_name": "Monitor",
      "summary": "Sets up a linear address range to be monitored.",
      "syntax": "MONITOR",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 C8",
        "visual_parts": []
      },
      "extension": "SSE3",
      "slug": "monitor",
      "rel_url": "x86/monitor/",
      "operands": [],
      "linked_summary": "Sets up a linear address range to be monitored.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mwait",
      "architecture": "x86",
      "full_name": "Monitor Wait",
      "summary": "Waits for a write to a monitored address.",
      "syntax": "MWAIT",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 C9",
        "visual_parts": []
      },
      "extension": "SSE3",
      "slug": "mwait",
      "rel_url": "x86/mwait/",
      "operands": [],
      "linked_summary": "Waits for a write to a monitored address.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "getsec",
      "architecture": "x86",
      "full_name": "Get Security Extensions",
      "summary": "Entry point for Safer Mode Extensions (Trusted Execution).",
      "syntax": "GETSEC",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 37",
        "visual_parts": []
      },
      "extension": "SMX",
      "slug": "getsec",
      "rel_url": "x86/getsec/",
      "operands": [],
      "linked_summary": "Entry point for Safer Mode Extensions (Trusted Execution).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bndmk",
      "architecture": "x86",
      "full_name": "Make Bounds",
      "summary": "Creates bounds data for MPX.",
      "syntax": "BNDMK b, m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 1B",
        "visual_parts": []
      },
      "extension": "MPX",
      "slug": "bndmk",
      "rel_url": "x86/bndmk/",
      "operands": [],
      "linked_summary": "Creates bounds data for MPX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bndcl",
      "architecture": "x86",
      "full_name": "Check Lower Bound",
      "summary": "Checks if address is within lower bound.",
      "syntax": "BNDCL b, r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 1A",
        "visual_parts": []
      },
      "extension": "MPX",
      "slug": "bndcl",
      "rel_url": "x86/bndcl/",
      "operands": [],
      "linked_summary": "Checks if address is within lower <a href=\"../../x86/bound_1/\">bound</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bndcu",
      "architecture": "x86",
      "full_name": "Check Upper Bound",
      "summary": "Checks if address is within upper bound.",
      "syntax": "BNDCU b, r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F2 0F 1A",
        "visual_parts": []
      },
      "extension": "MPX",
      "slug": "bndcu",
      "rel_url": "x86/bndcu/",
      "operands": [],
      "linked_summary": "Checks if address is within upper <a href=\"../../x86/bound_1/\">bound</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bndmov",
      "architecture": "x86",
      "full_name": "Move Bounds",
      "summary": "Moves MPX bounds data.",
      "syntax": "BNDMOV b, b/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "66 0F 1A",
        "visual_parts": []
      },
      "extension": "MPX",
      "slug": "bndmov",
      "rel_url": "x86/bndmov/",
      "operands": [],
      "linked_summary": "Moves MPX bounds data.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rdpkru",
      "architecture": "x86",
      "full_name": "Read Protection Key Rights",
      "summary": "Reads PKRU register into EAX (User-mode pages).",
      "syntax": "RDPKRU",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 EE",
        "visual_parts": []
      },
      "extension": "PKU",
      "slug": "rdpkru",
      "rel_url": "x86/rdpkru/",
      "operands": [],
      "linked_summary": "Reads PKRU register into EAX (User-mode pages).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "wrpkru",
      "architecture": "x86",
      "full_name": "Write Protection Key Rights",
      "summary": "Writes EAX/EDX to PKRU register.",
      "syntax": "WRPKRU",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 EF",
        "visual_parts": []
      },
      "extension": "PKU",
      "slug": "wrpkru",
      "rel_url": "x86/wrpkru/",
      "operands": [],
      "linked_summary": "Writes EAX/EDX to PKRU register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpdpbusd",
      "architecture": "x86",
      "full_name": "Multiply and Add Unsigned and Signed Bytes",
      "summary": "Dot product of unsigned/signed bytes, accum to dword.",
      "syntax": "VPDPBUSD zmm1, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 50",
        "visual_parts": []
      },
      "extension": "AVX512_VNNI",
      "slug": "vpdpbusd",
      "rel_url": "x86/vpdpbusd/",
      "operands": [],
      "linked_summary": "Dot product of unsigned/signed bytes, accum to dword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpdpbusds",
      "architecture": "x86",
      "full_name": "Multiply and Add Unsigned and Signed Bytes with Saturation",
      "summary": "Dot product of unsigned/signed bytes, accum to dword (Saturate).",
      "syntax": "VPDPBUSDS zmm1, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 51",
        "visual_parts": []
      },
      "extension": "AVX512_VNNI",
      "slug": "vpdpbusds",
      "rel_url": "x86/vpdpbusds/",
      "operands": [],
      "linked_summary": "Dot product of unsigned/signed bytes, accum to dword (Saturate).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpdpwssd",
      "architecture": "x86",
      "full_name": "Multiply and Add Signed Words",
      "summary": "Dot product of signed words, accum to dword.",
      "syntax": "VPDPWSSD zmm1, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 52",
        "visual_parts": []
      },
      "extension": "AVX512_VNNI",
      "slug": "vpdpwssd",
      "rel_url": "x86/vpdpwssd/",
      "operands": [],
      "linked_summary": "Dot product of signed words, accum to dword.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpdpwssds",
      "architecture": "x86",
      "full_name": "Multiply and Add Signed Words with Saturation",
      "summary": "Dot product of signed words, accum to dword (Saturate).",
      "syntax": "VPDPWSSDS zmm1, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 53",
        "visual_parts": []
      },
      "extension": "AVX512_VNNI",
      "slug": "vpdpwssds",
      "rel_url": "x86/vpdpwssds/",
      "operands": [],
      "linked_summary": "Dot product of signed words, accum to dword (Saturate).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "gf2p8affineinvqb",
      "architecture": "x86",
      "full_name": "Galois Field Affine Transformation Inverse",
      "summary": "Computes inverse affine transformation in GF(2^8).",
      "syntax": "GF2P8AFFINEINVQB xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "66 0F 3A CF",
        "visual_parts": []
      },
      "extension": "GFNI",
      "slug": "gf2p8affineinvqb",
      "rel_url": "x86/gf2p8affineinvqb/",
      "operands": [],
      "linked_summary": "Computes inverse affine transformation <a href=\"../../x86/in/\">in</a> GF(2^8).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "prefetchw",
      "architecture": "x86",
      "full_name": "Prefetch Data into Caches in Anticipation of a Write",
      "summary": "Prefetches data with intent to write (RFO).",
      "syntax": "PREFETCHW m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 0D /1",
        "visual_parts": []
      },
      "extension": "PREFETCHW",
      "slug": "prefetchw",
      "rel_url": "x86/prefetchw/",
      "operands": [],
      "linked_summary": "Prefetches data with intent to write (RFO).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "prefetchwt1",
      "architecture": "x86",
      "full_name": "Prefetch Hint T1 with Intent to Write",
      "summary": "Prefetches data to L2 (T1 hint) with intent to write.",
      "syntax": "PREFETCHWT1 m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 0D /2",
        "visual_parts": []
      },
      "extension": "PREFETCHWT1",
      "slug": "prefetchwt1",
      "rel_url": "x86/prefetchwt1/",
      "operands": [],
      "linked_summary": "Prefetches data to L2 (T1 <a href=\"../../armv8-a/hint/\">hint</a>) with intent to write.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vscatterdps",
      "architecture": "x86",
      "full_name": "Scatter Packed Single Precision",
      "summary": "Stores floats to non-contiguous memory locations.",
      "syntax": "VSCATTERDPS [base+zmm_idx*scale] {k1}, zmm1",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 A2",
        "visual_parts": []
      },
      "extension": "AVX512F",
      "slug": "vscatterdps",
      "rel_url": "x86/vscatterdps/",
      "operands": [],
      "linked_summary": "Stores floats to non-contiguous memory locations.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vscatterdpd",
      "architecture": "x86",
      "full_name": "Scatter Packed Double Precision",
      "summary": "Stores doubles to non-contiguous memory locations.",
      "syntax": "VSCATTERDPD [base+zmm_idx*scale] {k1}, zmm1",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 A2",
        "visual_parts": []
      },
      "extension": "AVX512F",
      "slug": "vscatterdpd",
      "rel_url": "x86/vscatterdpd/",
      "operands": [],
      "linked_summary": "Stores doubles to non-contiguous memory locations.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vscatterqps",
      "architecture": "x86",
      "full_name": "Scatter Packed Single Precision (Quadword Indices)",
      "summary": "Stores floats using 64-bit indices.",
      "syntax": "VSCATTERQPS [base+zmm_idx*scale] {k1}, zmm1",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 A3",
        "visual_parts": []
      },
      "extension": "AVX512F",
      "slug": "vscatterqps",
      "rel_url": "x86/vscatterqps/",
      "operands": [],
      "linked_summary": "Stores floats using 64-<a href=\"../../armv8-a/bit/\">bit</a> indices.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vscatterqpd",
      "architecture": "x86",
      "full_name": "Scatter Packed Double Precision (Quadword Indices)",
      "summary": "Stores doubles using 64-bit indices.",
      "syntax": "VSCATTERQPD [base+zmm_idx*scale] {k1}, zmm1",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 A3",
        "visual_parts": []
      },
      "extension": "AVX512F",
      "slug": "vscatterqpd",
      "rel_url": "x86/vscatterqpd/",
      "operands": [],
      "linked_summary": "Stores doubles using 64-<a href=\"../../armv8-a/bit/\">bit</a> indices.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfpclassps",
      "architecture": "x86",
      "full_name": "Floating-Point Class Single",
      "summary": "Tests for category (NaN, Inf, Denormal) for floats.",
      "syntax": "VFPCLASSPS k1 {k2}, zmm2/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 66",
        "visual_parts": []
      },
      "extension": "AVX512DQ",
      "slug": "vfpclassps",
      "rel_url": "x86/vfpclassps/",
      "operands": [],
      "linked_summary": "Tests for category (NaN, Inf, Denormal) for floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfpclasspd",
      "architecture": "x86",
      "full_name": "Floating-Point Class Double",
      "summary": "Tests for category (NaN, Inf, Denormal) for doubles.",
      "syntax": "VFPCLASSPD k1 {k2}, zmm2/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 67",
        "visual_parts": []
      },
      "extension": "AVX512DQ",
      "slug": "vfpclasspd",
      "rel_url": "x86/vfpclasspd/",
      "operands": [],
      "linked_summary": "Tests for category (NaN, Inf, Denormal) for doubles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vrangeps",
      "architecture": "x86",
      "full_name": "Range Restriction Calculation Packed Single",
      "summary": "Calculates range (min/max/abs) of float values.",
      "syntax": "VRANGEPS zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 50",
        "visual_parts": []
      },
      "extension": "AVX512DQ",
      "slug": "vrangeps",
      "rel_url": "x86/vrangeps/",
      "operands": [],
      "linked_summary": "Calculates range (min/max/<a href=\"../../armv8-a/abs_1/\">abs</a>) of float values.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vreduceps",
      "architecture": "x86",
      "full_name": "Perform Reduction Transformation Packed Single",
      "summary": "Performs reduction on floats (e.g. range reduction for trig).",
      "syntax": "VREDUCEPS zmm1 {k1}, zmm2/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 56",
        "visual_parts": []
      },
      "extension": "AVX512DQ",
      "slug": "vreduceps",
      "rel_url": "x86/vreduceps/",
      "operands": [],
      "linked_summary": "Performs reduction on floats (e.g. range reduction for trig).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfixupimmps",
      "architecture": "x86",
      "full_name": "Fix Up Special Packed Float32 Values",
      "summary": "Fixes special cases (NaN, Inf) using a table (Float32).",
      "syntax": "VFIXUPIMMPS zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 54",
        "visual_parts": []
      },
      "extension": "AVX512F",
      "slug": "vfixupimmps",
      "rel_url": "x86/vfixupimmps/",
      "operands": [],
      "linked_summary": "Fixes special cases (NaN, Inf) using a table (Float32).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vrsqrt14ps",
      "architecture": "x86",
      "full_name": "Compute Approximate Reciprocal Square Root (14-bit)",
      "summary": "Approximate 1/sqrt(x) with 2^-14 error.",
      "syntax": "VRSQRT14PS zmm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 4E",
        "visual_parts": []
      },
      "extension": "AVX512F",
      "slug": "vrsqrt14ps",
      "rel_url": "x86/vrsqrt14ps/",
      "operands": [],
      "linked_summary": "Approximate 1/sqrt(x) with 2^-14 error.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vrcp14ps",
      "architecture": "x86",
      "full_name": "Compute Approximate Reciprocal (14-bit)",
      "summary": "Approximate 1/x with 2^-14 error.",
      "syntax": "VRCP14PS zmm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 4C",
        "visual_parts": []
      },
      "extension": "AVX512F",
      "slug": "vrcp14ps",
      "rel_url": "x86/vrcp14ps/",
      "operands": [],
      "linked_summary": "Approximate 1/x with 2^-14 error.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "clui",
      "architecture": "x86",
      "full_name": "Clear User Interrupt Flag",
      "summary": "Clears the User Interrupt Flag (UIF).",
      "syntax": "CLUI",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 01 EE",
        "visual_parts": []
      },
      "extension": "UINTR",
      "slug": "clui",
      "rel_url": "x86/clui/",
      "operands": [],
      "linked_summary": "Clears the User Interrupt Flag (UIF).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stui",
      "architecture": "x86",
      "full_name": "Set User Interrupt Flag",
      "summary": "Sets the User Interrupt Flag (UIF).",
      "syntax": "STUI",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 01 EF",
        "visual_parts": []
      },
      "extension": "UINTR",
      "slug": "stui",
      "rel_url": "x86/stui/",
      "operands": [],
      "linked_summary": "Sets the User Interrupt Flag (UIF).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "testui",
      "architecture": "x86",
      "full_name": "Test User Interrupt",
      "summary": "Sets CF if UIF is 1, ZF if User Interrupt Pending.",
      "syntax": "TESTUI",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 01 ED",
        "visual_parts": []
      },
      "extension": "UINTR",
      "slug": "testui",
      "rel_url": "x86/testui/",
      "operands": [],
      "linked_summary": "Sets CF if UIF is 1, ZF if User Interrupt Pending.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fld",
      "architecture": "x86",
      "full_name": "Load Floating Point Value",
      "summary": "Pushes a floating-point value onto the FPU register stack (ST0).",
      "syntax": "FLD m32fp/m64fp/m80fp",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 /0",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "fld",
      "rel_url": "x86/fld/",
      "operands": [],
      "linked_summary": "Pushes a floating-point value onto the FPU register stack (ST0).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fst",
      "architecture": "x86",
      "full_name": "Store Floating Point Value",
      "summary": "Copies the value in ST(0) to memory or another register.",
      "syntax": "FST m32fp/m64fp",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 /2",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "fst",
      "rel_url": "x86/fst/",
      "operands": [],
      "linked_summary": "Copies the value <a href=\"../../x86/in/\">in</a> ST(0) to memory <a href=\"../../powerisa/or/\">or</a> another register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fstp",
      "architecture": "x86",
      "full_name": "Store Floating Point Value and Pop",
      "summary": "Copies ST(0) to destination and pops the register stack.",
      "syntax": "FSTP m32fp/m64fp/m80fp",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 /3",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "fstp",
      "rel_url": "x86/fstp/",
      "operands": [],
      "linked_summary": "Copies ST(0) to destination <a href=\"../../armv8-a/and_6/\">and</a> pops the register stack.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fild",
      "architecture": "x86",
      "full_name": "Load Integer",
      "summary": "Converts integer in memory to double-extended-precision float and pushes to ST(0).",
      "syntax": "FILD m16int/m32int/m64int",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "DF /0",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "fild",
      "rel_url": "x86/fild/",
      "operands": [],
      "linked_summary": "Converts integer <a href=\"../../x86/in/\">in</a> memory to double-extended-precision float <a href=\"../../armv8-a/and_6/\">and</a> pushes to ST(0).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fist",
      "architecture": "x86",
      "full_name": "Store Integer",
      "summary": "Converts ST(0) to integer and stores in memory.",
      "syntax": "FIST m16int/m32int",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "DF /2",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "fist",
      "rel_url": "x86/fist/",
      "operands": [],
      "linked_summary": "Converts ST(0) to integer <a href=\"../../armv8-a/and_6/\">and</a> stores <a href=\"../../x86/in/\">in</a> memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fistp",
      "architecture": "x86",
      "full_name": "Store Integer and Pop",
      "summary": "Converts ST(0) to integer, stores in memory, and pops stack.",
      "syntax": "FISTP m16int/m32int/m64int",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "DF /3",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "fistp",
      "rel_url": "x86/fistp/",
      "operands": [],
      "linked_summary": "Converts ST(0) to integer, stores <a href=\"../../x86/in/\">in</a> memory, <a href=\"../../armv8-a/and_6/\">and</a> pops stack.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fadd",
      "architecture": "x86",
      "full_name": "Add Floating Point",
      "summary": "Adds src to dest (ST(0) += src).",
      "syntax": "FADD m32fp/m64fp",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D8 /0",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "fadd",
      "rel_url": "x86/fadd/",
      "operands": [],
      "linked_summary": "Adds src to dest (ST(0) += src).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fsub",
      "architecture": "x86",
      "full_name": "Subtract Floating Point",
      "summary": "Subtracts src from dest.",
      "syntax": "FSUB m32fp/m64fp",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D8 /4",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "fsub",
      "rel_url": "x86/fsub/",
      "operands": [],
      "linked_summary": "Subtracts src from dest.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fmul",
      "architecture": "x86",
      "full_name": "Multiply Floating Point",
      "summary": "Multiplies dest by src.",
      "syntax": "FMUL m32fp/m64fp",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D8 /1",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "fmul",
      "rel_url": "x86/fmul/",
      "operands": [],
      "linked_summary": "Multiplies dest by src.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fdiv",
      "architecture": "x86",
      "full_name": "Divide Floating Point",
      "summary": "Divides dest by src.",
      "syntax": "FDIV m32fp/m64fp",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D8 /6",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "fdiv",
      "rel_url": "x86/fdiv/",
      "operands": [],
      "linked_summary": "Divides dest by src.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fprem",
      "architecture": "x86",
      "full_name": "Partial Remainder",
      "summary": "Computes remainder of ST(0) / ST(1).",
      "syntax": "FPREM",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 F8",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "fprem",
      "rel_url": "x86/fprem/",
      "operands": [],
      "linked_summary": "Computes remainder of ST(0) / ST(1).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fabs",
      "architecture": "x86",
      "full_name": "Absolute Value",
      "summary": "Replaces ST(0) with its absolute value.",
      "syntax": "FABS",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 E1",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "fabs",
      "rel_url": "x86/fabs/",
      "operands": [],
      "linked_summary": "Replaces ST(0) with its absolute value.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fchs",
      "architecture": "x86",
      "full_name": "Change Sign",
      "summary": "Reverses the sign of ST(0).",
      "syntax": "FCHS",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 E0",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "fchs",
      "rel_url": "x86/fchs/",
      "operands": [],
      "linked_summary": "Reverses the sign of ST(0).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fsqrt",
      "architecture": "x86",
      "full_name": "Square Root",
      "summary": "Computes square root of ST(0).",
      "syntax": "FSQRT",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 FA",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "fsqrt",
      "rel_url": "x86/fsqrt/",
      "operands": [],
      "linked_summary": "Computes square root of ST(0).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fsin",
      "architecture": "x86",
      "full_name": "Sine",
      "summary": "Computes sine of ST(0) (in radians).",
      "syntax": "FSIN",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 FE",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "fsin",
      "rel_url": "x86/fsin/",
      "operands": [],
      "linked_summary": "Computes sine of ST(0) (<a href=\"../../x86/in/\">in</a> radians).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fcos",
      "architecture": "x86",
      "full_name": "Cosine",
      "summary": "Computes cosine of ST(0) (in radians).",
      "syntax": "FCOS",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 FF",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "fcos",
      "rel_url": "x86/fcos/",
      "operands": [],
      "linked_summary": "Computes cosine of ST(0) (<a href=\"../../x86/in/\">in</a> radians).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fsincos",
      "architecture": "x86",
      "full_name": "Sine and Cosine",
      "summary": "Computes sine and cosine of ST(0), pushing both to stack.",
      "syntax": "FSINCOS",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 FB",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "fsincos",
      "rel_url": "x86/fsincos/",
      "operands": [],
      "linked_summary": "Computes sine <a href=\"../../armv8-a/and_6/\">and</a> cosine of ST(0), pushing both to stack.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fptan",
      "architecture": "x86",
      "full_name": "Partial Tangent",
      "summary": "Computes tangent of ST(0) and pushes 1.0.",
      "syntax": "FPTAN",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 F2",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "fptan",
      "rel_url": "x86/fptan/",
      "operands": [],
      "linked_summary": "Computes tangent of ST(0) <a href=\"../../armv8-a/and_6/\">and</a> pushes 1.0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fpatan",
      "architecture": "x86",
      "full_name": "Partial Arctangent",
      "summary": "Computes arctan(ST(1)/ST(0)).",
      "syntax": "FPATAN",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 F3",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "fpatan",
      "rel_url": "x86/fpatan/",
      "operands": [],
      "linked_summary": "Computes arctan(ST(1)/ST(0)).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fyl2x",
      "architecture": "x86",
      "full_name": "Y * log2(X)",
      "summary": "Computes ST(1) * log2(ST(0)).",
      "syntax": "FYL2X",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 F1",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "fyl2x",
      "rel_url": "x86/fyl2x/",
      "operands": [],
      "linked_summary": "Computes ST(1) * log2(ST(0)).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fxch",
      "architecture": "x86",
      "full_name": "Exchange Register",
      "summary": "Exchanges contents of ST(0) and ST(i).",
      "syntax": "FXCH ST(i)",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 C8+i",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "fxch",
      "rel_url": "x86/fxch/",
      "operands": [],
      "linked_summary": "Exchanges contents of ST(0) <a href=\"../../armv8-a/and_6/\">and</a> ST(i).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fcom",
      "architecture": "x86",
      "full_name": "Compare Real",
      "summary": "Compares ST(0) with source.",
      "syntax": "FCOM m32fp/m64fp",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D8 /2",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "fcom",
      "rel_url": "x86/fcom/",
      "operands": [],
      "linked_summary": "Compares ST(0) with source.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fcomi",
      "architecture": "x86",
      "full_name": "Compare Real and Set EFLAGS",
      "summary": "Compares ST(0) with ST(i) and sets CPU EFLAGS directly.",
      "syntax": "FCOMI ST(0), ST(i)",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "DB F0+i",
        "visual_parts": []
      },
      "extension": "x87 FPU (P6+)",
      "slug": "fcomi",
      "rel_url": "x86/fcomi/",
      "operands": [],
      "linked_summary": "Compares ST(0) with ST(i) <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../x86/sets/\">sets</a> CPU EFLAGS directly.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "finit",
      "architecture": "x86",
      "full_name": "Initialize FPU",
      "summary": "Resets FPU to default state.",
      "syntax": "FINIT",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "9B DB E3",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "finit",
      "rel_url": "x86/finit/",
      "operands": [],
      "linked_summary": "Resets FPU to default state.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fclex",
      "architecture": "x86",
      "full_name": "Clear Exceptions",
      "summary": "Clears floating-point exception flags.",
      "syntax": "FCLEX",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "9B DB E2",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "fclex",
      "rel_url": "x86/fclex/",
      "operands": [],
      "linked_summary": "Clears floating-point exception flags.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fstsw",
      "architecture": "x86",
      "full_name": "Store Status Word",
      "summary": "Stores FPU status word to AX or memory.",
      "syntax": "FSTSW AX",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "9B DF E0",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "fstsw",
      "rel_url": "x86/fstsw/",
      "operands": [],
      "linked_summary": "Stores FPU status word to AX <a href=\"../../powerisa/or/\">or</a> memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fldcw",
      "architecture": "x86",
      "full_name": "Load Control Word",
      "summary": "Loads FPU control word from memory.",
      "syntax": "FLDCW m2byte",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 /5",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "fldcw",
      "rel_url": "x86/fldcw/",
      "operands": [],
      "linked_summary": "Loads FPU control word from memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fstcw",
      "architecture": "x86",
      "full_name": "Store Control Word",
      "summary": "Stores FPU control word to memory.",
      "syntax": "FSTCW m2byte",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "9B D9 /7",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "fstcw",
      "rel_url": "x86/fstcw/",
      "operands": [],
      "linked_summary": "Stores FPU control word to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "frstor",
      "architecture": "x86",
      "full_name": "Restore FPU State",
      "summary": "Loads FPU state from memory.",
      "syntax": "FRSTOR m108byte",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "DD /4",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "frstor",
      "rel_url": "x86/frstor/",
      "operands": [],
      "linked_summary": "Loads FPU state from memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fsave",
      "architecture": "x86",
      "full_name": "Save FPU State",
      "summary": "Stores FPU state to memory and re-initializes FPU.",
      "syntax": "FSAVE m108byte",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "9B DD /6",
        "visual_parts": []
      },
      "extension": "x87 FPU",
      "slug": "fsave",
      "rel_url": "x86/fsave/",
      "operands": [],
      "linked_summary": "Stores FPU state to memory <a href=\"../../armv8-a/and_6/\">and</a> re-initializes FPU.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lgdt",
      "architecture": "x86",
      "full_name": "Load Global Descriptor Table Register",
      "summary": "Loads the GDT register (Privileged).",
      "syntax": "LGDT m16&amp;32",
      "encoding": {
        "format": "System",
        "hex_opcode": "0F 01 /2",
        "visual_parts": []
      },
      "extension": "System",
      "slug": "lgdt",
      "rel_url": "x86/lgdt/",
      "operands": [],
      "linked_summary": "Loads the GDT register (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lidt",
      "architecture": "x86",
      "full_name": "Load Interrupt Descriptor Table Register",
      "summary": "Loads the IDT register (Privileged).",
      "syntax": "LIDT m16&amp;32",
      "encoding": {
        "format": "System",
        "hex_opcode": "0F 01 /3",
        "visual_parts": []
      },
      "extension": "System",
      "slug": "lidt",
      "rel_url": "x86/lidt/",
      "operands": [],
      "linked_summary": "Loads the IDT register (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sgdt",
      "architecture": "x86",
      "full_name": "Store Global Descriptor Table Register",
      "summary": "Stores GDT limit and base address to memory.",
      "syntax": "SGDT m",
      "encoding": {
        "format": "System",
        "hex_opcode": "0F 01 /0",
        "visual_parts": []
      },
      "extension": "System",
      "slug": "sgdt",
      "rel_url": "x86/sgdt/",
      "operands": [],
      "linked_summary": "Stores GDT limit <a href=\"../../armv8-a/and_6/\">and</a> base address to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sidt",
      "architecture": "x86",
      "full_name": "Store Interrupt Descriptor Table Register",
      "summary": "Stores IDT limit and base address to memory.",
      "syntax": "SIDT m",
      "encoding": {
        "format": "System",
        "hex_opcode": "0F 01 /1",
        "visual_parts": []
      },
      "extension": "System",
      "slug": "sidt",
      "rel_url": "x86/sidt/",
      "operands": [],
      "linked_summary": "Stores IDT limit <a href=\"../../armv8-a/and_6/\">and</a> base address to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lldt",
      "architecture": "x86",
      "full_name": "Load Local Descriptor Table Register",
      "summary": "Loads LDT segment selector (Privileged).",
      "syntax": "LLDT r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0F 00 /2",
        "visual_parts": []
      },
      "extension": "System",
      "slug": "lldt",
      "rel_url": "x86/lldt/",
      "operands": [],
      "linked_summary": "Loads LDT segment selector (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sldt",
      "architecture": "x86",
      "full_name": "Store Local Descriptor Table Register",
      "summary": "Stores LDT segment selector.",
      "syntax": "SLDT r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0F 00 /0",
        "visual_parts": []
      },
      "extension": "System",
      "slug": "sldt",
      "rel_url": "x86/sldt/",
      "operands": [],
      "linked_summary": "Stores LDT segment selector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ltr",
      "architecture": "x86",
      "full_name": "Load Task Register",
      "summary": "Loads Task Register (Privileged).",
      "syntax": "LTR r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0F 00 /3",
        "visual_parts": []
      },
      "extension": "System",
      "slug": "ltr",
      "rel_url": "x86/ltr/",
      "operands": [],
      "linked_summary": "Loads Task Register (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "str",
      "architecture": "x86",
      "full_name": "Store Task Register",
      "summary": "Stores Task Register.",
      "syntax": "STR r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0F 00 /1",
        "visual_parts": []
      },
      "extension": "System",
      "slug": "str",
      "rel_url": "x86/str/",
      "operands": [],
      "linked_summary": "Stores Task Register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mov cr",
      "architecture": "x86",
      "full_name": "Move Control Register",
      "summary": "Moves data to/from Control Registers (CR0, CR3, etc.) (Privileged).",
      "syntax": "MOV CRn, r",
      "encoding": {
        "format": "System",
        "hex_opcode": "0F 22 /r",
        "visual_parts": []
      },
      "extension": "System",
      "slug": "mov_cr",
      "rel_url": "x86/mov_cr/",
      "operands": [],
      "linked_summary": "Moves data to/from Control Registers (CR0, CR3, etc.) (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mov dr",
      "architecture": "x86",
      "full_name": "Move Debug Register",
      "summary": "Moves data to/from Debug Registers (DR0-DR7) (Privileged).",
      "syntax": "MOV DRn, r",
      "encoding": {
        "format": "System",
        "hex_opcode": "0F 23 /r",
        "visual_parts": []
      },
      "extension": "System",
      "slug": "mov_dr",
      "rel_url": "x86/mov_dr/",
      "operands": [],
      "linked_summary": "Moves data to/from Debug Registers (DR0-DR7) (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lmsw",
      "architecture": "x86",
      "full_name": "Load Machine Status Word",
      "summary": "Loads Machine Status Word (Legacy CR0 modification).",
      "syntax": "LMSW r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0F 01 /6",
        "visual_parts": []
      },
      "extension": "System",
      "slug": "lmsw",
      "rel_url": "x86/lmsw/",
      "operands": [],
      "linked_summary": "Loads Machine Status Word (Legacy CR0 modification).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "smsw",
      "architecture": "x86",
      "full_name": "Store Machine Status Word",
      "summary": "Stores Machine Status Word.",
      "syntax": "SMSW r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0F 01 /4",
        "visual_parts": []
      },
      "extension": "System",
      "slug": "smsw",
      "rel_url": "x86/smsw/",
      "operands": [],
      "linked_summary": "Stores Machine Status Word.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "clts",
      "architecture": "x86",
      "full_name": "Clear Task-Switched Flag",
      "summary": "Clears the TS flag in CR0 (Privileged).",
      "syntax": "CLTS",
      "encoding": {
        "format": "System",
        "hex_opcode": "0F 06",
        "visual_parts": []
      },
      "extension": "System",
      "slug": "clts",
      "rel_url": "x86/clts/",
      "operands": [],
      "linked_summary": "Clears the TS flag <a href=\"../../x86/in/\">in</a> CR0 (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "invd",
      "architecture": "x86",
      "full_name": "Invalidate Internal Caches",
      "summary": "Flushes internal caches without writing back data (Privileged).",
      "syntax": "INVD",
      "encoding": {
        "format": "System",
        "hex_opcode": "0F 08",
        "visual_parts": []
      },
      "extension": "System",
      "slug": "invd",
      "rel_url": "x86/invd/",
      "operands": [],
      "linked_summary": "Flushes internal caches without writing back data (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "wbinvd",
      "architecture": "x86",
      "full_name": "Write Back and Invalidate Cache",
      "summary": "Writes back modified data and invalidates caches (Privileged).",
      "syntax": "WBINVD",
      "encoding": {
        "format": "System",
        "hex_opcode": "0F 09",
        "visual_parts": []
      },
      "extension": "System",
      "slug": "wbinvd",
      "rel_url": "x86/wbinvd/",
      "operands": [],
      "linked_summary": "Writes back modified data <a href=\"../../armv8-a/and_6/\">and</a> invalidates caches (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "invlpg",
      "architecture": "x86",
      "full_name": "Invalidate TLB Entry",
      "summary": "Invalidates a specific TLB entry (Privileged).",
      "syntax": "INVLPG m",
      "encoding": {
        "format": "System",
        "hex_opcode": "0F 01 /7",
        "visual_parts": []
      },
      "extension": "System",
      "slug": "invlpg",
      "rel_url": "x86/invlpg/",
      "operands": [],
      "linked_summary": "Invalidates a specific TLB entry (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rdmsr",
      "architecture": "x86",
      "full_name": "Read Model Specific Register",
      "summary": "Reads MSR specified by ECX into EDX:EAX (Privileged).",
      "syntax": "RDMSR",
      "encoding": {
        "format": "System",
        "hex_opcode": "0F 32",
        "visual_parts": []
      },
      "extension": "System",
      "slug": "rdmsr",
      "rel_url": "x86/rdmsr/",
      "operands": [],
      "linked_summary": "Reads MSR specified by ECX into EDX:EAX (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "wrmsr",
      "architecture": "x86",
      "full_name": "Write Model Specific Register",
      "summary": "Writes EDX:EAX to MSR specified by ECX (Privileged).",
      "syntax": "WRMSR",
      "encoding": {
        "format": "System",
        "hex_opcode": "0F 30",
        "visual_parts": []
      },
      "extension": "System",
      "slug": "wrmsr",
      "rel_url": "x86/wrmsr/",
      "operands": [],
      "linked_summary": "Writes EDX:EAX to MSR specified by ECX (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rdpmc",
      "architecture": "x86",
      "full_name": "Read Performance-Monitoring Counters",
      "summary": "Reads performance counter specified by ECX into EDX:EAX.",
      "syntax": "RDPMC",
      "encoding": {
        "format": "System",
        "hex_opcode": "0F 33",
        "visual_parts": []
      },
      "extension": "System",
      "slug": "rdpmc",
      "rel_url": "x86/rdpmc/",
      "operands": [],
      "linked_summary": "Reads performance counter specified by ECX into EDX:EAX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sysenter",
      "architecture": "x86",
      "full_name": "Fast System Call",
      "summary": "Fast call to level 0 system procedures.",
      "syntax": "SYSENTER",
      "encoding": {
        "format": "System",
        "hex_opcode": "0F 34",
        "visual_parts": []
      },
      "extension": "System",
      "slug": "sysenter",
      "rel_url": "x86/sysenter/",
      "operands": [],
      "linked_summary": "Fast <a href=\"../../x86/call_1/\">call</a> to level 0 system procedures.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sysexit",
      "architecture": "x86",
      "full_name": "Fast Return from System Call",
      "summary": "Fast return to level 3 user code.",
      "syntax": "SYSEXIT",
      "encoding": {
        "format": "System",
        "hex_opcode": "0F 35",
        "visual_parts": []
      },
      "extension": "System",
      "slug": "sysexit",
      "rel_url": "x86/sysexit/",
      "operands": [],
      "linked_summary": "Fast return to level 3 user code.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lar",
      "architecture": "x86",
      "full_name": "Load Access Rights Byte",
      "summary": "Reads access rights from segment descriptor.",
      "syntax": "LAR r, r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0F 02",
        "visual_parts": []
      },
      "extension": "System",
      "slug": "lar",
      "rel_url": "x86/lar/",
      "operands": [],
      "linked_summary": "Reads access rights from segment descriptor.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lsl",
      "architecture": "x86",
      "full_name": "Load Segment Limit",
      "summary": "Reads segment limit from descriptor.",
      "syntax": "LSL r, r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0F 03",
        "visual_parts": []
      },
      "extension": "System",
      "slug": "lsl",
      "rel_url": "x86/lsl/",
      "operands": [],
      "linked_summary": "Reads segment limit from descriptor.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "verr",
      "architecture": "x86",
      "full_name": "Verify Segment for Reading",
      "summary": "Checks if segment can be read; sets ZF.",
      "syntax": "VERR r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0F 00 /4",
        "visual_parts": []
      },
      "extension": "System",
      "slug": "verr",
      "rel_url": "x86/verr/",
      "operands": [],
      "linked_summary": "Checks if segment can be read; <a href=\"../../x86/sets/\">sets</a> ZF.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "verw",
      "architecture": "x86",
      "full_name": "Verify Segment for Writing",
      "summary": "Checks if segment can be written; sets ZF.",
      "syntax": "VERW r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0F 00 /5",
        "visual_parts": []
      },
      "extension": "System",
      "slug": "verw",
      "rel_url": "x86/verw/",
      "operands": [],
      "linked_summary": "Checks if segment can be written; <a href=\"../../x86/sets/\">sets</a> ZF.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "arpl",
      "architecture": "x86",
      "full_name": "Adjust Requested Privilege Level",
      "summary": "Adjusts RPL of selector to match current CPL (Legacy).",
      "syntax": "ARPL r/m16, r16",
      "encoding": {
        "format": "System",
        "hex_opcode": "63",
        "visual_parts": []
      },
      "extension": "System (32-bit)",
      "slug": "arpl",
      "rel_url": "x86/arpl/",
      "operands": [],
      "linked_summary": "Adjusts RPL of selector to <a href=\"../../armv9-a/match_2/\">match</a> current CPL (Legacy).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rsm",
      "architecture": "x86",
      "full_name": "Resume from System Management Mode",
      "summary": "Exits SMM and returns to previous state (Privileged).",
      "syntax": "RSM",
      "encoding": {
        "format": "System",
        "hex_opcode": "0F AA",
        "visual_parts": []
      },
      "extension": "System (SMM)",
      "slug": "rsm",
      "rel_url": "x86/rsm/",
      "operands": [],
      "linked_summary": "Exits SMM <a href=\"../../armv8-a/and_6/\">and</a> returns to previous state (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bswap",
      "architecture": "x86",
      "full_name": "Byte Swap",
      "summary": "Reverses the byte order of a 32/64-bit register.",
      "syntax": "BSWAP r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F C8",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "bswap_1",
      "rel_url": "x86/bswap_1/",
      "operands": [],
      "linked_summary": "Reverses the byte order of a 32/64-<a href=\"../../armv8-a/bit/\">bit</a> register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmpxchg8b",
      "architecture": "x86",
      "full_name": "Compare and Exchange 8 Bytes",
      "summary": "Atomically compares EDX:EAX with memory; swaps if equal.",
      "syntax": "CMPXCHG8B m64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F C7 /1",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "cmpxchg8b",
      "rel_url": "x86/cmpxchg8b/",
      "operands": [],
      "linked_summary": "Atomically compares EDX:EAX with memory; swaps if equal.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "addsubps",
      "architecture": "x86",
      "full_name": "Packed Single-FP Add/Subtract",
      "summary": "Adds odd elements, subtracts even elements (Complex Math).",
      "syntax": "ADDSUBPS xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE3",
        "hex_opcode": "F2 0F D0",
        "visual_parts": []
      },
      "extension": "SSE3",
      "slug": "addsubps",
      "rel_url": "x86/addsubps/",
      "operands": [],
      "linked_summary": "Adds odd elements, subtracts even elements (Complex Math).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "haddps",
      "architecture": "x86",
      "full_name": "Horizontal Add Packed Single-Precision",
      "summary": "Adds adjacent float elements horizontally.",
      "syntax": "HADDPS xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE3",
        "hex_opcode": "F2 0F 7C",
        "visual_parts": []
      },
      "extension": "SSE3",
      "slug": "haddps",
      "rel_url": "x86/haddps/",
      "operands": [],
      "linked_summary": "Adds adjacent float elements horizontally.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movddup",
      "architecture": "x86",
      "full_name": "Move One Double-FP and Duplicate",
      "summary": "Loads 64-bit double and duplicates it to fill 128-bit register.",
      "syntax": "MOVDDUP xmm1, xmm2/m64",
      "encoding": {
        "format": "SSE3",
        "hex_opcode": "F2 0F 12",
        "visual_parts": []
      },
      "extension": "SSE3",
      "slug": "movddup",
      "rel_url": "x86/movddup/",
      "operands": [],
      "linked_summary": "Loads 64-<a href=\"../../armv8-a/bit/\">bit</a> double <a href=\"../../armv8-a/and_6/\">and</a> duplicates <a href=\"../../armv8-a/it/\">it</a> to fill 128-<a href=\"../../armv8-a/bit/\">bit</a> register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lddqu",
      "architecture": "x86",
      "full_name": "Load Unaligned Integer 128-bit",
      "summary": "Loads unaligned data avoiding split-line penalties.",
      "syntax": "LDDQU xmm1, m128",
      "encoding": {
        "format": "SSE3",
        "hex_opcode": "F2 0F F0",
        "visual_parts": []
      },
      "extension": "SSE3",
      "slug": "lddqu",
      "rel_url": "x86/lddqu/",
      "operands": [],
      "linked_summary": "Loads unaligned data avoiding split-line penalties.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pshufb",
      "architecture": "x86",
      "full_name": "Packed Shuffle Bytes",
      "summary": "Shuffles bytes according to indices in source operand.",
      "syntax": "PSHUFB xmm1, xmm2/m128",
      "encoding": {
        "format": "SSSE3",
        "hex_opcode": "66 0F 38 00",
        "visual_parts": []
      },
      "extension": "SSSE3",
      "slug": "pshufb",
      "rel_url": "x86/pshufb/",
      "operands": [],
      "linked_summary": "Shuffles bytes according to indices <a href=\"../../x86/in/\">in</a> source operand.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "phaddw",
      "architecture": "x86",
      "full_name": "Packed Horizontal Add Word",
      "summary": "Adds adjacent 16-bit integers horizontally.",
      "syntax": "PHADDW xmm1, xmm2/m128",
      "encoding": {
        "format": "SSSE3",
        "hex_opcode": "66 0F 38 01",
        "visual_parts": []
      },
      "extension": "SSSE3",
      "slug": "phaddw",
      "rel_url": "x86/phaddw/",
      "operands": [],
      "linked_summary": "Adds adjacent 16-<a href=\"../../armv8-a/bit/\">bit</a> integers horizontally.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "palignr",
      "architecture": "x86",
      "full_name": "Packed Align Right",
      "summary": "Concatenates dest and src, extracts 128 bits byte-aligned.",
      "syntax": "PALIGNR xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "SSSE3",
        "hex_opcode": "66 0F 3A 0F",
        "visual_parts": []
      },
      "extension": "SSSE3",
      "slug": "palignr",
      "rel_url": "x86/palignr/",
      "operands": [],
      "linked_summary": "Concatenates dest <a href=\"../../armv8-a/and_6/\">and</a> src, extracts 128 bits byte-aligned.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmulhrsw",
      "architecture": "x86",
      "full_name": "Packed Multiply High with Round and Scale",
      "summary": "Multiplies signed 16-bit words, rounds, and scales.",
      "syntax": "PMULHRSW xmm1, xmm2/m128",
      "encoding": {
        "format": "SSSE3",
        "hex_opcode": "66 0F 38 0B",
        "visual_parts": []
      },
      "extension": "SSSE3",
      "slug": "pmulhrsw",
      "rel_url": "x86/pmulhrsw/",
      "operands": [],
      "linked_summary": "Multiplies signed 16-<a href=\"../../armv8-a/bit/\">bit</a> words, rounds, <a href=\"../../armv8-a/and_6/\">and</a> scales.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psignb",
      "architecture": "x86",
      "full_name": "Packed Sign Byte",
      "summary": "Negates/Zeroes bytes in dest based on sign of src.",
      "syntax": "PSIGNB xmm1, xmm2/m128",
      "encoding": {
        "format": "SSSE3",
        "hex_opcode": "66 0F 38 08",
        "visual_parts": []
      },
      "extension": "SSSE3",
      "slug": "psignb",
      "rel_url": "x86/psignb/",
      "operands": [],
      "linked_summary": "Negates/Zeroes bytes <a href=\"../../x86/in/\">in</a> dest based on sign of src.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pabsb",
      "architecture": "x86",
      "full_name": "Packed Absolute Value Byte",
      "summary": "Computes absolute value of bytes.",
      "syntax": "PABSB xmm1, xmm2/m128",
      "encoding": {
        "format": "SSSE3",
        "hex_opcode": "66 0F 38 1C",
        "visual_parts": []
      },
      "extension": "SSSE3",
      "slug": "pabsb",
      "rel_url": "x86/pabsb/",
      "operands": [],
      "linked_summary": "Computes absolute value of bytes.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "blendps",
      "architecture": "x86",
      "full_name": "Blend Packed Single-Precision",
      "summary": "Selects floats from two sources based on immediate mask.",
      "syntax": "BLENDPS xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 3A 0C",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "blendps",
      "rel_url": "x86/blendps/",
      "operands": [],
      "linked_summary": "Selects floats from two sources based on immediate mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pblendw",
      "architecture": "x86",
      "full_name": "Packed Blend Words",
      "summary": "Selects words from two sources based on immediate mask.",
      "syntax": "PBLENDW xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 3A 0E",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "pblendw",
      "rel_url": "x86/pblendw/",
      "operands": [],
      "linked_summary": "Selects words from two sources based on immediate mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "adc",
      "architecture": "x86",
      "full_name": "Add with Carry",
      "summary": "Adds operands and the Carry Flag (CF).",
      "syntax": "ADC r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "11",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        },
        {
          "name": "src",
          "desc": "Reg"
        }
      ],
      "extension": "Base",
      "slug": "adc",
      "rel_url": "x86/adc/",
      "linked_summary": "Adds operands <a href=\"../../armv8-a/and_6/\">and</a> the Carry Flag (CF).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sbb",
      "architecture": "x86",
      "full_name": "Subtract with Borrow",
      "summary": "Subtracts operands and the Carry Flag (CF).",
      "syntax": "SBB r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "19",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        },
        {
          "name": "src",
          "desc": "Reg"
        }
      ],
      "extension": "Base",
      "slug": "sbb",
      "rel_url": "x86/sbb/",
      "linked_summary": "Subtracts operands <a href=\"../../armv8-a/and_6/\">and</a> the Carry Flag (CF).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "shld",
      "architecture": "x86",
      "full_name": "Double Precision Shift Left",
      "summary": "Shifts dest left, filling with bits from src.",
      "syntax": "SHLD r/m, r, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F A4",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        },
        {
          "name": "fill",
          "desc": "Reg"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "Base",
      "slug": "shld",
      "rel_url": "x86/shld/",
      "linked_summary": "Shifts dest left, filling with bits from src.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "shrd",
      "architecture": "x86",
      "full_name": "Double Precision Shift Right",
      "summary": "Shifts dest right, filling with bits from src.",
      "syntax": "SHRD r/m, r, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F AC",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        },
        {
          "name": "fill",
          "desc": "Reg"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "Base",
      "slug": "shrd",
      "rel_url": "x86/shrd/",
      "linked_summary": "Shifts dest right, filling with bits from src.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpermb",
      "architecture": "x86",
      "full_name": "Permute Packed Bytes",
      "summary": "Permutes bytes in ZMM based on index vector.",
      "syntax": "VPERMB zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 8D",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "idx",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512_VBMI",
      "slug": "vpermb",
      "rel_url": "x86/vpermb/",
      "linked_summary": "Permutes bytes <a href=\"../../x86/in/\">in</a> ZMM based on <a href=\"../../armv8-a/index/\">index</a> vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpermi2b",
      "architecture": "x86",
      "full_name": "Permute Two-Source Bytes",
      "summary": "Shuffles bytes from two ZMM registers into destination.",
      "syntax": "VPERMI2B zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 75",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "idx",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512_VBMI",
      "slug": "vpermi2b",
      "rel_url": "x86/vpermi2b/",
      "linked_summary": "Shuffles bytes from two ZMM registers into destination.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpermt2b",
      "architecture": "x86",
      "full_name": "Permute Two-Source Bytes (Overwrite)",
      "summary": "Shuffles bytes from two sources, overwriting index.",
      "syntax": "VPERMT2B zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 7D",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "idx",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512_VBMI",
      "slug": "vpermt2b",
      "rel_url": "x86/vpermt2b/",
      "linked_summary": "Shuffles bytes from two sources, overwriting <a href=\"../../armv8-a/index/\">index</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmultishiftqb",
      "architecture": "x86",
      "full_name": "Select Packed Unaligned Bytes from Quadword Sources",
      "summary": "Selects bytes from each 64-bit element based on shift control.",
      "syntax": "VPMULTISHIFTQB zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 83",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "ctrl",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512_VBMI",
      "slug": "vpmultishiftqb",
      "rel_url": "x86/vpmultishiftqb/",
      "linked_summary": "Selects bytes from each 64-<a href=\"../../armv8-a/bit/\">bit</a> element based on shift control.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpshldd",
      "architecture": "x86",
      "full_name": "Packed Shift Left Double Concatenate",
      "summary": "Funnel shift left of doublewords.",
      "syntax": "VPSHLDD zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 71",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        },
        {
          "name": "cnt",
          "desc": "Imm"
        }
      ],
      "extension": "AVX-512_VBMI2",
      "slug": "vpshldd",
      "rel_url": "x86/vpshldd/",
      "linked_summary": "Funnel shift left of doublewords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpshrdd",
      "architecture": "x86",
      "full_name": "Packed Shift Right Double Concatenate",
      "summary": "Funnel shift right of doublewords.",
      "syntax": "VPSHRDD zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 73",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        },
        {
          "name": "cnt",
          "desc": "Imm"
        }
      ],
      "extension": "AVX-512_VBMI2",
      "slug": "vpshrdd",
      "rel_url": "x86/vpshrdd/",
      "linked_summary": "Funnel shift right of doublewords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpcompressb",
      "architecture": "x86",
      "full_name": "Store Sparse Packed Byte Integer Values",
      "summary": "Compresses active bytes from ZMM to memory.",
      "syntax": "VPCOMPRESSB m512 {k1}, zmm1",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 63",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Mem"
        },
        {
          "name": "src",
          "desc": "ZMM"
        }
      ],
      "extension": "AVX-512_VBMI2",
      "slug": "vpcompressb",
      "rel_url": "x86/vpcompressb/",
      "linked_summary": "Compresses active bytes from ZMM to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpexpandb",
      "architecture": "x86",
      "full_name": "Load Sparse Packed Byte Integer Values",
      "summary": "Expands bytes from memory into sparse locations in ZMM.",
      "syntax": "VPEXPANDB zmm1 {k1}, m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 62",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "Mem"
        }
      ],
      "extension": "AVX-512_VBMI2",
      "slug": "vpexpandb",
      "rel_url": "x86/vpexpandb/",
      "linked_summary": "Expands bytes from memory into sparse locations <a href=\"../../x86/in/\">in</a> ZMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpopcntb",
      "architecture": "x86",
      "full_name": "Packed Population Count Byte",
      "summary": "Counts set bits in each byte.",
      "syntax": "VPOPCNTB zmm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 54",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512_BITALG",
      "slug": "vpopcntb",
      "rel_url": "x86/vpopcntb/",
      "linked_summary": "Counts set bits <a href=\"../../x86/in/\">in</a> each byte.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpshufbitqmb",
      "architecture": "x86",
      "full_name": "Shuffle Bits from Quadword Elements to Mask",
      "summary": "Extracts bits from bytes and packs into a mask register.",
      "syntax": "VPSHUFBITQMB k1 {k2}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 8F",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "k-reg"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512_BITALG",
      "slug": "vpshufbitqmb",
      "rel_url": "x86/vpshufbitqmb/",
      "linked_summary": "Extracts bits from bytes <a href=\"../../armv8-a/and_6/\">and</a> packs into a mask register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vp2intersectd",
      "architecture": "x86",
      "full_name": "Compute Intersection Pair Doublewords",
      "summary": "Computes intersection of two ZMM registers into mask pair.",
      "syntax": "VP2INTERSECTD k1+1, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "F2 0F 38 68",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "kdest",
          "desc": "k-pair"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512_VP2INTERSECT",
      "slug": "vp2intersectd",
      "rel_url": "x86/vp2intersectd/",
      "linked_summary": "Computes intersection of two ZMM registers into mask pair.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmadd52luq",
      "architecture": "x86",
      "full_name": "Packed Multiply-Add Unsigned 52-bit Integers (Low)",
      "summary": "Fused multiply-add for 52-bit integers (Low 52 bits).",
      "syntax": "VPMADD52LUQ zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 B4",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512_IFMA",
      "slug": "vpmadd52luq",
      "rel_url": "x86/vpmadd52luq/",
      "linked_summary": "Fused multiply-<a href=\"../../armv8-a/add_8/\">add</a> for 52-<a href=\"../../armv8-a/bit/\">bit</a> integers (Low 52 bits).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmadd52huq",
      "architecture": "x86",
      "full_name": "Packed Multiply-Add Unsigned 52-bit Integers (High)",
      "summary": "Fused multiply-add for 52-bit integers (High 52 bits).",
      "syntax": "VPMADD52HUQ zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 B5",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512_IFMA",
      "slug": "vpmadd52huq",
      "rel_url": "x86/vpmadd52huq/",
      "linked_summary": "Fused multiply-<a href=\"../../armv8-a/add_8/\">add</a> for 52-<a href=\"../../armv8-a/bit/\">bit</a> integers (High 52 bits).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aadd",
      "architecture": "x86",
      "full_name": "Atomically Add",
      "summary": "Atomically adds a value to a remote memory location.",
      "syntax": "AADD m32, r32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "66 0F 38 FC",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Mem"
        },
        {
          "name": "src",
          "desc": "Reg"
        }
      ],
      "extension": "RAO-INT",
      "slug": "aadd",
      "rel_url": "x86/aadd/",
      "linked_summary": "Atomically <a href=\"../../armv8-a/adds_5/\">adds</a> a value to a remote memory location.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aand",
      "architecture": "x86",
      "full_name": "Atomically AND",
      "summary": "Atomically ANDs a value to a remote memory location.",
      "syntax": "AAND m32, r32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "66 0F 38 FC /r",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Mem"
        },
        {
          "name": "src",
          "desc": "Reg"
        }
      ],
      "extension": "RAO-INT",
      "slug": "aand",
      "rel_url": "x86/aand/",
      "linked_summary": "Atomically ANDs a value to a remote memory location.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aor",
      "architecture": "x86",
      "full_name": "Atomically OR",
      "summary": "Atomically ORs a value to a remote memory location.",
      "syntax": "AOR m32, r32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "66 0F 38 FC /r",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Mem"
        },
        {
          "name": "src",
          "desc": "Reg"
        }
      ],
      "extension": "RAO-INT",
      "slug": "aor",
      "rel_url": "x86/aor/",
      "linked_summary": "Atomically ORs a value to a remote memory location.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "axor",
      "architecture": "x86",
      "full_name": "Atomically XOR",
      "summary": "Atomically XORs a value to a remote memory location.",
      "syntax": "AXOR m32, r32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "66 0F 38 FC /r",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Mem"
        },
        {
          "name": "src",
          "desc": "Reg"
        }
      ],
      "extension": "RAO-INT",
      "slug": "axor",
      "rel_url": "x86/axor/",
      "linked_summary": "Atomically XORs a value to a remote memory location.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmpccxadd",
      "architecture": "x86",
      "full_name": "Compare and Add if Condition is Met",
      "summary": "Atomically adds if condition is met.",
      "syntax": "CMPccXADD m32, r32, r32",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 E0",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Mem"
        },
        {
          "name": "src1",
          "desc": "Reg"
        },
        {
          "name": "src2",
          "desc": "Reg"
        }
      ],
      "extension": "CMPccXADD",
      "slug": "cmpccxadd",
      "rel_url": "x86/cmpccxadd/",
      "linked_summary": "Atomically <a href=\"../../armv8-a/adds_5/\">adds</a> if condition is met.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "erets",
      "architecture": "x86",
      "full_name": "Event Return Supervisor",
      "summary": "Returns from an event handler to supervisor mode (FRED).",
      "syntax": "ERETS",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F2 0F 01 CA",
        "length": "4",
        "visual_parts": []
      },
      "operands": [],
      "extension": "FRED",
      "slug": "erets",
      "rel_url": "x86/erets/",
      "linked_summary": "Returns from an event handler to supervisor mode (FRED).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "eretu",
      "architecture": "x86",
      "full_name": "Event Return User",
      "summary": "Returns from an event handler to user mode (FRED).",
      "syntax": "ERETU",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 01 CA",
        "length": "4",
        "visual_parts": []
      },
      "operands": [],
      "extension": "FRED",
      "slug": "eretu",
      "rel_url": "x86/eretu/",
      "linked_summary": "Returns from an event handler to user mode (FRED).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lkgs",
      "architecture": "x86",
      "full_name": "Load Kernel GS Base",
      "summary": "Loads the kernel GS base address (FRED support).",
      "syntax": "LKGS r16",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F2 0F 00 /6",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Reg"
        }
      ],
      "extension": "LKGS",
      "slug": "lkgs",
      "rel_url": "x86/lkgs/",
      "linked_summary": "Loads the kernel GS base address (FRED support).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "enqcmd",
      "architecture": "x86",
      "full_name": "Enqueue Command",
      "summary": "Writes a command to a device (DSA/IAA accelerator).",
      "syntax": "ENQCMD r32, m512",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F2 0F 38 F8",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "Mem"
        }
      ],
      "extension": "ENQCMD",
      "slug": "enqcmd",
      "rel_url": "x86/enqcmd/",
      "linked_summary": "Writes a command to a device (DSA/IAA accelerator).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pconfig",
      "architecture": "x86",
      "full_name": "Platform Configuration",
      "summary": "Configures platform features like MKTME (Memory Encryption).",
      "syntax": "PCONFIG",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 C5",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "PCONFIG",
      "slug": "pconfig",
      "rel_url": "x86/pconfig/",
      "linked_summary": "Configures platform features like MKTME (Memory Encryption).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "wbnoinvd",
      "architecture": "x86",
      "full_name": "Write Back and Do Not Invalidate Cache",
      "summary": "Writes back modified lines but keeps them valid in cache.",
      "syntax": "WBNOINVD",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 09",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "WBNOINVD",
      "slug": "wbnoinvd",
      "rel_url": "x86/wbnoinvd/",
      "linked_summary": "Writes back modified lines but keeps them valid <a href=\"../../x86/in/\">in</a> cache.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aesencwide128kl",
      "architecture": "x86",
      "full_name": "AES Encrypt Wide 128-bit Key Locker",
      "summary": "Encrypts 8 blocks using 128-bit Key Locker handle.",
      "syntax": "AESENCWIDE128KL m128",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 38 D8",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "handle",
          "desc": "Mem"
        }
      ],
      "extension": "KEYLOCKER_WIDE",
      "slug": "aesencwide128kl",
      "rel_url": "x86/aesencwide128kl/",
      "linked_summary": "Encrypts 8 blocks using 128-<a href=\"../../armv8-a/bit/\">bit</a> Key Locker handle.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aesencwide256kl",
      "architecture": "x86",
      "full_name": "AES Encrypt Wide 256-bit Key Locker",
      "summary": "Encrypts 8 blocks using 256-bit Key Locker handle.",
      "syntax": "AESENCWIDE256KL m128",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 38 D8 /1",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "handle",
          "desc": "Mem"
        }
      ],
      "extension": "KEYLOCKER_WIDE",
      "slug": "aesencwide256kl",
      "rel_url": "x86/aesencwide256kl/",
      "linked_summary": "Encrypts 8 blocks using 256-<a href=\"../../armv8-a/bit/\">bit</a> Key Locker handle.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fucom",
      "architecture": "x86",
      "full_name": "Unordered Compare Real",
      "summary": "Compares ST(0) with source (supports NaNs).",
      "syntax": "FUCOM ST(i)",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "DD E0+i",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Reg"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fucom",
      "rel_url": "x86/fucom/",
      "linked_summary": "Compares ST(0) with source (supports NaNs).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "frndint",
      "architecture": "x86",
      "full_name": "Round to Integer",
      "summary": "Rounds ST(0) to integer according to RC field.",
      "syntax": "FRNDINT",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 FC",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "frndint",
      "rel_url": "x86/frndint/",
      "linked_summary": "Rounds ST(0) to integer according to RC field.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fscale",
      "architecture": "x86",
      "full_name": "Scale",
      "summary": "Scales ST(0) by ST(1) (ST(0) * 2^ST(1)).",
      "syntax": "FSCALE",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 FD",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fscale",
      "rel_url": "x86/fscale/",
      "linked_summary": "Scales ST(0) by ST(1) (ST(0) * 2^ST(1)).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fxtract",
      "architecture": "x86",
      "full_name": "Extract Exponent and Significand",
      "summary": "Separates exponent and significand of ST(0).",
      "syntax": "FXTRACT",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 F4",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fxtract",
      "rel_url": "x86/fxtract/",
      "linked_summary": "Separates exponent <a href=\"../../armv8-a/and_6/\">and</a> significand of ST(0).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "f2xm1",
      "architecture": "x86",
      "full_name": "Compute 2^x - 1",
      "summary": "Computes (2^ST(0)) - 1.",
      "syntax": "F2XM1",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 F0",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "f2xm1",
      "rel_url": "x86/f2xm1/",
      "linked_summary": "Computes (2^ST(0)) - 1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fyl2xp1",
      "architecture": "x86",
      "full_name": "Compute y * log2(x + 1)",
      "summary": "Computes ST(1) * log2(ST(0) + 1).",
      "syntax": "FYL2XP1",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 F9",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fyl2xp1",
      "rel_url": "x86/fyl2xp1/",
      "linked_summary": "Computes ST(1) * log2(ST(0) + 1).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "clrssbsy",
      "architecture": "x86",
      "full_name": "Clear Shadow Stack Busy Flag",
      "summary": "Clears the busy flag in the shadow stack token.",
      "syntax": "CLRSSBSY m64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F AE /6",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "token",
          "desc": "Mem"
        }
      ],
      "extension": "CET-SS",
      "slug": "clrssbsy",
      "rel_url": "x86/clrssbsy/",
      "linked_summary": "Clears the busy flag <a href=\"../../x86/in/\">in</a> the shadow stack token.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tdpfp16ps",
      "architecture": "x86",
      "full_name": "Tile Dot Product FP16 Packed Single",
      "summary": "Matrix multiply (FP16 * FP16) accumulating to Float32.",
      "syntax": "TDPFP16PS tmm1, tmm2, tmm3",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 5C",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "TMM"
        },
        {
          "name": "src1",
          "desc": "TMM"
        },
        {
          "name": "src2",
          "desc": "TMM"
        }
      ],
      "extension": "AMX-FP16",
      "slug": "tdpfp16ps",
      "rel_url": "x86/tdpfp16ps/",
      "linked_summary": "Matrix multiply (FP16 * FP16) accumulating to Float32.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movss",
      "architecture": "x86",
      "full_name": "Move Scalar Single-Precision",
      "summary": "Moves a single float (low 32 bits) between XMM/Memory.",
      "syntax": "MOVSS xmm1, xmm2/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "F3 0F 10",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "movss",
      "rel_url": "x86/movss/",
      "operands": [],
      "linked_summary": "Moves a single float (low 32 bits) between XMM/Memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movsd",
      "architecture": "x86",
      "full_name": "Move Scalar Double-Precision",
      "summary": "Moves a single double (low 64 bits) between XMM/Memory.",
      "syntax": "MOVSD xmm1, xmm2/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "F2 0F 10",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "movsd",
      "rel_url": "x86/movsd/",
      "operands": [],
      "linked_summary": "Moves a single double (low 64 bits) between XMM/Memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvtdq2pd",
      "architecture": "x86",
      "full_name": "Convert Packed Doubleword to Packed Double-Precision",
      "summary": "Converts two 32-bit integers to two 64-bit doubles.",
      "syntax": "CVTDQ2PD xmm1, xmm2/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "F3 0F E6",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "cvtdq2pd",
      "rel_url": "x86/cvtdq2pd/",
      "operands": [],
      "linked_summary": "Converts two 32-<a href=\"../../armv8-a/bit/\">bit</a> integers to two 64-<a href=\"../../armv8-a/bit/\">bit</a> doubles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvtpd2dq",
      "architecture": "x86",
      "full_name": "Convert Packed Double-Precision to Packed Doubleword",
      "summary": "Converts two doubles to two 32-bit integers (Rounded).",
      "syntax": "CVTPD2DQ xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "F2 0F E6",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "cvtpd2dq",
      "rel_url": "x86/cvtpd2dq/",
      "operands": [],
      "linked_summary": "Converts two doubles to two 32-<a href=\"../../armv8-a/bit/\">bit</a> integers (Rounded).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvttpd2dq",
      "architecture": "x86",
      "full_name": "Convert with Truncation Packed Double to Packed Doubleword",
      "summary": "Converts two doubles to two 32-bit integers (Truncated).",
      "syntax": "CVTTPD2DQ xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F E6",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "cvttpd2dq",
      "rel_url": "x86/cvttpd2dq/",
      "operands": [],
      "linked_summary": "Converts two doubles to two 32-<a href=\"../../armv8-a/bit/\">bit</a> integers (Truncated).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvtss2si",
      "architecture": "x86",
      "full_name": "Convert Scalar Single to Integer",
      "summary": "Converts low float to integer (Rounded according to MXCSR).",
      "syntax": "CVTSS2SI r32, xmm/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "F3 0F 2D",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "cvtss2si",
      "rel_url": "x86/cvtss2si/",
      "operands": [],
      "linked_summary": "Converts low float to integer (Rounded according to MXCSR).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvtsd2si",
      "architecture": "x86",
      "full_name": "Convert Scalar Double to Integer",
      "summary": "Converts low double to integer (Rounded according to MXCSR).",
      "syntax": "CVTSD2SI r32, xmm/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "F2 0F 2D",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "cvtsd2si",
      "rel_url": "x86/cvtsd2si/",
      "operands": [],
      "linked_summary": "Converts low double to integer (Rounded according to MXCSR).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcvtph2ps",
      "architecture": "x86",
      "full_name": "Convert 16-bit FP to 32-bit FP",
      "summary": "Converts half-precision floats to single-precision.",
      "syntax": "VCVTPH2PS xmm1, xmm2/m64",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "66 0F 38 13",
        "visual_parts": []
      },
      "extension": "F16C",
      "slug": "vcvtph2ps",
      "rel_url": "x86/vcvtph2ps/",
      "operands": [],
      "linked_summary": "Converts half-precision floats to single-precision.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcvtps2ph",
      "architecture": "x86",
      "full_name": "Convert 32-bit FP to 16-bit FP",
      "summary": "Converts single-precision floats to half-precision.",
      "syntax": "VCVTPS2PH xmm1/m64, xmm2, imm8",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "66 0F 3A 1D",
        "visual_parts": []
      },
      "extension": "F16C",
      "slug": "vcvtps2ph",
      "rel_url": "x86/vcvtps2ph/",
      "operands": [],
      "linked_summary": "Converts single-precision floats to half-precision.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vtestps",
      "architecture": "x86",
      "full_name": "Packed Bit Test Single-Precision",
      "summary": "Sets ZF/CF based on sign bit comparisons of floats.",
      "syntax": "VTESTPS xmm1, xmm2/m128",
      "encoding": {
        "format": "AVX",
        "hex_opcode": "66 0F 38 0E",
        "visual_parts": []
      },
      "extension": "AVX",
      "slug": "vtestps",
      "rel_url": "x86/vtestps/",
      "operands": [],
      "linked_summary": "Sets ZF/CF based on sign <a href=\"../../armv8-a/bit/\">bit</a> comparisons of floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vtestpd",
      "architecture": "x86",
      "full_name": "Packed Bit Test Double-Precision",
      "summary": "Sets ZF/CF based on sign bit comparisons of doubles.",
      "syntax": "VTESTPD xmm1, xmm2/m128",
      "encoding": {
        "format": "AVX",
        "hex_opcode": "66 0F 38 0F",
        "visual_parts": []
      },
      "extension": "AVX",
      "slug": "vtestpd",
      "rel_url": "x86/vtestpd/",
      "operands": [],
      "linked_summary": "Sets ZF/CF based on sign <a href=\"../../armv8-a/bit/\">bit</a> comparisons of doubles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vperm2f128",
      "architecture": "x86",
      "full_name": "Permute Floating-Point 128-bit Blocks",
      "summary": "Shuffles 128-bit float lanes between YMM registers.",
      "syntax": "VPERM2F128 ymm1, ymm2, ymm3/m256, imm8",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "66 0F 3A 06",
        "visual_parts": []
      },
      "extension": "AVX",
      "slug": "vperm2f128",
      "rel_url": "x86/vperm2f128/",
      "operands": [],
      "linked_summary": "Shuffles 128-<a href=\"../../armv8-a/bit/\">bit</a> float lanes between YMM registers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "prefetcht1",
      "architecture": "x86",
      "full_name": "Prefetch Data to L2 Cache",
      "summary": "Hints to fetch data to L2 and L3 caches.",
      "syntax": "PREFETCHT1 m8",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F 18 /2",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "prefetcht1",
      "rel_url": "x86/prefetcht1/",
      "operands": [],
      "linked_summary": "Hints to fetch data to L2 <a href=\"../../armv8-a/and_6/\">and</a> L3 caches.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "prefetcht2",
      "architecture": "x86",
      "full_name": "Prefetch Data to L3 Cache",
      "summary": "Hints to fetch data to L3 cache only.",
      "syntax": "PREFETCHT2 m8",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F 18 /3",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "prefetcht2",
      "rel_url": "x86/prefetcht2/",
      "operands": [],
      "linked_summary": "Hints to fetch data to L3 cache only.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movsxd",
      "architecture": "x86",
      "full_name": "Move with Sign-Extension Doubleword",
      "summary": "Sign-extends 32-bit register to 64-bit.",
      "syntax": "MOVSXD r64, r/m32",
      "encoding": {
        "format": "Base (64-bit)",
        "hex_opcode": "63",
        "visual_parts": []
      },
      "extension": "Base (64-bit)",
      "slug": "movsxd",
      "rel_url": "x86/movsxd/",
      "operands": [],
      "linked_summary": "Sign-extends 32-<a href=\"../../armv8-a/bit/\">bit</a> register to 64-<a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "int1",
      "architecture": "x86",
      "full_name": "ICE Breakpoint",
      "summary": "Single byte opcode (0xF1) used for In-Circuit Emulation.",
      "syntax": "INT1",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F1",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "int1",
      "rel_url": "x86/int1/",
      "operands": [],
      "linked_summary": "Single byte opcode (0xF1) used for In-Circuit Emulation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpcmov",
      "architecture": "x86",
      "full_name": "Vector Packed Conditional Move",
      "summary": "Bitwise conditional move based on selector.",
      "syntax": "VPCMOV xmm1, xmm2, xmm3, xmm4",
      "encoding": {
        "format": "XOP",
        "hex_opcode": "08 A2",
        "visual_parts": []
      },
      "extension": "XOP",
      "slug": "vpcmov",
      "rel_url": "x86/vpcmov/",
      "operands": [],
      "linked_summary": "Bitwise conditional move based on selector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpcomb",
      "architecture": "x86",
      "full_name": "Vector Packed Compare Byte",
      "summary": "Compares bytes using immediate condition.",
      "syntax": "VPCOMB xmm1, xmm2, xmm3/m128, imm8",
      "encoding": {
        "format": "XOP",
        "hex_opcode": "08 CC",
        "visual_parts": []
      },
      "extension": "XOP",
      "slug": "vpcomb",
      "rel_url": "x86/vpcomb/",
      "operands": [],
      "linked_summary": "Compares bytes using immediate condition.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "blcfill",
      "architecture": "x86",
      "full_name": "Fill From Lowest Clear Bit",
      "summary": "Sets all bits below the lowest clear bit (x & (x+1)).",
      "syntax": "BLCFILL r32, r/m32",
      "encoding": {
        "format": "TBM",
        "hex_opcode": "8F ... 01",
        "visual_parts": []
      },
      "extension": "TBM",
      "slug": "blcfill",
      "rel_url": "x86/blcfill/",
      "operands": [],
      "linked_summary": "Sets all bits below the lowest clear <a href=\"../../armv8-a/bit/\">bit</a> (x & (x+1)).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vgetexpss",
      "architecture": "x86",
      "full_name": "Get Exponent Scalar Single",
      "summary": "Extracts exponent from low float.",
      "syntax": "VGETEXPSS xmm1 {k1}, xmm2, xmm3/m32",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 43",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vgetexpss",
      "rel_url": "x86/vgetexpss/",
      "operands": [],
      "linked_summary": "Extracts exponent from low float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vgetmantsd",
      "architecture": "x86",
      "full_name": "Get Mantissa Scalar Double",
      "summary": "Extracts mantissa from low double.",
      "syntax": "VGETMANTSD xmm1 {k1}, xmm2, xmm3/m64, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 27",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vgetmantsd",
      "rel_url": "x86/vgetmantsd/",
      "operands": [],
      "linked_summary": "Extracts mantissa from low double.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movq",
      "architecture": "x86",
      "full_name": "Move Quadword (MMX)",
      "summary": "Moves 64-bit data between MMX registers/memory.",
      "syntax": "MOVQ mm, mm/m64",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F 6F",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "movq",
      "rel_url": "x86/movq/",
      "operands": [],
      "linked_summary": "Moves 64-<a href=\"../../armv8-a/bit/\">bit</a> data between MMX registers/memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "paddusb",
      "architecture": "x86",
      "full_name": "Packed Add Unsigned Saturate Byte (MMX)",
      "summary": "Adds 8 unsigned bytes with saturation (MMX).",
      "syntax": "PADDUSB mm, mm/m64",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F DC",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "paddusb",
      "rel_url": "x86/paddusb/",
      "operands": [],
      "linked_summary": "Adds 8 unsigned bytes with saturation (MMX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "paddsb",
      "architecture": "x86",
      "full_name": "Packed Add Signed Saturate Byte (MMX)",
      "summary": "Adds 8 signed bytes with saturation (MMX).",
      "syntax": "PADDSB mm, mm/m64",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F EC",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "paddsb",
      "rel_url": "x86/paddsb/",
      "operands": [],
      "linked_summary": "Adds 8 signed bytes with saturation (MMX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "paddusw",
      "architecture": "x86",
      "full_name": "Packed Add Unsigned Saturate Word (MMX)",
      "summary": "Adds 4 unsigned words with saturation (MMX).",
      "syntax": "PADDUSW mm, mm/m64",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F DD",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "paddusw",
      "rel_url": "x86/paddusw/",
      "operands": [],
      "linked_summary": "Adds 4 unsigned words with saturation (MMX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "paddsw",
      "architecture": "x86",
      "full_name": "Packed Add Signed Saturate Word (MMX)",
      "summary": "Adds 4 signed words with saturation (MMX).",
      "syntax": "PADDSW mm, mm/m64",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F ED",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "paddsw",
      "rel_url": "x86/paddsw/",
      "operands": [],
      "linked_summary": "Adds 4 signed words with saturation (MMX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psubusb",
      "architecture": "x86",
      "full_name": "Packed Subtract Unsigned Saturate Byte (MMX)",
      "summary": "Subtracts 8 unsigned bytes with saturation (MMX).",
      "syntax": "PSUBUSB mm, mm/m64",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F D8",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "psubusb",
      "rel_url": "x86/psubusb/",
      "operands": [],
      "linked_summary": "Subtracts 8 unsigned bytes with saturation (MMX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psubsb",
      "architecture": "x86",
      "full_name": "Packed Subtract Signed Saturate Byte (MMX)",
      "summary": "Subtracts 8 signed bytes with saturation (MMX).",
      "syntax": "PSUBSB mm, mm/m64",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F E8",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "psubsb",
      "rel_url": "x86/psubsb/",
      "operands": [],
      "linked_summary": "Subtracts 8 signed bytes with saturation (MMX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psubusw",
      "architecture": "x86",
      "full_name": "Packed Subtract Unsigned Saturate Word (MMX)",
      "summary": "Subtracts 4 unsigned words with saturation (MMX).",
      "syntax": "PSUBUSW mm, mm/m64",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F D9",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "psubusw",
      "rel_url": "x86/psubusw/",
      "operands": [],
      "linked_summary": "Subtracts 4 unsigned words with saturation (MMX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psubsw",
      "architecture": "x86",
      "full_name": "Packed Subtract Signed Saturate Word (MMX)",
      "summary": "Subtracts 4 signed words with saturation (MMX).",
      "syntax": "PSUBSW mm, mm/m64",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F E9",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "psubsw",
      "rel_url": "x86/psubsw/",
      "operands": [],
      "linked_summary": "Subtracts 4 signed words with saturation (MMX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmullw",
      "architecture": "x86",
      "full_name": "Packed Multiply Low Word (MMX)",
      "summary": "Multiplies 4 words and stores low 16 bits (MMX).",
      "syntax": "PMULLW mm, mm/m64",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F D5",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "pmullw",
      "rel_url": "x86/pmullw/",
      "operands": [],
      "linked_summary": "Multiplies 4 words <a href=\"../../armv8-a/and_6/\">and</a> stores low 16 bits (MMX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmulhw",
      "architecture": "x86",
      "full_name": "Packed Multiply High Word (MMX)",
      "summary": "Multiplies 4 signed words and stores high 16 bits (MMX).",
      "syntax": "PMULHW mm, mm/m64",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F E5",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "pmulhw",
      "rel_url": "x86/pmulhw/",
      "operands": [],
      "linked_summary": "Multiplies 4 signed words <a href=\"../../armv8-a/and_6/\">and</a> stores high 16 bits (MMX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmaddwd",
      "architecture": "x86",
      "full_name": "Packed Multiply Add Word to Doubleword (MMX)",
      "summary": "Multiplies words and adds adjacent pairs (MMX).",
      "syntax": "PMADDWD mm, mm/m64",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F F5",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "pmaddwd",
      "rel_url": "x86/pmaddwd/",
      "operands": [],
      "linked_summary": "Multiplies words <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../armv8-a/adds_5/\">adds</a> adjacent pairs (MMX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pand",
      "architecture": "x86",
      "full_name": "Packed Logical AND (MMX)",
      "summary": "Bitwise AND of 64-bit MMX registers.",
      "syntax": "PAND mm, mm/m64",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F DB",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "pand",
      "rel_url": "x86/pand/",
      "operands": [],
      "linked_summary": "Bitwise <a href=\"../../armv9-a/and_1/\">AND</a> of 64-<a href=\"../../armv8-a/bit/\">bit</a> MMX registers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "por",
      "architecture": "x86",
      "full_name": "Packed Logical OR (MMX)",
      "summary": "Bitwise OR of 64-bit MMX registers.",
      "syntax": "POR mm, mm/m64",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F EB",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "por",
      "rel_url": "x86/por/",
      "operands": [],
      "linked_summary": "Bitwise <a href=\"../../risc-v/or/\">OR</a> of 64-<a href=\"../../armv8-a/bit/\">bit</a> MMX registers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pxor",
      "architecture": "x86",
      "full_name": "Packed Logical XOR (MMX)",
      "summary": "Bitwise XOR of 64-bit MMX registers.",
      "syntax": "PXOR mm, mm/m64",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F EF",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "pxor",
      "rel_url": "x86/pxor/",
      "operands": [],
      "linked_summary": "Bitwise <a href=\"../../risc-v/xor/\">XOR</a> of 64-<a href=\"../../armv8-a/bit/\">bit</a> MMX registers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pandn",
      "architecture": "x86",
      "full_name": "Packed Logical AND NOT (MMX)",
      "summary": "Bitwise AND NOT of 64-bit MMX registers.",
      "syntax": "PANDN mm, mm/m64",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F DF",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "pandn",
      "rel_url": "x86/pandn/",
      "operands": [],
      "linked_summary": "Bitwise <a href=\"../../armv9-a/and_1/\">AND</a> <a href=\"../../armv9-a/not/\">NOT</a> of 64-<a href=\"../../armv8-a/bit/\">bit</a> MMX registers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pcmpgtb",
      "architecture": "x86",
      "full_name": "Packed Compare Greater Than Byte (MMX)",
      "summary": "Compares bytes for greater than (MMX).",
      "syntax": "PCMPGTB mm, mm/m64",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F 64",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "pcmpgtb",
      "rel_url": "x86/pcmpgtb/",
      "operands": [],
      "linked_summary": "Compares bytes for greater than (MMX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pcmpgtw",
      "architecture": "x86",
      "full_name": "Packed Compare Greater Than Word (MMX)",
      "summary": "Compares words for greater than (MMX).",
      "syntax": "PCMPGTW mm, mm/m64",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F 65",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "pcmpgtw",
      "rel_url": "x86/pcmpgtw/",
      "operands": [],
      "linked_summary": "Compares words for greater than (MMX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pcmpgtd",
      "architecture": "x86",
      "full_name": "Packed Compare Greater Than Doubleword (MMX)",
      "summary": "Compares doublewords for greater than (MMX).",
      "syntax": "PCMPGTD mm, mm/m64",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F 66",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "pcmpgtd",
      "rel_url": "x86/pcmpgtd/",
      "operands": [],
      "linked_summary": "Compares doublewords for greater than (MMX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pcmpeqb",
      "architecture": "x86",
      "full_name": "Packed Compare Equal Byte (MMX)",
      "summary": "Compares bytes for equality (MMX).",
      "syntax": "PCMPEQB mm, mm/m64",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F 74",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "pcmpeqb",
      "rel_url": "x86/pcmpeqb/",
      "operands": [],
      "linked_summary": "Compares bytes for equality (MMX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pcmpeqw",
      "architecture": "x86",
      "full_name": "Packed Compare Equal Word (MMX)",
      "summary": "Compares words for equality (MMX).",
      "syntax": "PCMPEQW mm, mm/m64",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F 75",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "pcmpeqw",
      "rel_url": "x86/pcmpeqw/",
      "operands": [],
      "linked_summary": "Compares words for equality (MMX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pcmpeqd",
      "architecture": "x86",
      "full_name": "Packed Compare Equal Doubleword (MMX)",
      "summary": "Compares doublewords for equality (MMX).",
      "syntax": "PCMPEQD mm, mm/m64",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F 76",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "pcmpeqd",
      "rel_url": "x86/pcmpeqd/",
      "operands": [],
      "linked_summary": "Compares doublewords for equality (MMX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psllw",
      "architecture": "x86",
      "full_name": "Packed Shift Left Logical Word (MMX)",
      "summary": "Shifts words left (MMX).",
      "syntax": "PSLLW mm, imm8",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F 71 /6",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "psllw",
      "rel_url": "x86/psllw/",
      "operands": [],
      "linked_summary": "Shifts words left (MMX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pslld",
      "architecture": "x86",
      "full_name": "Packed Shift Left Logical Doubleword (MMX)",
      "summary": "Shifts doublewords left (MMX).",
      "syntax": "PSLLD mm, imm8",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F 72 /6",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "pslld",
      "rel_url": "x86/pslld/",
      "operands": [],
      "linked_summary": "Shifts doublewords left (MMX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psllq",
      "architecture": "x86",
      "full_name": "Packed Shift Left Logical Quadword (MMX)",
      "summary": "Shifts quadword left (MMX).",
      "syntax": "PSLLQ mm, imm8",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F 73 /6",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "psllq",
      "rel_url": "x86/psllq/",
      "operands": [],
      "linked_summary": "Shifts quadword left (MMX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psrlw",
      "architecture": "x86",
      "full_name": "Packed Shift Right Logical Word (MMX)",
      "summary": "Shifts words right logical (MMX).",
      "syntax": "PSRLW mm, imm8",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F 71 /2",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "psrlw",
      "rel_url": "x86/psrlw/",
      "operands": [],
      "linked_summary": "Shifts words right logical (MMX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psrld",
      "architecture": "x86",
      "full_name": "Packed Shift Right Logical Doubleword (MMX)",
      "summary": "Shifts doublewords right logical (MMX).",
      "syntax": "PSRLD mm, imm8",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F 72 /2",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "psrld",
      "rel_url": "x86/psrld/",
      "operands": [],
      "linked_summary": "Shifts doublewords right logical (MMX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psrlq",
      "architecture": "x86",
      "full_name": "Packed Shift Right Logical Quadword (MMX)",
      "summary": "Shifts quadword right logical (MMX).",
      "syntax": "PSRLQ mm, imm8",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F 73 /2",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "psrlq",
      "rel_url": "x86/psrlq/",
      "operands": [],
      "linked_summary": "Shifts quadword right logical (MMX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psraw",
      "architecture": "x86",
      "full_name": "Packed Shift Right Arithmetic Word (MMX)",
      "summary": "Shifts words right arithmetic (MMX).",
      "syntax": "PSRAW mm, imm8",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F 71 /4",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "psraw",
      "rel_url": "x86/psraw/",
      "operands": [],
      "linked_summary": "Shifts words right arithmetic (MMX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psrad",
      "architecture": "x86",
      "full_name": "Packed Shift Right Arithmetic Doubleword (MMX)",
      "summary": "Shifts doublewords right arithmetic (MMX).",
      "syntax": "PSRAD mm, imm8",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F 72 /4",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "psrad",
      "rel_url": "x86/psrad/",
      "operands": [],
      "linked_summary": "Shifts doublewords right arithmetic (MMX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mov",
      "architecture": "x86",
      "full_name": "Move",
      "summary": "Copies data from source to destination.",
      "syntax": "MOV r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x89",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        },
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "Base",
      "slug": "mov_1",
      "rel_url": "x86/mov_1/",
      "linked_summary": "Copies data from source to destination.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "add",
      "architecture": "x86",
      "full_name": "Add",
      "summary": "Adds src to dest and stores result in dest.",
      "syntax": "ADD r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x01",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        },
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "Base",
      "slug": "add_1",
      "rel_url": "x86/add_1/",
      "linked_summary": "Adds src to dest <a href=\"../../armv8-a/and_6/\">and</a> stores result <a href=\"../../x86/in/\">in</a> dest.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sub",
      "architecture": "x86",
      "full_name": "Subtract",
      "summary": "Subtracts src from dest.",
      "syntax": "SUB r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x29",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        },
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "Base",
      "slug": "sub_1",
      "rel_url": "x86/sub_1/",
      "linked_summary": "Subtracts src from dest.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "inc",
      "architecture": "x86",
      "full_name": "Increment",
      "summary": "Increments the operand by 1.",
      "syntax": "INC r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xFF /0",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        }
      ],
      "extension": "Base",
      "slug": "inc_1",
      "rel_url": "x86/inc_1/",
      "linked_summary": "Increments the operand by 1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dec",
      "architecture": "x86",
      "full_name": "Decrement",
      "summary": "Decrements the operand by 1.",
      "syntax": "DEC r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xFF /1",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        }
      ],
      "extension": "Base",
      "slug": "dec_1",
      "rel_url": "x86/dec_1/",
      "linked_summary": "Decrements the operand by 1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mul",
      "architecture": "x86",
      "full_name": "Unsigned Multiply",
      "summary": "Unsigned multiply (AX = AL * src).",
      "syntax": "MUL r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xF7 /4",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Register/Memory"
        }
      ],
      "extension": "Base",
      "slug": "mul_1",
      "rel_url": "x86/mul_1/",
      "linked_summary": "Unsigned multiply (AX = AL * src).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "imul",
      "architecture": "x86",
      "full_name": "Signed Multiply",
      "summary": "Signed multiply.",
      "syntax": "IMUL r, r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F AF",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "Base",
      "slug": "imul_1",
      "rel_url": "x86/imul_1/",
      "linked_summary": "Signed multiply.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "div",
      "architecture": "x86",
      "full_name": "Unsigned Divide",
      "summary": "Unsigned divide (AX / src).",
      "syntax": "DIV r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xF7 /6",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Register/Memory"
        }
      ],
      "extension": "Base",
      "slug": "div_1",
      "rel_url": "x86/div_1/",
      "linked_summary": "Unsigned divide (AX / src).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "idiv",
      "architecture": "x86",
      "full_name": "Signed Divide",
      "summary": "Signed divide (AX / src).",
      "syntax": "IDIV r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xF7 /7",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Register/Memory"
        }
      ],
      "extension": "Base",
      "slug": "idiv_1",
      "rel_url": "x86/idiv_1/",
      "linked_summary": "Signed divide (AX / src).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "and",
      "architecture": "x86",
      "full_name": "Logical AND",
      "summary": "Performs bitwise AND.",
      "syntax": "AND r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x21",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        },
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "Base",
      "slug": "and_1",
      "rel_url": "x86/and_1/",
      "linked_summary": "Performs bitwise <a href=\"../../armv9-a/and_1/\">AND</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "or",
      "architecture": "x86",
      "full_name": "Logical OR",
      "summary": "Performs bitwise OR.",
      "syntax": "OR r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x09",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        },
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "Base",
      "slug": "or_1",
      "rel_url": "x86/or_1/",
      "linked_summary": "Performs bitwise <a href=\"../../risc-v/or/\">OR</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xor",
      "architecture": "x86",
      "full_name": "Logical Exclusive OR",
      "summary": "Performs bitwise XOR.",
      "syntax": "XOR r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x31",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        },
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "Base",
      "slug": "xor_1",
      "rel_url": "x86/xor_1/",
      "linked_summary": "Performs bitwise <a href=\"../../risc-v/xor/\">XOR</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "not",
      "architecture": "x86",
      "full_name": "One's Complement Negation",
      "summary": "Reverses bits of operand.",
      "syntax": "NOT r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xF7 /2",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        }
      ],
      "extension": "Base",
      "slug": "not_1",
      "rel_url": "x86/not_1/",
      "linked_summary": "Reverses bits of operand.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "neg",
      "architecture": "x86",
      "full_name": "Two's Complement Negation",
      "summary": "Negates value (0 - operand).",
      "syntax": "NEG r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xF7 /3",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        }
      ],
      "extension": "Base",
      "slug": "neg_1",
      "rel_url": "x86/neg_1/",
      "linked_summary": "Negates value (0 - operand).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "shl",
      "architecture": "x86",
      "full_name": "Shift Logical Left",
      "summary": "Shifts bits left (same as SAL).",
      "syntax": "SHL r/m, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xC1 /4",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        },
        {
          "name": "count",
          "desc": "Immediate"
        }
      ],
      "extension": "Base",
      "slug": "shl_1",
      "rel_url": "x86/shl_1/",
      "linked_summary": "Shifts bits left (same as SAL).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "shr",
      "architecture": "x86",
      "full_name": "Shift Logical Right",
      "summary": "Shifts bits right, filling with zeros.",
      "syntax": "SHR r/m, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xC1 /5",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        },
        {
          "name": "count",
          "desc": "Immediate"
        }
      ],
      "extension": "Base",
      "slug": "shr_1",
      "rel_url": "x86/shr_1/",
      "linked_summary": "Shifts bits right, filling with zeros.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sar",
      "architecture": "x86",
      "full_name": "Shift Arithmetic Right",
      "summary": "Shifts bits right, preserving sign bit.",
      "syntax": "SAR r/m, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xC1 /7",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        },
        {
          "name": "count",
          "desc": "Immediate"
        }
      ],
      "extension": "Base",
      "slug": "sar_1",
      "rel_url": "x86/sar_1/",
      "linked_summary": "Shifts bits right, preserving sign <a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmp",
      "architecture": "x86",
      "full_name": "Compare Two Operands",
      "summary": "Subtracts src from dest and updates flags (dest not modified).",
      "syntax": "CMP r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x39",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        },
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "Base",
      "slug": "cmp_1",
      "rel_url": "x86/cmp_1/",
      "linked_summary": "Subtracts src from dest <a href=\"../../armv8-a/and_6/\">and</a> updates flags (dest <a href=\"../../armv8-a/not_1/\">not</a> modified).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "test",
      "architecture": "x86",
      "full_name": "Logical Compare",
      "summary": "ANDs operands and updates flags (result discarded).",
      "syntax": "TEST r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x85",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register/Memory"
        },
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "Base",
      "slug": "test_1",
      "rel_url": "x86/test_1/",
      "linked_summary": "ANDs operands <a href=\"../../armv8-a/and_6/\">and</a> updates flags (result discarded).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "jmp",
      "architecture": "x86",
      "full_name": "Jump",
      "summary": "Unconditional jump to target.",
      "syntax": "JMP rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xE9",
        "length": "5",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "rel",
          "desc": "Offset"
        }
      ],
      "extension": "Base",
      "slug": "jmp_1",
      "rel_url": "x86/jmp_1/",
      "linked_summary": "Unconditional jump to target.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "je",
      "architecture": "x86",
      "full_name": "Jump if Equal",
      "summary": "Jump if ZF=1 (Same as JZ).",
      "syntax": "JE rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x74",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "rel",
          "desc": "Offset"
        }
      ],
      "extension": "Base",
      "slug": "je_1",
      "rel_url": "x86/je_1/",
      "linked_summary": "Jump if ZF=1 (Same as JZ).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "jne",
      "architecture": "x86",
      "full_name": "Jump if Not Equal",
      "summary": "Jump if ZF=0 (Same as JNZ).",
      "syntax": "JNE rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x75",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "rel",
          "desc": "Offset"
        }
      ],
      "extension": "Base",
      "slug": "jne_1",
      "rel_url": "x86/jne_1/",
      "linked_summary": "Jump if ZF=0 (Same as JNZ).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "jg",
      "architecture": "x86",
      "full_name": "Jump if Greater",
      "summary": "Jump if ZF=0 and SF=OF (Signed >).",
      "syntax": "JG rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x7F",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "rel",
          "desc": "Offset"
        }
      ],
      "extension": "Base",
      "slug": "jg_1",
      "rel_url": "x86/jg_1/",
      "linked_summary": "Jump if ZF=0 <a href=\"../../armv8-a/and_6/\">and</a> SF=OF (Signed >).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "jl",
      "architecture": "x86",
      "full_name": "Jump if Less",
      "summary": "Jump if SF!=OF (Signed <).",
      "syntax": "JL rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x7C",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "rel",
          "desc": "Offset"
        }
      ],
      "extension": "Base",
      "slug": "jl_1",
      "rel_url": "x86/jl_1/",
      "linked_summary": "Jump if SF!=OF (Signed <).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ja",
      "architecture": "x86",
      "full_name": "Jump if Above",
      "summary": "Jump if CF=0 and ZF=0 (Unsigned >).",
      "syntax": "JA rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x77",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "rel",
          "desc": "Offset"
        }
      ],
      "extension": "Base",
      "slug": "ja_1",
      "rel_url": "x86/ja_1/",
      "linked_summary": "Jump if CF=0 <a href=\"../../armv8-a/and_6/\">and</a> ZF=0 (Unsigned >).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "jb",
      "architecture": "x86",
      "full_name": "Jump if Below",
      "summary": "Jump if CF=1 (Unsigned <).",
      "syntax": "JB rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x72",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "rel",
          "desc": "Offset"
        }
      ],
      "extension": "Base",
      "slug": "jb_1",
      "rel_url": "x86/jb_1/",
      "linked_summary": "Jump if CF=1 (Unsigned <).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "call",
      "architecture": "x86",
      "full_name": "Call Procedure",
      "summary": "Push EIP/RIP and jump to target.",
      "syntax": "CALL rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xE8",
        "length": "5",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "rel",
          "desc": "Offset"
        }
      ],
      "extension": "Base",
      "slug": "call_1",
      "rel_url": "x86/call_1/",
      "linked_summary": "Push EIP/RIP <a href=\"../../armv8-a/and_6/\">and</a> jump to target.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ret",
      "architecture": "x86",
      "full_name": "Return from Procedure",
      "summary": "Pop EIP/RIP and resume execution.",
      "syntax": "RET",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xC3",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "ret_1",
      "rel_url": "x86/ret_1/",
      "linked_summary": "Pop EIP/RIP <a href=\"../../armv8-a/and_6/\">and</a> resume execution.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "push",
      "architecture": "x86",
      "full_name": "Push Word/Doubleword/Quadword Onto Stack",
      "summary": "Decrements SP and stores operand on stack.",
      "syntax": "PUSH r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xFF /6",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "Base",
      "slug": "push_1",
      "rel_url": "x86/push_1/",
      "linked_summary": "Decrements SP <a href=\"../../armv8-a/and_6/\">and</a> stores operand on stack.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pop",
      "architecture": "x86",
      "full_name": "Pop Value from Stack",
      "summary": "Loads operand from stack and increments SP.",
      "syntax": "POP r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x8F /0",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "Base",
      "slug": "pop_1",
      "rel_url": "x86/pop_1/",
      "linked_summary": "Loads operand from stack <a href=\"../../armv8-a/and_6/\">and</a> increments SP.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lea",
      "architecture": "x86",
      "full_name": "Load Effective Address",
      "summary": "Computes effective address and stores in register.",
      "syntax": "LEA r, m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x8D",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register"
        },
        {
          "name": "src",
          "desc": "Memory"
        }
      ],
      "extension": "Base",
      "slug": "lea_1",
      "rel_url": "x86/lea_1/",
      "linked_summary": "Computes effective address <a href=\"../../armv8-a/and_6/\">and</a> stores <a href=\"../../x86/in/\">in</a> register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "nop",
      "architecture": "x86",
      "full_name": "No Operation",
      "summary": "Does nothing (alias for XCHG EAX, EAX).",
      "syntax": "NOP",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x90",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "nop_1",
      "rel_url": "x86/nop_1/",
      "linked_summary": "Does nothing (alias for XCHG EAX, EAX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xchg",
      "architecture": "x86",
      "full_name": "Exchange Register/Memory with Register",
      "summary": "Exchanges content of two operands.",
      "syntax": "XCHG r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x87",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "op1",
          "desc": "Reg/Mem"
        },
        {
          "name": "op2",
          "desc": "Register"
        }
      ],
      "extension": "Base",
      "slug": "xchg_1",
      "rel_url": "x86/xchg_1/",
      "linked_summary": "Exchanges content of two operands.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cpuid",
      "architecture": "x86",
      "full_name": "CPU Identification",
      "summary": "Returns processor information based on EAX value.",
      "syntax": "CPUID",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F A2",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "cpuid_1",
      "rel_url": "x86/cpuid_1/",
      "linked_summary": "Returns processor information based on EAX value.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rdtsc",
      "architecture": "x86",
      "full_name": "Read Time-Stamp Counter",
      "summary": "Reads the time-stamp counter into EDX:EAX.",
      "syntax": "RDTSC",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F 31",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "rdtsc_1",
      "rel_url": "x86/rdtsc_1/",
      "linked_summary": "Reads the time-stamp counter into EDX:EAX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movsx",
      "architecture": "x86",
      "full_name": "Move with Sign-Extension",
      "summary": "Copies and sign-extends a smaller value to a larger register.",
      "syntax": "MOVSX r, r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F BE",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "Base",
      "slug": "movsx_1",
      "rel_url": "x86/movsx_1/",
      "linked_summary": "Copies <a href=\"../../armv8-a/and_6/\">and</a> sign-extends a smaller value to a larger register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movzx",
      "architecture": "x86",
      "full_name": "Move with Zero-Extension",
      "summary": "Copies and zero-extends a smaller value to a larger register.",
      "syntax": "MOVZX r, r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F B6",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "Base",
      "slug": "movzx_1",
      "rel_url": "x86/movzx_1/",
      "linked_summary": "Copies <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../armv9-a/zero_2/\">zero</a>-extends a smaller value to a larger register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cwtl",
      "architecture": "x86",
      "full_name": "Convert Word to Long",
      "summary": "Sign-extends AX into EAX (also CWDE).",
      "syntax": "CWTL",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x98",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "cwtl_1",
      "rel_url": "x86/cwtl_1/",
      "linked_summary": "Sign-extends AX into EAX (also CWDE).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cltd",
      "architecture": "x86",
      "full_name": "Convert Long to Double Long",
      "summary": "Sign-extends EAX into EDX:EAX (also CDQ).",
      "syntax": "CLTD",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x99",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "cltd_1",
      "rel_url": "x86/cltd_1/",
      "linked_summary": "Sign-extends EAX into EDX:EAX (also CDQ).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cqto",
      "architecture": "x86",
      "full_name": "Convert Quadword to Octoword",
      "summary": "Sign-extends RAX into RDX:RAX (also CQO).",
      "syntax": "CQTO",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x48 99",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base (64-bit)",
      "slug": "cqto_1",
      "rel_url": "x86/cqto_1/",
      "linked_summary": "Sign-extends RAX into RDX:RAX (also CQO).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bswap",
      "architecture": "x86",
      "full_name": "Byte Swap",
      "summary": "Reverses the byte order of a register (Endian swap).",
      "syntax": "BSWAP r32",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F C8+rd",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "reg",
          "desc": "Register"
        }
      ],
      "extension": "Base",
      "slug": "bswap_2",
      "rel_url": "x86/bswap_2/",
      "linked_summary": "Reverses the byte order of a register (Endian swap).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xadd",
      "architecture": "x86",
      "full_name": "Exchange and Add",
      "summary": "Exchanges dest and src, then loads sum into dest.",
      "syntax": "XADD r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F C1",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        },
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "Base",
      "slug": "xadd_1",
      "rel_url": "x86/xadd_1/",
      "linked_summary": "Exchanges dest <a href=\"../../armv8-a/and_6/\">and</a> src, then loads sum into dest.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmpxchg",
      "architecture": "x86",
      "full_name": "Compare and Exchange",
      "summary": "Compares accumulator with dest; if equal, dest = src; else accumulator = dest.",
      "syntax": "CMPXCHG r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F B1",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        },
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "Base",
      "slug": "cmpxchg_1",
      "rel_url": "x86/cmpxchg_1/",
      "linked_summary": "Compares accumulator with dest; if equal, dest = src; else accumulator = dest.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmovcc",
      "architecture": "x86",
      "full_name": "Conditional Move",
      "summary": "Moves data if condition code is met (e.g., CMOVE, CMOVNE).",
      "syntax": "CMOVcc r, r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F 4x",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "CMOV",
      "slug": "cmovcc_1",
      "rel_url": "x86/cmovcc_1/",
      "linked_summary": "Moves data if condition code is met (e.g., CMOVE, CMOVNE).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "setcc",
      "architecture": "x86",
      "full_name": "Set Byte on Condition",
      "summary": "Sets byte to 1 if condition met, else 0 (e.g., SETE, SETZ).",
      "syntax": "SETcc r/m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F 9x",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "Base",
      "slug": "setcc_1",
      "rel_url": "x86/setcc_1/",
      "linked_summary": "Sets byte to 1 if condition met, else 0 (e.g., SETE, SETZ).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "hlt",
      "architecture": "x86",
      "full_name": "Halt",
      "summary": "Stops instruction execution and places processor in HALT state.",
      "syntax": "HLT",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xF4",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "hlt_1",
      "rel_url": "x86/hlt_1/",
      "linked_summary": "Stops instruction execution <a href=\"../../armv8-a/and_6/\">and</a> places processor <a href=\"../../x86/in/\">in</a> HALT state.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "int",
      "architecture": "x86",
      "full_name": "Interrupt",
      "summary": "Calls to interrupt procedure.",
      "syntax": "INT imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xCD",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "vector",
          "desc": "ID"
        }
      ],
      "extension": "Base",
      "slug": "int_1",
      "rel_url": "x86/int_1/",
      "linked_summary": "Calls to interrupt procedure.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "int3",
      "architecture": "x86",
      "full_name": "Breakpoint",
      "summary": "Calls to interrupt vector 3 (Debugger breakpoint).",
      "syntax": "INT3",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xCC",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "int3_1",
      "rel_url": "x86/int3_1/",
      "linked_summary": "Calls to interrupt vector 3 (Debugger breakpoint).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ud2",
      "architecture": "x86",
      "full_name": "Undefined Instruction",
      "summary": "Generates an invalid opcode exception.",
      "syntax": "UD2",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F 0B",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "ud2_1",
      "rel_url": "x86/ud2_1/",
      "linked_summary": "Generates an invalid opcode exception.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pause",
      "architecture": "x86",
      "full_name": "Spin Loop Hint",
      "summary": "Improves performance of spin-wait loops (alias for REP NOP).",
      "syntax": "PAUSE",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xF3 90",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "pause_1",
      "rel_url": "x86/pause_1/",
      "linked_summary": "Improves performance of spin-<a href=\"../../powerisa/wait_1/\">wait</a> loops (alias for REP <a href=\"../../risc-v/nop/\">NOP</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "clc",
      "architecture": "x86",
      "full_name": "Clear Carry Flag",
      "summary": "Sets the CF flag to 0.",
      "syntax": "CLC",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xF8",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "clc_1",
      "rel_url": "x86/clc_1/",
      "linked_summary": "Sets the CF flag to 0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stc",
      "architecture": "x86",
      "full_name": "Set Carry Flag",
      "summary": "Sets the CF flag to 1.",
      "syntax": "STC",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xF9",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "stc_1",
      "rel_url": "x86/stc_1/",
      "linked_summary": "Sets the CF flag to 1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmc",
      "architecture": "x86",
      "full_name": "Complement Carry Flag",
      "summary": "Toggles the CF flag.",
      "syntax": "CMC",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xF5",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "cmc_1",
      "rel_url": "x86/cmc_1/",
      "linked_summary": "Toggles the CF flag.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cld",
      "architecture": "x86",
      "full_name": "Clear Direction Flag",
      "summary": "Sets DF to 0 (String operations increment).",
      "syntax": "CLD",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xFC",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "cld_1",
      "rel_url": "x86/cld_1/",
      "linked_summary": "Sets DF to 0 (String operations increment).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "std",
      "architecture": "x86",
      "full_name": "Set Direction Flag",
      "summary": "Sets DF to 1 (String operations decrement).",
      "syntax": "STD",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xFD",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "std_1",
      "rel_url": "x86/std_1/",
      "linked_summary": "Sets DF to 1 (String operations decrement).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cli",
      "architecture": "x86",
      "full_name": "Clear Interrupt Flag",
      "summary": "Disables maskable hardware interrupts.",
      "syntax": "CLI",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xFA",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "cli_1",
      "rel_url": "x86/cli_1/",
      "linked_summary": "Disables maskable hardware interrupts.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sti",
      "architecture": "x86",
      "full_name": "Set Interrupt Flag",
      "summary": "Enables maskable hardware interrupts.",
      "syntax": "STI",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xFB",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "sti_1",
      "rel_url": "x86/sti_1/",
      "linked_summary": "Enables maskable hardware interrupts.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sahf",
      "architecture": "x86",
      "full_name": "Store AH into Flags",
      "summary": "Loads SF, ZF, AF, PF, and CF from AH.",
      "syntax": "SAHF",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x9E",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "sahf_1",
      "rel_url": "x86/sahf_1/",
      "linked_summary": "Loads SF, ZF, AF, PF, <a href=\"../../armv8-a/and_6/\">and</a> CF from AH.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lahf",
      "architecture": "x86",
      "full_name": "Load Flags into AH",
      "summary": "Loads bits 0, 2, 4, 6, and 7 of EFLAGS into AH.",
      "syntax": "LAHF",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x9F",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "lahf_1",
      "rel_url": "x86/lahf_1/",
      "linked_summary": "Loads bits 0, 2, 4, 6, <a href=\"../../armv8-a/and_6/\">and</a> 7 of EFLAGS into AH.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "loop",
      "architecture": "x86",
      "full_name": "Loop",
      "summary": "Decrements ECX/RCX and jumps if not zero.",
      "syntax": "LOOP rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xE2",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "rel",
          "desc": "Offset"
        }
      ],
      "extension": "Base",
      "slug": "loop_1",
      "rel_url": "x86/loop_1/",
      "linked_summary": "Decrements ECX/RCX <a href=\"../../armv8-a/and_6/\">and</a> jumps if <a href=\"../../armv8-a/not_1/\">not</a> <a href=\"../../armv9-a/zero_2/\">zero</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "loope",
      "architecture": "x86",
      "full_name": "Loop if Equal",
      "summary": "Decrements count; jumps if count!=0 and ZF=1.",
      "syntax": "LOOPE rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xE1",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "rel",
          "desc": "Offset"
        }
      ],
      "extension": "Base",
      "slug": "loope_1",
      "rel_url": "x86/loope_1/",
      "linked_summary": "Decrements count; jumps if count!=0 <a href=\"../../armv8-a/and_6/\">and</a> ZF=1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "loopne",
      "architecture": "x86",
      "full_name": "Loop if Not Equal",
      "summary": "Decrements count; jumps if count!=0 and ZF=0.",
      "syntax": "LOOPNE rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xE0",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "rel",
          "desc": "Offset"
        }
      ],
      "extension": "Base",
      "slug": "loopne_1",
      "rel_url": "x86/loopne_1/",
      "linked_summary": "Decrements count; jumps if count!=0 <a href=\"../../armv8-a/and_6/\">and</a> ZF=0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "jecxz",
      "architecture": "x86",
      "full_name": "Jump if ECX is Zero",
      "summary": "Jumps if ECX register is 0.",
      "syntax": "JECXZ rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xE3",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "rel",
          "desc": "Offset"
        }
      ],
      "extension": "Base",
      "slug": "jecxz_1",
      "rel_url": "x86/jecxz_1/",
      "linked_summary": "Jumps if ECX register is 0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "enter",
      "architecture": "x86",
      "full_name": "Make Stack Frame",
      "summary": "Creates a stack frame for procedure parameters.",
      "syntax": "ENTER imm16, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xC8",
        "length": "4",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "alloc",
          "desc": "Bytes"
        },
        {
          "name": "nesting",
          "desc": "Level"
        }
      ],
      "extension": "Base",
      "slug": "enter_1",
      "rel_url": "x86/enter_1/",
      "linked_summary": "Creates a stack frame for procedure parameters.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "leave",
      "architecture": "x86",
      "full_name": "High Level Procedure Exit",
      "summary": "Releases stack frame (MOV ESP, EBP; POP EBP).",
      "syntax": "LEAVE",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xC9",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "leave_1",
      "rel_url": "x86/leave_1/",
      "linked_summary": "Releases stack frame (<a href=\"../../armv9-a/mov/\">MOV</a> ESP, EBP; POP EBP).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rep movs",
      "architecture": "x86",
      "full_name": "Repeat Move String",
      "summary": "Moves ECX bytes/words from [ESI] to [EDI].",
      "syntax": "REP MOVS m, m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xF3 A4/A5",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "rep_movs_1",
      "rel_url": "x86/rep_movs_1/",
      "linked_summary": "Moves ECX bytes/words from [ESI] to [EDI].",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rep stos",
      "architecture": "x86",
      "full_name": "Repeat Store String",
      "summary": "Fills [EDI] with AL/AX/EAX for ECX repeats.",
      "syntax": "REP STOS m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xF3 AA/AB",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "rep_stos_1",
      "rel_url": "x86/rep_stos_1/",
      "linked_summary": "Fills [EDI] with AL/AX/EAX for ECX repeats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "repe cmps",
      "architecture": "x86",
      "full_name": "Repeat Compare String Equal",
      "summary": "Compares [ESI] and [EDI] until mismatch or ECX=0.",
      "syntax": "REPE CMPS m, m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xF3 A6/A7",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "repe_cmps_1",
      "rel_url": "x86/repe_cmps_1/",
      "linked_summary": "Compares [ESI] <a href=\"../../armv8-a/and_6/\">and</a> [EDI] until mismatch <a href=\"../../powerisa/or/\">or</a> ECX=0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "repne scas",
      "architecture": "x86",
      "full_name": "Repeat Scan String Not Equal",
      "summary": "Scans [EDI] for AL/AX/EAX until match or ECX=0.",
      "syntax": "REPNE SCAS m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xF2 AE/AF",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "repne_scas_1",
      "rel_url": "x86/repne_scas_1/",
      "linked_summary": "Scans [EDI] for AL/AX/EAX until <a href=\"../../armv9-a/match_2/\">match</a> <a href=\"../../powerisa/or/\">or</a> ECX=0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rol",
      "architecture": "x86",
      "full_name": "Rotate Left",
      "summary": "Rotates bits left.",
      "syntax": "ROL r/m, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xC1 /0",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "Base",
      "slug": "rol_1",
      "rel_url": "x86/rol_1/",
      "linked_summary": "Rotates bits left.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ror",
      "architecture": "x86",
      "full_name": "Rotate Right",
      "summary": "Rotates bits right.",
      "syntax": "ROR r/m, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xC1 /1",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "Base",
      "slug": "ror_1",
      "rel_url": "x86/ror_1/",
      "linked_summary": "Rotates bits right.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rcl",
      "architecture": "x86",
      "full_name": "Rotate Carry Left",
      "summary": "Rotates bits left through Carry Flag.",
      "syntax": "RCL r/m, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xC1 /2",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "Base",
      "slug": "rcl_1",
      "rel_url": "x86/rcl_1/",
      "linked_summary": "Rotates bits left through Carry Flag.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rcr",
      "architecture": "x86",
      "full_name": "Rotate Carry Right",
      "summary": "Rotates bits right through Carry Flag.",
      "syntax": "RCR r/m, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xC1 /3",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "Base",
      "slug": "rcr_1",
      "rel_url": "x86/rcr_1/",
      "linked_summary": "Rotates bits right through Carry Flag.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bt",
      "architecture": "x86",
      "full_name": "Bit Test",
      "summary": "Selects a bit and stores it in CF.",
      "syntax": "BT r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F A3",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "base",
          "desc": "Reg/Mem"
        },
        {
          "name": "offset",
          "desc": "Reg"
        }
      ],
      "extension": "Base",
      "slug": "bt_1",
      "rel_url": "x86/bt_1/",
      "linked_summary": "Selects a <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../armv8-a/and_6/\">and</a> stores <a href=\"../../armv8-a/it/\">it</a> <a href=\"../../x86/in/\">in</a> CF.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bts",
      "architecture": "x86",
      "full_name": "Bit Test and Set",
      "summary": "Stores bit in CF and sets bit to 1.",
      "syntax": "BTS r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F AB",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "base",
          "desc": "Reg/Mem"
        },
        {
          "name": "offset",
          "desc": "Reg"
        }
      ],
      "extension": "Base",
      "slug": "bts_1",
      "rel_url": "x86/bts_1/",
      "linked_summary": "Stores <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> CF <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../x86/sets/\">sets</a> <a href=\"../../armv8-a/bit/\">bit</a> to 1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "btr",
      "architecture": "x86",
      "full_name": "Bit Test and Reset",
      "summary": "Stores bit in CF and clears bit to 0.",
      "syntax": "BTR r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F B3",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "base",
          "desc": "Reg/Mem"
        },
        {
          "name": "offset",
          "desc": "Reg"
        }
      ],
      "extension": "Base",
      "slug": "btr_1",
      "rel_url": "x86/btr_1/",
      "linked_summary": "Stores <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> CF <a href=\"../../armv8-a/and_6/\">and</a> clears <a href=\"../../armv8-a/bit/\">bit</a> to 0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "btc",
      "architecture": "x86",
      "full_name": "Bit Test and Complement",
      "summary": "Stores bit in CF and complements the bit.",
      "syntax": "BTC r/m, r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F BB",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "base",
          "desc": "Reg/Mem"
        },
        {
          "name": "offset",
          "desc": "Reg"
        }
      ],
      "extension": "Base",
      "slug": "btc_1",
      "rel_url": "x86/btc_1/",
      "linked_summary": "Stores <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/in/\">in</a> CF <a href=\"../../armv8-a/and_6/\">and</a> complements the <a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bsf",
      "architecture": "x86",
      "full_name": "Bit Scan Forward",
      "summary": "Scans for LSB set to 1.",
      "syntax": "BSF r, r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F BC",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "Base",
      "slug": "bsf_1",
      "rel_url": "x86/bsf_1/",
      "linked_summary": "Scans for LSB set to 1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bsr",
      "architecture": "x86",
      "full_name": "Bit Scan Reverse",
      "summary": "Scans for MSB set to 1.",
      "syntax": "BSR r, r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F BD",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "Base",
      "slug": "bsr_1",
      "rel_url": "x86/bsr_1/",
      "linked_summary": "Scans for <a href=\"../../armv9-a/msb/\">MSB</a> set to 1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xlat",
      "architecture": "x86",
      "full_name": "Table Look-up Translation",
      "summary": "Replaces AL with byte from table at [EBX+AL].",
      "syntax": "XLAT m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD7",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "xlat_1",
      "rel_url": "x86/xlat_1/",
      "linked_summary": "Replaces AL with byte from table <a href=\"../../armv8-a/at_2/\">at</a> [EBX+AL].",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pushf",
      "architecture": "x86",
      "full_name": "Push Flags",
      "summary": "Pushes EFLAGS onto stack.",
      "syntax": "PUSHF",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x9C",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "pushf_1",
      "rel_url": "x86/pushf_1/",
      "linked_summary": "Pushes EFLAGS onto stack.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "popf",
      "architecture": "x86",
      "full_name": "Pop Flags",
      "summary": "Pops stack into EFLAGS.",
      "syntax": "POPF",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x9D",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "popf_1",
      "rel_url": "x86/popf_1/",
      "linked_summary": "Pops stack into EFLAGS.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pusha",
      "architecture": "x86",
      "full_name": "Push All General-Purpose Registers",
      "summary": "Pushes AX, CX, DX, BX, SP, BP, SI, DI (Invalid in 64-bit).",
      "syntax": "PUSHA",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x60",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base (32-bit only)",
      "slug": "pusha_1",
      "rel_url": "x86/pusha_1/",
      "linked_summary": "Pushes AX, CX, DX, BX, SP, BP, SI, DI (Invalid <a href=\"../../x86/in/\">in</a> 64-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "popa",
      "architecture": "x86",
      "full_name": "Pop All General-Purpose Registers",
      "summary": "Pops into DI, SI, BP, SP, BX, DX, CX, AX (Invalid in 64-bit).",
      "syntax": "POPA",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x61",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base (32-bit only)",
      "slug": "popa_1",
      "rel_url": "x86/popa_1/",
      "linked_summary": "Pops into DI, SI, BP, SP, BX, DX, CX, AX (Invalid <a href=\"../../x86/in/\">in</a> 64-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bound",
      "architecture": "x86",
      "full_name": "Check Array Index Against Bounds",
      "summary": "Checks if operand is within bounds defined in memory.",
      "syntax": "BOUND r, m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x62",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "idx",
          "desc": "Register"
        },
        {
          "name": "bounds",
          "desc": "Memory"
        }
      ],
      "extension": "Base (32-bit only)",
      "slug": "bound_1",
      "rel_url": "x86/bound_1/",
      "linked_summary": "Checks if operand is within bounds defined <a href=\"../../x86/in/\">in</a> memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aaa",
      "architecture": "x86",
      "full_name": "ASCII Adjust After Addition",
      "summary": "Adjusts AL after addition for unpacked BCD.",
      "syntax": "AAA",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x37",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base (Legacy)",
      "slug": "aaa_1",
      "rel_url": "x86/aaa_1/",
      "linked_summary": "Adjusts AL after addition for unpacked BCD.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aas",
      "architecture": "x86",
      "full_name": "ASCII Adjust After Subtraction",
      "summary": "Adjusts AL after subtraction for unpacked BCD.",
      "syntax": "AAS",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x3F",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base (Legacy)",
      "slug": "aas_1",
      "rel_url": "x86/aas_1/",
      "linked_summary": "Adjusts AL after subtraction for unpacked BCD.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "daa",
      "architecture": "x86",
      "full_name": "Decimal Adjust After Addition",
      "summary": "Adjusts AL after addition for packed BCD.",
      "syntax": "DAA",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x27",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base (Legacy)",
      "slug": "daa_1",
      "rel_url": "x86/daa_1/",
      "linked_summary": "Adjusts AL after addition for packed BCD.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "das",
      "architecture": "x86",
      "full_name": "Decimal Adjust After Subtraction",
      "summary": "Adjusts AL after subtraction for packed BCD.",
      "syntax": "DAS",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x2F",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base (Legacy)",
      "slug": "das_1",
      "rel_url": "x86/das_1/",
      "linked_summary": "Adjusts AL after subtraction for packed BCD.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aam",
      "architecture": "x86",
      "full_name": "ASCII Adjust After Multiply",
      "summary": "Adjusts AX after multiply for unpacked BCD.",
      "syntax": "AAM imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD4",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base (Legacy)",
      "slug": "aam_1",
      "rel_url": "x86/aam_1/",
      "linked_summary": "Adjusts AX after multiply for unpacked BCD.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aad",
      "architecture": "x86",
      "full_name": "ASCII Adjust Before Division",
      "summary": "Adjusts AX before division for unpacked BCD.",
      "syntax": "AAD imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD5",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base (Legacy)",
      "slug": "aad_1",
      "rel_url": "x86/aad_1/",
      "linked_summary": "Adjusts AX before division for unpacked BCD.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cbw",
      "architecture": "x86",
      "full_name": "Convert Byte to Word",
      "summary": "Sign-extends AL into AX.",
      "syntax": "CBW",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x98",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "cbw_1",
      "rel_url": "x86/cbw_1/",
      "linked_summary": "Sign-extends AL into AX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cwd",
      "architecture": "x86",
      "full_name": "Convert Word to Doubleword",
      "summary": "Sign-extends AX into DX:AX.",
      "syntax": "CWD",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x99",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "cwd_1",
      "rel_url": "x86/cwd_1/",
      "linked_summary": "Sign-extends AX into DX:AX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "wait",
      "architecture": "x86",
      "full_name": "Wait",
      "summary": "Wait for FPU (same as FWAIT).",
      "syntax": "WAIT",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x9B",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "wait_1",
      "rel_url": "x86/wait_1/",
      "linked_summary": "Wait for FPU (same as FWAIT).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lfence",
      "architecture": "x86",
      "full_name": "Load Fence",
      "summary": "Serializes load operations (Wait for prior loads to complete).",
      "syntax": "LFENCE",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0F AE E8",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "lfence",
      "rel_url": "x86/lfence/",
      "operands": [],
      "linked_summary": "Serializes load operations (Wait for prior loads to complete).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sfence",
      "architecture": "x86",
      "full_name": "Store Fence",
      "summary": "Serializes store operations (Wait for prior stores to complete).",
      "syntax": "SFENCE",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F AE F8",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "sfence",
      "rel_url": "x86/sfence/",
      "operands": [],
      "linked_summary": "Serializes store operations (Wait for prior stores to complete).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mfence",
      "architecture": "x86",
      "full_name": "Memory Fence",
      "summary": "Serializes all load and store operations.",
      "syntax": "MFENCE",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0F AE F0",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "mfence",
      "rel_url": "x86/mfence/",
      "operands": [],
      "linked_summary": "Serializes all load <a href=\"../../armv8-a/and_6/\">and</a> store operations.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "clflush",
      "architecture": "x86",
      "full_name": "Cache Line Flush",
      "summary": "Flushes the cache line containing the operand from all caches.",
      "syntax": "CLFLUSH m8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0F AE /7",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "clflush",
      "rel_url": "x86/clflush/",
      "operands": [],
      "linked_summary": "Flushes the cache line containing the operand from all caches.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rdtscp",
      "architecture": "x86",
      "full_name": "Read Time-Stamp Counter and Processor ID",
      "summary": "Reads TSC into EDX:EAX and Processor ID into ECX.",
      "syntax": "RDTSCP",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 F9",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "rdtscp",
      "rel_url": "x86/rdtscp/",
      "operands": [],
      "linked_summary": "Reads TSC into EDX:EAX <a href=\"../../armv8-a/and_6/\">and</a> Processor ID into ECX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsave",
      "architecture": "x86",
      "full_name": "Save Processor Extended States",
      "summary": "Saves specified state components (AVX, SSE, etc.) to memory.",
      "syntax": "XSAVE m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F AE /4",
        "visual_parts": []
      },
      "extension": "XSAVE",
      "slug": "xsave",
      "rel_url": "x86/xsave/",
      "operands": [],
      "linked_summary": "Saves specified state components (AVX, SSE, etc.) to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xrstor",
      "architecture": "x86",
      "full_name": "Restore Processor Extended States",
      "summary": "Restores specified state components from memory.",
      "syntax": "XRSTOR m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F AE /5",
        "visual_parts": []
      },
      "extension": "XSAVE",
      "slug": "xrstor",
      "rel_url": "x86/xrstor/",
      "operands": [],
      "linked_summary": "Restores specified state components from memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xgetbv",
      "architecture": "x86",
      "full_name": "Get Value of Extended Control Register",
      "summary": "Reads the state of XCR0 (feature mask) into EDX:EAX.",
      "syntax": "XGETBV",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 D0",
        "visual_parts": []
      },
      "extension": "XSAVE",
      "slug": "xgetbv",
      "rel_url": "x86/xgetbv/",
      "operands": [],
      "linked_summary": "Reads the state of XCR0 (feature mask) into EDX:EAX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsetbv",
      "architecture": "x86",
      "full_name": "Set Value of Extended Control Register",
      "summary": "Writes EDX:EAX to XCR0 (Enables/disables AVX/SSE states).",
      "syntax": "XSETBV",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 D1",
        "visual_parts": []
      },
      "extension": "XSAVE",
      "slug": "xsetbv",
      "rel_url": "x86/xsetbv/",
      "operands": [],
      "linked_summary": "Writes EDX:EAX to XCR0 (Enables/disables AVX/SSE states).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "shufps",
      "architecture": "x86",
      "full_name": "Shuffle Packed Single-Precision",
      "summary": "Shuffles 32-bit floats between two XMM registers.",
      "syntax": "SHUFPS xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F C6",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "shufps",
      "rel_url": "x86/shufps/",
      "operands": [],
      "linked_summary": "Shuffles 32-<a href=\"../../armv8-a/bit/\">bit</a> floats between two XMM registers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "shufpd",
      "architecture": "x86",
      "full_name": "Shuffle Packed Double-Precision",
      "summary": "Shuffles 64-bit doubles between two XMM registers.",
      "syntax": "SHUFPD xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F C6",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "shufpd",
      "rel_url": "x86/shufpd/",
      "operands": [],
      "linked_summary": "Shuffles 64-<a href=\"../../armv8-a/bit/\">bit</a> doubles between two XMM registers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "unpcklps",
      "architecture": "x86",
      "full_name": "Unpack Low Packed Single-Precision",
      "summary": "Interleaves low floats from two registers.",
      "syntax": "UNPCKLPS xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F 14",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "unpcklps",
      "rel_url": "x86/unpcklps/",
      "operands": [],
      "linked_summary": "Interleaves low floats from two registers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "unpckhps",
      "architecture": "x86",
      "full_name": "Unpack High Packed Single-Precision",
      "summary": "Interleaves high floats from two registers.",
      "syntax": "UNPCKHPS xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F 15",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "unpckhps",
      "rel_url": "x86/unpckhps/",
      "operands": [],
      "linked_summary": "Interleaves high floats from two registers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movntps",
      "architecture": "x86",
      "full_name": "Move Non-Temporal Packed Single",
      "summary": "Stores float vectors directly to RAM, bypassing cache.",
      "syntax": "MOVNTPS m128, xmm",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F 2B",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "movntps",
      "rel_url": "x86/movntps/",
      "operands": [],
      "linked_summary": "Stores float vectors directly to RAM, bypassing cache.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movntpd",
      "architecture": "x86",
      "full_name": "Move Non-Temporal Packed Double",
      "summary": "Stores double vectors directly to RAM, bypassing cache.",
      "syntax": "MOVNTPD m128, xmm",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 2B",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "movntpd",
      "rel_url": "x86/movntpd/",
      "operands": [],
      "linked_summary": "Stores double vectors directly to RAM, bypassing cache.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "blendpd",
      "architecture": "x86",
      "full_name": "Blend Packed Double-Precision",
      "summary": "Selects doubles from two sources based on immediate mask.",
      "syntax": "BLENDPD xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 3A 0D",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "blendpd",
      "rel_url": "x86/blendpd/",
      "operands": [],
      "linked_summary": "Selects doubles from two sources based on immediate mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "insertps",
      "architecture": "x86",
      "full_name": "Insert Packed Single-Precision",
      "summary": "Inserts a single float into a specific index of XMM.",
      "syntax": "INSERTPS xmm1, xmm2/m32, imm8",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 3A 21",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "insertps",
      "rel_url": "x86/insertps/",
      "operands": [],
      "linked_summary": "Inserts a single float into a specific <a href=\"../../armv8-a/index/\">index</a> of XMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "extractps",
      "architecture": "x86",
      "full_name": "Extract Packed Single-Precision",
      "summary": "Extracts a single float from XMM to an integer register.",
      "syntax": "EXTRACTPS r32/m32, xmm1, imm8",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 3A 17",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "extractps",
      "rel_url": "x86/extractps/",
      "operands": [],
      "linked_summary": "Extracts a single float from XMM to an integer register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dpps",
      "architecture": "x86",
      "full_name": "Dot Product Packed Single-Precision",
      "summary": "Computes the dot product of two float vectors.",
      "syntax": "DPPS xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 3A 40",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "dpps",
      "rel_url": "x86/dpps/",
      "operands": [],
      "linked_summary": "Computes the dot product of two float vectors.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "dppd",
      "architecture": "x86",
      "full_name": "Dot Product Packed Double-Precision",
      "summary": "Computes the dot product of two double vectors.",
      "syntax": "DPPD xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 3A 41",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "dppd",
      "rel_url": "x86/dppd/",
      "operands": [],
      "linked_summary": "Computes the dot product of two double vectors.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "roundps",
      "architecture": "x86",
      "full_name": "Round Packed Single-Precision",
      "summary": "Rounds all packed floats according to immediate mode.",
      "syntax": "ROUNDPS xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 3A 08",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "roundps",
      "rel_url": "x86/roundps/",
      "operands": [],
      "linked_summary": "Rounds all packed floats according to immediate mode.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "roundpd",
      "architecture": "x86",
      "full_name": "Round Packed Double-Precision",
      "summary": "Rounds all packed doubles according to immediate mode.",
      "syntax": "ROUNDPD xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 3A 09",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "roundpd",
      "rel_url": "x86/roundpd/",
      "operands": [],
      "linked_summary": "Rounds all packed doubles according to immediate mode.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pcmpeqq",
      "architecture": "x86",
      "full_name": "Packed Compare Equal Quadword",
      "summary": "Checks if 64-bit integer elements are equal.",
      "syntax": "PCMPEQQ xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 29",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "pcmpeqq",
      "rel_url": "x86/pcmpeqq/",
      "operands": [],
      "linked_summary": "Checks if 64-<a href=\"../../armv8-a/bit/\">bit</a> integer elements are equal.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pcmpestri",
      "architecture": "x86",
      "full_name": "Packed Compare Explicit Length Strings, Return Index",
      "summary": "Complex string search/compare; returns index in ECX.",
      "syntax": "PCMPESTRI xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "SSE4.2",
        "hex_opcode": "66 0F 3A 61",
        "visual_parts": []
      },
      "extension": "SSE4.2",
      "slug": "pcmpestri",
      "rel_url": "x86/pcmpestri/",
      "operands": [],
      "linked_summary": "Complex string search/compare; returns <a href=\"../../armv8-a/index/\">index</a> <a href=\"../../x86/in/\">in</a> ECX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pcmpestrm",
      "architecture": "x86",
      "full_name": "Packed Compare Explicit Length Strings, Return Mask",
      "summary": "Complex string search/compare; returns mask in XMM0.",
      "syntax": "PCMPESTRM xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "SSE4.2",
        "hex_opcode": "66 0F 3A 60",
        "visual_parts": []
      },
      "extension": "SSE4.2",
      "slug": "pcmpestrm",
      "rel_url": "x86/pcmpestrm/",
      "operands": [],
      "linked_summary": "Complex string search/compare; returns mask <a href=\"../../x86/in/\">in</a> XMM0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pcmpistri",
      "architecture": "x86",
      "full_name": "Packed Compare Implicit Length Strings, Return Index",
      "summary": "String search (null-terminated); returns index in ECX.",
      "syntax": "PCMPISTRI xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "SSE4.2",
        "hex_opcode": "66 0F 3A 63",
        "visual_parts": []
      },
      "extension": "SSE4.2",
      "slug": "pcmpistri",
      "rel_url": "x86/pcmpistri/",
      "operands": [],
      "linked_summary": "String search (null-terminated); returns <a href=\"../../armv8-a/index/\">index</a> <a href=\"../../x86/in/\">in</a> ECX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfmadd132ss",
      "architecture": "x86",
      "full_name": "Fused Multiply-Add Scalar Single (132)",
      "summary": "Scalar FMA: Dest = (Dest * Src2) + Src1.",
      "syntax": "VFMADD132SS xmm1, xmm2, xmm3/m32",
      "encoding": {
        "format": "FMA3",
        "hex_opcode": "C4 ... 99",
        "visual_parts": []
      },
      "extension": "FMA3",
      "slug": "vfmadd132ss",
      "rel_url": "x86/vfmadd132ss/",
      "operands": [],
      "linked_summary": "Scalar FMA: Dest = (Dest * Src2) + Src1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfmadd213ss",
      "architecture": "x86",
      "full_name": "Fused Multiply-Add Scalar Single (213)",
      "summary": "Scalar FMA: Dest = (Src1 * Dest) + Src2.",
      "syntax": "VFMADD213SS xmm1, xmm2, xmm3/m32",
      "encoding": {
        "format": "FMA3",
        "hex_opcode": "C4 ... A9",
        "visual_parts": []
      },
      "extension": "FMA3",
      "slug": "vfmadd213ss",
      "rel_url": "x86/vfmadd213ss/",
      "operands": [],
      "linked_summary": "Scalar FMA: Dest = (Src1 * Dest) + Src2.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfmadd231ss",
      "architecture": "x86",
      "full_name": "Fused Multiply-Add Scalar Single (231)",
      "summary": "Scalar FMA: Dest = (Src1 * Src2) + Dest.",
      "syntax": "VFMADD231SS xmm1, xmm2, xmm3/m32",
      "encoding": {
        "format": "FMA3",
        "hex_opcode": "C4 ... B9",
        "visual_parts": []
      },
      "extension": "FMA3",
      "slug": "vfmadd231ss",
      "rel_url": "x86/vfmadd231ss/",
      "operands": [],
      "linked_summary": "Scalar FMA: Dest = (Src1 * Src2) + Dest.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpermilps",
      "architecture": "x86",
      "full_name": "Permute In-Lane Packed Single",
      "summary": "Shuffles floats within 128-bit lanes (AVX).",
      "syntax": "VPERMILPS ymm1, ymm2/m256, imm8",
      "encoding": {
        "format": "AVX",
        "hex_opcode": "C4 ... 04",
        "visual_parts": []
      },
      "extension": "AVX",
      "slug": "vpermilps",
      "rel_url": "x86/vpermilps/",
      "operands": [],
      "linked_summary": "Shuffles floats within 128-<a href=\"../../armv8-a/bit/\">bit</a> lanes (AVX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpermilpd",
      "architecture": "x86",
      "full_name": "Permute In-Lane Packed Double",
      "summary": "Shuffles doubles within 128-bit lanes (AVX).",
      "syntax": "VPERMILPD ymm1, ymm2/m256, imm8",
      "encoding": {
        "format": "AVX",
        "hex_opcode": "C4 ... 05",
        "visual_parts": []
      },
      "extension": "AVX",
      "slug": "vpermilpd",
      "rel_url": "x86/vpermilpd/",
      "operands": [],
      "linked_summary": "Shuffles doubles within 128-<a href=\"../../armv8-a/bit/\">bit</a> lanes (AVX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vbroadcastss",
      "architecture": "x86",
      "full_name": "Broadcast Scalar Single",
      "summary": "Loads one float and replicates it to all YMM elements.",
      "syntax": "VBROADCASTSS ymm1, m32",
      "encoding": {
        "format": "AVX",
        "hex_opcode": "C4 ... 18",
        "visual_parts": []
      },
      "extension": "AVX",
      "slug": "vbroadcastss",
      "rel_url": "x86/vbroadcastss/",
      "operands": [],
      "linked_summary": "Loads one float <a href=\"../../armv8-a/and_6/\">and</a> replicates <a href=\"../../armv8-a/it/\">it</a> to all YMM elements.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpbroadcastd",
      "architecture": "x86",
      "full_name": "Broadcast Doubleword",
      "summary": "Loads one integer and replicates it to all YMM elements.",
      "syntax": "VPBROADCASTD ymm1, xmm2/m32",
      "encoding": {
        "format": "AVX2",
        "hex_opcode": "C4 ... 58",
        "visual_parts": []
      },
      "extension": "AVX2",
      "slug": "vpbroadcastd",
      "rel_url": "x86/vpbroadcastd/",
      "operands": [],
      "linked_summary": "Loads one integer <a href=\"../../armv8-a/and_6/\">and</a> replicates <a href=\"../../armv8-a/it/\">it</a> to all YMM elements.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pclmulqdq",
      "architecture": "x86",
      "full_name": "Carry-Less Multiplication",
      "summary": "Performs carry-less multiplication (Galois Field math for AES-GCM).",
      "syntax": "PCLMULQDQ xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "PCLMUL",
        "hex_opcode": "66 0F 3A 44",
        "visual_parts": []
      },
      "extension": "PCLMULQDQ",
      "slug": "pclmulqdq",
      "rel_url": "x86/pclmulqdq/",
      "operands": [],
      "linked_summary": "Performs carry-less multiplication (Galois Field math for AES-GCM).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "crc32",
      "architecture": "x86",
      "full_name": "Accumulate CRC32 Value",
      "summary": "Accumulates CRC32C value using polynomial 0x11EDC6F41.",
      "syntax": "CRC32 r32, r/m",
      "encoding": {
        "format": "SSE4.2",
        "hex_opcode": "F2 0F 38 F1",
        "visual_parts": []
      },
      "extension": "SSE4.2",
      "slug": "crc32",
      "rel_url": "x86/crc32/",
      "operands": [],
      "linked_summary": "Accumulates CRC32C value using polynomial 0x11EDC6F41.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvtsq2ss",
      "architecture": "x86",
      "full_name": "Convert Signed Quadword Integer to Scalar Single-Precision",
      "summary": "Converts 64-bit integer to float.",
      "syntax": "CVTSQ2SS xmm1, r/m64",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "F3 0F 2A",
        "visual_parts": []
      },
      "extension": "Base (64-bit)",
      "slug": "cvtsq2ss",
      "rel_url": "x86/cvtsq2ss/",
      "operands": [],
      "linked_summary": "Converts 64-<a href=\"../../armv8-a/bit/\">bit</a> integer to float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvtsq2sd",
      "architecture": "x86",
      "full_name": "Convert Signed Quadword Integer to Scalar Double-Precision",
      "summary": "Converts 64-bit integer to double.",
      "syntax": "CVTSQ2SD xmm1, r/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "F2 0F 2A",
        "visual_parts": []
      },
      "extension": "Base (64-bit)",
      "slug": "cvtsq2sd",
      "rel_url": "x86/cvtsq2sd/",
      "operands": [],
      "linked_summary": "Converts 64-<a href=\"../../armv8-a/bit/\">bit</a> integer to double.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvtss2sq",
      "architecture": "x86",
      "full_name": "Convert Scalar Single-Precision to Signed Quadword Integer",
      "summary": "Converts float to 64-bit integer (Rounded).",
      "syntax": "CVTSS2SQ r64, xmm/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "F3 0F 2D",
        "visual_parts": []
      },
      "extension": "Base (64-bit)",
      "slug": "cvtss2sq",
      "rel_url": "x86/cvtss2sq/",
      "operands": [],
      "linked_summary": "Converts float to 64-<a href=\"../../armv8-a/bit/\">bit</a> integer (Rounded).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvtsd2sq",
      "architecture": "x86",
      "full_name": "Convert Scalar Double-Precision to Signed Quadword Integer",
      "summary": "Converts double to 64-bit integer (Rounded).",
      "syntax": "CVTSD2SQ r64, xmm/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "F2 0F 2D",
        "visual_parts": []
      },
      "extension": "Base (64-bit)",
      "slug": "cvtsd2sq",
      "rel_url": "x86/cvtsd2sq/",
      "operands": [],
      "linked_summary": "Converts double to 64-<a href=\"../../armv8-a/bit/\">bit</a> integer (Rounded).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvttss2sq",
      "architecture": "x86",
      "full_name": "Convert with Truncation Scalar Single-Precision to Signed Quadword Integer",
      "summary": "Converts float to 64-bit integer (Truncated).",
      "syntax": "CVTTSS2SQ r64, xmm/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "F3 0F 2C",
        "visual_parts": []
      },
      "extension": "Base (64-bit)",
      "slug": "cvttss2sq",
      "rel_url": "x86/cvttss2sq/",
      "operands": [],
      "linked_summary": "Converts float to 64-<a href=\"../../armv8-a/bit/\">bit</a> integer (Truncated).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvttsd2sq",
      "architecture": "x86",
      "full_name": "Convert with Truncation Scalar Double-Precision to Signed Quadword Integer",
      "summary": "Converts double to 64-bit integer (Truncated).",
      "syntax": "CVTTSD2SQ r64, xmm/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "F2 0F 2C",
        "visual_parts": []
      },
      "extension": "Base (64-bit)",
      "slug": "cvttsd2sq",
      "rel_url": "x86/cvttsd2sq/",
      "operands": [],
      "linked_summary": "Converts double to 64-<a href=\"../../armv8-a/bit/\">bit</a> integer (Truncated).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "haddpd",
      "architecture": "x86",
      "full_name": "Horizontal Add Packed Double-Precision",
      "summary": "Adds adjacent double-precision elements horizontally.",
      "syntax": "HADDPD xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE3",
        "hex_opcode": "66 0F 7C",
        "visual_parts": []
      },
      "extension": "SSE3",
      "slug": "haddpd",
      "rel_url": "x86/haddpd/",
      "operands": [],
      "linked_summary": "Adds adjacent double-precision elements horizontally.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "hsubps",
      "architecture": "x86",
      "full_name": "Horizontal Subtract Packed Single-Precision",
      "summary": "Subtracts adjacent single-precision elements horizontally.",
      "syntax": "HSUBPS xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE3",
        "hex_opcode": "F2 0F 7D",
        "visual_parts": []
      },
      "extension": "SSE3",
      "slug": "hsubps",
      "rel_url": "x86/hsubps/",
      "operands": [],
      "linked_summary": "Subtracts adjacent single-precision elements horizontally.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "hsubpd",
      "architecture": "x86",
      "full_name": "Horizontal Subtract Packed Double-Precision",
      "summary": "Subtracts adjacent double-precision elements horizontally.",
      "syntax": "HSUBPD xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE3",
        "hex_opcode": "66 0F 7D",
        "visual_parts": []
      },
      "extension": "SSE3",
      "slug": "hsubpd",
      "rel_url": "x86/hsubpd/",
      "operands": [],
      "linked_summary": "Subtracts adjacent double-precision elements horizontally.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "addsubpd",
      "architecture": "x86",
      "full_name": "Packed Double-FP Add/Subtract",
      "summary": "Adds odd elements, subtracts even elements (Double).",
      "syntax": "ADDSUBPD xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE3",
        "hex_opcode": "66 0F D0",
        "visual_parts": []
      },
      "extension": "SSE3",
      "slug": "addsubpd",
      "rel_url": "x86/addsubpd/",
      "operands": [],
      "linked_summary": "Adds odd elements, subtracts even elements (Double).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpermi2q",
      "architecture": "x86",
      "full_name": "Permute Two-Source Quadwords",
      "summary": "Shuffles quadwords from two ZMM registers into destination.",
      "syntax": "VPERMI2Q zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 76",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vpermi2q",
      "rel_url": "x86/vpermi2q/",
      "operands": [],
      "linked_summary": "Shuffles quadwords from two ZMM registers into destination.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpermt2q",
      "architecture": "x86",
      "full_name": "Permute Two-Source Quadwords (Overwrite)",
      "summary": "Shuffles 2 sources, overwriting the index register (Quadword).",
      "syntax": "VPERMT2Q zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 7F",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vpermt2q",
      "rel_url": "x86/vpermt2q/",
      "operands": [],
      "linked_summary": "Shuffles 2 sources, overwriting the <a href=\"../../armv8-a/index/\">index</a> register (Quadword).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpsllvd",
      "architecture": "x86",
      "full_name": "Variable Bit Shift Left Logical Doubleword",
      "summary": "Shifts doublewords left by individual counts.",
      "syntax": "VPSLLVD ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "AVX2",
        "hex_opcode": "C4 ... 47",
        "visual_parts": []
      },
      "extension": "AVX2",
      "slug": "vpsllvd",
      "rel_url": "x86/vpsllvd/",
      "operands": [],
      "linked_summary": "Shifts doublewords left by individual counts.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpsllvq",
      "architecture": "x86",
      "full_name": "Variable Bit Shift Left Logical Quadword",
      "summary": "Shifts quadwords left by individual counts.",
      "syntax": "VPSLLVQ ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "AVX2",
        "hex_opcode": "C4 ... 47",
        "visual_parts": []
      },
      "extension": "AVX2",
      "slug": "vpsllvq",
      "rel_url": "x86/vpsllvq/",
      "operands": [],
      "linked_summary": "Shifts quadwords left by individual counts.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpsravd",
      "architecture": "x86",
      "full_name": "Variable Bit Shift Right Arithmetic Doubleword",
      "summary": "Shifts doublewords right arithmetic by individual counts.",
      "syntax": "VPSRAVD ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "AVX2",
        "hex_opcode": "C4 ... 46",
        "visual_parts": []
      },
      "extension": "AVX2",
      "slug": "vpsravd",
      "rel_url": "x86/vpsravd/",
      "operands": [],
      "linked_summary": "Shifts doublewords right arithmetic by individual counts.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpsravq",
      "architecture": "x86",
      "full_name": "Variable Bit Shift Right Arithmetic Quadword",
      "summary": "Shifts quadwords right arithmetic by individual counts.",
      "syntax": "VPSRAVQ zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 46",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vpsravq",
      "rel_url": "x86/vpsravq/",
      "operands": [],
      "linked_summary": "Shifts quadwords right arithmetic by individual counts.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpsrlvd",
      "architecture": "x86",
      "full_name": "Variable Bit Shift Right Logical Doubleword",
      "summary": "Shifts doublewords right logical by individual counts.",
      "syntax": "VPSRLVD ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "AVX2",
        "hex_opcode": "C4 ... 45",
        "visual_parts": []
      },
      "extension": "AVX2",
      "slug": "vpsrlvd",
      "rel_url": "x86/vpsrlvd/",
      "operands": [],
      "linked_summary": "Shifts doublewords right logical by individual counts.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpsrlvq",
      "architecture": "x86",
      "full_name": "Variable Bit Shift Right Logical Quadword",
      "summary": "Shifts quadwords right logical by individual counts.",
      "syntax": "VPSRLVQ ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "AVX2",
        "hex_opcode": "C4 ... 45",
        "visual_parts": []
      },
      "extension": "AVX2",
      "slug": "vpsrlvq",
      "rel_url": "x86/vpsrlvq/",
      "operands": [],
      "linked_summary": "Shifts quadwords right logical by individual counts.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pminsb",
      "architecture": "x86",
      "full_name": "Minimum of Packed Signed Byte Integers",
      "summary": "Returns minimum of signed bytes.",
      "syntax": "PMINSB xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 38",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "pminsb",
      "rel_url": "x86/pminsb/",
      "operands": [],
      "linked_summary": "Returns minimum of signed bytes.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmaxsb",
      "architecture": "x86",
      "full_name": "Maximum of Packed Signed Byte Integers",
      "summary": "Returns maximum of signed bytes.",
      "syntax": "PMAXSB xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 3C",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "pmaxsb",
      "rel_url": "x86/pmaxsb/",
      "operands": [],
      "linked_summary": "Returns maximum of signed bytes.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pminuw",
      "architecture": "x86",
      "full_name": "Minimum of Packed Unsigned Word Integers",
      "summary": "Returns minimum of unsigned words.",
      "syntax": "PMINUW xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 3A",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "pminuw",
      "rel_url": "x86/pminuw/",
      "operands": [],
      "linked_summary": "Returns minimum of unsigned words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmaxuw",
      "architecture": "x86",
      "full_name": "Maximum of Packed Unsigned Word Integers",
      "summary": "Returns maximum of unsigned words.",
      "syntax": "PMAXUW xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 3E",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "pmaxuw",
      "rel_url": "x86/pmaxuw/",
      "operands": [],
      "linked_summary": "Returns maximum of unsigned words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pminud",
      "architecture": "x86",
      "full_name": "Minimum of Packed Unsigned Doubleword Integers",
      "summary": "Returns minimum of unsigned doublewords.",
      "syntax": "PMINUD xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 3B",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "pminud",
      "rel_url": "x86/pminud/",
      "operands": [],
      "linked_summary": "Returns minimum of unsigned doublewords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmaxud",
      "architecture": "x86",
      "full_name": "Maximum of Packed Unsigned Doubleword Integers",
      "summary": "Returns maximum of unsigned doublewords.",
      "syntax": "PMAXUD xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 3F",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "pmaxud",
      "rel_url": "x86/pmaxud/",
      "operands": [],
      "linked_summary": "Returns maximum of unsigned doublewords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pminsd",
      "architecture": "x86",
      "full_name": "Minimum of Packed Signed Doubleword Integers",
      "summary": "Returns minimum of signed doublewords.",
      "syntax": "PMINSD xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 39",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "pminsd",
      "rel_url": "x86/pminsd/",
      "operands": [],
      "linked_summary": "Returns minimum of signed doublewords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmaxsd",
      "architecture": "x86",
      "full_name": "Maximum of Packed Signed Doubleword Integers",
      "summary": "Returns maximum of signed doublewords.",
      "syntax": "PMAXSD xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 3D",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "pmaxsd",
      "rel_url": "x86/pmaxsd/",
      "operands": [],
      "linked_summary": "Returns maximum of signed doublewords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pinsrd",
      "architecture": "x86",
      "full_name": "Packed Insert Doubleword",
      "summary": "Inserts a doubleword from register to XMM.",
      "syntax": "PINSRD xmm1, r32/m32, imm8",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 3A 22",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "pinsrd",
      "rel_url": "x86/pinsrd/",
      "operands": [],
      "linked_summary": "Inserts a doubleword from register to XMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pinsrq",
      "architecture": "x86",
      "full_name": "Packed Insert Quadword",
      "summary": "Inserts a quadword from register to XMM.",
      "syntax": "PINSRQ xmm1, r64/m64, imm8",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 3A 22",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "pinsrq",
      "rel_url": "x86/pinsrq/",
      "operands": [],
      "linked_summary": "Inserts a quadword from register to XMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pextrd",
      "architecture": "x86",
      "full_name": "Packed Extract Doubleword",
      "summary": "Extracts a doubleword from XMM to register.",
      "syntax": "PEXTRD r32/m32, xmm1, imm8",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 3A 16",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "pextrd",
      "rel_url": "x86/pextrd/",
      "operands": [],
      "linked_summary": "Extracts a doubleword from XMM to register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pextrq",
      "architecture": "x86",
      "full_name": "Packed Extract Quadword",
      "summary": "Extracts a quadword from XMM to register.",
      "syntax": "PEXTRQ r64/m64, xmm1, imm8",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 3A 16",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "pextrq",
      "rel_url": "x86/pextrq/",
      "operands": [],
      "linked_summary": "Extracts a quadword from XMM to register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movntdqa",
      "architecture": "x86",
      "full_name": "Load Double Quadword Non-Temporal Aligned",
      "summary": "Efficiently loads 128-bits from WC memory (Streaming Load).",
      "syntax": "MOVNTDQA xmm1, m128",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 2A",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "movntdqa",
      "rel_url": "x86/movntdqa/",
      "operands": [],
      "linked_summary": "Efficiently loads 128-bits from WC memory (Streaming Load).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pcmpgtq",
      "architecture": "x86",
      "full_name": "Packed Compare Greater Than Quadword",
      "summary": "Compares quadwords for greater than (signed).",
      "syntax": "PCMPGTQ xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE4.2",
        "hex_opcode": "66 0F 38 37",
        "visual_parts": []
      },
      "extension": "SSE4.2",
      "slug": "pcmpgtq",
      "rel_url": "x86/pcmpgtq/",
      "operands": [],
      "linked_summary": "Compares quadwords for greater than (signed).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "packusdw",
      "architecture": "x86",
      "full_name": "Pack with Unsigned Saturation Doubleword to Word",
      "summary": "Converts signed dwords to unsigned words with saturation.",
      "syntax": "PACKUSDW xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 2B",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "packusdw",
      "rel_url": "x86/packusdw/",
      "operands": [],
      "linked_summary": "Converts signed dwords to unsigned words with saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sets",
      "architecture": "x86",
      "full_name": "Set Byte on Sign",
      "summary": "Sets byte to 1 if SF=1 (Negative).",
      "syntax": "SETS r/m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 98",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "sets",
      "rel_url": "x86/sets/",
      "operands": [],
      "linked_summary": "Sets byte to 1 if SF=1 (Negative).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "setns",
      "architecture": "x86",
      "full_name": "Set Byte on Not Sign",
      "summary": "Sets byte to 1 if SF=0 (Positive).",
      "syntax": "SETNS r/m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 99",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "setns",
      "rel_url": "x86/setns/",
      "operands": [],
      "linked_summary": "Sets byte to 1 if SF=0 (Positive).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "setp",
      "architecture": "x86",
      "full_name": "Set Byte on Parity",
      "summary": "Sets byte to 1 if PF=1 (Even Parity).",
      "syntax": "SETP r/m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 9A",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "setp",
      "rel_url": "x86/setp/",
      "operands": [],
      "linked_summary": "Sets byte to 1 if PF=1 (Even Parity).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "setnp",
      "architecture": "x86",
      "full_name": "Set Byte on Not Parity",
      "summary": "Sets byte to 1 if PF=0 (Odd Parity).",
      "syntax": "SETNP r/m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 9B",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "setnp",
      "rel_url": "x86/setnp/",
      "operands": [],
      "linked_summary": "Sets byte to 1 if PF=0 (Odd Parity).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "setl",
      "architecture": "x86",
      "full_name": "Set Byte on Less",
      "summary": "Sets byte to 1 if SF!=OF.",
      "syntax": "SETL r/m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 9C",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "setl",
      "rel_url": "x86/setl/",
      "operands": [],
      "linked_summary": "Sets byte to 1 if SF!=OF.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "setle",
      "architecture": "x86",
      "full_name": "Set Byte on Less or Equal",
      "summary": "Sets byte to 1 if ZF=1 or SF!=OF.",
      "syntax": "SETLE r/m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 9E",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "setle",
      "rel_url": "x86/setle/",
      "operands": [],
      "linked_summary": "Sets byte to 1 if ZF=1 <a href=\"../../powerisa/or/\">or</a> SF!=OF.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "setg",
      "architecture": "x86",
      "full_name": "Set Byte on Greater",
      "summary": "Sets byte to 1 if ZF=0 and SF=OF.",
      "syntax": "SETG r/m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 9F",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "setg",
      "rel_url": "x86/setg/",
      "operands": [],
      "linked_summary": "Sets byte to 1 if ZF=0 <a href=\"../../armv8-a/and_6/\">and</a> SF=OF.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "setge",
      "architecture": "x86",
      "full_name": "Set Byte on Greater or Equal",
      "summary": "Sets byte to 1 if SF=OF.",
      "syntax": "SETGE r/m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 9D",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "setge",
      "rel_url": "x86/setge/",
      "operands": [],
      "linked_summary": "Sets byte to 1 if SF=OF.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "setb",
      "architecture": "x86",
      "full_name": "Set Byte on Below",
      "summary": "Sets byte to 1 if CF=1.",
      "syntax": "SETB r/m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 92",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "setb",
      "rel_url": "x86/setb/",
      "operands": [],
      "linked_summary": "Sets byte to 1 if CF=1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "setbe",
      "architecture": "x86",
      "full_name": "Set Byte on Below or Equal",
      "summary": "Sets byte to 1 if CF=1 or ZF=1.",
      "syntax": "SETBE r/m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 96",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "setbe",
      "rel_url": "x86/setbe/",
      "operands": [],
      "linked_summary": "Sets byte to 1 if CF=1 <a href=\"../../powerisa/or/\">or</a> ZF=1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "seta",
      "architecture": "x86",
      "full_name": "Set Byte on Above",
      "summary": "Sets byte to 1 if CF=0 and ZF=0.",
      "syntax": "SETA r/m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 97",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "seta",
      "rel_url": "x86/seta/",
      "operands": [],
      "linked_summary": "Sets byte to 1 if CF=0 <a href=\"../../armv8-a/and_6/\">and</a> ZF=0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "setae",
      "architecture": "x86",
      "full_name": "Set Byte on Above or Equal",
      "summary": "Sets byte to 1 if CF=0.",
      "syntax": "SETAE r/m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 93",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "setae",
      "rel_url": "x86/setae/",
      "operands": [],
      "linked_summary": "Sets byte to 1 if CF=0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kunpckwd",
      "architecture": "x86",
      "full_name": "Unpack and Interleave Masks Word to Doubleword",
      "summary": "Interleaves 16-bit masks into 32-bit mask.",
      "syntax": "KUNPCKWD k1, k2, k3",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 4B",
        "visual_parts": []
      },
      "extension": "AVX-512BW",
      "slug": "kunpckwd",
      "rel_url": "x86/kunpckwd/",
      "operands": [],
      "linked_summary": "Interleaves 16-<a href=\"../../armv8-a/bit/\">bit</a> masks into 32-<a href=\"../../armv8-a/bit/\">bit</a> mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kunpckdq",
      "architecture": "x86",
      "full_name": "Unpack and Interleave Masks Doubleword to Quadword",
      "summary": "Interleaves 32-bit masks into 64-bit mask.",
      "syntax": "KUNPCKDQ k1, k2, k3",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 4B",
        "visual_parts": []
      },
      "extension": "AVX-512BW",
      "slug": "kunpckdq",
      "rel_url": "x86/kunpckdq/",
      "operands": [],
      "linked_summary": "Interleaves 32-<a href=\"../../armv8-a/bit/\">bit</a> masks into 64-<a href=\"../../armv8-a/bit/\">bit</a> mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpconflictq",
      "architecture": "x86",
      "full_name": "Detect Conflicts Within a Vector of Packed Quadword Values",
      "summary": "Detects duplicate values in a quadword vector.",
      "syntax": "VPCONFLICTQ zmm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 C4",
        "visual_parts": []
      },
      "extension": "AVX-512CD",
      "slug": "vpconflictq",
      "rel_url": "x86/vpconflictq/",
      "operands": [],
      "linked_summary": "Detects duplicate values <a href=\"../../x86/in/\">in</a> a quadword vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vplzcntq",
      "architecture": "x86",
      "full_name": "Count Leading Zero Bits Quadword",
      "summary": "Counts leading zeros for each quadword element.",
      "syntax": "VPLZCNTQ zmm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 44",
        "visual_parts": []
      },
      "extension": "AVX-512CD",
      "slug": "vplzcntq",
      "rel_url": "x86/vplzcntq/",
      "operands": [],
      "linked_summary": "Counts leading zeros for each quadword element.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpermw",
      "architecture": "x86",
      "full_name": "Permute Word Integers",
      "summary": "Full permutation of 32 words using indices.",
      "syntax": "VPERMW zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 8D",
        "visual_parts": []
      },
      "extension": "AVX-512BW",
      "slug": "vpermw",
      "rel_url": "x86/vpermw/",
      "operands": [],
      "linked_summary": "Full permutation of 32 words using indices.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpermq",
      "architecture": "x86",
      "full_name": "Permute Quadword Integers",
      "summary": "Shuffles quadwords within 256-bit lanes using immediate.",
      "syntax": "VPERMQ ymm1, ymm2/m256, imm8",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "66 0F 3A 00",
        "visual_parts": []
      },
      "extension": "AVX2",
      "slug": "vpermq",
      "rel_url": "x86/vpermq/",
      "operands": [],
      "linked_summary": "Shuffles quadwords within 256-<a href=\"../../armv8-a/bit/\">bit</a> lanes using immediate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vprolvq",
      "architecture": "x86",
      "full_name": "Rotate Left Quadword Variable",
      "summary": "Rotates quadwords left by amounts in second vector.",
      "syntax": "VPROLVQ zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 15",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vprolvq",
      "rel_url": "x86/vprolvq/",
      "operands": [],
      "linked_summary": "Rotates quadwords left by amounts <a href=\"../../x86/in/\">in</a> second vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vprorvd",
      "architecture": "x86",
      "full_name": "Rotate Right Doubleword Variable",
      "summary": "Rotates doublewords right by amounts in second vector.",
      "syntax": "VPRORVD zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 14",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vprorvd",
      "rel_url": "x86/vprorvd/",
      "operands": [],
      "linked_summary": "Rotates doublewords right by amounts <a href=\"../../x86/in/\">in</a> second vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vprorvq",
      "architecture": "x86",
      "full_name": "Rotate Right Quadword Variable",
      "summary": "Rotates quadwords right by amounts in second vector.",
      "syntax": "VPRORVQ zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 14",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vprorvq",
      "rel_url": "x86/vprorvq/",
      "operands": [],
      "linked_summary": "Rotates quadwords right by amounts <a href=\"../../x86/in/\">in</a> second vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmovb2m",
      "architecture": "x86",
      "full_name": "Move Byte Mask to Mask Register",
      "summary": "Moves byte integer mask from ZMM to k-register.",
      "syntax": "VPMOVB2M k1, zmm1",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F2 ... 29",
        "visual_parts": []
      },
      "extension": "AVX-512BW",
      "slug": "vpmovb2m",
      "rel_url": "x86/vpmovb2m/",
      "operands": [],
      "linked_summary": "Moves byte integer mask from ZMM to k-register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmovw2m",
      "architecture": "x86",
      "full_name": "Move Word Mask to Mask Register",
      "summary": "Moves word integer mask from ZMM to k-register.",
      "syntax": "VPMOVW2M k1, zmm1",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F2 ... 29",
        "visual_parts": []
      },
      "extension": "AVX-512BW",
      "slug": "vpmovw2m",
      "rel_url": "x86/vpmovw2m/",
      "operands": [],
      "linked_summary": "Moves word integer mask from ZMM to k-register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmovd2m",
      "architecture": "x86",
      "full_name": "Move Doubleword Mask to Mask Register",
      "summary": "Moves doubleword integer mask from ZMM to k-register.",
      "syntax": "VPMOVD2M k1, zmm1",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F2 ... 39",
        "visual_parts": []
      },
      "extension": "AVX-512DQ",
      "slug": "vpmovd2m",
      "rel_url": "x86/vpmovd2m/",
      "operands": [],
      "linked_summary": "Moves doubleword integer mask from ZMM to k-register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmovq2m",
      "architecture": "x86",
      "full_name": "Move Quadword Mask to Mask Register",
      "summary": "Moves quadword integer mask from ZMM to k-register.",
      "syntax": "VPMOVQ2M k1, zmm1",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F2 ... 39",
        "visual_parts": []
      },
      "extension": "AVX-512DQ",
      "slug": "vpmovq2m",
      "rel_url": "x86/vpmovq2m/",
      "operands": [],
      "linked_summary": "Moves quadword integer mask from ZMM to k-register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmovm2b",
      "architecture": "x86",
      "full_name": "Move Mask Register to Byte Mask",
      "summary": "Expands k-register bits to byte elements in ZMM.",
      "syntax": "VPMOVM2B zmm1, k1",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F2 ... 28",
        "visual_parts": []
      },
      "extension": "AVX-512BW",
      "slug": "vpmovm2b",
      "rel_url": "x86/vpmovm2b/",
      "operands": [],
      "linked_summary": "Expands k-register bits to byte elements <a href=\"../../x86/in/\">in</a> ZMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmovm2w",
      "architecture": "x86",
      "full_name": "Move Mask Register to Word Mask",
      "summary": "Expands k-register bits to word elements in ZMM.",
      "syntax": "VPMOVM2W zmm1, k1",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F2 ... 28",
        "visual_parts": []
      },
      "extension": "AVX-512BW",
      "slug": "vpmovm2w",
      "rel_url": "x86/vpmovm2w/",
      "operands": [],
      "linked_summary": "Expands k-register bits to word elements <a href=\"../../x86/in/\">in</a> ZMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmovm2d",
      "architecture": "x86",
      "full_name": "Move Mask Register to Doubleword Mask",
      "summary": "Expands k-register bits to doubleword elements in ZMM.",
      "syntax": "VPMOVM2D zmm1, k1",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F2 ... 38",
        "visual_parts": []
      },
      "extension": "AVX-512DQ",
      "slug": "vpmovm2d",
      "rel_url": "x86/vpmovm2d/",
      "operands": [],
      "linked_summary": "Expands k-register bits to doubleword elements <a href=\"../../x86/in/\">in</a> ZMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmovm2q",
      "architecture": "x86",
      "full_name": "Move Mask Register to Quadword Mask",
      "summary": "Expands k-register bits to quadword elements in ZMM.",
      "syntax": "VPMOVM2Q zmm1, k1",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F2 ... 38",
        "visual_parts": []
      },
      "extension": "AVX-512DQ",
      "slug": "vpmovm2q",
      "rel_url": "x86/vpmovm2q/",
      "operands": [],
      "linked_summary": "Expands k-register bits to quadword elements <a href=\"../../x86/in/\">in</a> ZMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kshiftrb",
      "architecture": "x86",
      "full_name": "Shift Right Mask Byte",
      "summary": "Logically shifts 8-bit mask right.",
      "syntax": "KSHIFTRB k1, k2, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 30",
        "visual_parts": []
      },
      "extension": "AVX-512DQ",
      "slug": "kshiftrb",
      "rel_url": "x86/kshiftrb/",
      "operands": [],
      "linked_summary": "Logically shifts 8-<a href=\"../../armv8-a/bit/\">bit</a> mask right.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kshiftrw",
      "architecture": "x86",
      "full_name": "Shift Right Mask Word",
      "summary": "Logically shifts 16-bit mask right.",
      "syntax": "KSHIFTRW k1, k2, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 32",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "kshiftrw",
      "rel_url": "x86/kshiftrw/",
      "operands": [],
      "linked_summary": "Logically shifts 16-<a href=\"../../armv8-a/bit/\">bit</a> mask right.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kshiftrd",
      "architecture": "x86",
      "full_name": "Shift Right Mask Doubleword",
      "summary": "Logically shifts 32-bit mask right.",
      "syntax": "KSHIFTRD k1, k2, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 34",
        "visual_parts": []
      },
      "extension": "AVX-512BW",
      "slug": "kshiftrd",
      "rel_url": "x86/kshiftrd/",
      "operands": [],
      "linked_summary": "Logically shifts 32-<a href=\"../../armv8-a/bit/\">bit</a> mask right.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kshiftrq",
      "architecture": "x86",
      "full_name": "Shift Right Mask Quadword",
      "summary": "Logically shifts 64-bit mask right.",
      "syntax": "KSHIFTRQ k1, k2, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 36",
        "visual_parts": []
      },
      "extension": "AVX-512BW",
      "slug": "kshiftrq",
      "rel_url": "x86/kshiftrq/",
      "operands": [],
      "linked_summary": "Logically shifts 64-<a href=\"../../armv8-a/bit/\">bit</a> mask right.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kshiftlb",
      "architecture": "x86",
      "full_name": "Shift Left Mask Byte",
      "summary": "Logically shifts 8-bit mask left.",
      "syntax": "KSHIFTLB k1, k2, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 31",
        "visual_parts": []
      },
      "extension": "AVX-512DQ",
      "slug": "kshiftlb",
      "rel_url": "x86/kshiftlb/",
      "operands": [],
      "linked_summary": "Logically shifts 8-<a href=\"../../armv8-a/bit/\">bit</a> mask left.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kshiftlw",
      "architecture": "x86",
      "full_name": "Shift Left Mask Word",
      "summary": "Logically shifts 16-bit mask left.",
      "syntax": "KSHIFTLW k1, k2, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 33",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "kshiftlw",
      "rel_url": "x86/kshiftlw/",
      "operands": [],
      "linked_summary": "Logically shifts 16-<a href=\"../../armv8-a/bit/\">bit</a> mask left.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kshiftld",
      "architecture": "x86",
      "full_name": "Shift Left Mask Doubleword",
      "summary": "Logically shifts 32-bit mask left.",
      "syntax": "KSHIFTLD k1, k2, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 35",
        "visual_parts": []
      },
      "extension": "AVX-512BW",
      "slug": "kshiftld",
      "rel_url": "x86/kshiftld/",
      "operands": [],
      "linked_summary": "Logically shifts 32-<a href=\"../../armv8-a/bit/\">bit</a> mask left.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kshiftlq",
      "architecture": "x86",
      "full_name": "Shift Left Mask Quadword",
      "summary": "Logically shifts 64-bit mask left.",
      "syntax": "KSHIFTLQ k1, k2, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 37",
        "visual_parts": []
      },
      "extension": "AVX-512BW",
      "slug": "kshiftlq",
      "rel_url": "x86/kshiftlq/",
      "operands": [],
      "linked_summary": "Logically shifts 64-<a href=\"../../armv8-a/bit/\">bit</a> mask left.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "knotb",
      "architecture": "x86",
      "full_name": "NOT Mask Byte",
      "summary": "Bitwise NOT of 8-bit mask.",
      "syntax": "KNOTB k1, k2",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 44",
        "visual_parts": []
      },
      "extension": "AVX-512DQ",
      "slug": "knotb",
      "rel_url": "x86/knotb/",
      "operands": [],
      "linked_summary": "Bitwise <a href=\"../../armv9-a/not/\">NOT</a> of 8-<a href=\"../../armv8-a/bit/\">bit</a> mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "knotd",
      "architecture": "x86",
      "full_name": "NOT Mask Doubleword",
      "summary": "Bitwise NOT of 32-bit mask.",
      "syntax": "KNOTD k1, k2",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 44",
        "visual_parts": []
      },
      "extension": "AVX-512BW",
      "slug": "knotd",
      "rel_url": "x86/knotd/",
      "operands": [],
      "linked_summary": "Bitwise <a href=\"../../armv9-a/not/\">NOT</a> of 32-<a href=\"../../armv8-a/bit/\">bit</a> mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "korb",
      "architecture": "x86",
      "full_name": "OR Mask Byte",
      "summary": "Bitwise OR of 8-bit masks.",
      "syntax": "KORB k1, k2, k3",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 45",
        "visual_parts": []
      },
      "extension": "AVX-512DQ",
      "slug": "korb",
      "rel_url": "x86/korb/",
      "operands": [],
      "linked_summary": "Bitwise <a href=\"../../risc-v/or/\">OR</a> of 8-<a href=\"../../armv8-a/bit/\">bit</a> masks.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kord",
      "architecture": "x86",
      "full_name": "OR Mask Doubleword",
      "summary": "Bitwise OR of 32-bit masks.",
      "syntax": "KORD k1, k2, k3",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 45",
        "visual_parts": []
      },
      "extension": "AVX-512BW",
      "slug": "kord",
      "rel_url": "x86/kord/",
      "operands": [],
      "linked_summary": "Bitwise <a href=\"../../risc-v/or/\">OR</a> of 32-<a href=\"../../armv8-a/bit/\">bit</a> masks.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kxorq",
      "architecture": "x86",
      "full_name": "XOR Mask Quadword",
      "summary": "Bitwise XOR of 64-bit masks.",
      "syntax": "KXORQ k1, k2, k3",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 47",
        "visual_parts": []
      },
      "extension": "AVX-512BW",
      "slug": "kxorq",
      "rel_url": "x86/kxorq/",
      "operands": [],
      "linked_summary": "Bitwise <a href=\"../../risc-v/xor/\">XOR</a> of 64-<a href=\"../../armv8-a/bit/\">bit</a> masks.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kxord",
      "architecture": "x86",
      "full_name": "XOR Mask Doubleword",
      "summary": "Bitwise XOR of 32-bit masks.",
      "syntax": "KXORD k1, k2, k3",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 47",
        "visual_parts": []
      },
      "extension": "AVX-512BW",
      "slug": "kxord",
      "rel_url": "x86/kxord/",
      "operands": [],
      "linked_summary": "Bitwise <a href=\"../../risc-v/xor/\">XOR</a> of 32-<a href=\"../../armv8-a/bit/\">bit</a> masks.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kxorb",
      "architecture": "x86",
      "full_name": "XOR Mask Byte",
      "summary": "Bitwise XOR of 8-bit masks.",
      "syntax": "KXORB k1, k2, k3",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 47",
        "visual_parts": []
      },
      "extension": "AVX-512DQ",
      "slug": "kxorb",
      "rel_url": "x86/kxorb/",
      "operands": [],
      "linked_summary": "Bitwise <a href=\"../../risc-v/xor/\">XOR</a> of 8-<a href=\"../../armv8-a/bit/\">bit</a> masks.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kortestb",
      "architecture": "x86",
      "full_name": "OR Masks and Set Flags Byte",
      "summary": "ORs 8-bit masks and sets EFLAGS (ZF/CF).",
      "syntax": "KORTESTB k1, k2",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 98",
        "visual_parts": []
      },
      "extension": "AVX-512DQ",
      "slug": "kortestb",
      "rel_url": "x86/kortestb/",
      "operands": [],
      "linked_summary": "ORs 8-<a href=\"../../armv8-a/bit/\">bit</a> masks <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../x86/sets/\">sets</a> EFLAGS (ZF/CF).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kortestq",
      "architecture": "x86",
      "full_name": "OR Masks and Set Flags Quadword",
      "summary": "ORs 64-bit masks and sets EFLAGS (ZF/CF).",
      "syntax": "KORTESTQ k1, k2",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 98",
        "visual_parts": []
      },
      "extension": "AVX-512BW",
      "slug": "kortestq",
      "rel_url": "x86/kortestq/",
      "operands": [],
      "linked_summary": "ORs 64-<a href=\"../../armv8-a/bit/\">bit</a> masks <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../x86/sets/\">sets</a> EFLAGS (ZF/CF).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ktestb",
      "architecture": "x86",
      "full_name": "Test Masks Byte",
      "summary": "ANDs 8-bit masks and sets EFLAGS (ZF/CF).",
      "syntax": "KTESTB k1, k2",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 99",
        "visual_parts": []
      },
      "extension": "AVX-512DQ",
      "slug": "ktestb",
      "rel_url": "x86/ktestb/",
      "operands": [],
      "linked_summary": "ANDs 8-<a href=\"../../armv8-a/bit/\">bit</a> masks <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../x86/sets/\">sets</a> EFLAGS (ZF/CF).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ktestw",
      "architecture": "x86",
      "full_name": "Test Masks Word",
      "summary": "ANDs 16-bit masks and sets EFLAGS (ZF/CF).",
      "syntax": "KTESTW k1, k2",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 99",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "ktestw",
      "rel_url": "x86/ktestw/",
      "operands": [],
      "linked_summary": "ANDs 16-<a href=\"../../armv8-a/bit/\">bit</a> masks <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../x86/sets/\">sets</a> EFLAGS (ZF/CF).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ktestd",
      "architecture": "x86",
      "full_name": "Test Masks Doubleword",
      "summary": "ANDs 32-bit masks and sets EFLAGS (ZF/CF).",
      "syntax": "KTESTD k1, k2",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 99",
        "visual_parts": []
      },
      "extension": "AVX-512BW",
      "slug": "ktestd",
      "rel_url": "x86/ktestd/",
      "operands": [],
      "linked_summary": "ANDs 32-<a href=\"../../armv8-a/bit/\">bit</a> masks <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../x86/sets/\">sets</a> EFLAGS (ZF/CF).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ktestq",
      "architecture": "x86",
      "full_name": "Test Masks Quadword",
      "summary": "ANDs 64-bit masks and sets EFLAGS (ZF/CF).",
      "syntax": "KTESTQ k1, k2",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 99",
        "visual_parts": []
      },
      "extension": "AVX-512BW",
      "slug": "ktestq",
      "rel_url": "x86/ktestq/",
      "operands": [],
      "linked_summary": "ANDs 64-<a href=\"../../armv8-a/bit/\">bit</a> masks <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../x86/sets/\">sets</a> EFLAGS (ZF/CF).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcvtudq2pd",
      "architecture": "x86",
      "full_name": "Convert Packed Unsigned Doubleword to Double",
      "summary": "Converts unsigned 32-bit integers to 64-bit doubles.",
      "syntax": "VCVTUDQ2PD zmm1 {k1}, ymm2/m256",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "F3 0F 7A",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vcvtudq2pd",
      "rel_url": "x86/vcvtudq2pd/",
      "operands": [],
      "linked_summary": "Converts unsigned 32-<a href=\"../../armv8-a/bit/\">bit</a> integers to 64-<a href=\"../../armv8-a/bit/\">bit</a> doubles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcvtpd2udq",
      "architecture": "x86",
      "full_name": "Convert Packed Double to Unsigned Doubleword",
      "summary": "Converts 64-bit doubles to unsigned 32-bit integers.",
      "syntax": "VCVTPD2UDQ ymm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 79",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vcvtpd2udq",
      "rel_url": "x86/vcvtpd2udq/",
      "operands": [],
      "linked_summary": "Converts 64-<a href=\"../../armv8-a/bit/\">bit</a> doubles to unsigned 32-<a href=\"../../armv8-a/bit/\">bit</a> integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcvtps2udq",
      "architecture": "x86",
      "full_name": "Convert Packed Single to Unsigned Doubleword",
      "summary": "Converts 32-bit floats to unsigned 32-bit integers.",
      "syntax": "VCVTPS2UDQ zmm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 79",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vcvtps2udq",
      "rel_url": "x86/vcvtps2udq/",
      "operands": [],
      "linked_summary": "Converts 32-<a href=\"../../armv8-a/bit/\">bit</a> floats to unsigned 32-<a href=\"../../armv8-a/bit/\">bit</a> integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcvtuq2ps",
      "architecture": "x86",
      "full_name": "Convert Packed Unsigned Quadword to Single",
      "summary": "Converts unsigned 64-bit integers to 32-bit floats.",
      "syntax": "VCVTUQ2PS ymm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "F2 0F 7A",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vcvtuq2ps",
      "rel_url": "x86/vcvtuq2ps/",
      "operands": [],
      "linked_summary": "Converts unsigned 64-<a href=\"../../armv8-a/bit/\">bit</a> integers to 32-<a href=\"../../armv8-a/bit/\">bit</a> floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcvtuq2pd",
      "architecture": "x86",
      "full_name": "Convert Packed Unsigned Quadword to Double",
      "summary": "Converts unsigned 64-bit integers to 64-bit doubles.",
      "syntax": "VCVTUQ2PD zmm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "F3 0F 7A",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vcvtuq2pd",
      "rel_url": "x86/vcvtuq2pd/",
      "operands": [],
      "linked_summary": "Converts unsigned 64-<a href=\"../../armv8-a/bit/\">bit</a> integers to 64-<a href=\"../../armv8-a/bit/\">bit</a> doubles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcvtps2uq",
      "architecture": "x86",
      "full_name": "Convert Packed Single to Unsigned Quadword",
      "summary": "Converts 32-bit floats to unsigned 64-bit integers.",
      "syntax": "VCVTPS2UQ zmm1 {k1}, ymm2/m256",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 79",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vcvtps2uq",
      "rel_url": "x86/vcvtps2uq/",
      "operands": [],
      "linked_summary": "Converts 32-<a href=\"../../armv8-a/bit/\">bit</a> floats to unsigned 64-<a href=\"../../armv8-a/bit/\">bit</a> integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcvtpd2uq",
      "architecture": "x86",
      "full_name": "Convert Packed Double to Unsigned Quadword",
      "summary": "Converts 64-bit doubles to unsigned 64-bit integers.",
      "syntax": "VCVTPD2UQ zmm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 79",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vcvtpd2uq",
      "rel_url": "x86/vcvtpd2uq/",
      "operands": [],
      "linked_summary": "Converts 64-<a href=\"../../armv8-a/bit/\">bit</a> doubles to unsigned 64-<a href=\"../../armv8-a/bit/\">bit</a> integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfmaddcph",
      "architecture": "x86",
      "full_name": "Complex Multiply-Add FP16",
      "summary": "Complex multiply-add for half-precision.",
      "syntax": "VFMADDCPH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F6 ... 56",
        "visual_parts": []
      },
      "extension": "AVX-512-FP16",
      "slug": "vfmaddcph",
      "rel_url": "x86/vfmaddcph/",
      "operands": [],
      "linked_summary": "Complex multiply-<a href=\"../../armv8-a/add_8/\">add</a> for half-precision.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfcmaddcph",
      "architecture": "x86",
      "full_name": "Complex Conjugate Multiply-Add FP16",
      "summary": "Complex conjugate multiply-add for half-precision.",
      "syntax": "VFCMADDCPH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F6 ... 57",
        "visual_parts": []
      },
      "extension": "AVX-512-FP16",
      "slug": "vfcmaddcph",
      "rel_url": "x86/vfcmaddcph/",
      "operands": [],
      "linked_summary": "Complex conjugate multiply-<a href=\"../../armv8-a/add_8/\">add</a> for half-precision.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfmaddcsh",
      "architecture": "x86",
      "full_name": "Complex Multiply-Add Scalar FP16",
      "summary": "Complex multiply-add for scalar half-precision.",
      "syntax": "VFMADDCSH xmm1 {k1}, xmm2, xmm3/m32",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F6 ... 57",
        "visual_parts": []
      },
      "extension": "AVX-512-FP16",
      "slug": "vfmaddcsh",
      "rel_url": "x86/vfmaddcsh/",
      "operands": [],
      "linked_summary": "Complex multiply-<a href=\"../../armv8-a/add_8/\">add</a> for scalar half-precision.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcmpps",
      "architecture": "x86",
      "full_name": "Compare Packed Single-Precision (AVX)",
      "summary": "Compares packed floats (AVX version with immediate).",
      "syntax": "VCMPPS ymm1, ymm2, ymm3/m256, imm8",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C5 ... C2",
        "visual_parts": []
      },
      "extension": "AVX",
      "slug": "vcmpps",
      "rel_url": "x86/vcmpps/",
      "operands": [],
      "linked_summary": "Compares packed floats (AVX version with immediate).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcmppd",
      "architecture": "x86",
      "full_name": "Compare Packed Double-Precision (AVX)",
      "summary": "Compares packed doubles (AVX version with immediate).",
      "syntax": "VCMPPD ymm1, ymm2, ymm3/m256, imm8",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C5 ... C2",
        "visual_parts": []
      },
      "extension": "AVX",
      "slug": "vcmppd",
      "rel_url": "x86/vcmppd/",
      "operands": [],
      "linked_summary": "Compares packed doubles (AVX version with immediate).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpcmpb",
      "architecture": "x86",
      "full_name": "Compare Packed Byte Integers",
      "summary": "Compares bytes and stores result in k-register mask.",
      "syntax": "VPCMPB k1 {k2}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F3 ... 3F",
        "visual_parts": []
      },
      "extension": "AVX-512BW",
      "slug": "vpcmpb",
      "rel_url": "x86/vpcmpb/",
      "operands": [],
      "linked_summary": "Compares bytes <a href=\"../../armv8-a/and_6/\">and</a> stores result <a href=\"../../x86/in/\">in</a> k-register mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpcmpw",
      "architecture": "x86",
      "full_name": "Compare Packed Word Integers",
      "summary": "Compares words and stores result in k-register mask.",
      "syntax": "VPCMPW k1 {k2}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F3 ... 3F",
        "visual_parts": []
      },
      "extension": "AVX-512BW",
      "slug": "vpcmpw",
      "rel_url": "x86/vpcmpw/",
      "operands": [],
      "linked_summary": "Compares words <a href=\"../../armv8-a/and_6/\">and</a> stores result <a href=\"../../x86/in/\">in</a> k-register mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpcmpd",
      "architecture": "x86",
      "full_name": "Compare Packed Doubleword Integers",
      "summary": "Compares doublewords and stores result in k-register mask.",
      "syntax": "VPCMPD k1 {k2}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F3 ... 1F",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vpcmpd",
      "rel_url": "x86/vpcmpd/",
      "operands": [],
      "linked_summary": "Compares doublewords <a href=\"../../armv8-a/and_6/\">and</a> stores result <a href=\"../../x86/in/\">in</a> k-register mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpcmpq",
      "architecture": "x86",
      "full_name": "Compare Packed Quadword Integers",
      "summary": "Compares quadwords and stores result in k-register mask.",
      "syntax": "VPCMPQ k1 {k2}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F3 ... 1F",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vpcmpq",
      "rel_url": "x86/vpcmpq/",
      "operands": [],
      "linked_summary": "Compares quadwords <a href=\"../../armv8-a/and_6/\">and</a> stores result <a href=\"../../x86/in/\">in</a> k-register mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpcmpub",
      "architecture": "x86",
      "full_name": "Compare Packed Unsigned Byte Integers",
      "summary": "Compares unsigned bytes and stores result in k-register.",
      "syntax": "VPCMPUB k1 {k2}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F3 ... 3E",
        "visual_parts": []
      },
      "extension": "AVX-512BW",
      "slug": "vpcmpub",
      "rel_url": "x86/vpcmpub/",
      "operands": [],
      "linked_summary": "Compares unsigned bytes <a href=\"../../armv8-a/and_6/\">and</a> stores result <a href=\"../../x86/in/\">in</a> k-register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpcmpuw",
      "architecture": "x86",
      "full_name": "Compare Packed Unsigned Word Integers",
      "summary": "Compares unsigned words and stores result in k-register.",
      "syntax": "VPCMPUW k1 {k2}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F3 ... 3E",
        "visual_parts": []
      },
      "extension": "AVX-512BW",
      "slug": "vpcmpuw",
      "rel_url": "x86/vpcmpuw/",
      "operands": [],
      "linked_summary": "Compares unsigned words <a href=\"../../armv8-a/and_6/\">and</a> stores result <a href=\"../../x86/in/\">in</a> k-register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpcmpud",
      "architecture": "x86",
      "full_name": "Compare Packed Unsigned Doubleword Integers",
      "summary": "Compares unsigned doublewords and stores result in k-register.",
      "syntax": "VPCMPUD k1 {k2}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F3 ... 1E",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vpcmpud",
      "rel_url": "x86/vpcmpud/",
      "operands": [],
      "linked_summary": "Compares unsigned doublewords <a href=\"../../armv8-a/and_6/\">and</a> stores result <a href=\"../../x86/in/\">in</a> k-register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpcmpuq",
      "architecture": "x86",
      "full_name": "Compare Packed Unsigned Quadword Integers",
      "summary": "Compares unsigned quadwords and stores result in k-register.",
      "syntax": "VPCMPUQ k1 {k2}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F3 ... 1E",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vpcmpuq",
      "rel_url": "x86/vpcmpuq/",
      "operands": [],
      "linked_summary": "Compares unsigned quadwords <a href=\"../../armv8-a/and_6/\">and</a> stores result <a href=\"../../x86/in/\">in</a> k-register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vptestmb",
      "architecture": "x86",
      "full_name": "Packed Test Mask Byte",
      "summary": "Tests byte integers and sets k-register mask.",
      "syntax": "VPTESTMB k1 {k2}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F2 ... 26",
        "visual_parts": []
      },
      "extension": "AVX-512BW",
      "slug": "vptestmb",
      "rel_url": "x86/vptestmb/",
      "operands": [],
      "linked_summary": "Tests byte integers <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../x86/sets/\">sets</a> k-register mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vptestmw",
      "architecture": "x86",
      "full_name": "Packed Test Mask Word",
      "summary": "Tests word integers and sets k-register mask.",
      "syntax": "VPTESTMW k1 {k2}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F2 ... 26",
        "visual_parts": []
      },
      "extension": "AVX-512BW",
      "slug": "vptestmw",
      "rel_url": "x86/vptestmw/",
      "operands": [],
      "linked_summary": "Tests word integers <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../x86/sets/\">sets</a> k-register mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vptestmd",
      "architecture": "x86",
      "full_name": "Packed Test Mask Doubleword",
      "summary": "Tests doubleword integers and sets k-register mask.",
      "syntax": "VPTESTMD k1 {k2}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F2 ... 27",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vptestmd",
      "rel_url": "x86/vptestmd/",
      "operands": [],
      "linked_summary": "Tests doubleword integers <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../x86/sets/\">sets</a> k-register mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vptestmq",
      "architecture": "x86",
      "full_name": "Packed Test Mask Quadword",
      "summary": "Tests quadword integers and sets k-register mask.",
      "syntax": "VPTESTMQ k1 {k2}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F2 ... 27",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vptestmq",
      "rel_url": "x86/vptestmq/",
      "operands": [],
      "linked_summary": "Tests quadword integers <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../x86/sets/\">sets</a> k-register mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "monitorx",
      "architecture": "x86",
      "full_name": "Monitor Extended",
      "summary": "Sets up a monitor address (AMD extension).",
      "syntax": "MONITORX",
      "encoding": {
        "format": "AMD",
        "hex_opcode": "0F 01 FA",
        "visual_parts": []
      },
      "extension": "AMD",
      "slug": "monitorx",
      "rel_url": "x86/monitorx/",
      "operands": [],
      "linked_summary": "Sets up a <a href=\"../../x86/monitor/\">monitor</a> address (AMD extension).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mwaitx",
      "architecture": "x86",
      "full_name": "Monitor Wait Extended",
      "summary": "Waits for a write to monitored address (AMD extension).",
      "syntax": "MWAITX",
      "encoding": {
        "format": "AMD",
        "hex_opcode": "0F 01 FB",
        "visual_parts": []
      },
      "extension": "AMD",
      "slug": "mwaitx",
      "rel_url": "x86/mwaitx/",
      "operands": [],
      "linked_summary": "Waits for a write to monitored address (AMD extension).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fld",
      "architecture": "x86",
      "full_name": "Load Floating Point Value",
      "summary": "Pushes a floating-point value onto the FPU register stack (ST0).",
      "syntax": "FLD m32fp/m64fp/m80fp",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 /0",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Memory"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fld_1",
      "rel_url": "x86/fld_1/",
      "linked_summary": "Pushes a floating-point value onto the FPU register stack (ST0).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fst",
      "architecture": "x86",
      "full_name": "Store Floating Point Value",
      "summary": "Copies the value in ST(0) to memory or another register.",
      "syntax": "FST m32fp/m64fp",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 /2",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Memory"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fst_1",
      "rel_url": "x86/fst_1/",
      "linked_summary": "Copies the value <a href=\"../../x86/in/\">in</a> ST(0) to memory <a href=\"../../powerisa/or/\">or</a> another register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fstp",
      "architecture": "x86",
      "full_name": "Store Floating Point Value and Pop",
      "summary": "Copies ST(0) to destination and pops the register stack.",
      "syntax": "FSTP m32fp/m64fp/m80fp",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 /3",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Memory"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fstp_1",
      "rel_url": "x86/fstp_1/",
      "linked_summary": "Copies ST(0) to destination <a href=\"../../armv8-a/and_6/\">and</a> pops the register stack.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fild",
      "architecture": "x86",
      "full_name": "Load Integer",
      "summary": "Converts integer in memory to double-extended-precision float and pushes to ST(0).",
      "syntax": "FILD m16int/m32int/m64int",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xDF /0",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Integer Memory"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fild_1",
      "rel_url": "x86/fild_1/",
      "linked_summary": "Converts integer <a href=\"../../x86/in/\">in</a> memory to double-extended-precision float <a href=\"../../armv8-a/and_6/\">and</a> pushes to ST(0).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fist",
      "architecture": "x86",
      "full_name": "Store Integer",
      "summary": "Converts ST(0) to integer and stores in memory.",
      "syntax": "FIST m16int/m32int",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xDF /2",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Integer Memory"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fist_1",
      "rel_url": "x86/fist_1/",
      "linked_summary": "Converts ST(0) to integer <a href=\"../../armv8-a/and_6/\">and</a> stores <a href=\"../../x86/in/\">in</a> memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fistp",
      "architecture": "x86",
      "full_name": "Store Integer and Pop",
      "summary": "Converts ST(0) to integer, stores in memory, and pops stack.",
      "syntax": "FISTP m16int/m32int/m64int",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xDF /3",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Integer Memory"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fistp_1",
      "rel_url": "x86/fistp_1/",
      "linked_summary": "Converts ST(0) to integer, stores <a href=\"../../x86/in/\">in</a> memory, <a href=\"../../armv8-a/and_6/\">and</a> pops stack.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fadd",
      "architecture": "x86",
      "full_name": "Add Floating Point",
      "summary": "Adds src to dest (ST(0) += src).",
      "syntax": "FADD m32fp/m64fp",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD8 /0",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Memory/Reg"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fadd_1",
      "rel_url": "x86/fadd_1/",
      "linked_summary": "Adds src to dest (ST(0) += src).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fsub",
      "architecture": "x86",
      "full_name": "Subtract Floating Point",
      "summary": "Subtracts src from dest.",
      "syntax": "FSUB m32fp/m64fp",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD8 /4",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Memory/Reg"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fsub_1",
      "rel_url": "x86/fsub_1/",
      "linked_summary": "Subtracts src from dest.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fmul",
      "architecture": "x86",
      "full_name": "Multiply Floating Point",
      "summary": "Multiplies dest by src.",
      "syntax": "FMUL m32fp/m64fp",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD8 /1",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Memory/Reg"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fmul_1",
      "rel_url": "x86/fmul_1/",
      "linked_summary": "Multiplies dest by src.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fdiv",
      "architecture": "x86",
      "full_name": "Divide Floating Point",
      "summary": "Divides dest by src.",
      "syntax": "FDIV m32fp/m64fp",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD8 /6",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Memory/Reg"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fdiv_1",
      "rel_url": "x86/fdiv_1/",
      "linked_summary": "Divides dest by src.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fprem",
      "architecture": "x86",
      "full_name": "Partial Remainder",
      "summary": "Computes remainder of ST(0) / ST(1).",
      "syntax": "FPREM",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 F8",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fprem_1",
      "rel_url": "x86/fprem_1/",
      "linked_summary": "Computes remainder of ST(0) / ST(1).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fabs",
      "architecture": "x86",
      "full_name": "Absolute Value",
      "summary": "Replaces ST(0) with its absolute value.",
      "syntax": "FABS",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 E1",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fabs_1",
      "rel_url": "x86/fabs_1/",
      "linked_summary": "Replaces ST(0) with its absolute value.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fchs",
      "architecture": "x86",
      "full_name": "Change Sign",
      "summary": "Reverses the sign of ST(0).",
      "syntax": "FCHS",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 E0",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fchs_1",
      "rel_url": "x86/fchs_1/",
      "linked_summary": "Reverses the sign of ST(0).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fsqrt",
      "architecture": "x86",
      "full_name": "Square Root",
      "summary": "Computes square root of ST(0).",
      "syntax": "FSQRT",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 FA",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fsqrt_1",
      "rel_url": "x86/fsqrt_1/",
      "linked_summary": "Computes square root of ST(0).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fsin",
      "architecture": "x86",
      "full_name": "Sine",
      "summary": "Computes sine of ST(0) (in radians).",
      "syntax": "FSIN",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 FE",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fsin_1",
      "rel_url": "x86/fsin_1/",
      "linked_summary": "Computes sine of ST(0) (<a href=\"../../x86/in/\">in</a> radians).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fcos",
      "architecture": "x86",
      "full_name": "Cosine",
      "summary": "Computes cosine of ST(0) (in radians).",
      "syntax": "FCOS",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 FF",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fcos_1",
      "rel_url": "x86/fcos_1/",
      "linked_summary": "Computes cosine of ST(0) (<a href=\"../../x86/in/\">in</a> radians).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fsincos",
      "architecture": "x86",
      "full_name": "Sine and Cosine",
      "summary": "Computes sine and cosine of ST(0), pushing both to stack.",
      "syntax": "FSINCOS",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 FB",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fsincos_1",
      "rel_url": "x86/fsincos_1/",
      "linked_summary": "Computes sine <a href=\"../../armv8-a/and_6/\">and</a> cosine of ST(0), pushing both to stack.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fptan",
      "architecture": "x86",
      "full_name": "Partial Tangent",
      "summary": "Computes tangent of ST(0) and pushes 1.0.",
      "syntax": "FPTAN",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 F2",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fptan_1",
      "rel_url": "x86/fptan_1/",
      "linked_summary": "Computes tangent of ST(0) <a href=\"../../armv8-a/and_6/\">and</a> pushes 1.0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fpatan",
      "architecture": "x86",
      "full_name": "Partial Arctangent",
      "summary": "Computes arctan(ST(1)/ST(0)).",
      "syntax": "FPATAN",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 F3",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fpatan_1",
      "rel_url": "x86/fpatan_1/",
      "linked_summary": "Computes arctan(ST(1)/ST(0)).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fyl2x",
      "architecture": "x86",
      "full_name": "Y * log2(X)",
      "summary": "Computes ST(1) * log2(ST(0)).",
      "syntax": "FYL2X",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 F1",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fyl2x_1",
      "rel_url": "x86/fyl2x_1/",
      "linked_summary": "Computes ST(1) * log2(ST(0)).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fxch",
      "architecture": "x86",
      "full_name": "Exchange Register",
      "summary": "Exchanges contents of ST(0) and ST(i).",
      "syntax": "FXCH ST(i)",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 C8+i",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fxch_1",
      "rel_url": "x86/fxch_1/",
      "linked_summary": "Exchanges contents of ST(0) <a href=\"../../armv8-a/and_6/\">and</a> ST(i).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fcom",
      "architecture": "x86",
      "full_name": "Compare Real",
      "summary": "Compares ST(0) with source.",
      "syntax": "FCOM m32fp/m64fp",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD8 /2",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Memory/Reg"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fcom_1",
      "rel_url": "x86/fcom_1/",
      "linked_summary": "Compares ST(0) with source.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fcomi",
      "architecture": "x86",
      "full_name": "Compare Real and Set EFLAGS",
      "summary": "Compares ST(0) with ST(i) and sets CPU EFLAGS directly.",
      "syntax": "FCOMI ST(0), ST(i)",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xDB F0+i",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "x87 FPU (P6+)",
      "slug": "fcomi_1",
      "rel_url": "x86/fcomi_1/",
      "linked_summary": "Compares ST(0) with ST(i) <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../x86/sets/\">sets</a> CPU EFLAGS directly.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "finit",
      "architecture": "x86",
      "full_name": "Initialize FPU",
      "summary": "Resets FPU to default state.",
      "syntax": "FINIT",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x9B DB E3",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "finit_1",
      "rel_url": "x86/finit_1/",
      "linked_summary": "Resets FPU to default state.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fclex",
      "architecture": "x86",
      "full_name": "Clear Exceptions",
      "summary": "Clears floating-point exception flags.",
      "syntax": "FCLEX",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x9B DB E2",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fclex_1",
      "rel_url": "x86/fclex_1/",
      "linked_summary": "Clears floating-point exception flags.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fstsw",
      "architecture": "x86",
      "full_name": "Store Status Word",
      "summary": "Stores FPU status word to AX or memory.",
      "syntax": "FSTSW AX",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x9B DF E0",
        "length": "3",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "AX/Mem"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fstsw_1",
      "rel_url": "x86/fstsw_1/",
      "linked_summary": "Stores FPU status word to AX <a href=\"../../powerisa/or/\">or</a> memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fldcw",
      "architecture": "x86",
      "full_name": "Load Control Word",
      "summary": "Loads FPU control word from memory.",
      "syntax": "FLDCW m2byte",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xD9 /5",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Memory"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fldcw_1",
      "rel_url": "x86/fldcw_1/",
      "linked_summary": "Loads FPU control word from memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fstcw",
      "architecture": "x86",
      "full_name": "Store Control Word",
      "summary": "Stores FPU control word to memory.",
      "syntax": "FSTCW m2byte",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x9B D9 /7",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Memory"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fstcw_1",
      "rel_url": "x86/fstcw_1/",
      "linked_summary": "Stores FPU control word to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "frstor",
      "architecture": "x86",
      "full_name": "Restore FPU State",
      "summary": "Loads FPU state from memory.",
      "syntax": "FRSTOR m108byte",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xDD /4",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Memory"
        }
      ],
      "extension": "x87 FPU",
      "slug": "frstor_1",
      "rel_url": "x86/frstor_1/",
      "linked_summary": "Loads FPU state from memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fsave",
      "architecture": "x86",
      "full_name": "Save FPU State",
      "summary": "Stores FPU state to memory and re-initializes FPU.",
      "syntax": "FSAVE m108byte",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x9B DD /6",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Memory"
        }
      ],
      "extension": "x87 FPU",
      "slug": "fsave_1",
      "rel_url": "x86/fsave_1/",
      "linked_summary": "Stores FPU state to memory <a href=\"../../armv8-a/and_6/\">and</a> re-initializes FPU.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lgdt",
      "architecture": "x86",
      "full_name": "Load Global Descriptor Table Register",
      "summary": "Loads the GDT register (Privileged).",
      "syntax": "LGDT m16&amp;32",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 01 /2",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Memory"
        }
      ],
      "extension": "System",
      "slug": "lgdt_1",
      "rel_url": "x86/lgdt_1/",
      "linked_summary": "Loads the GDT register (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lidt",
      "architecture": "x86",
      "full_name": "Load Interrupt Descriptor Table Register",
      "summary": "Loads the IDT register (Privileged).",
      "syntax": "LIDT m16&amp;32",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 01 /3",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Memory"
        }
      ],
      "extension": "System",
      "slug": "lidt_1",
      "rel_url": "x86/lidt_1/",
      "linked_summary": "Loads the IDT register (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sgdt",
      "architecture": "x86",
      "full_name": "Store Global Descriptor Table Register",
      "summary": "Stores GDT limit and base address to memory.",
      "syntax": "SGDT m",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 01 /0",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Memory"
        }
      ],
      "extension": "System",
      "slug": "sgdt_1",
      "rel_url": "x86/sgdt_1/",
      "linked_summary": "Stores GDT limit <a href=\"../../armv8-a/and_6/\">and</a> base address to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sidt",
      "architecture": "x86",
      "full_name": "Store Interrupt Descriptor Table Register",
      "summary": "Stores IDT limit and base address to memory.",
      "syntax": "SIDT m",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 01 /1",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Memory"
        }
      ],
      "extension": "System",
      "slug": "sidt_1",
      "rel_url": "x86/sidt_1/",
      "linked_summary": "Stores IDT limit <a href=\"../../armv8-a/and_6/\">and</a> base address to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lldt",
      "architecture": "x86",
      "full_name": "Load Local Descriptor Table Register",
      "summary": "Loads LDT segment selector (Privileged).",
      "syntax": "LLDT r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 00 /2",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "System",
      "slug": "lldt_1",
      "rel_url": "x86/lldt_1/",
      "linked_summary": "Loads LDT segment selector (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sldt",
      "architecture": "x86",
      "full_name": "Store Local Descriptor Table Register",
      "summary": "Stores LDT segment selector.",
      "syntax": "SLDT r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 00 /0",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "System",
      "slug": "sldt_1",
      "rel_url": "x86/sldt_1/",
      "linked_summary": "Stores LDT segment selector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ltr",
      "architecture": "x86",
      "full_name": "Load Task Register",
      "summary": "Loads Task Register (Privileged).",
      "syntax": "LTR r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 00 /3",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "System",
      "slug": "ltr_1",
      "rel_url": "x86/ltr_1/",
      "linked_summary": "Loads Task Register (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "str",
      "architecture": "x86",
      "full_name": "Store Task Register",
      "summary": "Stores Task Register.",
      "syntax": "STR r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 00 /1",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "System",
      "slug": "str_1",
      "rel_url": "x86/str_1/",
      "linked_summary": "Stores Task Register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mov cr",
      "architecture": "x86",
      "full_name": "Move Control Register",
      "summary": "Moves data to/from Control Registers (CR0, CR3, etc.) (Privileged).",
      "syntax": "MOV CRn, r",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 22 /r",
        "length": "3",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "CRn"
        },
        {
          "name": "src",
          "desc": "Reg"
        }
      ],
      "extension": "System",
      "slug": "mov_cr_1",
      "rel_url": "x86/mov_cr_1/",
      "linked_summary": "Moves data to/from Control Registers (CR0, CR3, etc.) (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mov dr",
      "architecture": "x86",
      "full_name": "Move Debug Register",
      "summary": "Moves data to/from Debug Registers (DR0-DR7) (Privileged).",
      "syntax": "MOV DRn, r",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 23 /r",
        "length": "3",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "DRn"
        },
        {
          "name": "src",
          "desc": "Reg"
        }
      ],
      "extension": "System",
      "slug": "mov_dr_1",
      "rel_url": "x86/mov_dr_1/",
      "linked_summary": "Moves data to/from Debug Registers (DR0-DR7) (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lmsw",
      "architecture": "x86",
      "full_name": "Load Machine Status Word",
      "summary": "Loads Machine Status Word (Legacy CR0 modification).",
      "syntax": "LMSW r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 01 /6",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "System",
      "slug": "lmsw_1",
      "rel_url": "x86/lmsw_1/",
      "linked_summary": "Loads Machine Status Word (Legacy CR0 modification).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "smsw",
      "architecture": "x86",
      "full_name": "Store Machine Status Word",
      "summary": "Stores Machine Status Word.",
      "syntax": "SMSW r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 01 /4",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "System",
      "slug": "smsw_1",
      "rel_url": "x86/smsw_1/",
      "linked_summary": "Stores Machine Status Word.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "clts",
      "architecture": "x86",
      "full_name": "Clear Task-Switched Flag",
      "summary": "Clears the TS flag in CR0 (Privileged).",
      "syntax": "CLTS",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 06",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "System",
      "slug": "clts_1",
      "rel_url": "x86/clts_1/",
      "linked_summary": "Clears the TS flag <a href=\"../../x86/in/\">in</a> CR0 (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "invd",
      "architecture": "x86",
      "full_name": "Invalidate Internal Caches",
      "summary": "Flushes internal caches without writing back data (Privileged).",
      "syntax": "INVD",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 08",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "System",
      "slug": "invd_1",
      "rel_url": "x86/invd_1/",
      "linked_summary": "Flushes internal caches without writing back data (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "wbinvd",
      "architecture": "x86",
      "full_name": "Write Back and Invalidate Cache",
      "summary": "Writes back modified data and invalidates caches (Privileged).",
      "syntax": "WBINVD",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 09",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "System",
      "slug": "wbinvd_1",
      "rel_url": "x86/wbinvd_1/",
      "linked_summary": "Writes back modified data <a href=\"../../armv8-a/and_6/\">and</a> invalidates caches (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "invlpg",
      "architecture": "x86",
      "full_name": "Invalidate TLB Entry",
      "summary": "Invalidates a specific TLB entry (Privileged).",
      "syntax": "INVLPG m",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 01 /7",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "addr",
          "desc": "Memory"
        }
      ],
      "extension": "System",
      "slug": "invlpg_1",
      "rel_url": "x86/invlpg_1/",
      "linked_summary": "Invalidates a specific TLB entry (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rdmsr",
      "architecture": "x86",
      "full_name": "Read Model Specific Register",
      "summary": "Reads MSR specified by ECX into EDX:EAX (Privileged).",
      "syntax": "RDMSR",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 32",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "System",
      "slug": "rdmsr_1",
      "rel_url": "x86/rdmsr_1/",
      "linked_summary": "Reads MSR specified by ECX into EDX:EAX (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "wrmsr",
      "architecture": "x86",
      "full_name": "Write Model Specific Register",
      "summary": "Writes EDX:EAX to MSR specified by ECX (Privileged).",
      "syntax": "WRMSR",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 30",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "System",
      "slug": "wrmsr_1",
      "rel_url": "x86/wrmsr_1/",
      "linked_summary": "Writes EDX:EAX to MSR specified by ECX (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rdpmc",
      "architecture": "x86",
      "full_name": "Read Performance-Monitoring Counters",
      "summary": "Reads performance counter specified by ECX into EDX:EAX.",
      "syntax": "RDPMC",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 33",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "System",
      "slug": "rdpmc_1",
      "rel_url": "x86/rdpmc_1/",
      "linked_summary": "Reads performance counter specified by ECX into EDX:EAX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sysenter",
      "architecture": "x86",
      "full_name": "Fast System Call",
      "summary": "Fast call to level 0 system procedures.",
      "syntax": "SYSENTER",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 34",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "System",
      "slug": "sysenter_1",
      "rel_url": "x86/sysenter_1/",
      "linked_summary": "Fast <a href=\"../../x86/call_1/\">call</a> to level 0 system procedures.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sysexit",
      "architecture": "x86",
      "full_name": "Fast Return from System Call",
      "summary": "Fast return to level 3 user code.",
      "syntax": "SYSEXIT",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 35",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "System",
      "slug": "sysexit_1",
      "rel_url": "x86/sysexit_1/",
      "linked_summary": "Fast return to level 3 user code.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lar",
      "architecture": "x86",
      "full_name": "Load Access Rights Byte",
      "summary": "Reads access rights from segment descriptor.",
      "syntax": "LAR r, r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 02",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register"
        },
        {
          "name": "src",
          "desc": "Selector"
        }
      ],
      "extension": "System",
      "slug": "lar_1",
      "rel_url": "x86/lar_1/",
      "linked_summary": "Reads access rights from segment descriptor.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lsl",
      "architecture": "x86",
      "full_name": "Load Segment Limit",
      "summary": "Reads segment limit from descriptor.",
      "syntax": "LSL r, r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 03",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register"
        },
        {
          "name": "src",
          "desc": "Selector"
        }
      ],
      "extension": "System",
      "slug": "lsl_1",
      "rel_url": "x86/lsl_1/",
      "linked_summary": "Reads segment limit from descriptor.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "verr",
      "architecture": "x86",
      "full_name": "Verify Segment for Reading",
      "summary": "Checks if segment can be read; sets ZF.",
      "syntax": "VERR r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 00 /4",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Selector"
        }
      ],
      "extension": "System",
      "slug": "verr_1",
      "rel_url": "x86/verr_1/",
      "linked_summary": "Checks if segment can be read; <a href=\"../../x86/sets/\">sets</a> ZF.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "verw",
      "architecture": "x86",
      "full_name": "Verify Segment for Writing",
      "summary": "Checks if segment can be written; sets ZF.",
      "syntax": "VERW r/m16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F 00 /5",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Selector"
        }
      ],
      "extension": "System",
      "slug": "verw_1",
      "rel_url": "x86/verw_1/",
      "linked_summary": "Checks if segment can be written; <a href=\"../../x86/sets/\">sets</a> ZF.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "arpl",
      "architecture": "x86",
      "full_name": "Adjust Requested Privilege Level",
      "summary": "Adjusts RPL of selector to match current CPL (Legacy).",
      "syntax": "ARPL r/m16, r16",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x63",
        "length": "2+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Selector"
        },
        {
          "name": "src",
          "desc": "RPL"
        }
      ],
      "extension": "System (32-bit)",
      "slug": "arpl_1",
      "rel_url": "x86/arpl_1/",
      "linked_summary": "Adjusts RPL of selector to <a href=\"../../armv9-a/match_2/\">match</a> current CPL (Legacy).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rsm",
      "architecture": "x86",
      "full_name": "Resume from System Management Mode",
      "summary": "Exits SMM and returns to previous state (Privileged).",
      "syntax": "RSM",
      "encoding": {
        "format": "System",
        "hex_opcode": "0x0F AA",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "System (SMM)",
      "slug": "rsm_1",
      "rel_url": "x86/rsm_1/",
      "linked_summary": "Exits SMM <a href=\"../../armv8-a/and_6/\">and</a> returns to previous state (Privileged).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bswap",
      "architecture": "x86",
      "full_name": "Byte Swap",
      "summary": "Reverses the byte order of a 32/64-bit register.",
      "syntax": "BSWAP r",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F C8",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register"
        }
      ],
      "extension": "Base",
      "slug": "bswap_3",
      "rel_url": "x86/bswap_3/",
      "linked_summary": "Reverses the byte order of a 32/64-<a href=\"../../armv8-a/bit/\">bit</a> register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmpxchg8b",
      "architecture": "x86",
      "full_name": "Compare and Exchange 8 Bytes",
      "summary": "Atomically compares EDX:EAX with memory; swaps if equal.",
      "syntax": "CMPXCHG8B m64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0x0F C7 /1",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Memory"
        }
      ],
      "extension": "Base",
      "slug": "cmpxchg8b_1",
      "rel_url": "x86/cmpxchg8b_1/",
      "linked_summary": "Atomically compares EDX:EAX with memory; swaps if equal.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "add",
      "architecture": "x86",
      "full_name": "Add",
      "summary": "Adds src to dest and stores result in dest.",
      "syntax": "ADD r/m, r",
      "pseudocode": "DEST \u2190 DEST + SRC;\n// Flags Affected: OF, SF, ZF, AF, CF, PF",
      "example": "ADD EAX, EBX  ; Add EBX to EAX\nADD [EAX], 5  ; Add 5 to the 32-bit integer at address EAX",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "01",
        "length": "2+",
        "visual_parts": []
      },
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">DEST \u2190 DEST + SRC;\n// Flags Affected: OF, SF, ZF, AF, CF, PF</code></pre>",
      "slug": "add_2",
      "rel_url": "x86/add_2/",
      "operands": [],
      "linked_summary": "Adds src to dest <a href=\"../../armv8-a/and_6/\">and</a> stores result <a href=\"../../x86/in/\">in</a> dest.",
      "linked_pseudocode": "DEST \u2190 DEST + SRC;\n// Flags Affected: OF, SF, ZF, AF, CF, PF"
    },
    {
      "mnemonic": "sub",
      "architecture": "x86",
      "full_name": "Subtract",
      "summary": "Subtracts src from dest.",
      "syntax": "SUB r/m, r",
      "pseudocode": "DEST \u2190 DEST - SRC;\n// Flags Affected: OF, SF, ZF, AF, CF, PF",
      "example": "SUB EAX, 10   ; Subtract 10 from EAX\nSUB ECX, EDX  ; Subtract EDX from ECX",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "29",
        "length": "2+",
        "visual_parts": []
      },
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">DEST \u2190 DEST - SRC;\n// Flags Affected: OF, SF, ZF, AF, CF, PF</code></pre>",
      "slug": "sub_2",
      "rel_url": "x86/sub_2/",
      "operands": [],
      "linked_summary": "Subtracts src from dest.",
      "linked_pseudocode": "DEST \u2190 DEST - SRC;\n// Flags Affected: OF, SF, ZF, AF, CF, PF"
    },
    {
      "mnemonic": "mov",
      "architecture": "x86",
      "full_name": "Move",
      "summary": "Copies data from source to destination.",
      "syntax": "MOV r/m, r",
      "pseudocode": "DEST \u2190 SRC;",
      "example": "MOV EAX, 5    ; Load 5 into EAX\nMOV [EBX], EAX ; Store EAX to memory at EBX",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "89",
        "length": "2+",
        "visual_parts": []
      },
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">DEST \u2190 SRC;</code></pre>",
      "slug": "mov_2",
      "rel_url": "x86/mov_2/",
      "operands": [],
      "linked_summary": "Copies data from source to destination.",
      "linked_pseudocode": "DEST \u2190 SRC;"
    },
    {
      "mnemonic": "cmp",
      "architecture": "x86",
      "full_name": "Compare Two Operands",
      "summary": "Subtracts src from dest and updates flags (dest not modified).",
      "syntax": "CMP r/m, r",
      "pseudocode": "temp \u2190 DEST - SRC;\nModifyFlags(temp);\n// DEST is NOT modified",
      "example": "CMP EAX, 10   ; Compare EAX with 10\nJE label      ; Jump if Equal",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "39",
        "length": "2+",
        "visual_parts": []
      },
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">temp \u2190 DEST - SRC;\nModifyFlags(temp);\n// DEST is NOT modified</code></pre>",
      "slug": "cmp_2",
      "rel_url": "x86/cmp_2/",
      "operands": [],
      "linked_summary": "Subtracts src from dest <a href=\"../../armv8-a/and_6/\">and</a> updates flags (dest <a href=\"../../armv8-a/not_1/\">not</a> modified).",
      "linked_pseudocode": "temp \u2190 DEST - SRC;\nModifyFlags(temp);\n// DEST is <a href=\"../../armv9-a/not/\">NOT</a> modified"
    },
    {
      "mnemonic": "jmp",
      "architecture": "x86",
      "full_name": "Jump",
      "summary": "Unconditional jump to target.",
      "syntax": "JMP rel",
      "pseudocode": "RIP \u2190 RIP + Offset;",
      "example": "JMP 0x401000  ; Jump to address\nJMP label     ; Jump to label",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "E9",
        "length": "5",
        "visual_parts": []
      },
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">RIP \u2190 RIP + Offset;</code></pre>",
      "slug": "jmp_2",
      "rel_url": "x86/jmp_2/",
      "operands": [],
      "linked_summary": "Unconditional jump to target.",
      "linked_pseudocode": "RIP \u2190 RIP + Offset;"
    },
    {
      "mnemonic": "and",
      "architecture": "x86",
      "full_name": "Logical AND",
      "summary": "Performs bitwise AND.",
      "syntax": "AND r/m, r",
      "pseudocode": "DEST \u2190 DEST AND SRC;\nCF \u2190 0; OF \u2190 0;",
      "example": "AND EAX, 0xFF ; Keep lowest 8 bits\nAND ECX, EDX  ; Bitwise AND of ECX and EDX",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "21",
        "length": "2+",
        "visual_parts": []
      },
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">DEST \u2190 DEST AND SRC;\nCF \u2190 0; OF \u2190 0;</code></pre>",
      "slug": "and_2",
      "rel_url": "x86/and_2/",
      "operands": [],
      "linked_summary": "Performs bitwise <a href=\"../../armv9-a/and_1/\">AND</a>.",
      "linked_pseudocode": "DEST \u2190 DEST <a href=\"../../armv9-a/and_1/\">AND</a> SRC;\nCF \u2190 0; OF \u2190 0;"
    },
    {
      "mnemonic": "or",
      "architecture": "x86",
      "full_name": "Logical OR",
      "summary": "Performs bitwise OR.",
      "syntax": "OR r/m, r",
      "pseudocode": "DEST \u2190 DEST OR SRC;\nCF \u2190 0; OF \u2190 0;",
      "example": "OR EAX, 1     ; Set lowest bit\nOR EAX, EAX   ; Check if EAX is zero (sets ZF)",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "09",
        "length": "2+",
        "visual_parts": []
      },
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">DEST \u2190 DEST OR SRC;\nCF \u2190 0; OF \u2190 0;</code></pre>",
      "slug": "or_2",
      "rel_url": "x86/or_2/",
      "operands": [],
      "linked_summary": "Performs bitwise <a href=\"../../risc-v/or/\">OR</a>.",
      "linked_pseudocode": "DEST \u2190 DEST <a href=\"../../risc-v/or/\">OR</a> SRC;\nCF \u2190 0; OF \u2190 0;"
    },
    {
      "mnemonic": "xor",
      "architecture": "x86",
      "full_name": "Logical Exclusive OR",
      "summary": "Performs bitwise XOR.",
      "syntax": "XOR r/m, r",
      "pseudocode": "DEST \u2190 DEST XOR SRC;\nCF \u2190 0; OF \u2190 0;",
      "example": "XOR EAX, EAX  ; Clear EAX (set to 0)\nXOR EAX, 5    ; Toggle bits 0 and 2",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "31",
        "length": "2+",
        "visual_parts": []
      },
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">DEST \u2190 DEST XOR SRC;\nCF \u2190 0; OF \u2190 0;</code></pre>",
      "slug": "xor_2",
      "rel_url": "x86/xor_2/",
      "operands": [],
      "linked_summary": "Performs bitwise <a href=\"../../risc-v/xor/\">XOR</a>.",
      "linked_pseudocode": "DEST \u2190 DEST <a href=\"../../risc-v/xor/\">XOR</a> SRC;\nCF \u2190 0; OF \u2190 0;"
    },
    {
      "mnemonic": "test",
      "architecture": "x86",
      "full_name": "Logical Compare",
      "summary": "ANDs operands and updates flags (result discarded).",
      "syntax": "TEST r/m, r",
      "pseudocode": "temp \u2190 DEST AND SRC;\nSF \u2190 MSB(temp); ZF \u2190 (temp = 0);\nPF \u2190 Parity(temp); CF \u2190 0; OF \u2190 0;",
      "example": "TEST EAX, EAX ; Check if EAX is 0\nTEST AL, 1    ; Check if lowest bit is set",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "85",
        "length": "2+",
        "visual_parts": []
      },
      "extension": "Base",
      "pseudocode_html": "<pre><code class=\"language-clike\">temp \u2190 DEST AND SRC;\nSF \u2190 MSB(temp); ZF \u2190 (temp = 0);\nPF \u2190 Parity(temp); CF \u2190 0; OF \u2190 0;</code></pre>",
      "slug": "test_2",
      "rel_url": "x86/test_2/",
      "operands": [],
      "linked_summary": "ANDs operands <a href=\"../../armv8-a/and_6/\">and</a> updates flags (result discarded).",
      "linked_pseudocode": "temp \u2190 DEST <a href=\"../../armv9-a/and_1/\">AND</a> SRC;\nSF \u2190 <a href=\"../../armv9-a/msb/\">MSB</a>(temp); ZF \u2190 (temp = 0);\nPF \u2190 Parity(temp); CF \u2190 0; OF \u2190 0;"
    },
    {
      "mnemonic": "subss",
      "architecture": "x86",
      "full_name": "Subtract Scalar Single-Precision",
      "summary": "Subtracts the low single-precision floating-point value.",
      "syntax": "SUBSS xmm1, xmm2/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "F3 0F 5C",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "subss",
      "rel_url": "x86/subss/",
      "operands": [],
      "linked_summary": "Subtracts the low single-precision floating-point value.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "subsd",
      "architecture": "x86",
      "full_name": "Subtract Scalar Double-Precision",
      "summary": "Subtracts the low double-precision floating-point value.",
      "syntax": "SUBSD xmm1, xmm2/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "F2 0F 5C",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "subsd",
      "rel_url": "x86/subsd/",
      "operands": [],
      "linked_summary": "Subtracts the low double-precision floating-point value.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mulss",
      "architecture": "x86",
      "full_name": "Multiply Scalar Single-Precision",
      "summary": "Multiplies the low single-precision floating-point value.",
      "syntax": "MULSS xmm1, xmm2/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "F3 0F 59",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "mulss",
      "rel_url": "x86/mulss/",
      "operands": [],
      "linked_summary": "Multiplies the low single-precision floating-point value.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mulsd",
      "architecture": "x86",
      "full_name": "Multiply Scalar Double-Precision",
      "summary": "Multiplies the low double-precision floating-point value.",
      "syntax": "MULSD xmm1, xmm2/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "F2 0F 59",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "mulsd",
      "rel_url": "x86/mulsd/",
      "operands": [],
      "linked_summary": "Multiplies the low double-precision floating-point value.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "divss",
      "architecture": "x86",
      "full_name": "Divide Scalar Single-Precision",
      "summary": "Divides the low single-precision floating-point value.",
      "syntax": "DIVSS xmm1, xmm2/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "F3 0F 5E",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "divss",
      "rel_url": "x86/divss/",
      "operands": [],
      "linked_summary": "Divides the low single-precision floating-point value.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "divsd",
      "architecture": "x86",
      "full_name": "Divide Scalar Double-Precision",
      "summary": "Divides the low double-precision floating-point value.",
      "syntax": "DIVSD xmm1, xmm2/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "F2 0F 5E",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "divsd",
      "rel_url": "x86/divsd/",
      "operands": [],
      "linked_summary": "Divides the low double-precision floating-point value.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sqrtss",
      "architecture": "x86",
      "full_name": "Square Root Scalar Single-Precision",
      "summary": "Computes square root of the low float.",
      "syntax": "SQRTSS xmm1, xmm2/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "F3 0F 51",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "sqrtss",
      "rel_url": "x86/sqrtss/",
      "operands": [],
      "linked_summary": "Computes square root of the low float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sqrtsd",
      "architecture": "x86",
      "full_name": "Square Root Scalar Double-Precision",
      "summary": "Computes square root of the low double.",
      "syntax": "SQRTSD xmm1, xmm2/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "F2 0F 51",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "sqrtsd",
      "rel_url": "x86/sqrtsd/",
      "operands": [],
      "linked_summary": "Computes square root of the low double.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "minss",
      "architecture": "x86",
      "full_name": "Minimum Scalar Single-Precision",
      "summary": "Returns the minimum of two low single-precision values.",
      "syntax": "MINSS xmm1, xmm2/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "F3 0F 5D",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "minss",
      "rel_url": "x86/minss/",
      "operands": [],
      "linked_summary": "Returns the minimum of two low single-precision values.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "minsd",
      "architecture": "x86",
      "full_name": "Minimum Scalar Double-Precision",
      "summary": "Returns the minimum of two low double-precision values.",
      "syntax": "MINSD xmm1, xmm2/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "F2 0F 5D",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "minsd",
      "rel_url": "x86/minsd/",
      "operands": [],
      "linked_summary": "Returns the minimum of two low double-precision values.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "maxss",
      "architecture": "x86",
      "full_name": "Maximum Scalar Single-Precision",
      "summary": "Returns the maximum of two low single-precision values.",
      "syntax": "MAXSS xmm1, xmm2/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "F3 0F 5F",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "maxss",
      "rel_url": "x86/maxss/",
      "operands": [],
      "linked_summary": "Returns the maximum of two low single-precision values.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "maxsd",
      "architecture": "x86",
      "full_name": "Maximum Scalar Double-Precision",
      "summary": "Returns the maximum of two low double-precision values.",
      "syntax": "MAXSD xmm1, xmm2/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "F2 0F 5F",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "maxsd",
      "rel_url": "x86/maxsd/",
      "operands": [],
      "linked_summary": "Returns the maximum of two low double-precision values.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmpss",
      "architecture": "x86",
      "full_name": "Compare Scalar Single-Precision",
      "summary": "Compares low single-precision values and returns mask.",
      "syntax": "CMPSS xmm1, xmm2/m32, imm8",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "F3 0F C2",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "cmpss",
      "rel_url": "x86/cmpss/",
      "operands": [],
      "linked_summary": "Compares low single-precision values <a href=\"../../armv8-a/and_6/\">and</a> returns mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmpsd",
      "architecture": "x86",
      "full_name": "Compare Scalar Double-Precision",
      "summary": "Compares low double-precision values and returns mask.",
      "syntax": "CMPSD xmm1, xmm2/m64, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "F2 0F C2",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "cmpsd",
      "rel_url": "x86/cmpsd/",
      "operands": [],
      "linked_summary": "Compares low double-precision values <a href=\"../../armv8-a/and_6/\">and</a> returns mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rcpss",
      "architecture": "x86",
      "full_name": "Reciprocal Scalar Single-Precision",
      "summary": "Computes approximate reciprocal (1/x) of low float.",
      "syntax": "RCPSS xmm1, xmm2/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "F3 0F 53",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "rcpss",
      "rel_url": "x86/rcpss/",
      "operands": [],
      "linked_summary": "Computes approximate reciprocal (1/x) of low float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rsqrtss",
      "architecture": "x86",
      "full_name": "Reciprocal Square Root Scalar Single-Precision",
      "summary": "Computes approximate reciprocal sqrt (1/sqrt(x)) of low float.",
      "syntax": "RSQRTSS xmm1, xmm2/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "F3 0F 52",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "rsqrtss",
      "rel_url": "x86/rsqrtss/",
      "operands": [],
      "linked_summary": "Computes approximate reciprocal sqrt (1/sqrt(x)) of low float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "roundss",
      "architecture": "x86",
      "full_name": "Round Scalar Single-Precision",
      "summary": "Rounds low float according to immediate mode.",
      "syntax": "ROUNDSS xmm1, xmm2/m32, imm8",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 3A 0A",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "roundss",
      "rel_url": "x86/roundss/",
      "operands": [],
      "linked_summary": "Rounds low float according to immediate mode.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "roundsd",
      "architecture": "x86",
      "full_name": "Round Scalar Double-Precision",
      "summary": "Rounds low double according to immediate mode.",
      "syntax": "ROUNDSD xmm1, xmm2/m64, imm8",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 3A 0B",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "roundsd",
      "rel_url": "x86/roundsd/",
      "operands": [],
      "linked_summary": "Rounds low double according to immediate mode.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvttps2pi",
      "architecture": "x86",
      "full_name": "Convert with Truncation Packed Single to Packed Integer (MMX)",
      "summary": "Converts packed floats to packed MMX integers (Truncate).",
      "syntax": "CVTTPS2PI mm, xmm/m64",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F 2C",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "cvttps2pi",
      "rel_url": "x86/cvttps2pi/",
      "operands": [],
      "linked_summary": "Converts packed floats to packed MMX integers (Truncate).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvtps2pd",
      "architecture": "x86",
      "full_name": "Convert Packed Single to Packed Double",
      "summary": "Converts lower two floats to doubles.",
      "syntax": "CVTPS2PD xmm1, xmm2/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0F 5A",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "cvtps2pd",
      "rel_url": "x86/cvtps2pd/",
      "operands": [],
      "linked_summary": "Converts lower two floats to doubles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvtpd2ps",
      "architecture": "x86",
      "full_name": "Convert Packed Double to Packed Single",
      "summary": "Converts two doubles to two floats.",
      "syntax": "CVTPD2PS xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 5A",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "cvtpd2ps",
      "rel_url": "x86/cvtpd2ps/",
      "operands": [],
      "linked_summary": "Converts two doubles to two floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "jo",
      "architecture": "x86",
      "full_name": "Jump if Overflow",
      "summary": "Jump near if overflow flag is 1.",
      "syntax": "JO rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "70",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "jo",
      "rel_url": "x86/jo/",
      "operands": [],
      "linked_summary": "Jump near if overflow flag is 1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "jno",
      "architecture": "x86",
      "full_name": "Jump if Not Overflow",
      "summary": "Jump near if overflow flag is 0.",
      "syntax": "JNO rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "71",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "jno",
      "rel_url": "x86/jno/",
      "operands": [],
      "linked_summary": "Jump near if overflow flag is 0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "js",
      "architecture": "x86",
      "full_name": "Jump if Sign",
      "summary": "Jump near if sign flag is 1 (Negative).",
      "syntax": "JS rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "78",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "js",
      "rel_url": "x86/js/",
      "operands": [],
      "linked_summary": "Jump near if sign flag is 1 (Negative).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "jns",
      "architecture": "x86",
      "full_name": "Jump if Not Sign",
      "summary": "Jump near if sign flag is 0 (Positive).",
      "syntax": "JNS rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "79",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "jns",
      "rel_url": "x86/jns/",
      "operands": [],
      "linked_summary": "Jump near if sign flag is 0 (Positive).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "jp",
      "architecture": "x86",
      "full_name": "Jump if Parity",
      "summary": "Jump near if parity flag is 1 (Even parity).",
      "syntax": "JP rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "7A",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "jp",
      "rel_url": "x86/jp/",
      "operands": [],
      "linked_summary": "Jump near if parity flag is 1 (Even parity).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "jnp",
      "architecture": "x86",
      "full_name": "Jump if Not Parity",
      "summary": "Jump near if parity flag is 0 (Odd parity).",
      "syntax": "JNP rel",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "7B",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "jnp",
      "rel_url": "x86/jnp/",
      "operands": [],
      "linked_summary": "Jump near if parity flag is 0 (Odd parity).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "seto",
      "architecture": "x86",
      "full_name": "Set Byte on Overflow",
      "summary": "Sets byte to 1 if OF=1.",
      "syntax": "SETO r/m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 90",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "seto",
      "rel_url": "x86/seto/",
      "operands": [],
      "linked_summary": "Sets byte to 1 if OF=1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "setno",
      "architecture": "x86",
      "full_name": "Set Byte on Not Overflow",
      "summary": "Sets byte to 1 if OF=0.",
      "syntax": "SETNO r/m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 91",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "setno",
      "rel_url": "x86/setno/",
      "operands": [],
      "linked_summary": "Sets byte to 1 if OF=0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "setz",
      "architecture": "x86",
      "full_name": "Set Byte on Zero",
      "summary": "Sets byte to 1 if ZF=1.",
      "syntax": "SETZ r/m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 94",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "setz",
      "rel_url": "x86/setz/",
      "operands": [],
      "linked_summary": "Sets byte to 1 if ZF=1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "setnz",
      "architecture": "x86",
      "full_name": "Set Byte on Not Zero",
      "summary": "Sets byte to 1 if ZF=0.",
      "syntax": "SETNZ r/m8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 95",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "setnz",
      "rel_url": "x86/setnz/",
      "operands": [],
      "linked_summary": "Sets byte to 1 if ZF=0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmovg",
      "architecture": "x86",
      "full_name": "Conditional Move Greater",
      "summary": "Move if ZF=0 and SF=OF.",
      "syntax": "CMOVG r, r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 4F",
        "visual_parts": []
      },
      "extension": "CMOV",
      "slug": "cmovg",
      "rel_url": "x86/cmovg/",
      "operands": [],
      "linked_summary": "Move if ZF=0 <a href=\"../../armv8-a/and_6/\">and</a> SF=OF.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmovge",
      "architecture": "x86",
      "full_name": "Conditional Move Greater or Equal",
      "summary": "Move if SF=OF.",
      "syntax": "CMOVGE r, r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 4D",
        "visual_parts": []
      },
      "extension": "CMOV",
      "slug": "cmovge",
      "rel_url": "x86/cmovge/",
      "operands": [],
      "linked_summary": "Move if SF=OF.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmovl",
      "architecture": "x86",
      "full_name": "Conditional Move Less",
      "summary": "Move if SF!=OF.",
      "syntax": "CMOVL r, r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 4C",
        "visual_parts": []
      },
      "extension": "CMOV",
      "slug": "cmovl",
      "rel_url": "x86/cmovl/",
      "operands": [],
      "linked_summary": "Move if SF!=OF.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmovle",
      "architecture": "x86",
      "full_name": "Conditional Move Less or Equal",
      "summary": "Move if ZF=1 or SF!=OF.",
      "syntax": "CMOVLE r, r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 4E",
        "visual_parts": []
      },
      "extension": "CMOV",
      "slug": "cmovle",
      "rel_url": "x86/cmovle/",
      "operands": [],
      "linked_summary": "Move if ZF=1 <a href=\"../../powerisa/or/\">or</a> SF!=OF.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmovz",
      "architecture": "x86",
      "full_name": "Conditional Move Zero",
      "summary": "Move if ZF=1.",
      "syntax": "CMOVZ r, r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 44",
        "visual_parts": []
      },
      "extension": "CMOV",
      "slug": "cmovz",
      "rel_url": "x86/cmovz/",
      "operands": [],
      "linked_summary": "Move if ZF=1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmovnz",
      "architecture": "x86",
      "full_name": "Conditional Move Not Zero",
      "summary": "Move if ZF=0.",
      "syntax": "CMOVNZ r, r/m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 45",
        "visual_parts": []
      },
      "extension": "CMOV",
      "slug": "cmovnz",
      "rel_url": "x86/cmovnz/",
      "operands": [],
      "linked_summary": "Move if ZF=0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "paddusw",
      "architecture": "x86",
      "full_name": "Packed Add Unsigned Saturation Word",
      "summary": "Adds 16-bit words with unsigned saturation.",
      "syntax": "PADDUSW xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F DD",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "paddusw_1",
      "rel_url": "x86/paddusw_1/",
      "operands": [],
      "linked_summary": "Adds 16-<a href=\"../../armv8-a/bit/\">bit</a> words with unsigned saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "paddsw",
      "architecture": "x86",
      "full_name": "Packed Add Signed Saturation Word",
      "summary": "Adds 16-bit words with signed saturation.",
      "syntax": "PADDSW xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F ED",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "paddsw_1",
      "rel_url": "x86/paddsw_1/",
      "operands": [],
      "linked_summary": "Adds 16-<a href=\"../../armv8-a/bit/\">bit</a> words with signed saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psubusw",
      "architecture": "x86",
      "full_name": "Packed Subtract Unsigned Saturation Word",
      "summary": "Subtracts 16-bit words with unsigned saturation.",
      "syntax": "PSUBUSW xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F D9",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "psubusw_1",
      "rel_url": "x86/psubusw_1/",
      "operands": [],
      "linked_summary": "Subtracts 16-<a href=\"../../armv8-a/bit/\">bit</a> words with unsigned saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psubsw",
      "architecture": "x86",
      "full_name": "Packed Subtract Signed Saturation Word",
      "summary": "Subtracts 16-bit words with signed saturation.",
      "syntax": "PSUBSW xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F E9",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "psubsw_1",
      "rel_url": "x86/psubsw_1/",
      "operands": [],
      "linked_summary": "Subtracts 16-<a href=\"../../armv8-a/bit/\">bit</a> words with signed saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmullw",
      "architecture": "x86",
      "full_name": "Packed Multiply Low Word",
      "summary": "Multiplies 16-bit words and stores low 16-bit result.",
      "syntax": "PMULLW xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F D5",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "pmullw_1",
      "rel_url": "x86/pmullw_1/",
      "operands": [],
      "linked_summary": "Multiplies 16-<a href=\"../../armv8-a/bit/\">bit</a> words <a href=\"../../armv8-a/and_6/\">and</a> stores low 16-<a href=\"../../armv8-a/bit/\">bit</a> result.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmaddwd",
      "architecture": "x86",
      "full_name": "Packed Multiply and Add Word to Doubleword",
      "summary": "Multiplies words, adds adjacent pairs to doublewords.",
      "syntax": "PMADDWD xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F F5",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "pmaddwd_1",
      "rel_url": "x86/pmaddwd_1/",
      "operands": [],
      "linked_summary": "Multiplies words, <a href=\"../../armv8-a/adds_5/\">adds</a> adjacent pairs to doublewords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pcmpgtb",
      "architecture": "x86",
      "full_name": "Packed Compare Greater Than Byte",
      "summary": "Compares bytes for greater than (signed).",
      "syntax": "PCMPGTB xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 64",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "pcmpgtb_1",
      "rel_url": "x86/pcmpgtb_1/",
      "operands": [],
      "linked_summary": "Compares bytes for greater than (signed).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pcmpgtw",
      "architecture": "x86",
      "full_name": "Packed Compare Greater Than Word",
      "summary": "Compares words for greater than (signed).",
      "syntax": "PCMPGTW xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 65",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "pcmpgtw_1",
      "rel_url": "x86/pcmpgtw_1/",
      "operands": [],
      "linked_summary": "Compares words for greater than (signed).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pcmpgtd",
      "architecture": "x86",
      "full_name": "Packed Compare Greater Than Doubleword",
      "summary": "Compares doublewords for greater than (signed).",
      "syntax": "PCMPGTD xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 66",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "pcmpgtd_1",
      "rel_url": "x86/pcmpgtd_1/",
      "operands": [],
      "linked_summary": "Compares doublewords for greater than (signed).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pinsrw",
      "architecture": "x86",
      "full_name": "Packed Insert Word",
      "summary": "Inserts a word from integer register into XMM.",
      "syntax": "PINSRW xmm1, r32/m16, imm8",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "66 0F C4",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "pinsrw",
      "rel_url": "x86/pinsrw/",
      "operands": [],
      "linked_summary": "Inserts a word from integer register into XMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pextrw",
      "architecture": "x86",
      "full_name": "Packed Extract Word",
      "summary": "Extracts a word from XMM to integer register.",
      "syntax": "PEXTRW r32, xmm1, imm8",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "66 0F C5",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "pextrw",
      "rel_url": "x86/pextrw/",
      "operands": [],
      "linked_summary": "Extracts a word from XMM to integer register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pshuflw",
      "architecture": "x86",
      "full_name": "Packed Shuffle Low Words",
      "summary": "Shuffles the low 4 words of XMM.",
      "syntax": "PSHUFLW xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "F2 0F 70",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "pshuflw",
      "rel_url": "x86/pshuflw/",
      "operands": [],
      "linked_summary": "Shuffles the low 4 words of XMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pshufhw",
      "architecture": "x86",
      "full_name": "Packed Shuffle High Words",
      "summary": "Shuffles the high 4 words of XMM.",
      "syntax": "PSHUFHW xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "F3 0F 70",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "pshufhw",
      "rel_url": "x86/pshufhw/",
      "operands": [],
      "linked_summary": "Shuffles the high 4 words of XMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movntq",
      "architecture": "x86",
      "full_name": "Move Non-Temporal Quadword",
      "summary": "Stores 64-bit MMX data bypassing cache.",
      "syntax": "MOVNTQ m64, mm",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F E7",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "movntq",
      "rel_url": "x86/movntq/",
      "operands": [],
      "linked_summary": "Stores 64-<a href=\"../../armv8-a/bit/\">bit</a> MMX data bypassing cache.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movnti",
      "architecture": "x86",
      "full_name": "Move Non-Temporal Integer",
      "summary": "Stores integer register to memory bypassing cache.",
      "syntax": "MOVNTI m32, r32",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0F C3",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "movnti",
      "rel_url": "x86/movnti/",
      "operands": [],
      "linked_summary": "Stores integer register to memory bypassing cache.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmpxchg16b",
      "architecture": "x86",
      "full_name": "Compare and Exchange 16 Bytes",
      "summary": "Atomically compares 128-bit memory with RDX:RAX.",
      "syntax": "CMPXCHG16B m128",
      "encoding": {
        "format": "Base (64-bit)",
        "hex_opcode": "0F C7 /1",
        "visual_parts": []
      },
      "extension": "Base (64-bit)",
      "slug": "cmpxchg16b",
      "rel_url": "x86/cmpxchg16b/",
      "operands": [],
      "linked_summary": "Atomically compares 128-<a href=\"../../armv8-a/bit/\">bit</a> memory with RDX:RAX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movbe",
      "architecture": "x86",
      "full_name": "Move Big-Endian",
      "summary": "Moves data swapping bytes (Big Endian load/store).",
      "syntax": "MOVBE r, m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 38 F0",
        "visual_parts": []
      },
      "extension": "MOVBE",
      "slug": "movbe",
      "rel_url": "x86/movbe/",
      "operands": [],
      "linked_summary": "Moves data swapping bytes (Big Endian load/store).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "blendvpd",
      "architecture": "x86",
      "full_name": "Variable Blend Packed Double",
      "summary": "Blends doubles based on variable mask in XMM0.",
      "syntax": "BLENDVPD xmm1, xmm2/m128, &lt;XMM0&gt;",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 15",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "blendvpd",
      "rel_url": "x86/blendvpd/",
      "operands": [],
      "linked_summary": "Blends doubles based on variable mask <a href=\"../../x86/in/\">in</a> XMM0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "blendvps",
      "architecture": "x86",
      "full_name": "Variable Blend Packed Single",
      "summary": "Blends floats based on variable mask in XMM0.",
      "syntax": "BLENDVPS xmm1, xmm2/m128, &lt;XMM0&gt;",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 14",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "blendvps",
      "rel_url": "x86/blendvps/",
      "operands": [],
      "linked_summary": "Blends floats based on variable mask <a href=\"../../x86/in/\">in</a> XMM0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pblendvb",
      "architecture": "x86",
      "full_name": "Variable Blend Packed Bytes",
      "summary": "Blends bytes based on variable mask in XMM0.",
      "syntax": "PBLENDVB xmm1, xmm2/m128, &lt;XMM0&gt;",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 10",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "pblendvb",
      "rel_url": "x86/pblendvb/",
      "operands": [],
      "linked_summary": "Blends bytes based on variable mask <a href=\"../../x86/in/\">in</a> XMM0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmrun",
      "architecture": "x86",
      "full_name": "Run Virtual Machine",
      "summary": "Switch to guest VM (AMD SVM).",
      "syntax": "VMRUN",
      "encoding": {
        "format": "SVM",
        "hex_opcode": "0F 01 D8",
        "visual_parts": []
      },
      "extension": "SVM",
      "slug": "vmrun",
      "rel_url": "x86/vmrun/",
      "operands": [],
      "linked_summary": "Switch to guest VM (AMD SVM).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmload",
      "architecture": "x86",
      "full_name": "Load State from VMCB",
      "summary": "Loads processor state from VMCB (AMD SVM).",
      "syntax": "VMLOAD",
      "encoding": {
        "format": "SVM",
        "hex_opcode": "0F 01 DA",
        "visual_parts": []
      },
      "extension": "SVM",
      "slug": "vmload",
      "rel_url": "x86/vmload/",
      "operands": [],
      "linked_summary": "Loads processor state from VMCB (AMD SVM).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmsave",
      "architecture": "x86",
      "full_name": "Save State to VMCB",
      "summary": "Saves processor state to VMCB (AMD SVM).",
      "syntax": "VMSAVE",
      "encoding": {
        "format": "SVM",
        "hex_opcode": "0F 01 DB",
        "visual_parts": []
      },
      "extension": "SVM",
      "slug": "vmsave",
      "rel_url": "x86/vmsave/",
      "operands": [],
      "linked_summary": "Saves processor state to VMCB (AMD SVM).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "clgi",
      "architecture": "x86",
      "full_name": "Clear Global Interrupt Flag",
      "summary": "Disables global interrupts (AMD SVM).",
      "syntax": "CLGI",
      "encoding": {
        "format": "SVM",
        "hex_opcode": "0F 01 DD",
        "visual_parts": []
      },
      "extension": "SVM",
      "slug": "clgi",
      "rel_url": "x86/clgi/",
      "operands": [],
      "linked_summary": "Disables global interrupts (AMD SVM).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stgi",
      "architecture": "x86",
      "full_name": "Set Global Interrupt Flag",
      "summary": "Enables global interrupts (AMD SVM).",
      "syntax": "STGI",
      "encoding": {
        "format": "SVM",
        "hex_opcode": "0F 01 DC",
        "visual_parts": []
      },
      "extension": "SVM",
      "slug": "stgi",
      "rel_url": "x86/stgi/",
      "operands": [],
      "linked_summary": "Enables global interrupts (AMD SVM).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "invlpga",
      "architecture": "x86",
      "full_name": "Invalidate TLB Entry in ASID",
      "summary": "Invalidates TLB entry for specific ASID (AMD SVM).",
      "syntax": "INVLPGA",
      "encoding": {
        "format": "SVM",
        "hex_opcode": "0F 01 DF",
        "visual_parts": []
      },
      "extension": "SVM",
      "slug": "invlpga",
      "rel_url": "x86/invlpga/",
      "operands": [],
      "linked_summary": "Invalidates TLB entry for specific ASID (AMD SVM).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pfadd",
      "architecture": "x86",
      "full_name": "Packed Floating-Point Add",
      "summary": "Adds two packed floats (3DNow!).",
      "syntax": "PFADD mm, mm/m64",
      "encoding": {
        "format": "3DNow!",
        "hex_opcode": "0F 0F /r 9E",
        "visual_parts": []
      },
      "extension": "3DNow!",
      "slug": "pfadd",
      "rel_url": "x86/pfadd/",
      "operands": [],
      "linked_summary": "Adds two packed floats (3DNow!).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pfsub",
      "architecture": "x86",
      "full_name": "Packed Floating-Point Subtract",
      "summary": "Subtracts packed floats (3DNow!).",
      "syntax": "PFSUB mm, mm/m64",
      "encoding": {
        "format": "3DNow!",
        "hex_opcode": "0F 0F /r 9A",
        "visual_parts": []
      },
      "extension": "3DNow!",
      "slug": "pfsub",
      "rel_url": "x86/pfsub/",
      "operands": [],
      "linked_summary": "Subtracts packed floats (3DNow!).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pfmul",
      "architecture": "x86",
      "full_name": "Packed Floating-Point Multiply",
      "summary": "Multiplies packed floats (3DNow!).",
      "syntax": "PFMUL mm, mm/m64",
      "encoding": {
        "format": "3DNow!",
        "hex_opcode": "0F 0F /r B4",
        "visual_parts": []
      },
      "extension": "3DNow!",
      "slug": "pfmul",
      "rel_url": "x86/pfmul/",
      "operands": [],
      "linked_summary": "Multiplies packed floats (3DNow!).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pfrcp",
      "architecture": "x86",
      "full_name": "Packed Floating-Point Reciprocal",
      "summary": "Approximates reciprocal (3DNow!).",
      "syntax": "PFRCP mm, mm/m64",
      "encoding": {
        "format": "3DNow!",
        "hex_opcode": "0F 0F /r 96",
        "visual_parts": []
      },
      "extension": "3DNow!",
      "slug": "pfrcp",
      "rel_url": "x86/pfrcp/",
      "operands": [],
      "linked_summary": "Approximates reciprocal (3DNow!).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pfrsqrt",
      "architecture": "x86",
      "full_name": "Packed Floating-Point Reciprocal Square Root",
      "summary": "Approximates reciprocal sqrt (3DNow!).",
      "syntax": "PFRSQRT mm, mm/m64",
      "encoding": {
        "format": "3DNow!",
        "hex_opcode": "0F 0F /r 97",
        "visual_parts": []
      },
      "extension": "3DNow!",
      "slug": "pfrsqrt",
      "rel_url": "x86/pfrsqrt/",
      "operands": [],
      "linked_summary": "Approximates reciprocal sqrt (3DNow!).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vaddsh",
      "architecture": "x86",
      "full_name": "Add Scalar Half-Precision",
      "summary": "Adds low FP16 value.",
      "syntax": "VADDSH xmm1 {k1}, xmm2, xmm3/m16",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "58",
        "visual_parts": []
      },
      "extension": "AVX512-FP16",
      "slug": "vaddsh",
      "rel_url": "x86/vaddsh/",
      "operands": [],
      "linked_summary": "Adds low FP16 value.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsubsh",
      "architecture": "x86",
      "full_name": "Subtract Scalar Half-Precision",
      "summary": "Subtracts low FP16 value.",
      "syntax": "VSUBSH xmm1 {k1}, xmm2, xmm3/m16",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "5C",
        "visual_parts": []
      },
      "extension": "AVX512-FP16",
      "slug": "vsubsh",
      "rel_url": "x86/vsubsh/",
      "operands": [],
      "linked_summary": "Subtracts low FP16 value.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmulsh",
      "architecture": "x86",
      "full_name": "Multiply Scalar Half-Precision",
      "summary": "Multiplies low FP16 value.",
      "syntax": "VMULSH xmm1 {k1}, xmm2, xmm3/m16",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "59",
        "visual_parts": []
      },
      "extension": "AVX512-FP16",
      "slug": "vmulsh",
      "rel_url": "x86/vmulsh/",
      "operands": [],
      "linked_summary": "Multiplies low FP16 value.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vdivsh",
      "architecture": "x86",
      "full_name": "Divide Scalar Half-Precision",
      "summary": "Divides low FP16 value.",
      "syntax": "VDIVSH xmm1 {k1}, xmm2, xmm3/m16",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "5E",
        "visual_parts": []
      },
      "extension": "AVX512-FP16",
      "slug": "vdivsh",
      "rel_url": "x86/vdivsh/",
      "operands": [],
      "linked_summary": "Divides low FP16 value.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vsqrtsh",
      "architecture": "x86",
      "full_name": "Square Root Scalar Half-Precision",
      "summary": "Square root of low FP16 value.",
      "syntax": "VSQRTSH xmm1 {k1}, xmm2/m16",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "51",
        "visual_parts": []
      },
      "extension": "AVX512-FP16",
      "slug": "vsqrtsh",
      "rel_url": "x86/vsqrtsh/",
      "operands": [],
      "linked_summary": "Square root of low FP16 value.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfmadd132sh",
      "architecture": "x86",
      "full_name": "Fused Multiply-Add Scalar Half-Precision (132)",
      "summary": "Scalar FMA (Dest * Src2 + Src1) for FP16.",
      "syntax": "VFMADD132SH xmm1 {k1}, xmm2, xmm3/m16",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "99",
        "visual_parts": []
      },
      "extension": "AVX512-FP16",
      "slug": "vfmadd132sh",
      "rel_url": "x86/vfmadd132sh/",
      "operands": [],
      "linked_summary": "Scalar FMA (Dest * Src2 + Src1) for FP16.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmullq",
      "architecture": "x86",
      "full_name": "Packed Multiply Low Quadword",
      "summary": "Multiplies 64-bit integers and keeps low 64-bit result.",
      "syntax": "VPMULLQ zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 40",
        "visual_parts": []
      },
      "extension": "AVX512DQ",
      "slug": "vpmullq",
      "rel_url": "x86/vpmullq/",
      "operands": [],
      "linked_summary": "Multiplies 64-<a href=\"../../armv8-a/bit/\">bit</a> integers <a href=\"../../armv8-a/and_6/\">and</a> keeps low 64-<a href=\"../../armv8-a/bit/\">bit</a> result.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpabsd",
      "architecture": "x86",
      "full_name": "Packed Absolute Value Doubleword",
      "summary": "Computes absolute value of 32-bit integers.",
      "syntax": "VPABSD zmm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 1E",
        "visual_parts": []
      },
      "extension": "AVX512F",
      "slug": "vpabsd",
      "rel_url": "x86/vpabsd/",
      "operands": [],
      "linked_summary": "Computes absolute value of 32-<a href=\"../../armv8-a/bit/\">bit</a> integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "valignq",
      "architecture": "x86",
      "full_name": "Align Quadword Vectors",
      "summary": "Extracts 512-bits from two concatenated ZMMs shifted by count.",
      "syntax": "VALIGNQ zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 03",
        "visual_parts": []
      },
      "extension": "AVX512F",
      "slug": "valignq",
      "rel_url": "x86/valignq/",
      "operands": [],
      "linked_summary": "Extracts 512-bits from two concatenated ZMMs shifted by count.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vdbpsadbw",
      "architecture": "x86",
      "full_name": "Double Block Packed Sum-Absolute-Differences",
      "summary": "Computes SAD on 16-bit blocks.",
      "syntax": "VDBPSADBW zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 42",
        "visual_parts": []
      },
      "extension": "AVX512BW",
      "slug": "vdbpsadbw",
      "rel_url": "x86/vdbpsadbw/",
      "operands": [],
      "linked_summary": "Computes SAD on 16-<a href=\"../../armv8-a/bit/\">bit</a> blocks.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vrangess",
      "architecture": "x86",
      "full_name": "Range Restriction Calculation Scalar Single",
      "summary": "Calculates range (min/max/abs) of low float.",
      "syntax": "VRANGESS xmm1 {k1}, xmm2, xmm3/m32, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 51",
        "visual_parts": []
      },
      "extension": "AVX512DQ",
      "slug": "vrangess",
      "rel_url": "x86/vrangess/",
      "operands": [],
      "linked_summary": "Calculates range (min/max/<a href=\"../../armv8-a/abs_1/\">abs</a>) of low float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfixupimmss",
      "architecture": "x86",
      "full_name": "Fix Up Special Scalar Float32 Value",
      "summary": "Fixes special cases (NaN, Inf) in low float using table.",
      "syntax": "VFIXUPIMMSS xmm1 {k1}, xmm2, xmm3/m32, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 55",
        "visual_parts": []
      },
      "extension": "AVX512F",
      "slug": "vfixupimmss",
      "rel_url": "x86/vfixupimmss/",
      "operands": [],
      "linked_summary": "Fixes special cases (NaN, Inf) <a href=\"../../x86/in/\">in</a> low float using table.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vreducess",
      "architecture": "x86",
      "full_name": "Perform Reduction Transformation Scalar Single",
      "summary": "Performs reduction on low float.",
      "syntax": "VREDUCESS xmm1 {k1}, xmm2, xmm3/m32, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 57",
        "visual_parts": []
      },
      "extension": "AVX512DQ",
      "slug": "vreducess",
      "rel_url": "x86/vreducess/",
      "operands": [],
      "linked_summary": "Performs reduction on low float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kandq",
      "architecture": "x86",
      "full_name": "Bitwise Logical AND Masks Quadword",
      "summary": "Bitwise AND of 64-bit mask registers.",
      "syntax": "KANDQ k1, k2, k3",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 41",
        "visual_parts": []
      },
      "extension": "AVX512BW",
      "slug": "kandq",
      "rel_url": "x86/kandq/",
      "operands": [],
      "linked_summary": "Bitwise <a href=\"../../armv9-a/and_1/\">AND</a> of 64-<a href=\"../../armv8-a/bit/\">bit</a> mask registers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "korq",
      "architecture": "x86",
      "full_name": "Bitwise Logical OR Masks Quadword",
      "summary": "Bitwise OR of 64-bit mask registers.",
      "syntax": "KORQ k1, k2, k3",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 45",
        "visual_parts": []
      },
      "extension": "AVX512BW",
      "slug": "korq",
      "rel_url": "x86/korq/",
      "operands": [],
      "linked_summary": "Bitwise <a href=\"../../risc-v/or/\">OR</a> of 64-<a href=\"../../armv8-a/bit/\">bit</a> mask registers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "knotq",
      "architecture": "x86",
      "full_name": "Bitwise Logical NOT Masks Quadword",
      "summary": "Bitwise NOT of 64-bit mask register.",
      "syntax": "KNOTQ k1, k2",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 44",
        "visual_parts": []
      },
      "extension": "AVX512BW",
      "slug": "knotq",
      "rel_url": "x86/knotq/",
      "operands": [],
      "linked_summary": "Bitwise <a href=\"../../armv9-a/not/\">NOT</a> of 64-<a href=\"../../armv8-a/bit/\">bit</a> mask register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aesimc",
      "architecture": "x86",
      "full_name": "AES Inverse Mix Columns",
      "summary": "Performs AES InvMixColumns transformation (decryption helper).",
      "syntax": "AESIMC xmm1, xmm2/m128",
      "encoding": {
        "format": "AES-NI",
        "hex_opcode": "66 0F 38 DB",
        "visual_parts": []
      },
      "extension": "AES-NI",
      "slug": "aesimc",
      "rel_url": "x86/aesimc/",
      "operands": [],
      "linked_summary": "Performs AES InvMixColumns transformation (decryption helper).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "maskmovq",
      "architecture": "x86",
      "full_name": "Store Selected Bytes of Quadword",
      "summary": "Non-temporal store of selected MMX bytes.",
      "syntax": "MASKMOVQ mm1, mm2",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F F7",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "maskmovq",
      "rel_url": "x86/maskmovq/",
      "operands": [],
      "linked_summary": "Non-temporal store of selected MMX bytes.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmulld",
      "architecture": "x86",
      "full_name": "Packed Multiply Low Doubleword",
      "summary": "Multiplies 32-bit integers, stores low 32-bit result.",
      "syntax": "PMULLD xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 40",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "pmulld",
      "rel_url": "x86/pmulld/",
      "operands": [],
      "linked_summary": "Multiplies 32-<a href=\"../../armv8-a/bit/\">bit</a> integers, stores low 32-<a href=\"../../armv8-a/bit/\">bit</a> result.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmovsxbw",
      "architecture": "x86",
      "full_name": "Packed Move with Sign Extend Byte to Word",
      "summary": "Sign extends 8-bit integers to 16-bit.",
      "syntax": "PMOVSXBW xmm1, xmm2/m64",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 20",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "pmovsxbw",
      "rel_url": "x86/pmovsxbw/",
      "operands": [],
      "linked_summary": "Sign extends 8-<a href=\"../../armv8-a/bit/\">bit</a> integers to 16-<a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmovzxbw",
      "architecture": "x86",
      "full_name": "Packed Move with Zero Extend Byte to Word",
      "summary": "Zero extends 8-bit integers to 16-bit.",
      "syntax": "PMOVZXBW xmm1, xmm2/m64",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 30",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "pmovzxbw",
      "rel_url": "x86/pmovzxbw/",
      "operands": [],
      "linked_summary": "Zero extends 8-<a href=\"../../armv8-a/bit/\">bit</a> integers to 16-<a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pinsrb",
      "architecture": "x86",
      "full_name": "Packed Insert Byte",
      "summary": "Inserts a byte from integer register into XMM.",
      "syntax": "PINSRB xmm1, r32/m8, imm8",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 3A 20",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "pinsrb",
      "rel_url": "x86/pinsrb/",
      "operands": [],
      "linked_summary": "Inserts a byte from integer register into XMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pextrb",
      "architecture": "x86",
      "full_name": "Packed Extract Byte",
      "summary": "Extracts a byte from XMM to integer register.",
      "syntax": "PEXTRB r32/m8, xmm1, imm8",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 3A 14",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "pextrb",
      "rel_url": "x86/pextrb/",
      "operands": [],
      "linked_summary": "Extracts a byte from XMM to integer register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ptest",
      "architecture": "x86",
      "full_name": "Packed Logical Comparison",
      "summary": "Bitwise compare of 128-bit value (AND) setting flags.",
      "syntax": "PTEST xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 17",
        "visual_parts": []
      },
      "extension": "SSE4.1",
      "slug": "ptest",
      "rel_url": "x86/ptest/",
      "operands": [],
      "linked_summary": "Bitwise compare of 128-<a href=\"../../armv8-a/bit/\">bit</a> value (<a href=\"../../armv9-a/and_1/\">AND</a>) setting flags.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aesenc",
      "architecture": "x86",
      "full_name": "AES Encrypt",
      "summary": "Performs one round of AES encryption flow.",
      "syntax": "AESENC xmm1, xmm2/m128",
      "encoding": {
        "format": "AES-NI",
        "hex_opcode": "66 0F 38 DC",
        "visual_parts": []
      },
      "extension": "AES-NI",
      "slug": "aesenc",
      "rel_url": "x86/aesenc/",
      "operands": [],
      "linked_summary": "Performs one round of AES encryption flow.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aesenclast",
      "architecture": "x86",
      "full_name": "AES Encrypt Last Round",
      "summary": "Performs the last round of AES encryption.",
      "syntax": "AESENCLAST xmm1, xmm2/m128",
      "encoding": {
        "format": "AES-NI",
        "hex_opcode": "66 0F 38 DD",
        "visual_parts": []
      },
      "extension": "AES-NI",
      "slug": "aesenclast",
      "rel_url": "x86/aesenclast/",
      "operands": [],
      "linked_summary": "Performs the last round of AES encryption.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aesdec",
      "architecture": "x86",
      "full_name": "AES Decrypt",
      "summary": "Performs one round of AES decryption flow.",
      "syntax": "AESDEC xmm1, xmm2/m128",
      "encoding": {
        "format": "AES-NI",
        "hex_opcode": "66 0F 38 DE",
        "visual_parts": []
      },
      "extension": "AES-NI",
      "slug": "aesdec",
      "rel_url": "x86/aesdec/",
      "operands": [],
      "linked_summary": "Performs one round of AES decryption flow.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aeskeygenassist",
      "architecture": "x86",
      "full_name": "AES Key Generation Assist",
      "summary": "Generates round key for AES encryption.",
      "syntax": "AESKEYGENASSIST xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "AES-NI",
        "hex_opcode": "66 0F 3A DF",
        "visual_parts": []
      },
      "extension": "AES-NI",
      "slug": "aeskeygenassist",
      "rel_url": "x86/aeskeygenassist/",
      "operands": [],
      "linked_summary": "Generates round key for AES encryption.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vaddps",
      "architecture": "x86",
      "full_name": "Add Packed Single-Precision (AVX)",
      "summary": "Adds packed floats (256-bit YMM support).",
      "syntax": "VADDPS ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C5 /r 58",
        "visual_parts": []
      },
      "extension": "AVX",
      "slug": "vaddps",
      "rel_url": "x86/vaddps/",
      "operands": [],
      "linked_summary": "Adds packed floats (256-<a href=\"../../armv8-a/bit/\">bit</a> YMM support).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmulps",
      "architecture": "x86",
      "full_name": "Multiply Packed Single-Precision (AVX)",
      "summary": "Multiplies packed floats (256-bit).",
      "syntax": "VMULPS ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C5 /r 59",
        "visual_parts": []
      },
      "extension": "AVX",
      "slug": "vmulps",
      "rel_url": "x86/vmulps/",
      "operands": [],
      "linked_summary": "Multiplies packed floats (256-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfmadd231ps",
      "architecture": "x86",
      "full_name": "Fused Multiply-Add (132)",
      "summary": "Computes (Dest * Src2) + Src1.",
      "syntax": "VFMADD231PS ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... B8",
        "visual_parts": []
      },
      "extension": "FMA3",
      "slug": "vfmadd231ps",
      "rel_url": "x86/vfmadd231ps/",
      "operands": [],
      "linked_summary": "Computes (Dest * Src2) + Src1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vinsertf128",
      "architecture": "x86",
      "full_name": "Insert Float 128-bit",
      "summary": "Inserts 128-bits into a YMM register.",
      "syntax": "VINSERTF128 ymm1, ymm2, xmm3/m128, imm8",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 18",
        "visual_parts": []
      },
      "extension": "AVX",
      "slug": "vinsertf128",
      "rel_url": "x86/vinsertf128/",
      "operands": [],
      "linked_summary": "Inserts 128-bits into a YMM register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vextractf128",
      "architecture": "x86",
      "full_name": "Extract Float 128-bit",
      "summary": "Extracts 128-bits from YMM register.",
      "syntax": "VEXTRACTF128 xmm1/m128, ymm2, imm8",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 19",
        "visual_parts": []
      },
      "extension": "AVX",
      "slug": "vextractf128",
      "rel_url": "x86/vextractf128/",
      "operands": [],
      "linked_summary": "Extracts 128-bits from YMM register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vzeroupper",
      "architecture": "x86",
      "full_name": "Zero Upper Bits of YMM Registers",
      "summary": "Clears bits 128-255 of all YMM registers (Avoids AVX-SSE transition penalty).",
      "syntax": "VZEROUPPER",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C5 F8 77",
        "visual_parts": []
      },
      "extension": "AVX",
      "slug": "vzeroupper",
      "rel_url": "x86/vzeroupper/",
      "operands": [],
      "linked_summary": "Clears bits 128-255 of all YMM registers (Avoids AVX-SSE transition penalty).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vzeroall",
      "architecture": "x86",
      "full_name": "Zero All YMM Registers",
      "summary": "Clears all YMM registers.",
      "syntax": "VZEROALL",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C5 FC 77",
        "visual_parts": []
      },
      "extension": "AVX",
      "slug": "vzeroall",
      "rel_url": "x86/vzeroall/",
      "operands": [],
      "linked_summary": "Clears all YMM registers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "emms",
      "architecture": "x86",
      "full_name": "Empty MMX Technology State",
      "summary": "Clears the FPU tag word to allow FP instructions after MMX.",
      "syntax": "EMMS",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0F 77",
        "visual_parts": []
      },
      "extension": "MMX",
      "slug": "emms",
      "rel_url": "x86/emms/",
      "operands": [],
      "linked_summary": "Clears the FPU tag word to allow FP instructions after MMX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movd",
      "architecture": "x86",
      "full_name": "Move Doubleword",
      "summary": "Moves 32 bits between GPR and XMM/MMX register.",
      "syntax": "MOVD mm/xmm, r32/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F 6E",
        "visual_parts": []
      },
      "extension": "MMX/SSE2",
      "slug": "movd",
      "rel_url": "x86/movd/",
      "operands": [],
      "linked_summary": "Moves 32 bits between GPR <a href=\"../../armv8-a/and_6/\">and</a> XMM/MMX register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movq",
      "architecture": "x86",
      "full_name": "Move Quadword",
      "summary": "Moves 64 bits between XMM registers or memory.",
      "syntax": "MOVQ xmm, xmm/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "F3 0F 7E",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "movq_1",
      "rel_url": "x86/movq_1/",
      "operands": [],
      "linked_summary": "Moves 64 bits between XMM registers <a href=\"../../powerisa/or/\">or</a> memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movaps",
      "architecture": "x86",
      "full_name": "Move Aligned Packed Single-Precision",
      "summary": "Moves 128-bit packed float data (Must be 16-byte aligned).",
      "syntax": "MOVAPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F 28",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "movaps",
      "rel_url": "x86/movaps/",
      "operands": [],
      "linked_summary": "Moves 128-<a href=\"../../armv8-a/bit/\">bit</a> packed float data (Must be 16-byte aligned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movups",
      "architecture": "x86",
      "full_name": "Move Unaligned Packed Single-Precision",
      "summary": "Moves 128-bit packed float data (Unaligned).",
      "syntax": "MOVUPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F 10",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "movups",
      "rel_url": "x86/movups/",
      "operands": [],
      "linked_summary": "Moves 128-<a href=\"../../armv8-a/bit/\">bit</a> packed float data (Unaligned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movapd",
      "architecture": "x86",
      "full_name": "Move Aligned Packed Double-Precision",
      "summary": "Moves 128-bit packed double data (Must be 16-byte aligned).",
      "syntax": "MOVAPD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 28",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "movapd",
      "rel_url": "x86/movapd/",
      "operands": [],
      "linked_summary": "Moves 128-<a href=\"../../armv8-a/bit/\">bit</a> packed double data (Must be 16-byte aligned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movupd",
      "architecture": "x86",
      "full_name": "Move Unaligned Packed Double-Precision",
      "summary": "Moves 128-bit packed double data (Unaligned).",
      "syntax": "MOVUPD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 10",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "movupd",
      "rel_url": "x86/movupd/",
      "operands": [],
      "linked_summary": "Moves 128-<a href=\"../../armv8-a/bit/\">bit</a> packed double data (Unaligned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movdqa",
      "architecture": "x86",
      "full_name": "Move Aligned Packed Integer",
      "summary": "Moves 128-bit integer data (Aligned).",
      "syntax": "MOVDQA xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 6F",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "movdqa",
      "rel_url": "x86/movdqa/",
      "operands": [],
      "linked_summary": "Moves 128-<a href=\"../../armv8-a/bit/\">bit</a> integer data (Aligned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movdqu",
      "architecture": "x86",
      "full_name": "Move Unaligned Packed Integer",
      "summary": "Moves 128-bit integer data (Unaligned).",
      "syntax": "MOVDQU xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "F3 0F 6F",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "movdqu",
      "rel_url": "x86/movdqu/",
      "operands": [],
      "linked_summary": "Moves 128-<a href=\"../../armv8-a/bit/\">bit</a> integer data (Unaligned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "addps",
      "architecture": "x86",
      "full_name": "Add Packed Single-Precision",
      "summary": "Adds four 32-bit floats.",
      "syntax": "ADDPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F 58",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "addps",
      "rel_url": "x86/addps/",
      "operands": [],
      "linked_summary": "Adds four 32-<a href=\"../../armv8-a/bit/\">bit</a> floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "addpd",
      "architecture": "x86",
      "full_name": "Add Packed Double-Precision",
      "summary": "Adds two 64-bit doubles.",
      "syntax": "ADDPD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 58",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "addpd",
      "rel_url": "x86/addpd/",
      "operands": [],
      "linked_summary": "Adds two 64-<a href=\"../../armv8-a/bit/\">bit</a> doubles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "addss",
      "architecture": "x86",
      "full_name": "Add Scalar Single-Precision",
      "summary": "Adds the low 32-bit float.",
      "syntax": "ADDSS xmm, xmm/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "F3 0F 58",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "addss",
      "rel_url": "x86/addss/",
      "operands": [],
      "linked_summary": "Adds the low 32-<a href=\"../../armv8-a/bit/\">bit</a> float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "addsd",
      "architecture": "x86",
      "full_name": "Add Scalar Double-Precision",
      "summary": "Adds the low 64-bit double.",
      "syntax": "ADDSD xmm, xmm/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "F2 0F 58",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "addsd",
      "rel_url": "x86/addsd/",
      "operands": [],
      "linked_summary": "Adds the low 64-<a href=\"../../armv8-a/bit/\">bit</a> double.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "subps",
      "architecture": "x86",
      "full_name": "Subtract Packed Single-Precision",
      "summary": "Subtracts four 32-bit floats.",
      "syntax": "SUBPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F 5C",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "subps",
      "rel_url": "x86/subps/",
      "operands": [],
      "linked_summary": "Subtracts four 32-<a href=\"../../armv8-a/bit/\">bit</a> floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "subpd",
      "architecture": "x86",
      "full_name": "Subtract Packed Double-Precision",
      "summary": "Subtracts two 64-bit doubles.",
      "syntax": "SUBPD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 5C",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "subpd",
      "rel_url": "x86/subpd/",
      "operands": [],
      "linked_summary": "Subtracts two 64-<a href=\"../../armv8-a/bit/\">bit</a> doubles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mulps",
      "architecture": "x86",
      "full_name": "Multiply Packed Single-Precision",
      "summary": "Multiplies four 32-bit floats.",
      "syntax": "MULPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F 59",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "mulps",
      "rel_url": "x86/mulps/",
      "operands": [],
      "linked_summary": "Multiplies four 32-<a href=\"../../armv8-a/bit/\">bit</a> floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mulpd",
      "architecture": "x86",
      "full_name": "Multiply Packed Double-Precision",
      "summary": "Multiplies two 64-bit doubles.",
      "syntax": "MULPD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 59",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "mulpd",
      "rel_url": "x86/mulpd/",
      "operands": [],
      "linked_summary": "Multiplies two 64-<a href=\"../../armv8-a/bit/\">bit</a> doubles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "divps",
      "architecture": "x86",
      "full_name": "Divide Packed Single-Precision",
      "summary": "Divides four 32-bit floats.",
      "syntax": "DIVPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F 5E",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "divps",
      "rel_url": "x86/divps/",
      "operands": [],
      "linked_summary": "Divides four 32-<a href=\"../../armv8-a/bit/\">bit</a> floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "divpd",
      "architecture": "x86",
      "full_name": "Divide Packed Double-Precision",
      "summary": "Divides two 64-bit doubles.",
      "syntax": "DIVPD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 5E",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "divpd",
      "rel_url": "x86/divpd/",
      "operands": [],
      "linked_summary": "Divides two 64-<a href=\"../../armv8-a/bit/\">bit</a> doubles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sqrtps",
      "architecture": "x86",
      "full_name": "Square Root Packed Single-Precision",
      "summary": "Computes square root of four 32-bit floats.",
      "syntax": "SQRTPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F 51",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "sqrtps",
      "rel_url": "x86/sqrtps/",
      "operands": [],
      "linked_summary": "Computes square root of four 32-<a href=\"../../armv8-a/bit/\">bit</a> floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sqrtpd",
      "architecture": "x86",
      "full_name": "Square Root Packed Double-Precision",
      "summary": "Computes square root of two 64-bit doubles.",
      "syntax": "SQRTPD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 51",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "sqrtpd",
      "rel_url": "x86/sqrtpd/",
      "operands": [],
      "linked_summary": "Computes square root of two 64-<a href=\"../../armv8-a/bit/\">bit</a> doubles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rcpps",
      "architecture": "x86",
      "full_name": "Reciprocal Packed Single-Precision",
      "summary": "Approximate reciprocal (1/x) of four 32-bit floats.",
      "syntax": "RCPPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F 53",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "rcpps",
      "rel_url": "x86/rcpps/",
      "operands": [],
      "linked_summary": "Approximate reciprocal (1/x) of four 32-<a href=\"../../armv8-a/bit/\">bit</a> floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rsqrtps",
      "architecture": "x86",
      "full_name": "Reciprocal Square Root Packed Single-Precision",
      "summary": "Approximate reciprocal sqrt (1/sqrt(x)) of four 32-bit floats.",
      "syntax": "RSQRTPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F 52",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "rsqrtps",
      "rel_url": "x86/rsqrtps/",
      "operands": [],
      "linked_summary": "Approximate reciprocal sqrt (1/sqrt(x)) of four 32-<a href=\"../../armv8-a/bit/\">bit</a> floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "maxps",
      "architecture": "x86",
      "full_name": "Maximum Packed Single-Precision",
      "summary": "Returns maximum of packed floats.",
      "syntax": "MAXPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F 5F",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "maxps",
      "rel_url": "x86/maxps/",
      "operands": [],
      "linked_summary": "Returns maximum of packed floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "minps",
      "architecture": "x86",
      "full_name": "Minimum Packed Single-Precision",
      "summary": "Returns minimum of packed floats.",
      "syntax": "MINPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F 5D",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "minps",
      "rel_url": "x86/minps/",
      "operands": [],
      "linked_summary": "Returns minimum of packed floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "andps",
      "architecture": "x86",
      "full_name": "Bitwise Logical AND Packed Single-Precision",
      "summary": "Bitwise AND of 128 bits.",
      "syntax": "ANDPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F 54",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "andps",
      "rel_url": "x86/andps/",
      "operands": [],
      "linked_summary": "Bitwise <a href=\"../../armv9-a/and_1/\">AND</a> of 128 bits.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "andpd",
      "architecture": "x86",
      "full_name": "Bitwise Logical AND Packed Double-Precision",
      "summary": "Bitwise AND of 128 bits.",
      "syntax": "ANDPD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 54",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "andpd",
      "rel_url": "x86/andpd/",
      "operands": [],
      "linked_summary": "Bitwise <a href=\"../../armv9-a/and_1/\">AND</a> of 128 bits.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "orps",
      "architecture": "x86",
      "full_name": "Bitwise Logical OR Packed Single-Precision",
      "summary": "Bitwise OR of 128 bits.",
      "syntax": "ORPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F 56",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "orps",
      "rel_url": "x86/orps/",
      "operands": [],
      "linked_summary": "Bitwise <a href=\"../../risc-v/or/\">OR</a> of 128 bits.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xorps",
      "architecture": "x86",
      "full_name": "Bitwise Logical XOR Packed Single-Precision",
      "summary": "Bitwise XOR of 128 bits (Used to clear registers).",
      "syntax": "XORPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F 57",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "xorps",
      "rel_url": "x86/xorps/",
      "operands": [],
      "linked_summary": "Bitwise <a href=\"../../risc-v/xor/\">XOR</a> of 128 bits (Used to clear registers).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "paddb",
      "architecture": "x86",
      "full_name": "Packed Add Bytes",
      "summary": "Adds 16 bytes (Wraparound).",
      "syntax": "PADDB xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F FC",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "paddb",
      "rel_url": "x86/paddb/",
      "operands": [],
      "linked_summary": "Adds 16 bytes (Wraparound).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "paddw",
      "architecture": "x86",
      "full_name": "Packed Add Words",
      "summary": "Adds 8 words (Wraparound).",
      "syntax": "PADDW xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F FD",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "paddw",
      "rel_url": "x86/paddw/",
      "operands": [],
      "linked_summary": "Adds 8 words (Wraparound).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "paddd",
      "architecture": "x86",
      "full_name": "Packed Add Doublewords",
      "summary": "Adds 4 doublewords (Wraparound).",
      "syntax": "PADDD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F FE",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "paddd",
      "rel_url": "x86/paddd/",
      "operands": [],
      "linked_summary": "Adds 4 doublewords (Wraparound).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "paddq",
      "architecture": "x86",
      "full_name": "Packed Add Quadwords",
      "summary": "Adds 2 quadwords (Wraparound).",
      "syntax": "PADDQ xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F D4",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "paddq",
      "rel_url": "x86/paddq/",
      "operands": [],
      "linked_summary": "Adds 2 quadwords (Wraparound).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "paddsb",
      "architecture": "x86",
      "full_name": "Packed Add Bytes Signed Saturate",
      "summary": "Adds 16 signed bytes with saturation.",
      "syntax": "PADDSB xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F EC",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "paddsb_1",
      "rel_url": "x86/paddsb_1/",
      "operands": [],
      "linked_summary": "Adds 16 signed bytes with saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "paddusb",
      "architecture": "x86",
      "full_name": "Packed Add Bytes Unsigned Saturate",
      "summary": "Adds 16 unsigned bytes with saturation.",
      "syntax": "PADDUSB xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F DC",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "paddusb_1",
      "rel_url": "x86/paddusb_1/",
      "operands": [],
      "linked_summary": "Adds 16 unsigned bytes with saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psubb",
      "architecture": "x86",
      "full_name": "Packed Subtract Bytes",
      "summary": "Subtracts 16 bytes.",
      "syntax": "PSUBB xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F F8",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "psubb",
      "rel_url": "x86/psubb/",
      "operands": [],
      "linked_summary": "Subtracts 16 bytes.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psubw",
      "architecture": "x86",
      "full_name": "Packed Subtract Words",
      "summary": "Subtracts 8 words.",
      "syntax": "PSUBW xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F F9",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "psubw",
      "rel_url": "x86/psubw/",
      "operands": [],
      "linked_summary": "Subtracts 8 words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psubd",
      "architecture": "x86",
      "full_name": "Packed Subtract Doublewords",
      "summary": "Subtracts 4 doublewords.",
      "syntax": "PSUBD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F FA",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "psubd",
      "rel_url": "x86/psubd/",
      "operands": [],
      "linked_summary": "Subtracts 4 doublewords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pand",
      "architecture": "x86",
      "full_name": "Packed Logical AND",
      "summary": "Bitwise AND of 128-bit integers.",
      "syntax": "PAND xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F DB",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "pand_1",
      "rel_url": "x86/pand_1/",
      "operands": [],
      "linked_summary": "Bitwise <a href=\"../../armv9-a/and_1/\">AND</a> of 128-<a href=\"../../armv8-a/bit/\">bit</a> integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "por",
      "architecture": "x86",
      "full_name": "Packed Logical OR",
      "summary": "Bitwise OR of 128-bit integers.",
      "syntax": "POR xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F EB",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "por_1",
      "rel_url": "x86/por_1/",
      "operands": [],
      "linked_summary": "Bitwise <a href=\"../../risc-v/or/\">OR</a> of 128-<a href=\"../../armv8-a/bit/\">bit</a> integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pxor",
      "architecture": "x86",
      "full_name": "Packed Logical Exclusive OR",
      "summary": "Bitwise XOR of 128-bit integers.",
      "syntax": "PXOR xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F EF",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "pxor_1",
      "rel_url": "x86/pxor_1/",
      "operands": [],
      "linked_summary": "Bitwise <a href=\"../../risc-v/xor/\">XOR</a> of 128-<a href=\"../../armv8-a/bit/\">bit</a> integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psllw",
      "architecture": "x86",
      "full_name": "Packed Shift Left Logical Word",
      "summary": "Shifts words left.",
      "syntax": "PSLLW xmm, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 71 /6",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "psllw_1",
      "rel_url": "x86/psllw_1/",
      "operands": [],
      "linked_summary": "Shifts words left.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pslld",
      "architecture": "x86",
      "full_name": "Packed Shift Left Logical Doubleword",
      "summary": "Shifts doublewords left.",
      "syntax": "PSLLD xmm, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 72 /6",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "pslld_1",
      "rel_url": "x86/pslld_1/",
      "operands": [],
      "linked_summary": "Shifts doublewords left.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psrlw",
      "architecture": "x86",
      "full_name": "Packed Shift Right Logical Word",
      "summary": "Shifts words right logical.",
      "syntax": "PSRLW xmm, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 71 /2",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "psrlw_1",
      "rel_url": "x86/psrlw_1/",
      "operands": [],
      "linked_summary": "Shifts words right logical.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psrld",
      "architecture": "x86",
      "full_name": "Packed Shift Right Logical Doubleword",
      "summary": "Shifts doublewords right logical.",
      "syntax": "PSRLD xmm, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 72 /2",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "psrld_1",
      "rel_url": "x86/psrld_1/",
      "operands": [],
      "linked_summary": "Shifts doublewords right logical.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psraw",
      "architecture": "x86",
      "full_name": "Packed Shift Right Arithmetic Word",
      "summary": "Shifts words right arithmetic (sign bit).",
      "syntax": "PSRAW xmm, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 71 /4",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "psraw_1",
      "rel_url": "x86/psraw_1/",
      "operands": [],
      "linked_summary": "Shifts words right arithmetic (sign <a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psrad",
      "architecture": "x86",
      "full_name": "Packed Shift Right Arithmetic Doubleword",
      "summary": "Shifts doublewords right arithmetic.",
      "syntax": "PSRAD xmm, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 72 /4",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "psrad_1",
      "rel_url": "x86/psrad_1/",
      "operands": [],
      "linked_summary": "Shifts doublewords right arithmetic.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pcmpeqb",
      "architecture": "x86",
      "full_name": "Packed Compare Equal Byte",
      "summary": "Compares bytes for equality (Result mask 0xFF or 0x00).",
      "syntax": "PCMPEQB xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 74",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "pcmpeqb_1",
      "rel_url": "x86/pcmpeqb_1/",
      "operands": [],
      "linked_summary": "Compares bytes for equality (Result mask 0xFF <a href=\"../../powerisa/or/\">or</a> 0x00).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pcmpeqw",
      "architecture": "x86",
      "full_name": "Packed Compare Equal Word",
      "summary": "Compares words for equality.",
      "syntax": "PCMPEQW xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 75",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "pcmpeqw_1",
      "rel_url": "x86/pcmpeqw_1/",
      "operands": [],
      "linked_summary": "Compares words for equality.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pcmpeqd",
      "architecture": "x86",
      "full_name": "Packed Compare Equal Doubleword",
      "summary": "Compares doublewords for equality.",
      "syntax": "PCMPEQD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 76",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "pcmpeqd_1",
      "rel_url": "x86/pcmpeqd_1/",
      "operands": [],
      "linked_summary": "Compares doublewords for equality.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "shufps",
      "architecture": "x86",
      "full_name": "Shuffle Packed Single-Precision",
      "summary": "Shuffles 32-bit floats based on immediate mask.",
      "syntax": "SHUFPS xmm, xmm/m128, imm8",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F C6",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "shufps_1",
      "rel_url": "x86/shufps_1/",
      "operands": [],
      "linked_summary": "Shuffles 32-<a href=\"../../armv8-a/bit/\">bit</a> floats based on immediate mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "shufpd",
      "architecture": "x86",
      "full_name": "Shuffle Packed Double-Precision",
      "summary": "Shuffles 64-bit doubles based on immediate mask.",
      "syntax": "SHUFPD xmm, xmm/m128, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F C6",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "shufpd_1",
      "rel_url": "x86/shufpd_1/",
      "operands": [],
      "linked_summary": "Shuffles 64-<a href=\"../../armv8-a/bit/\">bit</a> doubles based on immediate mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pshufd",
      "architecture": "x86",
      "full_name": "Packed Shuffle Doubleword",
      "summary": "Shuffles 32-bit integers.",
      "syntax": "PSHUFD xmm, xmm/m128, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 70",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "pshufd",
      "rel_url": "x86/pshufd/",
      "operands": [],
      "linked_summary": "Shuffles 32-<a href=\"../../armv8-a/bit/\">bit</a> integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvtsi2ss",
      "architecture": "x86",
      "full_name": "Convert Doubleword Integer to Scalar Single-Precision",
      "summary": "Converts 32-bit int to float.",
      "syntax": "CVTSI2SS xmm, r/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "F3 0F 2A",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "cvtsi2ss",
      "rel_url": "x86/cvtsi2ss/",
      "operands": [],
      "linked_summary": "Converts 32-<a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/int_1/\">int</a> to float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvtsi2sd",
      "architecture": "x86",
      "full_name": "Convert Doubleword Integer to Scalar Double-Precision",
      "summary": "Converts 32-bit int to double.",
      "syntax": "CVTSI2SD xmm, r/m32",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "F2 0F 2A",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "cvtsi2sd",
      "rel_url": "x86/cvtsi2sd/",
      "operands": [],
      "linked_summary": "Converts 32-<a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/int_1/\">int</a> to double.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvttss2si",
      "architecture": "x86",
      "full_name": "Convert with Truncation Scalar Single to Integer",
      "summary": "Converts float to 32-bit int (Truncate).",
      "syntax": "CVTTSS2SI r32, xmm/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "F3 0F 2C",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "cvttss2si",
      "rel_url": "x86/cvttss2si/",
      "operands": [],
      "linked_summary": "Converts float to 32-<a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/int_1/\">int</a> (Truncate).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvttsd2si",
      "architecture": "x86",
      "full_name": "Convert with Truncation Scalar Double to Integer",
      "summary": "Converts double to 32-bit int (Truncate).",
      "syntax": "CVTTSD2SI r32, xmm/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "F2 0F 2C",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "cvttsd2si",
      "rel_url": "x86/cvttsd2si/",
      "operands": [],
      "linked_summary": "Converts double to 32-<a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/int_1/\">int</a> (Truncate).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvtss2sd",
      "architecture": "x86",
      "full_name": "Convert Scalar Single to Scalar Double",
      "summary": "Converts float to double.",
      "syntax": "CVTSS2SD xmm, xmm/m32",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "F3 0F 5A",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "cvtss2sd",
      "rel_url": "x86/cvtss2sd/",
      "operands": [],
      "linked_summary": "Converts float to double.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvtsd2ss",
      "architecture": "x86",
      "full_name": "Convert Scalar Double to Scalar Single",
      "summary": "Converts double to float.",
      "syntax": "CVTSD2SS xmm, xmm/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "F2 0F 5A",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "cvtsd2ss",
      "rel_url": "x86/cvtsd2ss/",
      "operands": [],
      "linked_summary": "Converts double to float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ucomiss",
      "architecture": "x86",
      "full_name": "Unordered Compare Scalar Single-Precision",
      "summary": "Compares low float and sets EFLAGS.",
      "syntax": "UCOMISS xmm1, xmm2/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F 2E",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "ucomiss",
      "rel_url": "x86/ucomiss/",
      "operands": [],
      "linked_summary": "Compares low float <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../x86/sets/\">sets</a> EFLAGS.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ucomisd",
      "architecture": "x86",
      "full_name": "Unordered Compare Scalar Double-Precision",
      "summary": "Compares low double and sets EFLAGS.",
      "syntax": "UCOMISD xmm1, xmm2/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 2E",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "ucomisd",
      "rel_url": "x86/ucomisd/",
      "operands": [],
      "linked_summary": "Compares low double <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../x86/sets/\">sets</a> EFLAGS.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "punpcklbw",
      "architecture": "x86",
      "full_name": "Unpack Low Data Bytes",
      "summary": "Interleaves low bytes from two sources.",
      "syntax": "PUNPCKLBW xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 60",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "punpcklbw",
      "rel_url": "x86/punpcklbw/",
      "operands": [],
      "linked_summary": "Interleaves low bytes from two sources.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "punpcklwd",
      "architecture": "x86",
      "full_name": "Unpack Low Data Words",
      "summary": "Interleaves low words.",
      "syntax": "PUNPCKLWD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 61",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "punpcklwd",
      "rel_url": "x86/punpcklwd/",
      "operands": [],
      "linked_summary": "Interleaves low words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "punpckldq",
      "architecture": "x86",
      "full_name": "Unpack Low Data Doublewords",
      "summary": "Interleaves low doublewords.",
      "syntax": "PUNPCKLDQ xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 62",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "punpckldq",
      "rel_url": "x86/punpckldq/",
      "operands": [],
      "linked_summary": "Interleaves low doublewords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "punpcklqdq",
      "architecture": "x86",
      "full_name": "Unpack Low Data Quadwords",
      "summary": "Interleaves low quadwords.",
      "syntax": "PUNPCKLQDQ xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 6C",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "punpcklqdq",
      "rel_url": "x86/punpcklqdq/",
      "operands": [],
      "linked_summary": "Interleaves low quadwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "packsswb",
      "architecture": "x86",
      "full_name": "Pack with Signed Saturation Word to Byte",
      "summary": "Converts words to bytes with saturation.",
      "syntax": "PACKSSWB xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 63",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "packsswb",
      "rel_url": "x86/packsswb/",
      "operands": [],
      "linked_summary": "Converts words to bytes with saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "packssdw",
      "architecture": "x86",
      "full_name": "Pack with Signed Saturation Doubleword to Word",
      "summary": "Converts doublewords to words with saturation.",
      "syntax": "PACKSSDW xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 6B",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "packssdw",
      "rel_url": "x86/packssdw/",
      "operands": [],
      "linked_summary": "Converts doublewords to words with saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmovmskb",
      "architecture": "x86",
      "full_name": "Move Byte Mask",
      "summary": "Creates a mask from the MSB of each byte in XMM.",
      "syntax": "PMOVMSKB r32, xmm",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F D7",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "pmovmskb",
      "rel_url": "x86/pmovmskb/",
      "operands": [],
      "linked_summary": "Creates a mask from the <a href=\"../../armv9-a/msb/\">MSB</a> of each byte <a href=\"../../x86/in/\">in</a> XMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "maskmovdqu",
      "architecture": "x86",
      "full_name": "Store Selected Bytes of Double Quadword",
      "summary": "Non-temporal store of selected bytes (masked).",
      "syntax": "MASKMOVDQU xmm, xmm",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F F7",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "maskmovdqu",
      "rel_url": "x86/maskmovdqu/",
      "operands": [],
      "linked_summary": "Non-temporal store of selected bytes (masked).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ldmxcsr",
      "architecture": "x86",
      "full_name": "Load MXCSR Register",
      "summary": "Loads the MXCSR control/status register from memory.",
      "syntax": "LDMXCSR m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F AE /2",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "ldmxcsr",
      "rel_url": "x86/ldmxcsr/",
      "operands": [],
      "linked_summary": "Loads the MXCSR control/status register from memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stmxcsr",
      "architecture": "x86",
      "full_name": "Store MXCSR Register",
      "summary": "Stores the MXCSR register to memory.",
      "syntax": "STMXCSR m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F AE /3",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "stmxcsr",
      "rel_url": "x86/stmxcsr/",
      "operands": [],
      "linked_summary": "Stores the MXCSR register to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "prefetcht0",
      "architecture": "x86",
      "full_name": "Prefetch Data into all Cache Levels",
      "summary": "Prefetches data to L1 cache.",
      "syntax": "PREFETCHT0 m8",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F 18 /1",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "prefetcht0",
      "rel_url": "x86/prefetcht0/",
      "operands": [],
      "linked_summary": "Prefetches data to L1 cache.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "prefetchnta",
      "architecture": "x86",
      "full_name": "Prefetch Data using Non-Temporal Access",
      "summary": "Prefetches data to non-temporal cache structure (minimize pollution).",
      "syntax": "PREFETCHNTA m8",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F 18 /0",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "prefetchnta",
      "rel_url": "x86/prefetchnta/",
      "operands": [],
      "linked_summary": "Prefetches data to non-temporal cache structure (minimize pollution).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfmadd132ps",
      "architecture": "x86",
      "full_name": "Fused Multiply-Add (132) Packed Single",
      "summary": "Computes (Dest * Src2) + Src1.",
      "syntax": "VFMADD132PS ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 98",
        "visual_parts": []
      },
      "extension": "FMA3",
      "slug": "vfmadd132ps",
      "rel_url": "x86/vfmadd132ps/",
      "operands": [],
      "linked_summary": "Computes (Dest * Src2) + Src1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfmadd213ps",
      "architecture": "x86",
      "full_name": "Fused Multiply-Add (213) Packed Single",
      "summary": "Computes (Src1 * Dest) + Src2.",
      "syntax": "VFMADD213PS ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... A8",
        "visual_parts": []
      },
      "extension": "FMA3",
      "slug": "vfmadd213ps",
      "rel_url": "x86/vfmadd213ps/",
      "operands": [],
      "linked_summary": "Computes (Src1 * Dest) + Src2.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfmsub132ps",
      "architecture": "x86",
      "full_name": "Fused Multiply-Subtract (132) Packed Single",
      "summary": "Computes (Dest * Src2) - Src1.",
      "syntax": "VFMSUB132PS ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 9A",
        "visual_parts": []
      },
      "extension": "FMA3",
      "slug": "vfmsub132ps",
      "rel_url": "x86/vfmsub132ps/",
      "operands": [],
      "linked_summary": "Computes (Dest * Src2) - Src1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfnmadd132ps",
      "architecture": "x86",
      "full_name": "Fused Negative Multiply-Add (132) Packed Single",
      "summary": "Computes -(Dest * Src2) + Src1.",
      "syntax": "VFNMADD132PS ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 9C",
        "visual_parts": []
      },
      "extension": "FMA3",
      "slug": "vfnmadd132ps",
      "rel_url": "x86/vfnmadd132ps/",
      "operands": [],
      "linked_summary": "Computes -(Dest * Src2) + Src1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpaddd",
      "architecture": "x86",
      "full_name": "Packed Add Doubleword (AVX2)",
      "summary": "Adds 8 integers (256-bit).",
      "syntax": "VPADDD ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C5 ... FE",
        "visual_parts": []
      },
      "extension": "AVX2",
      "slug": "vpaddd",
      "rel_url": "x86/vpaddd/",
      "operands": [],
      "linked_summary": "Adds 8 integers (256-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpaddb",
      "architecture": "x86",
      "full_name": "Packed Add Byte (AVX2)",
      "summary": "Adds 32 bytes (256-bit).",
      "syntax": "VPADDB ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C5 ... FC",
        "visual_parts": []
      },
      "extension": "AVX2",
      "slug": "vpaddb",
      "rel_url": "x86/vpaddb/",
      "operands": [],
      "linked_summary": "Adds 32 bytes (256-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpsubd",
      "architecture": "x86",
      "full_name": "Packed Subtract Doubleword (AVX2)",
      "summary": "Subtracts 8 integers (256-bit).",
      "syntax": "VPSUBD ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C5 ... FA",
        "visual_parts": []
      },
      "extension": "AVX2",
      "slug": "vpsubd",
      "rel_url": "x86/vpsubd/",
      "operands": [],
      "linked_summary": "Subtracts 8 integers (256-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmulld",
      "architecture": "x86",
      "full_name": "Packed Multiply Low Doubleword (AVX2)",
      "summary": "Multiplies 8 integers (256-bit).",
      "syntax": "VPMULLD ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 40",
        "visual_parts": []
      },
      "extension": "AVX2",
      "slug": "vpmulld",
      "rel_url": "x86/vpmulld/",
      "operands": [],
      "linked_summary": "Multiplies 8 integers (256-<a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpshufb",
      "architecture": "x86",
      "full_name": "Packed Shuffle Bytes (AVX2)",
      "summary": "Shuffles 32 bytes based on indices.",
      "syntax": "VPSHUFB ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 00",
        "visual_parts": []
      },
      "extension": "AVX2",
      "slug": "vpshufb",
      "rel_url": "x86/vpshufb/",
      "operands": [],
      "linked_summary": "Shuffles 32 bytes based on indices.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vperm2i128",
      "architecture": "x86",
      "full_name": "Permute 128-bit Integer Blocks",
      "summary": "Shuffles two 128-bit lanes between registers.",
      "syntax": "VPERM2I128 ymm1, ymm2, ymm3/m256, imm8",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 46",
        "visual_parts": []
      },
      "extension": "AVX2",
      "slug": "vperm2i128",
      "rel_url": "x86/vperm2i128/",
      "operands": [],
      "linked_summary": "Shuffles two 128-<a href=\"../../armv8-a/bit/\">bit</a> lanes between registers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpermd",
      "architecture": "x86",
      "full_name": "Permute Doublewords",
      "summary": "Full permutation of 8 integers using indices from a register.",
      "syntax": "VPERMD ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 36",
        "visual_parts": []
      },
      "extension": "AVX2",
      "slug": "vpermd",
      "rel_url": "x86/vpermd/",
      "operands": [],
      "linked_summary": "Full permutation of 8 integers using indices from a register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpermps",
      "architecture": "x86",
      "full_name": "Permute Single-Precision Floating-Point",
      "summary": "Full permutation of 8 floats using indices.",
      "syntax": "VPERMPS ymm1, ymm2, ymm3/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 16",
        "visual_parts": []
      },
      "extension": "AVX2",
      "slug": "vpermps",
      "rel_url": "x86/vpermps/",
      "operands": [],
      "linked_summary": "Full permutation of 8 floats using indices.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpbroadcastb",
      "architecture": "x86",
      "full_name": "Broadcast Byte",
      "summary": "Broadcasts a byte from memory/register to all elements of YMM.",
      "syntax": "VPBROADCASTB ymm1, xmm2/m8",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 78",
        "visual_parts": []
      },
      "extension": "AVX2",
      "slug": "vpbroadcastb",
      "rel_url": "x86/vpbroadcastb/",
      "operands": [],
      "linked_summary": "Broadcasts a byte from memory/register to all elements of YMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vgatherdps",
      "architecture": "x86",
      "full_name": "Gather Packed Single Precision",
      "summary": "Loads floats from non-contiguous memory using indices.",
      "syntax": "VGATHERDPS ymm1, [base+ymm_idx*scale], ymm_mask",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 92",
        "visual_parts": []
      },
      "extension": "AVX2",
      "slug": "vgatherdps",
      "rel_url": "x86/vgatherdps/",
      "operands": [],
      "linked_summary": "Loads floats from non-contiguous memory using indices.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vgatherdpd",
      "architecture": "x86",
      "full_name": "Gather Packed Double Precision",
      "summary": "Loads doubles from non-contiguous memory using indices.",
      "syntax": "VGATHERDPD ymm1, [base+xmm_idx*scale], ymm_mask",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 92",
        "visual_parts": []
      },
      "extension": "AVX2",
      "slug": "vgatherdpd",
      "rel_url": "x86/vgatherdpd/",
      "operands": [],
      "linked_summary": "Loads doubles from non-contiguous memory using indices.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "andn",
      "architecture": "x86",
      "full_name": "Logical AND NOT",
      "summary": "Calculates (NOT src1) AND src2. Non-destructive.",
      "syntax": "ANDN r32, r32, r/m32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... F2",
        "visual_parts": []
      },
      "extension": "BMI1",
      "slug": "andn",
      "rel_url": "x86/andn/",
      "operands": [],
      "linked_summary": "Calculates (<a href=\"../../armv9-a/not/\">NOT</a> src1) <a href=\"../../armv9-a/and_1/\">AND</a> src2. Non-destructive.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bextr",
      "architecture": "x86",
      "full_name": "Bit Field Extract",
      "summary": "Extracts sequence of bits from source using index/length.",
      "syntax": "BEXTR r32, r/m32, r32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... F7",
        "visual_parts": []
      },
      "extension": "BMI1",
      "slug": "bextr",
      "rel_url": "x86/bextr/",
      "operands": [],
      "linked_summary": "Extracts sequence of bits from source using <a href=\"../../armv8-a/index/\">index</a>/length.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "blsi",
      "architecture": "x86",
      "full_name": "Extract Lowest Set Isolated Bit",
      "summary": "Extracts the lowest set bit (x & -x).",
      "syntax": "BLSI r32, r/m32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... F3 /3",
        "visual_parts": []
      },
      "extension": "BMI1",
      "slug": "blsi",
      "rel_url": "x86/blsi/",
      "operands": [],
      "linked_summary": "Extracts the lowest set <a href=\"../../armv8-a/bit/\">bit</a> (x & -x).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "blsmsk",
      "architecture": "x86",
      "full_name": "Get Mask Up to Lowest Set Bit",
      "summary": "Creates mask up to lowest set bit (x ^ (x-1)).",
      "syntax": "BLSMSK r32, r/m32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... F3 /2",
        "visual_parts": []
      },
      "extension": "BMI1",
      "slug": "blsmsk",
      "rel_url": "x86/blsmsk/",
      "operands": [],
      "linked_summary": "Creates mask up to lowest set <a href=\"../../armv8-a/bit/\">bit</a> (x ^ (x-1)).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "blsr",
      "architecture": "x86",
      "full_name": "Reset Lowest Set Bit",
      "summary": "Clears the lowest set bit (x & (x-1)).",
      "syntax": "BLSR r32, r/m32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... F3 /1",
        "visual_parts": []
      },
      "extension": "BMI1",
      "slug": "blsr",
      "rel_url": "x86/blsr/",
      "operands": [],
      "linked_summary": "Clears the lowest set <a href=\"../../armv8-a/bit/\">bit</a> (x & (x-1)).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tzcnt",
      "architecture": "x86",
      "full_name": "Count Trailing Zeros",
      "summary": "Counts the number of trailing zeros.",
      "syntax": "TZCNT r32, r/m32",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F BC",
        "visual_parts": []
      },
      "extension": "BMI1",
      "slug": "tzcnt",
      "rel_url": "x86/tzcnt/",
      "operands": [],
      "linked_summary": "Counts the number of trailing zeros.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "bzhi",
      "architecture": "x86",
      "full_name": "Zero High Bits Starting with Specified Bit Position",
      "summary": "Clears high bits starting at index.",
      "syntax": "BZHI r32, r/m32, r32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... F5",
        "visual_parts": []
      },
      "extension": "BMI2",
      "slug": "bzhi",
      "rel_url": "x86/bzhi/",
      "operands": [],
      "linked_summary": "Clears high bits starting <a href=\"../../armv8-a/at_2/\">at</a> <a href=\"../../armv8-a/index/\">index</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pext",
      "architecture": "x86",
      "full_name": "Parallel Bits Extract",
      "summary": "Extracts bits from source using mask and packs them to LSB.",
      "syntax": "PEXT r32, r32, r/m32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... F5",
        "visual_parts": []
      },
      "extension": "BMI2",
      "slug": "pext",
      "rel_url": "x86/pext/",
      "operands": [],
      "linked_summary": "Extracts bits from source using mask <a href=\"../../armv8-a/and_6/\">and</a> packs them to LSB.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pdep",
      "architecture": "x86",
      "full_name": "Parallel Bits Deposit",
      "summary": "Scatters bits from LSB of source to positions marked in mask.",
      "syntax": "PDEP r32, r32, r/m32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... F5",
        "visual_parts": []
      },
      "extension": "BMI2",
      "slug": "pdep",
      "rel_url": "x86/pdep/",
      "operands": [],
      "linked_summary": "Scatters bits from LSB of source to positions marked <a href=\"../../x86/in/\">in</a> mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mulx",
      "architecture": "x86",
      "full_name": "Unsigned Multiply Without Affecting Flags",
      "summary": "Unsigned multiply of RDX * Src. Result in Hi:Lo. No flags.",
      "syntax": "MULX r32, r32, r/m32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... F6",
        "visual_parts": []
      },
      "extension": "BMI2",
      "slug": "mulx",
      "rel_url": "x86/mulx/",
      "operands": [],
      "linked_summary": "Unsigned multiply of RDX * Src. Result <a href=\"../../x86/in/\">in</a> Hi:Lo. No flags.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "shlx",
      "architecture": "x86",
      "full_name": "Shift Logical Left Without Affecting Flags",
      "summary": "Logical left shift, count in register. No flags update.",
      "syntax": "SHLX r32, r/m32, r32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... F7",
        "visual_parts": []
      },
      "extension": "BMI2",
      "slug": "shlx",
      "rel_url": "x86/shlx/",
      "operands": [],
      "linked_summary": "Logical left shift, count <a href=\"../../x86/in/\">in</a> register. No flags update.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "shrx",
      "architecture": "x86",
      "full_name": "Shift Logical Right Without Affecting Flags",
      "summary": "Logical right shift, count in register. No flags update.",
      "syntax": "SHRX r32, r/m32, r32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... F7",
        "visual_parts": []
      },
      "extension": "BMI2",
      "slug": "shrx",
      "rel_url": "x86/shrx/",
      "operands": [],
      "linked_summary": "Logical right shift, count <a href=\"../../x86/in/\">in</a> register. No flags update.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sarx",
      "architecture": "x86",
      "full_name": "Shift Arithmetic Right Without Affecting Flags",
      "summary": "Arithmetic right shift, count in register. No flags update.",
      "syntax": "SARX r32, r/m32, r32",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... F7",
        "visual_parts": []
      },
      "extension": "BMI2",
      "slug": "sarx",
      "rel_url": "x86/sarx/",
      "operands": [],
      "linked_summary": "Arithmetic right shift, count <a href=\"../../x86/in/\">in</a> register. No flags update.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rorx",
      "architecture": "x86",
      "full_name": "Rotate Right Logical Without Affecting Flags",
      "summary": "Rotate right with immediate. No flags update.",
      "syntax": "RORX r32, r/m32, imm8",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... F0",
        "visual_parts": []
      },
      "extension": "BMI2",
      "slug": "rorx",
      "rel_url": "x86/rorx/",
      "operands": [],
      "linked_summary": "Rotate right with immediate. No flags update.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rdrand",
      "architecture": "x86",
      "full_name": "Read Random Number",
      "summary": "Retrieves a hardware-generated random number.",
      "syntax": "RDRAND r32",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F C7 /6",
        "visual_parts": []
      },
      "extension": "RDRAND",
      "slug": "rdrand",
      "rel_url": "x86/rdrand/",
      "operands": [],
      "linked_summary": "Retrieves a hardware-generated random number.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rdseed",
      "architecture": "x86",
      "full_name": "Read Random Seed",
      "summary": "Retrieves a random seed from hardware entropy source.",
      "syntax": "RDSEED r32",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F C7 /7",
        "visual_parts": []
      },
      "extension": "RDSEED",
      "slug": "rdseed",
      "rel_url": "x86/rdseed/",
      "operands": [],
      "linked_summary": "Retrieves a random seed from hardware entropy source.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "invpcid",
      "architecture": "x86",
      "full_name": "Invalidate Process-Context Identifier",
      "summary": "Invalidates TLB entries based on PCID.",
      "syntax": "INVPCID r32, m128",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "66 0F 38 82",
        "visual_parts": []
      },
      "extension": "INVPCID",
      "slug": "invpcid",
      "rel_url": "x86/invpcid/",
      "operands": [],
      "linked_summary": "Invalidates TLB entries based on PCID.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "adcx",
      "architecture": "x86",
      "full_name": "Unsigned Integer Addition of Two Operands with Carry Flag",
      "summary": "Adds with Carry Flag (distinct from ADC, affects CF only).",
      "syntax": "ADCX r32, r/m32",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "66 0F 38 F6",
        "visual_parts": []
      },
      "extension": "ADX",
      "slug": "adcx",
      "rel_url": "x86/adcx/",
      "operands": [],
      "linked_summary": "Adds with Carry Flag (distinct from ADC, affects CF only).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "adox",
      "architecture": "x86",
      "full_name": "Unsigned Integer Addition of Two Operands with Overflow Flag",
      "summary": "Adds with Overflow Flag (Parallel addition with ADCX).",
      "syntax": "ADOX r32, r/m32",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 38 F6",
        "visual_parts": []
      },
      "extension": "ADX",
      "slug": "adox",
      "rel_url": "x86/adox/",
      "operands": [],
      "linked_summary": "Adds with Overflow Flag (Parallel addition with ADCX).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vinserti128",
      "architecture": "x86",
      "full_name": "Insert Integer 128-bit",
      "summary": "Inserts 128-bits of integer data into a YMM register.",
      "syntax": "VINSERTI128 ymm1, ymm2, xmm3/m128, imm8",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 38",
        "visual_parts": []
      },
      "extension": "AVX2",
      "slug": "vinserti128",
      "rel_url": "x86/vinserti128/",
      "operands": [],
      "linked_summary": "Inserts 128-bits of integer data into a YMM register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vextracti128",
      "architecture": "x86",
      "full_name": "Extract Integer 128-bit",
      "summary": "Extracts 128-bits of integer data from YMM.",
      "syntax": "VEXTRACTI128 xmm1/m128, ymm2, imm8",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 39",
        "visual_parts": []
      },
      "extension": "AVX2",
      "slug": "vextracti128",
      "rel_url": "x86/vextracti128/",
      "operands": [],
      "linked_summary": "Extracts 128-bits of integer data from YMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "clac",
      "architecture": "x86",
      "full_name": "Clear AC Flag in EFLAGS",
      "summary": "Clears Alignment Check flag (SMAP prevention).",
      "syntax": "CLAC",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 CA",
        "visual_parts": []
      },
      "extension": "SMAP",
      "slug": "clac",
      "rel_url": "x86/clac/",
      "operands": [],
      "linked_summary": "Clears Alignment Check flag (SMAP prevention).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stac",
      "architecture": "x86",
      "full_name": "Set AC Flag in EFLAGS",
      "summary": "Sets Alignment Check flag (Allow user memory access).",
      "syntax": "STAC",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 CB",
        "visual_parts": []
      },
      "extension": "SMAP",
      "slug": "stac",
      "rel_url": "x86/stac/",
      "operands": [],
      "linked_summary": "Sets Alignment Check flag (Allow user memory access).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "gf2p8affineqb",
      "architecture": "x86",
      "full_name": "Galois Field Affine Transformation",
      "summary": "Computes affine transformation in GF(2^8).",
      "syntax": "GF2P8AFFINEQB xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "66 0F 3A CE",
        "visual_parts": []
      },
      "extension": "GFNI",
      "slug": "gf2p8affineqb",
      "rel_url": "x86/gf2p8affineqb/",
      "operands": [],
      "linked_summary": "Computes affine transformation <a href=\"../../x86/in/\">in</a> GF(2^8).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "gf2p8mulb",
      "architecture": "x86",
      "full_name": "Galois Field Multiply Bytes",
      "summary": "Multiplies bytes in GF(2^8).",
      "syntax": "GF2P8MULB xmm1, xmm2/m128",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "66 0F 38 CF",
        "visual_parts": []
      },
      "extension": "GFNI",
      "slug": "gf2p8mulb",
      "rel_url": "x86/gf2p8mulb/",
      "operands": [],
      "linked_summary": "Multiplies bytes <a href=\"../../x86/in/\">in</a> GF(2^8).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sha1msg1",
      "architecture": "x86",
      "full_name": "SHA1 Message Schedule 1",
      "summary": "Performs intermediate calculation for SHA1 message schedule.",
      "syntax": "SHA1MSG1 xmm1, xmm2/m128",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 38 C9",
        "visual_parts": []
      },
      "extension": "SHA",
      "slug": "sha1msg1",
      "rel_url": "x86/sha1msg1/",
      "operands": [],
      "linked_summary": "Performs intermediate calculation for SHA1 message schedule.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sha1msg2",
      "architecture": "x86",
      "full_name": "SHA1 Message Schedule 2",
      "summary": "Performs final calculation for SHA1 message schedule.",
      "syntax": "SHA1MSG2 xmm1, xmm2/m128",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 38 CA",
        "visual_parts": []
      },
      "extension": "SHA",
      "slug": "sha1msg2",
      "rel_url": "x86/sha1msg2/",
      "operands": [],
      "linked_summary": "Performs final calculation for SHA1 message schedule.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sha1nexte",
      "architecture": "x86",
      "full_name": "SHA1 State Variable E",
      "summary": "Calculates SHA1 state variable E.",
      "syntax": "SHA1NEXTE xmm1, xmm2/m128",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 38 C8",
        "visual_parts": []
      },
      "extension": "SHA",
      "slug": "sha1nexte",
      "rel_url": "x86/sha1nexte/",
      "operands": [],
      "linked_summary": "Calculates SHA1 state variable E.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sha1rnds4",
      "architecture": "x86",
      "full_name": "SHA1 Rounds 4",
      "summary": "Performs 4 rounds of SHA1 operation.",
      "syntax": "SHA1RNDS4 xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 3A CC",
        "visual_parts": []
      },
      "extension": "SHA",
      "slug": "sha1rnds4",
      "rel_url": "x86/sha1rnds4/",
      "operands": [],
      "linked_summary": "Performs 4 rounds of SHA1 operation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sha256msg1",
      "architecture": "x86",
      "full_name": "SHA256 Message Schedule 1",
      "summary": "Performs intermediate calculation for SHA256 message schedule.",
      "syntax": "SHA256MSG1 xmm1, xmm2/m128",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 38 CC",
        "visual_parts": []
      },
      "extension": "SHA",
      "slug": "sha256msg1",
      "rel_url": "x86/sha256msg1/",
      "operands": [],
      "linked_summary": "Performs intermediate calculation for SHA256 message schedule.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sha256msg2",
      "architecture": "x86",
      "full_name": "SHA256 Message Schedule 2",
      "summary": "Performs final calculation for SHA256 message schedule.",
      "syntax": "SHA256MSG2 xmm1, xmm2/m128",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 38 CD",
        "visual_parts": []
      },
      "extension": "SHA",
      "slug": "sha256msg2",
      "rel_url": "x86/sha256msg2/",
      "operands": [],
      "linked_summary": "Performs final calculation for SHA256 message schedule.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sha256rnds2",
      "architecture": "x86",
      "full_name": "SHA256 Rounds 2",
      "summary": "Performs 2 rounds of SHA256 operation.",
      "syntax": "SHA256RNDS2 xmm1, xmm2/m128, xmm0",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 38 CB",
        "visual_parts": []
      },
      "extension": "SHA",
      "slug": "sha256rnds2",
      "rel_url": "x86/sha256rnds2/",
      "operands": [],
      "linked_summary": "Performs 2 rounds of SHA256 operation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmxon",
      "architecture": "x86",
      "full_name": "Enter VMX Operation",
      "summary": "Enters VMX root operation (Host Mode).",
      "syntax": "VMXON m64",
      "encoding": {
        "format": "VMX",
        "hex_opcode": "F3 0F C7 /6",
        "visual_parts": []
      },
      "extension": "VMX",
      "slug": "vmxon",
      "rel_url": "x86/vmxon/",
      "operands": [],
      "linked_summary": "Enters VMX root operation (Host Mode).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmcall",
      "architecture": "x86",
      "full_name": "Call to VM Monitor",
      "summary": "Guest VM calls the Hypervisor (VM Exit).",
      "syntax": "VMCALL",
      "encoding": {
        "format": "VMX",
        "hex_opcode": "0F 01 C1",
        "visual_parts": []
      },
      "extension": "VMX",
      "slug": "vmcall",
      "rel_url": "x86/vmcall/",
      "operands": [],
      "linked_summary": "Guest VM calls the Hypervisor (VM Exit).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmclear",
      "architecture": "x86",
      "full_name": "Clear Virtual-Machine Control Structure",
      "summary": "Initializes a VMCS region in memory.",
      "syntax": "VMCLEAR m64",
      "encoding": {
        "format": "VMX",
        "hex_opcode": "66 0F C7 /6",
        "visual_parts": []
      },
      "extension": "VMX",
      "slug": "vmclear",
      "rel_url": "x86/vmclear/",
      "operands": [],
      "linked_summary": "Initializes a VMCS region <a href=\"../../x86/in/\">in</a> memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmlaunch",
      "architecture": "x86",
      "full_name": "Launch Virtual Machine",
      "summary": "Launches a VM managed by the current VMCS.",
      "syntax": "VMLAUNCH",
      "encoding": {
        "format": "VMX",
        "hex_opcode": "0F 01 C2",
        "visual_parts": []
      },
      "extension": "VMX",
      "slug": "vmlaunch",
      "rel_url": "x86/vmlaunch/",
      "operands": [],
      "linked_summary": "Launches a VM managed by the current VMCS.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmresume",
      "architecture": "x86",
      "full_name": "Resume Virtual Machine",
      "summary": "Resumes a VM from the current VMCS.",
      "syntax": "VMRESUME",
      "encoding": {
        "format": "VMX",
        "hex_opcode": "0F 01 C3",
        "visual_parts": []
      },
      "extension": "VMX",
      "slug": "vmresume",
      "rel_url": "x86/vmresume/",
      "operands": [],
      "linked_summary": "Resumes a VM from the current VMCS.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmptrld",
      "architecture": "x86",
      "full_name": "Load Pointer to VMCS",
      "summary": "Loads the current VMCS pointer from memory.",
      "syntax": "VMPTRLD m64",
      "encoding": {
        "format": "VMX",
        "hex_opcode": "0F C7 /6",
        "visual_parts": []
      },
      "extension": "VMX",
      "slug": "vmptrld",
      "rel_url": "x86/vmptrld/",
      "operands": [],
      "linked_summary": "Loads the current VMCS pointer from memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmptrst",
      "architecture": "x86",
      "full_name": "Store Pointer to VMCS",
      "summary": "Stores the current VMCS pointer to memory.",
      "syntax": "VMPTRST m64",
      "encoding": {
        "format": "VMX",
        "hex_opcode": "0F C7 /7",
        "visual_parts": []
      },
      "extension": "VMX",
      "slug": "vmptrst",
      "rel_url": "x86/vmptrst/",
      "operands": [],
      "linked_summary": "Stores the current VMCS pointer to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmread",
      "architecture": "x86",
      "full_name": "Read Field from VMCS",
      "summary": "Reads a field from the Virtual Machine Control Structure.",
      "syntax": "VMREAD r/m64, r64",
      "encoding": {
        "format": "VMX",
        "hex_opcode": "0F 78",
        "visual_parts": []
      },
      "extension": "VMX",
      "slug": "vmread",
      "rel_url": "x86/vmread/",
      "operands": [],
      "linked_summary": "Reads a field from the Virtual Machine Control Structure.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmwrite",
      "architecture": "x86",
      "full_name": "Write Field to VMCS",
      "summary": "Writes a field to the Virtual Machine Control Structure.",
      "syntax": "VMWRITE r64, r/m64",
      "encoding": {
        "format": "VMX",
        "hex_opcode": "0F 79",
        "visual_parts": []
      },
      "extension": "VMX",
      "slug": "vmwrite",
      "rel_url": "x86/vmwrite/",
      "operands": [],
      "linked_summary": "Writes a field to the Virtual Machine Control Structure.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmoff",
      "architecture": "x86",
      "full_name": "Leave VMX Operation",
      "summary": "Leaves VMX root operation.",
      "syntax": "VMOFF",
      "encoding": {
        "format": "VMX",
        "hex_opcode": "0F 01 C4",
        "visual_parts": []
      },
      "extension": "VMX",
      "slug": "vmoff",
      "rel_url": "x86/vmoff/",
      "operands": [],
      "linked_summary": "Leaves VMX root operation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "invept",
      "architecture": "x86",
      "full_name": "Invalidate Translations Derived from EPT",
      "summary": "Invalidates Extended Page Table entries.",
      "syntax": "INVEPT r64, m128",
      "encoding": {
        "format": "VMX",
        "hex_opcode": "66 0F 38 80",
        "visual_parts": []
      },
      "extension": "VMX (EPT)",
      "slug": "invept",
      "rel_url": "x86/invept/",
      "operands": [],
      "linked_summary": "Invalidates Extended Page Table entries.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "invvpid",
      "architecture": "x86",
      "full_name": "Invalidate Translations Based on VPID",
      "summary": "Invalidates TLB entries based on Virtual Processor ID.",
      "syntax": "INVVPID r64, m128",
      "encoding": {
        "format": "VMX",
        "hex_opcode": "66 0F 38 81",
        "visual_parts": []
      },
      "extension": "VMX (VPID)",
      "slug": "invvpid",
      "rel_url": "x86/invvpid/",
      "operands": [],
      "linked_summary": "Invalidates TLB entries based on Virtual Processor ID.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kmovw",
      "architecture": "x86",
      "full_name": "Move Word Mask Register",
      "summary": "Moves 16-bit mask to/from k-register.",
      "syntax": "KMOVW k1, k2/m16",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 90",
        "visual_parts": []
      },
      "extension": "AVX-512",
      "slug": "kmovw",
      "rel_url": "x86/kmovw/",
      "operands": [],
      "linked_summary": "Moves 16-<a href=\"../../armv8-a/bit/\">bit</a> mask to/from k-register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kmovq",
      "architecture": "x86",
      "full_name": "Move Quadword Mask Register",
      "summary": "Moves 64-bit mask to/from k-register.",
      "syntax": "KMOVQ k1, k2/m64",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 90",
        "visual_parts": []
      },
      "extension": "AVX-512BW",
      "slug": "kmovq",
      "rel_url": "x86/kmovq/",
      "operands": [],
      "linked_summary": "Moves 64-<a href=\"../../armv8-a/bit/\">bit</a> mask to/from k-register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kandw",
      "architecture": "x86",
      "full_name": "Bitwise Logical AND Masks Word",
      "summary": "Bitwise AND of 16-bit masks.",
      "syntax": "KANDW k1, k2, k3",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 41",
        "visual_parts": []
      },
      "extension": "AVX-512",
      "slug": "kandw",
      "rel_url": "x86/kandw/",
      "operands": [],
      "linked_summary": "Bitwise <a href=\"../../armv9-a/and_1/\">AND</a> of 16-<a href=\"../../armv8-a/bit/\">bit</a> masks.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kandnw",
      "architecture": "x86",
      "full_name": "Bitwise Logical AND NOT Masks Word",
      "summary": "Bitwise AND NOT of 16-bit masks.",
      "syntax": "KANDNW k1, k2, k3",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 42",
        "visual_parts": []
      },
      "extension": "AVX-512",
      "slug": "kandnw",
      "rel_url": "x86/kandnw/",
      "operands": [],
      "linked_summary": "Bitwise <a href=\"../../armv9-a/and_1/\">AND</a> <a href=\"../../armv9-a/not/\">NOT</a> of 16-<a href=\"../../armv8-a/bit/\">bit</a> masks.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "korw",
      "architecture": "x86",
      "full_name": "Bitwise Logical OR Masks Word",
      "summary": "Bitwise OR of 16-bit masks.",
      "syntax": "KORW k1, k2, k3",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 45",
        "visual_parts": []
      },
      "extension": "AVX-512",
      "slug": "korw",
      "rel_url": "x86/korw/",
      "operands": [],
      "linked_summary": "Bitwise <a href=\"../../risc-v/or/\">OR</a> of 16-<a href=\"../../armv8-a/bit/\">bit</a> masks.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kxorw",
      "architecture": "x86",
      "full_name": "Bitwise Logical XOR Masks Word",
      "summary": "Bitwise XOR of 16-bit masks.",
      "syntax": "KXORW k1, k2, k3",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 47",
        "visual_parts": []
      },
      "extension": "AVX-512",
      "slug": "kxorw",
      "rel_url": "x86/kxorw/",
      "operands": [],
      "linked_summary": "Bitwise <a href=\"../../risc-v/xor/\">XOR</a> of 16-<a href=\"../../armv8-a/bit/\">bit</a> masks.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "knotw",
      "architecture": "x86",
      "full_name": "Bitwise Logical NOT Masks Word",
      "summary": "Bitwise NOT of 16-bit mask.",
      "syntax": "KNOTW k1, k2",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 44",
        "visual_parts": []
      },
      "extension": "AVX-512",
      "slug": "knotw",
      "rel_url": "x86/knotw/",
      "operands": [],
      "linked_summary": "Bitwise <a href=\"../../armv9-a/not/\">NOT</a> of 16-<a href=\"../../armv8-a/bit/\">bit</a> mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kortestw",
      "architecture": "x86",
      "full_name": "OR Masks And Set Flags Word",
      "summary": "ORs two masks and sets EFLAGS (ZF, CF) based on result.",
      "syntax": "KORTESTW k1, k2",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 98",
        "visual_parts": []
      },
      "extension": "AVX-512",
      "slug": "kortestw",
      "rel_url": "x86/kortestw/",
      "operands": [],
      "linked_summary": "ORs two masks <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../x86/sets/\">sets</a> EFLAGS (ZF, CF) based on result.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpternlogd",
      "architecture": "x86",
      "full_name": "Packed Doubleword Ternary Logic",
      "summary": "Performs one of 256 logical operations on 3 inputs.",
      "syntax": "VPTERNLOGD zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 25",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vpternlogd",
      "rel_url": "x86/vpternlogd/",
      "operands": [],
      "linked_summary": "Performs one of 256 logical operations on 3 inputs.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpternlogq",
      "architecture": "x86",
      "full_name": "Packed Quadword Ternary Logic",
      "summary": "Performs one of 256 logical operations on 3 quadwords.",
      "syntax": "VPTERNLOGQ zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 25",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vpternlogq",
      "rel_url": "x86/vpternlogq/",
      "operands": [],
      "linked_summary": "Performs one of 256 logical operations on 3 quadwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcompresspd",
      "architecture": "x86",
      "full_name": "Store Sparse Packed Double-Precision Floating-Point Values",
      "summary": "Compresses active elements from ZMM to memory.",
      "syntax": "VCOMPRESSPD m512 {k1}, zmm1",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 8A",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vcompresspd",
      "rel_url": "x86/vcompresspd/",
      "operands": [],
      "linked_summary": "Compresses active elements from ZMM to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcompressps",
      "architecture": "x86",
      "full_name": "Store Sparse Packed Single-Precision Floating-Point Values",
      "summary": "Compresses active elements from ZMM to memory.",
      "syntax": "VCOMPRESSPS m512 {k1}, zmm1",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 8A",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vcompressps",
      "rel_url": "x86/vcompressps/",
      "operands": [],
      "linked_summary": "Compresses active elements from ZMM to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vexpandpd",
      "architecture": "x86",
      "full_name": "Load Sparse Packed Double-Precision Floating-Point Values",
      "summary": "Expands data from memory into sparse locations in ZMM.",
      "syntax": "VEXPANDPD zmm1 {k1}, m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 88",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vexpandpd",
      "rel_url": "x86/vexpandpd/",
      "operands": [],
      "linked_summary": "Expands data from memory into sparse locations <a href=\"../../x86/in/\">in</a> ZMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vexpandps",
      "architecture": "x86",
      "full_name": "Load Sparse Packed Single-Precision Floating-Point Values",
      "summary": "Expands data from memory into sparse locations in ZMM.",
      "syntax": "VEXPANDPS zmm1 {k1}, m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 88",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vexpandps",
      "rel_url": "x86/vexpandps/",
      "operands": [],
      "linked_summary": "Expands data from memory into sparse locations <a href=\"../../x86/in/\">in</a> ZMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpermi2d",
      "architecture": "x86",
      "full_name": "Permute Two-Source Doublewords",
      "summary": "Shuffles doublewords from two ZMM registers into destination.",
      "syntax": "VPERMI2D zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 76",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vpermi2d",
      "rel_url": "x86/vpermi2d/",
      "operands": [],
      "linked_summary": "Shuffles doublewords from two ZMM registers into destination.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpermt2d",
      "architecture": "x86",
      "full_name": "Permute Two-Source Doublewords (Overwrite)",
      "summary": "Shuffles 2 sources, overwriting the index register.",
      "syntax": "VPERMT2D zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 7F",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vpermt2d",
      "rel_url": "x86/vpermt2d/",
      "operands": [],
      "linked_summary": "Shuffles 2 sources, overwriting the <a href=\"../../armv8-a/index/\">index</a> register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vshuff32x4",
      "architecture": "x86",
      "full_name": "Shuffle Packed Float32x4",
      "summary": "Shuffles 128-bit blocks of single-precision floats.",
      "syntax": "VSHUFF32X4 zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 23",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vshuff32x4",
      "rel_url": "x86/vshuff32x4/",
      "operands": [],
      "linked_summary": "Shuffles 128-<a href=\"../../armv8-a/bit/\">bit</a> blocks of single-precision floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmovdb",
      "architecture": "x86",
      "full_name": "Truncate Doubleword to Byte",
      "summary": "Down-converts 32-bit integers to 8-bit.",
      "syntax": "VPMOVDB xmm1/m128 {k1}, zmm2",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "F3 0F 38 31",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vpmovdb",
      "rel_url": "x86/vpmovdb/",
      "operands": [],
      "linked_summary": "Down-converts 32-<a href=\"../../armv8-a/bit/\">bit</a> integers to 8-<a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmovusdb",
      "architecture": "x86",
      "full_name": "Saturate Unsigned Doubleword to Byte",
      "summary": "Down-converts 32-bit to 8-bit with unsigned saturation.",
      "syntax": "VPMOVUSDB xmm1/m128 {k1}, zmm2",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "F3 0F 38 11",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vpmovusdb",
      "rel_url": "x86/vpmovusdb/",
      "operands": [],
      "linked_summary": "Down-converts 32-<a href=\"../../armv8-a/bit/\">bit</a> to 8-<a href=\"../../armv8-a/bit/\">bit</a> with unsigned saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vrndscalepd",
      "architecture": "x86",
      "full_name": "Round Packed Double-Precision Floating-Point with Scale",
      "summary": "Rounds doubles to integer values using imm8 control.",
      "syntax": "VRNDSCALEPD zmm1 {k1}, zmm2/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 09",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vrndscalepd",
      "rel_url": "x86/vrndscalepd/",
      "operands": [],
      "linked_summary": "Rounds doubles to integer values using imm8 control.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vfixupimmpd",
      "architecture": "x86",
      "full_name": "Fix Up Special Packed Float64 Values",
      "summary": "Fixes special cases (NaN, Inf) using a table.",
      "syntax": "VFIXUPIMMPD zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 54",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vfixupimmpd",
      "rel_url": "x86/vfixupimmpd/",
      "operands": [],
      "linked_summary": "Fixes special cases (NaN, Inf) using a table.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vgetmantpd",
      "architecture": "x86",
      "full_name": "Get Mantissa Packed Double-Precision",
      "summary": "Extracts mantissas from doubles.",
      "syntax": "VGETMANTPD zmm1 {k1}, zmm2/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 26",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vgetmantpd",
      "rel_url": "x86/vgetmantpd/",
      "operands": [],
      "linked_summary": "Extracts mantissas from doubles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vgetexppd",
      "architecture": "x86",
      "full_name": "Get Exponent Packed Double-Precision",
      "summary": "Extracts exponents from doubles as float values.",
      "syntax": "VGETEXPPD zmm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 42",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vgetexppd",
      "rel_url": "x86/vgetexppd/",
      "operands": [],
      "linked_summary": "Extracts exponents from doubles as float values.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vscalefpd",
      "architecture": "x86",
      "full_name": "Scale Packed Float64 Values with Float64 Exponents",
      "summary": "Scales doubles by exponents (x * 2^n).",
      "syntax": "VSCALEFPD zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 2C",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vscalefpd",
      "rel_url": "x86/vscalefpd/",
      "operands": [],
      "linked_summary": "Scales doubles by exponents (x * 2^n).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "valignd",
      "architecture": "x86",
      "full_name": "Align Doubleword Vectors",
      "summary": "Extracts 512-bits from two concatenated ZMMs shifted by count.",
      "syntax": "VALIGND zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 03",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "valignd",
      "rel_url": "x86/valignd/",
      "operands": [],
      "linked_summary": "Extracts 512-bits from two concatenated ZMMs shifted by count.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpconflictd",
      "architecture": "x86",
      "full_name": "Detect Conflicts Within a Vector of Packed Dword Values",
      "summary": "Detects duplicate values in a vector (Conflict Detection).",
      "syntax": "VPCONFLICTD zmm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 C4",
        "visual_parts": []
      },
      "extension": "AVX-512CD",
      "slug": "vpconflictd",
      "rel_url": "x86/vpconflictd/",
      "operands": [],
      "linked_summary": "Detects duplicate values <a href=\"../../x86/in/\">in</a> a vector (Conflict Detection).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vplzcntd",
      "architecture": "x86",
      "full_name": "Count Leading Zero Bits",
      "summary": "Counts leading zeros for each doubleword element.",
      "syntax": "VPLZCNTD zmm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 44",
        "visual_parts": []
      },
      "extension": "AVX-512CD",
      "slug": "vplzcntd",
      "rel_url": "x86/vplzcntd/",
      "operands": [],
      "linked_summary": "Counts leading zeros for each doubleword element.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcvtudq2ps",
      "architecture": "x86",
      "full_name": "Convert Packed Unsigned Doubleword Integers to Packed Single-Precision Floating-Point",
      "summary": "Converts unsigned int32 to float.",
      "syntax": "VCVTUDQ2PS zmm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "F2 0F 5B",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vcvtudq2ps",
      "rel_url": "x86/vcvtudq2ps/",
      "operands": [],
      "linked_summary": "Converts unsigned int32 to float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vprolvd",
      "architecture": "x86",
      "full_name": "Rotate Left Doubleword Variable",
      "summary": "Rotates doublewords left by amounts in second vector.",
      "syntax": "VPROLVD zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 15",
        "visual_parts": []
      },
      "extension": "AVX-512F",
      "slug": "vprolvd",
      "rel_url": "x86/vprolvd/",
      "operands": [],
      "linked_summary": "Rotates doublewords left by amounts <a href=\"../../x86/in/\">in</a> second vector.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpopcntd",
      "architecture": "x86",
      "full_name": "Packed Population Count Doubleword",
      "summary": "Counts set bits in each doubleword element.",
      "syntax": "VPOPCNTD zmm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 55",
        "visual_parts": []
      },
      "extension": "AVX-512_VPOPCNTDQ",
      "slug": "vpopcntd",
      "rel_url": "x86/vpopcntd/",
      "operands": [],
      "linked_summary": "Counts set bits <a href=\"../../x86/in/\">in</a> each doubleword element.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "encls",
      "architecture": "x86",
      "full_name": "Execute Enclave Supervisor Leaf",
      "summary": "Executes an SGX supervisor function specified by EAX.",
      "syntax": "ENCLS",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 CF",
        "visual_parts": []
      },
      "extension": "SGX",
      "slug": "encls",
      "rel_url": "x86/encls/",
      "operands": [],
      "linked_summary": "Executes an SGX supervisor function specified by EAX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "enclu",
      "architecture": "x86",
      "full_name": "Execute Enclave User Leaf",
      "summary": "Executes an SGX user function specified by EAX.",
      "syntax": "ENCLU",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F 01 D7",
        "visual_parts": []
      },
      "extension": "SGX",
      "slug": "enclu",
      "rel_url": "x86/enclu/",
      "operands": [],
      "linked_summary": "Executes an SGX user function specified by EAX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "extrq",
      "architecture": "x86",
      "full_name": "Extract Field from Register",
      "summary": "Extracts bit field from register (AMD SSE4a).",
      "syntax": "EXTRQ xmm1, xmm2",
      "encoding": {
        "format": "SSE4a",
        "hex_opcode": "66 0F 79 /0",
        "visual_parts": []
      },
      "extension": "SSE4a",
      "slug": "extrq",
      "rel_url": "x86/extrq/",
      "operands": [],
      "linked_summary": "Extracts <a href=\"../../armv8-a/bit/\">bit</a> field from register (AMD SSE4a).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "insertq",
      "architecture": "x86",
      "full_name": "Insert Field to Register",
      "summary": "Inserts bit field into register (AMD SSE4a).",
      "syntax": "INSERTQ xmm1, xmm2",
      "encoding": {
        "format": "SSE4a",
        "hex_opcode": "66 0F 79 /4",
        "visual_parts": []
      },
      "extension": "SSE4a",
      "slug": "insertq",
      "rel_url": "x86/insertq/",
      "operands": [],
      "linked_summary": "Inserts <a href=\"../../armv8-a/bit/\">bit</a> field into register (AMD SSE4a).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movntss",
      "architecture": "x86",
      "full_name": "Move Non-Temporal Scalar Single",
      "summary": "Stores scalar float bypassing cache (AMD SSE4a).",
      "syntax": "MOVNTSS m32, xmm1",
      "encoding": {
        "format": "SSE4a",
        "hex_opcode": "F3 0F 2B",
        "visual_parts": []
      },
      "extension": "SSE4a",
      "slug": "movntss",
      "rel_url": "x86/movntss/",
      "operands": [],
      "linked_summary": "Stores scalar float bypassing cache (AMD SSE4a).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movntsd",
      "architecture": "x86",
      "full_name": "Move Non-Temporal Scalar Double",
      "summary": "Stores scalar double bypassing cache (AMD SSE4a).",
      "syntax": "MOVNTSD m64, xmm1",
      "encoding": {
        "format": "SSE4a",
        "hex_opcode": "F2 0F 2B",
        "visual_parts": []
      },
      "extension": "SSE4a",
      "slug": "movntsd",
      "rel_url": "x86/movntsd/",
      "operands": [],
      "linked_summary": "Stores scalar double bypassing cache (AMD SSE4a).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "clzero",
      "architecture": "x86",
      "full_name": "Zero Cache Line",
      "summary": "Clears the cache line at address RAX/EAX (AMD).",
      "syntax": "CLZERO",
      "encoding": {
        "format": "AMD",
        "hex_opcode": "0F 01 FC",
        "visual_parts": []
      },
      "extension": "CLZERO",
      "slug": "clzero",
      "rel_url": "x86/clzero/",
      "operands": [],
      "linked_summary": "Clears the cache line <a href=\"../../armv8-a/at_2/\">at</a> address RAX/EAX (AMD).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "blci",
      "architecture": "x86",
      "full_name": "Bit Line Create Isolated",
      "summary": "Sets all bits to 0 except the lowest set bit inverted (x | ~(x+1)).",
      "syntax": "BLCI r32, r/m32",
      "encoding": {
        "format": "TBM",
        "hex_opcode": "8F ... 02",
        "visual_parts": []
      },
      "extension": "TBM",
      "slug": "blci",
      "rel_url": "x86/blci/",
      "operands": [],
      "linked_summary": "Sets all bits to 0 except the lowest set <a href=\"../../armv8-a/bit/\">bit</a> inverted (x | ~(x+1)).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "blcic",
      "architecture": "x86",
      "full_name": "Bit Line Create Isolated and Complement",
      "summary": "Isolates lowest clear bit (~x & (x+1)).",
      "syntax": "BLCIC r32, r/m32",
      "encoding": {
        "format": "TBM",
        "hex_opcode": "8F ... 05",
        "visual_parts": []
      },
      "extension": "TBM",
      "slug": "blcic",
      "rel_url": "x86/blcic/",
      "operands": [],
      "linked_summary": "Isolates lowest clear <a href=\"../../armv8-a/bit/\">bit</a> (~x & (x+1)).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "blcmsk",
      "architecture": "x86",
      "full_name": "Bit Line Create Mask",
      "summary": "Creates mask from lowest clear bit (x ^ (x+1)).",
      "syntax": "BLCMSK r32, r/m32",
      "encoding": {
        "format": "TBM",
        "hex_opcode": "8F ... 01",
        "visual_parts": []
      },
      "extension": "TBM",
      "slug": "blcmsk",
      "rel_url": "x86/blcmsk/",
      "operands": [],
      "linked_summary": "Creates mask from lowest clear <a href=\"../../armv8-a/bit/\">bit</a> (x ^ (x+1)).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "blcs",
      "architecture": "x86",
      "full_name": "Bit Line Create Set",
      "summary": "Sets lowest clear bit (x | (x+1)).",
      "syntax": "BLCS r32, r/m32",
      "encoding": {
        "format": "TBM",
        "hex_opcode": "8F ... 03",
        "visual_parts": []
      },
      "extension": "TBM",
      "slug": "blcs",
      "rel_url": "x86/blcs/",
      "operands": [],
      "linked_summary": "Sets lowest clear <a href=\"../../armv8-a/bit/\">bit</a> (x | (x+1)).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "blsfill",
      "architecture": "x86",
      "full_name": "Bit Line Set Fill",
      "summary": "Sets all bits below lowest set bit ((x-1) | x).",
      "syntax": "BLSFILL r32, r/m32",
      "encoding": {
        "format": "TBM",
        "hex_opcode": "8F ... 04",
        "visual_parts": []
      },
      "extension": "TBM",
      "slug": "blsfill",
      "rel_url": "x86/blsfill/",
      "operands": [],
      "linked_summary": "Sets all bits below lowest set <a href=\"../../armv8-a/bit/\">bit</a> ((x-1) | x).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "blsic",
      "architecture": "x86",
      "full_name": "Bit Line Set Isolated and Complement",
      "summary": "Isolates lowest set bit and complements (~x | (x-1)).",
      "syntax": "BLSIC r32, r/m32",
      "encoding": {
        "format": "TBM",
        "hex_opcode": "8F ... 06",
        "visual_parts": []
      },
      "extension": "TBM",
      "slug": "blsic",
      "rel_url": "x86/blsic/",
      "operands": [],
      "linked_summary": "Isolates lowest set <a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../armv8-a/and_6/\">and</a> complements (~x | (x-1)).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "t1mskc",
      "architecture": "x86",
      "full_name": "Inverse Mask From Trailing Ones",
      "summary": "Creates mask from trailing ones (~x | (x+1)).",
      "syntax": "T1MSKC r32, r/m32",
      "encoding": {
        "format": "TBM",
        "hex_opcode": "8F ... 07",
        "visual_parts": []
      },
      "extension": "TBM",
      "slug": "t1mskc",
      "rel_url": "x86/t1mskc/",
      "operands": [],
      "linked_summary": "Creates mask from trailing ones (~x | (x+1)).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tzmsk",
      "architecture": "x86",
      "full_name": "Mask From Trailing Zeros",
      "summary": "Creates mask from trailing zeros (~x & (x-1)).",
      "syntax": "TZMSK r32, r/m32",
      "encoding": {
        "format": "TBM",
        "hex_opcode": "8F ... 04",
        "visual_parts": []
      },
      "extension": "TBM",
      "slug": "tzmsk",
      "rel_url": "x86/tzmsk/",
      "operands": [],
      "linked_summary": "Creates mask from trailing zeros (~x & (x-1)).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vprotb",
      "architecture": "x86",
      "full_name": "Vector Packed Rotate Byte",
      "summary": "Rotates bytes in XMM register.",
      "syntax": "VPROTB xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "XOP",
        "hex_opcode": "8F ... 90",
        "visual_parts": []
      },
      "extension": "XOP",
      "slug": "vprotb",
      "rel_url": "x86/vprotb/",
      "operands": [],
      "linked_summary": "Rotates bytes <a href=\"../../x86/in/\">in</a> XMM register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vprotw",
      "architecture": "x86",
      "full_name": "Vector Packed Rotate Word",
      "summary": "Rotates words in XMM register.",
      "syntax": "VPROTW xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "XOP",
        "hex_opcode": "8F ... 91",
        "visual_parts": []
      },
      "extension": "XOP",
      "slug": "vprotw",
      "rel_url": "x86/vprotw/",
      "operands": [],
      "linked_summary": "Rotates words <a href=\"../../x86/in/\">in</a> XMM register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vprotd",
      "architecture": "x86",
      "full_name": "Vector Packed Rotate Doubleword",
      "summary": "Rotates doublewords in XMM register.",
      "syntax": "VPROTD xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "XOP",
        "hex_opcode": "8F ... 92",
        "visual_parts": []
      },
      "extension": "XOP",
      "slug": "vprotd",
      "rel_url": "x86/vprotd/",
      "operands": [],
      "linked_summary": "Rotates doublewords <a href=\"../../x86/in/\">in</a> XMM register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vprotq",
      "architecture": "x86",
      "full_name": "Vector Packed Rotate Quadword",
      "summary": "Rotates quadwords in XMM register.",
      "syntax": "VPROTQ xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "XOP",
        "hex_opcode": "8F ... 93",
        "visual_parts": []
      },
      "extension": "XOP",
      "slug": "vprotq",
      "rel_url": "x86/vprotq/",
      "operands": [],
      "linked_summary": "Rotates quadwords <a href=\"../../x86/in/\">in</a> XMM register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpshab",
      "architecture": "x86",
      "full_name": "Vector Packed Shift Arithmetic Byte",
      "summary": "Shifts bytes arithmetically.",
      "syntax": "VPSHAB xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "XOP",
        "hex_opcode": "8F ... 98",
        "visual_parts": []
      },
      "extension": "XOP",
      "slug": "vpshab",
      "rel_url": "x86/vpshab/",
      "operands": [],
      "linked_summary": "Shifts bytes arithmetically.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpshaw",
      "architecture": "x86",
      "full_name": "Vector Packed Shift Arithmetic Word",
      "summary": "Shifts words arithmetically.",
      "syntax": "VPSHAW xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "XOP",
        "hex_opcode": "8F ... 99",
        "visual_parts": []
      },
      "extension": "XOP",
      "slug": "vpshaw",
      "rel_url": "x86/vpshaw/",
      "operands": [],
      "linked_summary": "Shifts words arithmetically.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpshad",
      "architecture": "x86",
      "full_name": "Vector Packed Shift Arithmetic Doubleword",
      "summary": "Shifts doublewords arithmetically.",
      "syntax": "VPSHAD xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "XOP",
        "hex_opcode": "8F ... 9A",
        "visual_parts": []
      },
      "extension": "XOP",
      "slug": "vpshad",
      "rel_url": "x86/vpshad/",
      "operands": [],
      "linked_summary": "Shifts doublewords arithmetically.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpshaq",
      "architecture": "x86",
      "full_name": "Vector Packed Shift Arithmetic Quadword",
      "summary": "Shifts quadwords arithmetically.",
      "syntax": "VPSHAQ xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "XOP",
        "hex_opcode": "8F ... 9B",
        "visual_parts": []
      },
      "extension": "XOP",
      "slug": "vpshaq",
      "rel_url": "x86/vpshaq/",
      "operands": [],
      "linked_summary": "Shifts quadwords arithmetically.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vphaddbw",
      "architecture": "x86",
      "full_name": "Vector Packed Horizontal Add Byte to Word",
      "summary": "Adds adjacent bytes to words.",
      "syntax": "VPHADDBW xmm1, xmm2/m128",
      "encoding": {
        "format": "XOP",
        "hex_opcode": "8F ... C1",
        "visual_parts": []
      },
      "extension": "XOP",
      "slug": "vphaddbw",
      "rel_url": "x86/vphaddbw/",
      "operands": [],
      "linked_summary": "Adds adjacent bytes to words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vphaddbd",
      "architecture": "x86",
      "full_name": "Vector Packed Horizontal Add Byte to Doubleword",
      "summary": "Adds adjacent bytes to doublewords.",
      "syntax": "VPHADDBD xmm1, xmm2/m128",
      "encoding": {
        "format": "XOP",
        "hex_opcode": "8F ... C2",
        "visual_parts": []
      },
      "extension": "XOP",
      "slug": "vphaddbd",
      "rel_url": "x86/vphaddbd/",
      "operands": [],
      "linked_summary": "Adds adjacent bytes to doublewords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vphaddbq",
      "architecture": "x86",
      "full_name": "Vector Packed Horizontal Add Byte to Quadword",
      "summary": "Adds adjacent bytes to quadwords.",
      "syntax": "VPHADDBQ xmm1, xmm2/m128",
      "encoding": {
        "format": "XOP",
        "hex_opcode": "8F ... C3",
        "visual_parts": []
      },
      "extension": "XOP",
      "slug": "vphaddbq",
      "rel_url": "x86/vphaddbq/",
      "operands": [],
      "linked_summary": "Adds adjacent bytes to quadwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vphaddwd",
      "architecture": "x86",
      "full_name": "Vector Packed Horizontal Add Word to Doubleword",
      "summary": "Adds adjacent words to doublewords.",
      "syntax": "VPHADDWD xmm1, xmm2/m128",
      "encoding": {
        "format": "XOP",
        "hex_opcode": "8F ... C6",
        "visual_parts": []
      },
      "extension": "XOP",
      "slug": "vphaddwd",
      "rel_url": "x86/vphaddwd/",
      "operands": [],
      "linked_summary": "Adds adjacent words to doublewords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vphaddwq",
      "architecture": "x86",
      "full_name": "Vector Packed Horizontal Add Word to Quadword",
      "summary": "Adds adjacent words to quadwords.",
      "syntax": "VPHADDWQ xmm1, xmm2/m128",
      "encoding": {
        "format": "XOP",
        "hex_opcode": "8F ... C7",
        "visual_parts": []
      },
      "extension": "XOP",
      "slug": "vphaddwq",
      "rel_url": "x86/vphaddwq/",
      "operands": [],
      "linked_summary": "Adds adjacent words to quadwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vphadddq",
      "architecture": "x86",
      "full_name": "Vector Packed Horizontal Add Doubleword to Quadword",
      "summary": "Adds adjacent doublewords to quadwords.",
      "syntax": "VPHADDDQ xmm1, xmm2/m128",
      "encoding": {
        "format": "XOP",
        "hex_opcode": "8F ... CB",
        "visual_parts": []
      },
      "extension": "XOP",
      "slug": "vphadddq",
      "rel_url": "x86/vphadddq/",
      "operands": [],
      "linked_summary": "Adds adjacent doublewords to quadwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmacsww",
      "architecture": "x86",
      "full_name": "Vector Packed Multiply Accumulate Signed Word",
      "summary": "Multiply-accumulate signed words.",
      "syntax": "VPMACSWW xmm1, xmm2, xmm3, xmm4",
      "encoding": {
        "format": "XOP",
        "hex_opcode": "8F ... 83",
        "visual_parts": []
      },
      "extension": "XOP",
      "slug": "vpmacsww",
      "rel_url": "x86/vpmacsww/",
      "operands": [],
      "linked_summary": "Multiply-accumulate signed words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmacssww",
      "architecture": "x86",
      "full_name": "Vector Packed Multiply Accumulate Signed Saturate Word",
      "summary": "Multiply-accumulate signed words with saturation.",
      "syntax": "VPMACSSWW xmm1, xmm2, xmm3, xmm4",
      "encoding": {
        "format": "XOP",
        "hex_opcode": "8F ... 87",
        "visual_parts": []
      },
      "extension": "XOP",
      "slug": "vpmacssww",
      "rel_url": "x86/vpmacssww/",
      "operands": [],
      "linked_summary": "Multiply-accumulate signed words with saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vgatherpf0dps",
      "architecture": "x86",
      "full_name": "Gather Prefetch Packed Single (L1)",
      "summary": "Prefetches floats to L1 cache using indices.",
      "syntax": "VGATHERPF0DPS {k1}, [base+zmm_idx]",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F2 ... C6 /1",
        "visual_parts": []
      },
      "extension": "AVX-512PF",
      "slug": "vgatherpf0dps",
      "rel_url": "x86/vgatherpf0dps/",
      "operands": [],
      "linked_summary": "Prefetches floats to L1 cache using indices.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vgatherpf0qps",
      "architecture": "x86",
      "full_name": "Gather Prefetch Packed Single (L1, Qword Indices)",
      "summary": "Prefetches floats to L1 using 64-bit indices.",
      "syntax": "VGATHERPF0QPS {k1}, [base+zmm_idx]",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F2 ... C7 /1",
        "visual_parts": []
      },
      "extension": "AVX-512PF",
      "slug": "vgatherpf0qps",
      "rel_url": "x86/vgatherpf0qps/",
      "operands": [],
      "linked_summary": "Prefetches floats to L1 using 64-<a href=\"../../armv8-a/bit/\">bit</a> indices.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vgatherpf0dpd",
      "architecture": "x86",
      "full_name": "Gather Prefetch Packed Double (L1)",
      "summary": "Prefetches doubles to L1 cache using indices.",
      "syntax": "VGATHERPF0DPD {k1}, [base+ymm_idx]",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F2 ... C6 /1",
        "visual_parts": []
      },
      "extension": "AVX-512PF",
      "slug": "vgatherpf0dpd",
      "rel_url": "x86/vgatherpf0dpd/",
      "operands": [],
      "linked_summary": "Prefetches doubles to L1 cache using indices.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vgatherpf0qpd",
      "architecture": "x86",
      "full_name": "Gather Prefetch Packed Double (L1, Qword Indices)",
      "summary": "Prefetches doubles to L1 using 64-bit indices.",
      "syntax": "VGATHERPF0QPD {k1}, [base+zmm_idx]",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F2 ... C7 /1",
        "visual_parts": []
      },
      "extension": "AVX-512PF",
      "slug": "vgatherpf0qpd",
      "rel_url": "x86/vgatherpf0qpd/",
      "operands": [],
      "linked_summary": "Prefetches doubles to L1 using 64-<a href=\"../../armv8-a/bit/\">bit</a> indices.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vscatterpf0dps",
      "architecture": "x86",
      "full_name": "Scatter Prefetch Packed Single (L1)",
      "summary": "Prefetches cache lines for scatter write (L1).",
      "syntax": "VSCATTERPF0DPS {k1}, [base+zmm_idx]",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F2 ... C6 /5",
        "visual_parts": []
      },
      "extension": "AVX-512PF",
      "slug": "vscatterpf0dps",
      "rel_url": "x86/vscatterpf0dps/",
      "operands": [],
      "linked_summary": "Prefetches cache lines for scatter write (L1).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vscatterpf0qps",
      "architecture": "x86",
      "full_name": "Scatter Prefetch Packed Single (L1, Qword Indices)",
      "summary": "Prefetches lines for scatter write (L1, 64-bit idx).",
      "syntax": "VSCATTERPF0QPS {k1}, [base+zmm_idx]",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F2 ... C7 /5",
        "visual_parts": []
      },
      "extension": "AVX-512PF",
      "slug": "vscatterpf0qps",
      "rel_url": "x86/vscatterpf0qps/",
      "operands": [],
      "linked_summary": "Prefetches lines for scatter write (L1, 64-<a href=\"../../armv8-a/bit/\">bit</a> idx).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vscatterpf0dpd",
      "architecture": "x86",
      "full_name": "Scatter Prefetch Packed Double (L1)",
      "summary": "Prefetches lines for scatter write (L1, Double).",
      "syntax": "VSCATTERPF0DPD {k1}, [base+ymm_idx]",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F2 ... C6 /5",
        "visual_parts": []
      },
      "extension": "AVX-512PF",
      "slug": "vscatterpf0dpd",
      "rel_url": "x86/vscatterpf0dpd/",
      "operands": [],
      "linked_summary": "Prefetches lines for scatter write (L1, Double).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vscatterpf0qpd",
      "architecture": "x86",
      "full_name": "Scatter Prefetch Packed Double (L1, Qword Indices)",
      "summary": "Prefetches lines for scatter write (L1, Double, 64-bit idx).",
      "syntax": "VSCATTERPF0QPD {k1}, [base+zmm_idx]",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F2 ... C7 /5",
        "visual_parts": []
      },
      "extension": "AVX-512PF",
      "slug": "vscatterpf0qpd",
      "rel_url": "x86/vscatterpf0qpd/",
      "operands": [],
      "linked_summary": "Prefetches lines for scatter write (L1, Double, 64-<a href=\"../../armv8-a/bit/\">bit</a> idx).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vp4dpwssd",
      "architecture": "x86",
      "full_name": "Dot Product Signed Word to Signed Doubleword (4-iterations)",
      "summary": "Neural Net 4-way dot product.",
      "syntax": "VP4DPWSSD zmm1 {k1}, zmm2+3, m128",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F2 ... 52",
        "visual_parts": []
      },
      "extension": "AVX-512-4VNNIW",
      "slug": "vp4dpwssd",
      "rel_url": "x86/vp4dpwssd/",
      "operands": [],
      "linked_summary": "Neural Net 4-way dot product.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vp4dpwssds",
      "architecture": "x86",
      "full_name": "Dot Product Signed Word to Signed Doubleword Saturate (4-iter)",
      "summary": "Neural Net 4-way dot product with saturation.",
      "syntax": "VP4DPWSSDS zmm1 {k1}, zmm2+3, m128",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F2 ... 53",
        "visual_parts": []
      },
      "extension": "AVX-512-4VNNIW",
      "slug": "vp4dpwssds",
      "rel_url": "x86/vp4dpwssds/",
      "operands": [],
      "linked_summary": "Neural Net 4-way dot product with saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "v4fmaddps",
      "architecture": "x86",
      "full_name": "Fused Multiply-Add Packed Single (4-iterations)",
      "summary": "4-way FMA for Neural Nets (Single).",
      "syntax": "V4FMADDPS zmm1 {k1}, zmm2+3, m128",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F2 ... 9A",
        "visual_parts": []
      },
      "extension": "AVX-512-4FMAPS",
      "slug": "v4fmaddps",
      "rel_url": "x86/v4fmaddps/",
      "operands": [],
      "linked_summary": "4-way FMA for Neural Nets (Single).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "v4fmaddss",
      "architecture": "x86",
      "full_name": "Fused Multiply-Add Scalar Single (4-iterations)",
      "summary": "4-way FMA for Neural Nets (Scalar).",
      "syntax": "V4FMADDSS xmm1 {k1}, xmm2+3, m128",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F2 ... 9B",
        "visual_parts": []
      },
      "extension": "AVX-512-4FMAPS",
      "slug": "v4fmaddss",
      "rel_url": "x86/v4fmaddss/",
      "operands": [],
      "linked_summary": "4-way FMA for Neural Nets (Scalar).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "v4fnmaddps",
      "architecture": "x86",
      "full_name": "Fused Negative Multiply-Add Packed Single (4-iterations)",
      "summary": "4-way Negative FMA for Neural Nets (Single).",
      "syntax": "V4FNMADDPS zmm1 {k1}, zmm2+3, m128",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F2 ... AA",
        "visual_parts": []
      },
      "extension": "AVX-512-4FMAPS",
      "slug": "v4fnmaddps",
      "rel_url": "x86/v4fnmaddps/",
      "operands": [],
      "linked_summary": "4-way Negative FMA for Neural Nets (Single).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "v4fnmaddss",
      "architecture": "x86",
      "full_name": "Fused Negative Multiply-Add Scalar Single (4-iterations)",
      "summary": "4-way Negative FMA for Neural Nets (Scalar).",
      "syntax": "V4FNMADDSS xmm1 {k1}, xmm2+3, m128",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "62 F2 ... AB",
        "visual_parts": []
      },
      "extension": "AVX-512-4FMAPS",
      "slug": "v4fnmaddss",
      "rel_url": "x86/v4fnmaddss/",
      "operands": [],
      "linked_summary": "4-way Negative FMA for Neural Nets (Scalar).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "addss",
      "architecture": "x86",
      "full_name": "Add Scalar Single-Precision",
      "summary": "Adds the low 32-bit float from source to destination.",
      "syntax": "ADDSS xmm1, xmm2/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "F3 0F 58",
        "visual_parts": []
      },
      "extension": "SSE",
      "slug": "addss_1",
      "rel_url": "x86/addss_1/",
      "operands": [],
      "linked_summary": "Adds the low 32-<a href=\"../../armv8-a/bit/\">bit</a> float from source to destination.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "addsd",
      "architecture": "x86",
      "full_name": "Add Scalar Double-Precision",
      "summary": "Adds the low 64-bit double from source to destination.",
      "syntax": "ADDSD xmm1, xmm2/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "F2 0F 58",
        "visual_parts": []
      },
      "extension": "SSE2",
      "slug": "addsd_1",
      "rel_url": "x86/addsd_1/",
      "operands": [],
      "linked_summary": "Adds the low 64-<a href=\"../../armv8-a/bit/\">bit</a> double from source to destination.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rdrand",
      "architecture": "x86",
      "full_name": "Read Random Number",
      "summary": "Retrieves a hardware-generated random number.",
      "syntax": "RDRAND r16/r32/r64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F C7 /6",
        "visual_parts": []
      },
      "extension": "RDRAND",
      "slug": "rdrand_1",
      "rel_url": "x86/rdrand_1/",
      "operands": [],
      "linked_summary": "Retrieves a hardware-generated random number.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rdseed",
      "architecture": "x86",
      "full_name": "Read Random Seed",
      "summary": "Retrieves a random seed from hardware entropy source.",
      "syntax": "RDSEED r16/r32/r64",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F C7 /7",
        "visual_parts": []
      },
      "extension": "RDSEED",
      "slug": "rdseed_1",
      "rel_url": "x86/rdseed_1/",
      "operands": [],
      "linked_summary": "Retrieves a random seed from hardware entropy source.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcvtdq2ps",
      "architecture": "x86",
      "full_name": "Convert Packed Doubleword to Packed Single",
      "summary": "Converts four 32-bit integers to floats.",
      "syntax": "VCVTDQ2PS ymm1, ymm2/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "0F 5B",
        "visual_parts": []
      },
      "extension": "AVX",
      "slug": "vcvtdq2ps",
      "rel_url": "x86/vcvtdq2ps/",
      "operands": [],
      "linked_summary": "Converts four 32-<a href=\"../../armv8-a/bit/\">bit</a> integers to floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcvtps2dq",
      "architecture": "x86",
      "full_name": "Convert Packed Single to Packed Doubleword",
      "summary": "Converts four floats to 32-bit integers (Rounded).",
      "syntax": "VCVTPS2DQ ymm1, ymm2/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "66 0F 5B",
        "visual_parts": []
      },
      "extension": "AVX",
      "slug": "vcvtps2dq",
      "rel_url": "x86/vcvtps2dq/",
      "operands": [],
      "linked_summary": "Converts four floats to 32-<a href=\"../../armv8-a/bit/\">bit</a> integers (Rounded).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vcvttps2dq",
      "architecture": "x86",
      "full_name": "Convert with Truncation Packed Single to Doubleword",
      "summary": "Converts four floats to 32-bit integers (Truncated).",
      "syntax": "VCVTTPS2DQ ymm1, ymm2/m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "F3 0F 5B",
        "visual_parts": []
      },
      "extension": "AVX",
      "slug": "vcvttps2dq",
      "rel_url": "x86/vcvttps2dq/",
      "operands": [],
      "linked_summary": "Converts four floats to 32-<a href=\"../../armv8-a/bit/\">bit</a> integers (Truncated).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "iret",
      "architecture": "x86",
      "full_name": "Interrupt Return",
      "summary": "Returns from an interrupt, exception, or task handler.",
      "syntax": "IRET",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "CF",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "iret",
      "rel_url": "x86/iret/",
      "operands": [],
      "linked_summary": "Returns from an interrupt, exception, <a href=\"../../powerisa/or/\">or</a> task handler.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "iretd",
      "architecture": "x86",
      "full_name": "Interrupt Return Doubleword",
      "summary": "Returns from interrupt (32-bit operand size).",
      "syntax": "IRETD",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "CF",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "iretd",
      "rel_url": "x86/iretd/",
      "operands": [],
      "linked_summary": "Returns from interrupt (32-<a href=\"../../armv8-a/bit/\">bit</a> operand size).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "iretq",
      "architecture": "x86",
      "full_name": "Interrupt Return Quadword",
      "summary": "Returns from interrupt (64-bit operand size).",
      "syntax": "IRETQ",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "CF",
        "visual_parts": []
      },
      "extension": "Base (64-bit)",
      "slug": "iretq",
      "rel_url": "x86/iretq/",
      "operands": [],
      "linked_summary": "Returns from interrupt (64-<a href=\"../../armv8-a/bit/\">bit</a> operand size).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "in_var",
      "architecture": "x86",
      "full_name": "Input from Port (Variable)",
      "summary": "Reads data from I/O port specified in DX.",
      "syntax": "IN AL/AX/EAX, DX",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "EC/ED",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "in_var",
      "rel_url": "x86/in_var/",
      "operands": [],
      "linked_summary": "Reads data from I/O port specified <a href=\"../../x86/in/\">in</a> DX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "out_var",
      "architecture": "x86",
      "full_name": "Output to Port (Variable)",
      "summary": "Writes data to I/O port specified in DX.",
      "syntax": "OUT DX, AL/AX/EAX",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "EE/EF",
        "visual_parts": []
      },
      "extension": "Base",
      "slug": "out_var",
      "rel_url": "x86/out_var/",
      "operands": [],
      "linked_summary": "Writes data to I/O port specified <a href=\"../../x86/in/\">in</a> DX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpopcntq",
      "architecture": "x86",
      "full_name": "Packed Population Count Quadword",
      "summary": "Counts set bits in each quadword element.",
      "syntax": "VPOPCNTQ zmm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 55",
        "visual_parts": []
      },
      "extension": "AVX-512_VPOPCNTDQ",
      "slug": "vpopcntq",
      "rel_url": "x86/vpopcntq/",
      "operands": [],
      "linked_summary": "Counts set bits <a href=\"../../x86/in/\">in</a> each quadword element.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpopcntw",
      "architecture": "x86",
      "full_name": "Packed Population Count Word",
      "summary": "Counts set bits in each word element.",
      "syntax": "VPOPCNTW zmm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 54",
        "visual_parts": []
      },
      "extension": "AVX-512_BITALG",
      "slug": "vpopcntw",
      "rel_url": "x86/vpopcntw/",
      "operands": [],
      "linked_summary": "Counts set bits <a href=\"../../x86/in/\">in</a> each word element.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpcompressw",
      "architecture": "x86",
      "full_name": "Store Sparse Packed Word Integer Values",
      "summary": "Compresses active words from ZMM to memory.",
      "syntax": "VPCOMPRESSW m512 {k1}, zmm1",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 63",
        "visual_parts": []
      },
      "extension": "AVX-512_VBMI2",
      "slug": "vpcompressw",
      "rel_url": "x86/vpcompressw/",
      "operands": [],
      "linked_summary": "Compresses active words from ZMM to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpexpandw",
      "architecture": "x86",
      "full_name": "Load Sparse Packed Word Integer Values",
      "summary": "Expands words from memory into sparse locations in ZMM.",
      "syntax": "VPEXPANDW zmm1 {k1}, m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 62",
        "visual_parts": []
      },
      "extension": "AVX-512_VBMI2",
      "slug": "vpexpandw",
      "rel_url": "x86/vpexpandw/",
      "operands": [],
      "linked_summary": "Expands words from memory into sparse locations <a href=\"../../x86/in/\">in</a> ZMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpshldw",
      "architecture": "x86",
      "full_name": "Packed Shift Left Word Concatenate",
      "summary": "Funnel shift left of words.",
      "syntax": "VPSHLDW zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 70",
        "visual_parts": []
      },
      "extension": "AVX-512_VBMI2",
      "slug": "vpshldw",
      "rel_url": "x86/vpshldw/",
      "operands": [],
      "linked_summary": "Funnel shift left of words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpshldq",
      "architecture": "x86",
      "full_name": "Packed Shift Left Quadword Concatenate",
      "summary": "Funnel shift left of quadwords.",
      "syntax": "VPSHLDQ zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 71",
        "visual_parts": []
      },
      "extension": "AVX-512_VBMI2",
      "slug": "vpshldq",
      "rel_url": "x86/vpshldq/",
      "operands": [],
      "linked_summary": "Funnel shift left of quadwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpshrdw",
      "architecture": "x86",
      "full_name": "Packed Shift Right Word Concatenate",
      "summary": "Funnel shift right of words.",
      "syntax": "VPSHRDW zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 72",
        "visual_parts": []
      },
      "extension": "AVX-512_VBMI2",
      "slug": "vpshrdw",
      "rel_url": "x86/vpshrdw/",
      "operands": [],
      "linked_summary": "Funnel shift right of words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpshrdq",
      "architecture": "x86",
      "full_name": "Packed Shift Right Quadword Concatenate",
      "summary": "Funnel shift right of quadwords.",
      "syntax": "VPSHRDQ zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 3A 73",
        "visual_parts": []
      },
      "extension": "AVX-512_VBMI2",
      "slug": "vpshrdq",
      "rel_url": "x86/vpshrdq/",
      "operands": [],
      "linked_summary": "Funnel shift right of quadwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vp2intersectq",
      "architecture": "x86",
      "full_name": "Compute Intersection Pair Quadwords",
      "summary": "Computes intersection of two ZMM registers into mask pair.",
      "syntax": "VP2INTERSECTQ k1+1, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "F2 0F 38 68",
        "visual_parts": []
      },
      "extension": "AVX-512_VP2INTERSECT",
      "slug": "vp2intersectq",
      "rel_url": "x86/vp2intersectq/",
      "operands": [],
      "linked_summary": "Computes intersection of two ZMM registers into mask pair.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tdpbuud",
      "architecture": "x86",
      "full_name": "Tile Dot Product Byte Unsigned Unsigned Doubleword",
      "summary": "Matrix multiply (Unsigned * Unsigned) accumulating to Int32.",
      "syntax": "TDPBUUD tmm1, tmm2, tmm3",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 5E",
        "visual_parts": []
      },
      "extension": "AMX-INT8",
      "slug": "tdpbuud",
      "rel_url": "x86/tdpbuud/",
      "operands": [],
      "linked_summary": "Matrix multiply (Unsigned * Unsigned) accumulating to Int32.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tdpbusd",
      "architecture": "x86",
      "full_name": "Tile Dot Product Byte Unsigned Signed Doubleword",
      "summary": "Matrix multiply (Unsigned * Signed) accumulating to Int32.",
      "syntax": "TDPBUSD tmm1, tmm2, tmm3",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 5E",
        "visual_parts": []
      },
      "extension": "AMX-INT8",
      "slug": "tdpbusd",
      "rel_url": "x86/tdpbusd/",
      "operands": [],
      "linked_summary": "Matrix multiply (Unsigned * Signed) accumulating to Int32.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tileloaddt1",
      "architecture": "x86",
      "full_name": "Load Tile Data (T1 Hint)",
      "summary": "Loads data into an AMX tile register with T1 hint.",
      "syntax": "TILELOADDT1 tmm1, m",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 4B",
        "visual_parts": []
      },
      "extension": "AMX-TILE",
      "slug": "tileloaddt1",
      "rel_url": "x86/tileloaddt1/",
      "operands": [],
      "linked_summary": "Loads data into an AMX tile register with T1 <a href=\"../../armv8-a/hint/\">hint</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aesdecwide128kl",
      "architecture": "x86",
      "full_name": "AES Decrypt Wide 128-bit Key Locker",
      "summary": "Decrypts 8 blocks using 128-bit Key Locker handle.",
      "syntax": "AESDECWIDE128KL m128",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 38 D8",
        "visual_parts": []
      },
      "extension": "KEYLOCKER_WIDE",
      "slug": "aesdecwide128kl",
      "rel_url": "x86/aesdecwide128kl/",
      "operands": [],
      "linked_summary": "Decrypts 8 blocks using 128-<a href=\"../../armv8-a/bit/\">bit</a> Key Locker handle.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aesencwide256kl",
      "architecture": "x86",
      "full_name": "AES Encrypt Wide 256-bit Key Locker",
      "summary": "Encrypts 8 blocks using 256-bit Key Locker handle.",
      "syntax": "AESENCWIDE256KL m128",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 38 D8",
        "visual_parts": []
      },
      "extension": "KEYLOCKER_WIDE",
      "slug": "aesencwide256kl_1",
      "rel_url": "x86/aesencwide256kl_1/",
      "operands": [],
      "linked_summary": "Encrypts 8 blocks using 256-<a href=\"../../armv8-a/bit/\">bit</a> Key Locker handle.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aesdecwide256kl",
      "architecture": "x86",
      "full_name": "AES Decrypt Wide 256-bit Key Locker",
      "summary": "Decrypts 8 blocks using 256-bit Key Locker handle.",
      "syntax": "AESDECWIDE256KL m128",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 38 D8",
        "visual_parts": []
      },
      "extension": "KEYLOCKER_WIDE",
      "slug": "aesdecwide256kl",
      "rel_url": "x86/aesdecwide256kl/",
      "operands": [],
      "linked_summary": "Decrypts 8 blocks using 256-<a href=\"../../armv8-a/bit/\">bit</a> Key Locker handle.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "encodekey256",
      "architecture": "x86",
      "full_name": "Encode 256-bit Key",
      "summary": "Wraps a 256-bit AES key into a handle.",
      "syntax": "ENCODEKEY256 r32, r32",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 38 FB",
        "visual_parts": []
      },
      "extension": "KEYLOCKER",
      "slug": "encodekey256",
      "rel_url": "x86/encodekey256/",
      "operands": [],
      "linked_summary": "Wraps a 256-<a href=\"../../armv8-a/bit/\">bit</a> AES key into a handle.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aesenc256kl",
      "architecture": "x86",
      "full_name": "AES Encrypt 256-bit Key Locker",
      "summary": "Encrypts data using 256-bit Key Locker handle.",
      "syntax": "AESENC256KL m128, xmm",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 38 DC",
        "visual_parts": []
      },
      "extension": "KEYLOCKER",
      "slug": "aesenc256kl",
      "rel_url": "x86/aesenc256kl/",
      "operands": [],
      "linked_summary": "Encrypts data using 256-<a href=\"../../armv8-a/bit/\">bit</a> Key Locker handle.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "aesdec256kl",
      "architecture": "x86",
      "full_name": "AES Decrypt 256-bit Key Locker",
      "summary": "Decrypts data using 256-bit Key Locker handle.",
      "syntax": "AESDEC256KL m128, xmm",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 38 DD",
        "visual_parts": []
      },
      "extension": "KEYLOCKER",
      "slug": "aesdec256kl",
      "rel_url": "x86/aesdec256kl/",
      "operands": [],
      "linked_summary": "Decrypts data using 256-<a href=\"../../armv8-a/bit/\">bit</a> Key Locker handle.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "enqcmds",
      "architecture": "x86",
      "full_name": "Enqueue Command Supervisor",
      "summary": "Writes a command to a device (Supervisor mode).",
      "syntax": "ENQCMDS r32, m512",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F3 0F 38 F8",
        "visual_parts": []
      },
      "extension": "ENQCMD",
      "slug": "enqcmds",
      "rel_url": "x86/enqcmds/",
      "operands": [],
      "linked_summary": "Writes a command to a device (Supervisor mode).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "tsxldtrk",
      "architecture": "x86",
      "full_name": "TSX Load Tracking",
      "summary": "Suspends/Resumes tracking of load operations in TSX.",
      "syntax": "TSXLDTRK",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "F2 0F 01 E8",
        "visual_parts": []
      },
      "extension": "TSXLDTRK",
      "slug": "tsxldtrk",
      "rel_url": "x86/tsxldtrk/",
      "operands": [],
      "linked_summary": "Suspends/Resumes tracking of load operations <a href=\"../../x86/in/\">in</a> TSX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "syscall",
      "architecture": "x86",
      "full_name": "System Call",
      "summary": "Fast call to privilege level 0 system procedures.",
      "syntax": "SYSCALL",
      "encoding": {
        "format": "System",
        "hex_opcode": "0F 05",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "System (64-bit)",
      "slug": "syscall",
      "rel_url": "x86/syscall/",
      "linked_summary": "Fast <a href=\"../../x86/call_1/\">call</a> to privilege level 0 system procedures.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sysret",
      "architecture": "x86",
      "full_name": "Return from System Call",
      "summary": "Fast return to privilege level 3 user code.",
      "syntax": "SYSRET",
      "encoding": {
        "format": "System",
        "hex_opcode": "0F 07",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "System (64-bit)",
      "slug": "sysret",
      "rel_url": "x86/sysret/",
      "linked_summary": "Fast return to privilege level 3 user code.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sal",
      "architecture": "x86",
      "full_name": "Shift Arithmetic Left",
      "summary": "Shifts bits left (Alias for SHL).",
      "syntax": "SAL r/m, imm8",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0xC1 /4",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg/Mem"
        },
        {
          "name": "count",
          "desc": "Immediate"
        }
      ],
      "extension": "Base",
      "slug": "sal",
      "rel_url": "x86/sal/",
      "linked_summary": "Shifts bits left (Alias for SHL).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmpsw",
      "architecture": "x86",
      "full_name": "Compare String Word",
      "summary": "Compares word at [ESI] with [EDI].",
      "syntax": "CMPSW",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "66 A7",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "cmpsw",
      "rel_url": "x86/cmpsw/",
      "linked_summary": "Compares word <a href=\"../../armv8-a/at_2/\">at</a> [ESI] with [EDI].",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmpsd",
      "architecture": "x86",
      "full_name": "Compare String Doubleword",
      "summary": "Compares doubleword at [ESI] with [EDI].",
      "syntax": "CMPSD",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "A7",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "cmpsd_1",
      "rel_url": "x86/cmpsd_1/",
      "linked_summary": "Compares doubleword <a href=\"../../armv8-a/at_2/\">at</a> [ESI] with [EDI].",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cmpsq",
      "architecture": "x86",
      "full_name": "Compare String Quadword",
      "summary": "Compares quadword at [RSI] with [RDI].",
      "syntax": "CMPSQ",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "48 A7",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base (64-bit)",
      "slug": "cmpsq",
      "rel_url": "x86/cmpsq/",
      "linked_summary": "Compares quadword <a href=\"../../armv8-a/at_2/\">at</a> [RSI] with [RDI].",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "scasw",
      "architecture": "x86",
      "full_name": "Scan String Word",
      "summary": "Compares AX with memory at [EDI].",
      "syntax": "SCASW",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "66 AF",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "scasw",
      "rel_url": "x86/scasw/",
      "linked_summary": "Compares AX with memory <a href=\"../../armv8-a/at_2/\">at</a> [EDI].",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "scasd",
      "architecture": "x86",
      "full_name": "Scan String Doubleword",
      "summary": "Compares EAX with memory at [EDI].",
      "syntax": "SCASD",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "AF",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "scasd",
      "rel_url": "x86/scasd/",
      "linked_summary": "Compares EAX with memory <a href=\"../../armv8-a/at_2/\">at</a> [EDI].",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "scasq",
      "architecture": "x86",
      "full_name": "Scan String Quadword",
      "summary": "Compares RAX with memory at [RDI].",
      "syntax": "SCASQ",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "48 AF",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base (64-bit)",
      "slug": "scasq",
      "rel_url": "x86/scasq/",
      "linked_summary": "Compares RAX with memory <a href=\"../../armv8-a/at_2/\">at</a> [RDI].",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lodsw",
      "architecture": "x86",
      "full_name": "Load String Word",
      "summary": "Loads word from [ESI] into AX.",
      "syntax": "LODSW",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "66 AC",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "lodsw",
      "rel_url": "x86/lodsw/",
      "linked_summary": "Loads word from [ESI] into AX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lodsd",
      "architecture": "x86",
      "full_name": "Load String Doubleword",
      "summary": "Loads doubleword from [ESI] into EAX.",
      "syntax": "LODSD",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "AC",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "lodsd",
      "rel_url": "x86/lodsd/",
      "linked_summary": "Loads doubleword from [ESI] into EAX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lodsq",
      "architecture": "x86",
      "full_name": "Load String Quadword",
      "summary": "Loads quadword from [RSI] into RAX.",
      "syntax": "LODSQ",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "48 AC",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base (64-bit)",
      "slug": "lodsq",
      "rel_url": "x86/lodsq/",
      "linked_summary": "Loads quadword from [RSI] into RAX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stosw",
      "architecture": "x86",
      "full_name": "Store String Word",
      "summary": "Stores AX to memory at [EDI].",
      "syntax": "STOSW",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "66 AA",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "stosw",
      "rel_url": "x86/stosw/",
      "linked_summary": "Stores AX to memory <a href=\"../../armv8-a/at_2/\">at</a> [EDI].",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stosd",
      "architecture": "x86",
      "full_name": "Store String Doubleword",
      "summary": "Stores EAX to memory at [EDI].",
      "syntax": "STOSD",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "AA",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "stosd",
      "rel_url": "x86/stosd/",
      "linked_summary": "Stores EAX to memory <a href=\"../../armv8-a/at_2/\">at</a> [EDI].",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stosq",
      "architecture": "x86",
      "full_name": "Store String Quadword",
      "summary": "Stores RAX to memory at [RDI].",
      "syntax": "STOSQ",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "48 AA",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base (64-bit)",
      "slug": "stosq",
      "rel_url": "x86/stosq/",
      "linked_summary": "Stores RAX to memory <a href=\"../../armv8-a/at_2/\">at</a> [RDI].",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movsw",
      "architecture": "x86",
      "full_name": "Move String Word",
      "summary": "Moves word from [ESI] to [EDI].",
      "syntax": "MOVSW",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "66 A5",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "movsw",
      "rel_url": "x86/movsw/",
      "linked_summary": "Moves word from [ESI] to [EDI].",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movsd",
      "architecture": "x86",
      "full_name": "Move String Doubleword",
      "summary": "Moves doubleword from [ESI] to [EDI].",
      "syntax": "MOVSD",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "A5",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "movsd_1",
      "rel_url": "x86/movsd_1/",
      "linked_summary": "Moves doubleword from [ESI] to [EDI].",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movsq",
      "architecture": "x86",
      "full_name": "Move String Quadword",
      "summary": "Moves quadword from [RSI] to [RDI].",
      "syntax": "MOVSQ",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "48 A5",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base (64-bit)",
      "slug": "movsq",
      "rel_url": "x86/movsq/",
      "linked_summary": "Moves quadword from [RSI] to [RDI].",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "insw",
      "architecture": "x86",
      "full_name": "Input String Word from Port",
      "summary": "Reads word from I/O port to memory at [EDI].",
      "syntax": "INSW",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "66 6D",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "insw",
      "rel_url": "x86/insw/",
      "linked_summary": "Reads word from I/O port to memory <a href=\"../../armv8-a/at_2/\">at</a> [EDI].",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "insd",
      "architecture": "x86",
      "full_name": "Input String Doubleword from Port",
      "summary": "Reads doubleword from I/O port to memory at [EDI].",
      "syntax": "INSD",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "6D",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "insd",
      "rel_url": "x86/insd/",
      "linked_summary": "Reads doubleword from I/O port to memory <a href=\"../../armv8-a/at_2/\">at</a> [EDI].",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "outsw",
      "architecture": "x86",
      "full_name": "Output String Word to Port",
      "summary": "Writes word from memory at [ESI] to I/O port.",
      "syntax": "OUTSW",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "66 6F",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "outsw",
      "rel_url": "x86/outsw/",
      "linked_summary": "Writes word from memory <a href=\"../../armv8-a/at_2/\">at</a> [ESI] to I/O port.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "outsd",
      "architecture": "x86",
      "full_name": "Output String Doubleword to Port",
      "summary": "Writes doubleword from memory at [ESI] to I/O port.",
      "syntax": "OUTSD",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "6F",
        "length": "1",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "outsd",
      "rel_url": "x86/outsd/",
      "linked_summary": "Writes doubleword from memory <a href=\"../../armv8-a/at_2/\">at</a> [ESI] to I/O port.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fld1",
      "architecture": "x86",
      "full_name": "Load Constant 1.0",
      "summary": "Pushes +1.0 onto the FPU register stack.",
      "syntax": "FLD1",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 E8",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fld1",
      "rel_url": "x86/fld1/",
      "linked_summary": "Pushes +1.0 onto the FPU register stack.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fldz",
      "architecture": "x86",
      "full_name": "Load Constant +0.0",
      "summary": "Pushes +0.0 onto the FPU register stack.",
      "syntax": "FLDZ",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 EE",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fldz",
      "rel_url": "x86/fldz/",
      "linked_summary": "Pushes +0.0 onto the FPU register stack.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fldpi",
      "architecture": "x86",
      "full_name": "Load Constant Pi",
      "summary": "Pushes Pi onto the FPU register stack.",
      "syntax": "FLDPI",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 EB",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fldpi",
      "rel_url": "x86/fldpi/",
      "linked_summary": "Pushes Pi onto the FPU register stack.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fldl2e",
      "architecture": "x86",
      "full_name": "Load Constant log2(e)",
      "summary": "Pushes log2(e) onto the FPU register stack.",
      "syntax": "FLDL2E",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 EA",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fldl2e",
      "rel_url": "x86/fldl2e/",
      "linked_summary": "Pushes log2(e) onto the FPU register stack.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fldl2t",
      "architecture": "x86",
      "full_name": "Load Constant log2(10)",
      "summary": "Pushes log2(10) onto the FPU register stack.",
      "syntax": "FLDL2T",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 E9",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fldl2t",
      "rel_url": "x86/fldl2t/",
      "linked_summary": "Pushes log2(10) onto the FPU register stack.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fldlg2",
      "architecture": "x86",
      "full_name": "Load Constant log10(2)",
      "summary": "Pushes log10(2) onto the FPU register stack.",
      "syntax": "FLDLG2",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 EC",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fldlg2",
      "rel_url": "x86/fldlg2/",
      "linked_summary": "Pushes log10(2) onto the FPU register stack.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fldln2",
      "architecture": "x86",
      "full_name": "Load Constant ln(2)",
      "summary": "Pushes ln(2) onto the FPU register stack.",
      "syntax": "FLDLN2",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 ED",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fldln2",
      "rel_url": "x86/fldln2/",
      "linked_summary": "Pushes ln(2) onto the FPU register stack.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fincstp",
      "architecture": "x86",
      "full_name": "Increment Stack-Top Pointer",
      "summary": "Increments the TOP field in the FPU status word.",
      "syntax": "FINCSTP",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 F7",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fincstp",
      "rel_url": "x86/fincstp/",
      "linked_summary": "Increments the TOP field <a href=\"../../x86/in/\">in</a> the FPU status word.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fdecstp",
      "architecture": "x86",
      "full_name": "Decrement Stack-Top Pointer",
      "summary": "Decrements the TOP field in the FPU status word.",
      "syntax": "FDECSTP",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "D9 F6",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "x87 FPU",
      "slug": "fdecstp",
      "rel_url": "x86/fdecstp/",
      "linked_summary": "Decrements the TOP field <a href=\"../../x86/in/\">in</a> the FPU status word.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ffree",
      "architecture": "x86",
      "full_name": "Free Floating-Point Register",
      "summary": "Sets the tag for ST(i) to empty.",
      "syntax": "FFREE ST(i)",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "DD C0+i",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Register"
        }
      ],
      "extension": "x87 FPU",
      "slug": "ffree",
      "rel_url": "x86/ffree/",
      "linked_summary": "Sets the tag for ST(i) to empty.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fcmovb",
      "architecture": "x86",
      "full_name": "Floating-Point Conditional Move If Below",
      "summary": "Moves ST(i) to ST(0) if CF=1.",
      "syntax": "FCMOVB ST(0), ST(i)",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "DA C0+i",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "x87 FPU (P6+)",
      "slug": "fcmovb",
      "rel_url": "x86/fcmovb/",
      "linked_summary": "Moves ST(i) to ST(0) if CF=1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fcmove",
      "architecture": "x86",
      "full_name": "Floating-Point Conditional Move If Equal",
      "summary": "Moves ST(i) to ST(0) if ZF=1.",
      "syntax": "FCMOVE ST(0), ST(i)",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "DA C8+i",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "x87 FPU (P6+)",
      "slug": "fcmove",
      "rel_url": "x86/fcmove/",
      "linked_summary": "Moves ST(i) to ST(0) if ZF=1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fcmovbe",
      "architecture": "x86",
      "full_name": "Floating-Point Conditional Move If Below or Equal",
      "summary": "Moves ST(i) to ST(0) if CF=1 or ZF=1.",
      "syntax": "FCMOVBE ST(0), ST(i)",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "DA D0+i",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "x87 FPU (P6+)",
      "slug": "fcmovbe",
      "rel_url": "x86/fcmovbe/",
      "linked_summary": "Moves ST(i) to ST(0) if CF=1 <a href=\"../../powerisa/or/\">or</a> ZF=1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fcmovu",
      "architecture": "x86",
      "full_name": "Floating-Point Conditional Move If Unordered",
      "summary": "Moves ST(i) to ST(0) if PF=1.",
      "syntax": "FCMOVU ST(0), ST(i)",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "DA D8+i",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "x87 FPU (P6+)",
      "slug": "fcmovu",
      "rel_url": "x86/fcmovu/",
      "linked_summary": "Moves ST(i) to ST(0) if PF=1.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fcmovnb",
      "architecture": "x86",
      "full_name": "Floating-Point Conditional Move If Not Below",
      "summary": "Moves ST(i) to ST(0) if CF=0.",
      "syntax": "FCMOVNB ST(0), ST(i)",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "DB C0+i",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "x87 FPU (P6+)",
      "slug": "fcmovnb",
      "rel_url": "x86/fcmovnb/",
      "linked_summary": "Moves ST(i) to ST(0) if CF=0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fcmovne",
      "architecture": "x86",
      "full_name": "Floating-Point Conditional Move If Not Equal",
      "summary": "Moves ST(i) to ST(0) if ZF=0.",
      "syntax": "FCMOVNE ST(0), ST(i)",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "DB C8+i",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "x87 FPU (P6+)",
      "slug": "fcmovne",
      "rel_url": "x86/fcmovne/",
      "linked_summary": "Moves ST(i) to ST(0) if ZF=0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fcmovnbe",
      "architecture": "x86",
      "full_name": "Floating-Point Conditional Move If Not Below or Equal",
      "summary": "Moves ST(i) to ST(0) if CF=0 and ZF=0.",
      "syntax": "FCMOVNBE ST(0), ST(i)",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "DB D0+i",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "x87 FPU (P6+)",
      "slug": "fcmovnbe",
      "rel_url": "x86/fcmovnbe/",
      "linked_summary": "Moves ST(i) to ST(0) if CF=0 <a href=\"../../armv8-a/and_6/\">and</a> ZF=0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "fcmovnu",
      "architecture": "x86",
      "full_name": "Floating-Point Conditional Move If Not Unordered",
      "summary": "Moves ST(i) to ST(0) if PF=0.",
      "syntax": "FCMOVNU ST(0), ST(i)",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "DB D8+i",
        "length": "2",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Register"
        }
      ],
      "extension": "x87 FPU (P6+)",
      "slug": "fcmovnu",
      "rel_url": "x86/fcmovnu/",
      "linked_summary": "Moves ST(i) to ST(0) if PF=0.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "packuswb",
      "architecture": "x86",
      "full_name": "Pack with Unsigned Saturation Word to Byte",
      "summary": "Converts signed words to unsigned bytes with saturation.",
      "syntax": "PACKUSWB xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 67",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "packuswb",
      "rel_url": "x86/packuswb/",
      "linked_summary": "Converts signed words to unsigned bytes with saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "punpckhbw",
      "architecture": "x86",
      "full_name": "Unpack High Data Bytes",
      "summary": "Interleaves high bytes from two sources.",
      "syntax": "PUNPCKHBW xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 68",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "punpckhbw",
      "rel_url": "x86/punpckhbw/",
      "linked_summary": "Interleaves high bytes from two sources.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "punpckhwd",
      "architecture": "x86",
      "full_name": "Unpack High Data Words",
      "summary": "Interleaves high words.",
      "syntax": "PUNPCKHWD xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 69",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "punpckhwd",
      "rel_url": "x86/punpckhwd/",
      "linked_summary": "Interleaves high words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "punpckhdq",
      "architecture": "x86",
      "full_name": "Unpack High Data Doublewords",
      "summary": "Interleaves high doublewords.",
      "syntax": "PUNPCKHDQ xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 6A",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "punpckhdq",
      "rel_url": "x86/punpckhdq/",
      "linked_summary": "Interleaves high doublewords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "punpckhqdq",
      "architecture": "x86",
      "full_name": "Unpack High Data Quadwords",
      "summary": "Interleaves high quadwords.",
      "syntax": "PUNPCKHQDQ xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 6D",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "punpckhqdq",
      "rel_url": "x86/punpckhqdq/",
      "linked_summary": "Interleaves high quadwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psadbw",
      "architecture": "x86",
      "full_name": "Compute Sum of Absolute Differences",
      "summary": "Computes absolute differences of bytes and sums them to words.",
      "syntax": "PSADBW xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F F6",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "psadbw",
      "rel_url": "x86/psadbw/",
      "linked_summary": "Computes absolute differences of bytes <a href=\"../../armv8-a/and_6/\">and</a> sums them to words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmaxub",
      "architecture": "x86",
      "full_name": "Maximum of Packed Unsigned Byte Integers",
      "summary": "Returns maximum of unsigned bytes.",
      "syntax": "PMAXUB xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F DE",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "pmaxub",
      "rel_url": "x86/pmaxub/",
      "linked_summary": "Returns maximum of unsigned bytes.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pminub",
      "architecture": "x86",
      "full_name": "Minimum of Packed Unsigned Byte Integers",
      "summary": "Returns minimum of unsigned bytes.",
      "syntax": "PMINUB xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F DA",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "pminub",
      "rel_url": "x86/pminub/",
      "linked_summary": "Returns minimum of unsigned bytes.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmaxsw",
      "architecture": "x86",
      "full_name": "Maximum of Packed Signed Word Integers",
      "summary": "Returns maximum of signed words.",
      "syntax": "PMAXSW xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F EE",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "pmaxsw",
      "rel_url": "x86/pmaxsw/",
      "linked_summary": "Returns maximum of signed words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pminsw",
      "architecture": "x86",
      "full_name": "Minimum of Packed Signed Word Integers",
      "summary": "Returns minimum of signed words.",
      "syntax": "PMINSW xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F EA",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "pminsw",
      "rel_url": "x86/pminsw/",
      "linked_summary": "Returns minimum of signed words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pavgb",
      "architecture": "x86",
      "full_name": "Average Packed Integers (Byte)",
      "summary": "Averages packed unsigned bytes (rounded up).",
      "syntax": "PAVGB xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F E0",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "pavgb",
      "rel_url": "x86/pavgb/",
      "linked_summary": "Averages packed unsigned bytes (rounded up).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pavgw",
      "architecture": "x86",
      "full_name": "Average Packed Integers (Word)",
      "summary": "Averages packed unsigned words (rounded up).",
      "syntax": "PAVGW xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F E3",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "pavgw",
      "rel_url": "x86/pavgw/",
      "linked_summary": "Averages packed unsigned words (rounded up).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmulhuw",
      "architecture": "x86",
      "full_name": "Packed Multiply High Unsigned",
      "summary": "Multiplies unsigned words, keeps high 16 bits.",
      "syntax": "PMULHUW xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F E4",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "pmulhuw",
      "rel_url": "x86/pmulhuw/",
      "linked_summary": "Multiplies unsigned words, keeps high 16 bits.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmulhw",
      "architecture": "x86",
      "full_name": "Packed Multiply High Signed",
      "summary": "Multiplies signed words, keeps high 16 bits.",
      "syntax": "PMULHW xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F E5",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "pmulhw_1",
      "rel_url": "x86/pmulhw_1/",
      "linked_summary": "Multiplies signed words, keeps high 16 bits.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psubq",
      "architecture": "x86",
      "full_name": "Packed Subtract Quadword",
      "summary": "Subtracts packed quadwords.",
      "syntax": "PSUBQ xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F FB",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "psubq",
      "rel_url": "x86/psubq/",
      "linked_summary": "Subtracts packed quadwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmuludq",
      "architecture": "x86",
      "full_name": "Multiply Packed Unsigned Doubleword Integers",
      "summary": "Multiplies low 32-bits of each 64-bit chunk to 64-bit result.",
      "syntax": "PMULUDQ xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F F4",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "pmuludq",
      "rel_url": "x86/pmuludq/",
      "linked_summary": "Multiplies low 32-bits of each 64-<a href=\"../../armv8-a/bit/\">bit</a> chunk to 64-<a href=\"../../armv8-a/bit/\">bit</a> result.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pslldq",
      "architecture": "x86",
      "full_name": "Shift Double Quadword Left Logical",
      "summary": "Shifts the entire 128-bit register left by bytes.",
      "syntax": "PSLLDQ xmm1, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 73 /7",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "SSE2",
      "slug": "pslldq",
      "rel_url": "x86/pslldq/",
      "linked_summary": "Shifts the entire 128-<a href=\"../../armv8-a/bit/\">bit</a> register left by bytes.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psrldq",
      "architecture": "x86",
      "full_name": "Shift Double Quadword Right Logical",
      "summary": "Shifts the entire 128-bit register right by bytes.",
      "syntax": "PSRLDQ xmm1, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 73 /3",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "SSE2",
      "slug": "psrldq",
      "rel_url": "x86/psrldq/",
      "linked_summary": "Shifts the entire 128-<a href=\"../../armv8-a/bit/\">bit</a> register right by bytes.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvtdq2ps",
      "architecture": "x86",
      "full_name": "Convert Packed Doubleword Integers to Packed Single-Precision",
      "summary": "Converts four 32-bit integers to floats.",
      "syntax": "CVTDQ2PS xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0F 5B",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "cvtdq2ps",
      "rel_url": "x86/cvtdq2ps/",
      "linked_summary": "Converts four 32-<a href=\"../../armv8-a/bit/\">bit</a> integers to floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvtps2dq",
      "architecture": "x86",
      "full_name": "Convert Packed Single-Precision to Packed Doubleword Integers",
      "summary": "Converts four floats to 32-bit integers (Rounded).",
      "syntax": "CVTPS2DQ xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 5B",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "cvtps2dq",
      "rel_url": "x86/cvtps2dq/",
      "linked_summary": "Converts four floats to 32-<a href=\"../../armv8-a/bit/\">bit</a> integers (Rounded).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvttps2dq",
      "architecture": "x86",
      "full_name": "Convert with Truncation Packed Single-Precision to Packed Doubleword Integers",
      "summary": "Converts four floats to 32-bit integers (Truncated).",
      "syntax": "CVTTPS2DQ xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "F3 0F 5B",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "cvttps2dq",
      "rel_url": "x86/cvttps2dq/",
      "linked_summary": "Converts four floats to 32-<a href=\"../../armv8-a/bit/\">bit</a> integers (Truncated).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movmskps",
      "architecture": "x86",
      "full_name": "Extract Packed Single-Precision Mask",
      "summary": "Extracts sign bits from four floats into low 4 bits of register.",
      "syntax": "MOVMSKPS r32, xmm",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F 50",
        "length": "3",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "XMM"
        }
      ],
      "extension": "SSE",
      "slug": "movmskps",
      "rel_url": "x86/movmskps/",
      "linked_summary": "Extracts sign bits from four floats into low 4 bits of register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movmskpd",
      "architecture": "x86",
      "full_name": "Extract Packed Double-Precision Mask",
      "summary": "Extracts sign bits from two doubles into low 2 bits of register.",
      "syntax": "MOVMSKPD r32, xmm",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 50",
        "length": "4",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "XMM"
        }
      ],
      "extension": "SSE2",
      "slug": "movmskpd",
      "rel_url": "x86/movmskpd/",
      "linked_summary": "Extracts sign bits from two doubles into low 2 bits of register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "comiss",
      "architecture": "x86",
      "full_name": "Compare Scalar Ordered Single-Precision",
      "summary": "Compares low float and sets EFLAGS (Signaling NaN raises exception).",
      "syntax": "COMISS xmm1, xmm2/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0F 2F",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src1",
          "desc": "XMM"
        },
        {
          "name": "src2",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "comiss",
      "rel_url": "x86/comiss/",
      "linked_summary": "Compares low float <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../x86/sets/\">sets</a> EFLAGS (Signaling NaN raises exception).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "comisd",
      "architecture": "x86",
      "full_name": "Compare Scalar Ordered Double-Precision",
      "summary": "Compares low double and sets EFLAGS (Signaling NaN raises exception).",
      "syntax": "COMISD xmm1, xmm2/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 2F",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src1",
          "desc": "XMM"
        },
        {
          "name": "src2",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "comisd",
      "rel_url": "x86/comisd/",
      "linked_summary": "Compares low double <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../x86/sets/\">sets</a> EFLAGS (Signaling NaN raises exception).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "unpcklps",
      "architecture": "x86",
      "full_name": "Unpack Low Packed Single-Precision",
      "summary": "Interleaves low floats from two sources.",
      "syntax": "UNPCKLPS xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 14",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "unpcklps_1",
      "rel_url": "x86/unpcklps_1/",
      "linked_summary": "Interleaves low floats from two sources.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "unpckhps",
      "architecture": "x86",
      "full_name": "Unpack High Packed Single-Precision",
      "summary": "Interleaves high floats from two sources.",
      "syntax": "UNPCKHPS xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 15",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "unpckhps_1",
      "rel_url": "x86/unpckhps_1/",
      "linked_summary": "Interleaves high floats from two sources.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "unpcklpd",
      "architecture": "x86",
      "full_name": "Unpack Low Packed Double-Precision",
      "summary": "Interleaves low doubles from two sources.",
      "syntax": "UNPCKLPD xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 14",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "unpcklpd",
      "rel_url": "x86/unpcklpd/",
      "linked_summary": "Interleaves low doubles from two sources.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "unpckhpd",
      "architecture": "x86",
      "full_name": "Unpack High Packed Double-Precision",
      "summary": "Interleaves high doubles from two sources.",
      "syntax": "UNPCKHPD xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "66 0F 15",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "unpckhpd",
      "rel_url": "x86/unpckhpd/",
      "linked_summary": "Interleaves high doubles from two sources.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movshdup",
      "architecture": "x86",
      "full_name": "Move Packed Single-FP High and Duplicate",
      "summary": "Duplicates high element of each qword pair.",
      "syntax": "MOVSHDUP xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE3",
        "hex_opcode": "F3 0F 16",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE3",
      "slug": "movshdup",
      "rel_url": "x86/movshdup/",
      "linked_summary": "Duplicates high element of each qword pair.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movsldup",
      "architecture": "x86",
      "full_name": "Move Packed Single-FP Low and Duplicate",
      "summary": "Duplicates low element of each qword pair.",
      "syntax": "MOVSLDUP xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE3",
        "hex_opcode": "F3 0F 12",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE3",
      "slug": "movsldup",
      "rel_url": "x86/movsldup/",
      "linked_summary": "Duplicates low element of each qword pair.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "phsubw",
      "architecture": "x86",
      "full_name": "Packed Horizontal Subtract Word",
      "summary": "Subtracts adjacent 16-bit integers horizontally.",
      "syntax": "PHSUBW xmm1, xmm2/m128",
      "encoding": {
        "format": "SSSE3",
        "hex_opcode": "66 0F 38 05",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSSE3",
      "slug": "phsubw",
      "rel_url": "x86/phsubw/",
      "linked_summary": "Subtracts adjacent 16-<a href=\"../../armv8-a/bit/\">bit</a> integers horizontally.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "phsubd",
      "architecture": "x86",
      "full_name": "Packed Horizontal Subtract Doubleword",
      "summary": "Subtracts adjacent 32-bit integers horizontally.",
      "syntax": "PHSUBD xmm1, xmm2/m128",
      "encoding": {
        "format": "SSSE3",
        "hex_opcode": "66 0F 38 06",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSSE3",
      "slug": "phsubd",
      "rel_url": "x86/phsubd/",
      "linked_summary": "Subtracts adjacent 32-<a href=\"../../armv8-a/bit/\">bit</a> integers horizontally.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmaddubsw",
      "architecture": "x86",
      "full_name": "Multiply and Add Packed Signed and Unsigned Bytes",
      "summary": "Multiplies signed/unsigned bytes and adds pairs to words.",
      "syntax": "PMADDUBSW xmm1, xmm2/m128",
      "encoding": {
        "format": "SSSE3",
        "hex_opcode": "66 0F 38 04",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSSE3",
      "slug": "pmaddubsw",
      "rel_url": "x86/pmaddubsw/",
      "linked_summary": "Multiplies signed/unsigned bytes <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../armv8-a/adds_5/\">adds</a> pairs to words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "phminposuw",
      "architecture": "x86",
      "full_name": "Packed Horizontal Minimum",
      "summary": "Finds minimum word and its index.",
      "syntax": "PHMINPOSUW xmm1, xmm2/m128",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 41",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE4.1",
      "slug": "phminposuw",
      "rel_url": "x86/phminposuw/",
      "linked_summary": "Finds minimum word <a href=\"../../armv8-a/and_6/\">and</a> its <a href=\"../../armv8-a/index/\">index</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mpsadbw",
      "architecture": "x86",
      "full_name": "Compute Multiple Sums of Absolute Differences",
      "summary": "Computes multiple SADs of byte blocks.",
      "syntax": "MPSADBW xmm1, xmm2/m128, imm8",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 3A 42",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        },
        {
          "name": "sel",
          "desc": "Imm"
        }
      ],
      "extension": "SSE4.1",
      "slug": "mpsadbw",
      "rel_url": "x86/mpsadbw/",
      "linked_summary": "Computes multiple SADs of byte blocks.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmovsxbq",
      "architecture": "x86",
      "full_name": "Packed Move with Sign Extend Byte to Quadword",
      "summary": "Sign extends 8-bit integers to 64-bit.",
      "syntax": "PMOVSXBQ xmm1, xmm2/m16",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 22",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE4.1",
      "slug": "pmovsxbq",
      "rel_url": "x86/pmovsxbq/",
      "linked_summary": "Sign extends 8-<a href=\"../../armv8-a/bit/\">bit</a> integers to 64-<a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmovsxwd",
      "architecture": "x86",
      "full_name": "Packed Move with Sign Extend Word to Doubleword",
      "summary": "Sign extends 16-bit integers to 32-bit.",
      "syntax": "PMOVSXWD xmm1, xmm2/m64",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 23",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE4.1",
      "slug": "pmovsxwd",
      "rel_url": "x86/pmovsxwd/",
      "linked_summary": "Sign extends 16-<a href=\"../../armv8-a/bit/\">bit</a> integers to 32-<a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmovsxwq",
      "architecture": "x86",
      "full_name": "Packed Move with Sign Extend Word to Quadword",
      "summary": "Sign extends 16-bit integers to 64-bit.",
      "syntax": "PMOVSXWQ xmm1, xmm2/m32",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 24",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE4.1",
      "slug": "pmovsxwq",
      "rel_url": "x86/pmovsxwq/",
      "linked_summary": "Sign extends 16-<a href=\"../../armv8-a/bit/\">bit</a> integers to 64-<a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmovsxdq",
      "architecture": "x86",
      "full_name": "Packed Move with Sign Extend Doubleword to Quadword",
      "summary": "Sign extends 32-bit integers to 64-bit.",
      "syntax": "PMOVSXDQ xmm1, xmm2/m64",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 25",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE4.1",
      "slug": "pmovsxdq",
      "rel_url": "x86/pmovsxdq/",
      "linked_summary": "Sign extends 32-<a href=\"../../armv8-a/bit/\">bit</a> integers to 64-<a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmovzxbd",
      "architecture": "x86",
      "full_name": "Packed Move with Zero Extend Byte to Doubleword",
      "summary": "Zero extends 8-bit integers to 32-bit.",
      "syntax": "PMOVZXBD xmm1, xmm2/m32",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 31",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE4.1",
      "slug": "pmovzxbd",
      "rel_url": "x86/pmovzxbd/",
      "linked_summary": "Zero extends 8-<a href=\"../../armv8-a/bit/\">bit</a> integers to 32-<a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmovzxbq",
      "architecture": "x86",
      "full_name": "Packed Move with Zero Extend Byte to Quadword",
      "summary": "Zero extends 8-bit integers to 64-bit.",
      "syntax": "PMOVZXBQ xmm1, xmm2/m16",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 32",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE4.1",
      "slug": "pmovzxbq",
      "rel_url": "x86/pmovzxbq/",
      "linked_summary": "Zero extends 8-<a href=\"../../armv8-a/bit/\">bit</a> integers to 64-<a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmovzxwd",
      "architecture": "x86",
      "full_name": "Packed Move with Zero Extend Word to Doubleword",
      "summary": "Zero extends 16-bit integers to 32-bit.",
      "syntax": "PMOVZXWD xmm1, xmm2/m64",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 33",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE4.1",
      "slug": "pmovzxwd",
      "rel_url": "x86/pmovzxwd/",
      "linked_summary": "Zero extends 16-<a href=\"../../armv8-a/bit/\">bit</a> integers to 32-<a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmovzxwq",
      "architecture": "x86",
      "full_name": "Packed Move with Zero Extend Word to Quadword",
      "summary": "Zero extends 16-bit integers to 64-bit.",
      "syntax": "PMOVZXWQ xmm1, xmm2/m32",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 34",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE4.1",
      "slug": "pmovzxwq",
      "rel_url": "x86/pmovzxwq/",
      "linked_summary": "Zero extends 16-<a href=\"../../armv8-a/bit/\">bit</a> integers to 64-<a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmovzxdq",
      "architecture": "x86",
      "full_name": "Packed Move with Zero Extend Doubleword to Quadword",
      "summary": "Zero extends 32-bit integers to 64-bit.",
      "syntax": "PMOVZXDQ xmm1, xmm2/m64",
      "encoding": {
        "format": "SSE4.1",
        "hex_opcode": "66 0F 38 35",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE4.1",
      "slug": "pmovzxdq",
      "rel_url": "x86/pmovzxdq/",
      "linked_summary": "Zero extends 32-<a href=\"../../armv8-a/bit/\">bit</a> integers to 64-<a href=\"../../armv8-a/bit/\">bit</a>.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vbroadcastsd",
      "architecture": "x86",
      "full_name": "Broadcast Scalar Double",
      "summary": "Broadcasts a double to all elements of YMM.",
      "syntax": "VBROADCASTSD ymm1, m64",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 19",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "src",
          "desc": "Memory"
        }
      ],
      "extension": "AVX2",
      "slug": "vbroadcastsd",
      "rel_url": "x86/vbroadcastsd/",
      "linked_summary": "Broadcasts a double to all elements of YMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vbroadcastf128",
      "architecture": "x86",
      "full_name": "Broadcast 128-bit Floating-Point",
      "summary": "Broadcasts 128-bit FP block to YMM.",
      "syntax": "VBROADCASTF128 ymm1, m128",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 1A",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "src",
          "desc": "Memory"
        }
      ],
      "extension": "AVX",
      "slug": "vbroadcastf128",
      "rel_url": "x86/vbroadcastf128/",
      "linked_summary": "Broadcasts 128-<a href=\"../../armv8-a/bit/\">bit</a> FP block to YMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vbroadcasti128",
      "architecture": "x86",
      "full_name": "Broadcast 128-bit Integer",
      "summary": "Broadcasts 128-bit integer block to YMM.",
      "syntax": "VBROADCASTI128 ymm1, m128",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 5A",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "src",
          "desc": "Memory"
        }
      ],
      "extension": "AVX2",
      "slug": "vbroadcasti128",
      "rel_url": "x86/vbroadcasti128/",
      "linked_summary": "Broadcasts 128-<a href=\"../../armv8-a/bit/\">bit</a> integer block to YMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpbroadcastw",
      "architecture": "x86",
      "full_name": "Broadcast Word",
      "summary": "Broadcasts a word to all elements of YMM.",
      "syntax": "VPBROADCASTW ymm1, xmm2/m16",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 79",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "AVX2",
      "slug": "vpbroadcastw",
      "rel_url": "x86/vpbroadcastw/",
      "linked_summary": "Broadcasts a word to all elements of YMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpbroadcastq",
      "architecture": "x86",
      "full_name": "Broadcast Quadword",
      "summary": "Broadcasts a quadword to all elements of YMM.",
      "syntax": "VPBROADCASTQ ymm1, xmm2/m64",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 59",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "AVX2",
      "slug": "vpbroadcastq",
      "rel_url": "x86/vpbroadcastq/",
      "linked_summary": "Broadcasts a quadword to all elements of YMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmaskmovps",
      "architecture": "x86",
      "full_name": "Conditional Move Packed Single-Precision",
      "summary": "Conditionally loads/stores floats based on mask.",
      "syntax": "VMASKMOVPS ymm1, ymm2, m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 2C",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "mask",
          "desc": "YMM"
        },
        {
          "name": "src",
          "desc": "Mem"
        }
      ],
      "extension": "AVX",
      "slug": "vmaskmovps",
      "rel_url": "x86/vmaskmovps/",
      "linked_summary": "Conditionally loads/stores floats based on mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmaskmovpd",
      "architecture": "x86",
      "full_name": "Conditional Move Packed Double-Precision",
      "summary": "Conditionally loads/stores doubles based on mask.",
      "syntax": "VMASKMOVPD ymm1, ymm2, m256",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 2D",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "mask",
          "desc": "YMM"
        },
        {
          "name": "src",
          "desc": "Mem"
        }
      ],
      "extension": "AVX",
      "slug": "vmaskmovpd",
      "rel_url": "x86/vmaskmovpd/",
      "linked_summary": "Conditionally loads/stores doubles based on mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpgatherdd",
      "architecture": "x86",
      "full_name": "Gather Packed Doubleword with Signed Doubleword Indices",
      "summary": "Gathers 32-bit integers using 32-bit indices.",
      "syntax": "VPGATHERDD ymm1, [base+ymm_idx*scale], ymm_mask",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 90",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "mem",
          "desc": "Base+Idx"
        },
        {
          "name": "mask",
          "desc": "YMM"
        }
      ],
      "extension": "AVX2",
      "slug": "vpgatherdd",
      "rel_url": "x86/vpgatherdd/",
      "linked_summary": "Gathers 32-<a href=\"../../armv8-a/bit/\">bit</a> integers using 32-<a href=\"../../armv8-a/bit/\">bit</a> indices.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpgatherdq",
      "architecture": "x86",
      "full_name": "Gather Packed Quadword with Signed Doubleword Indices",
      "summary": "Gathers 64-bit integers using 32-bit indices.",
      "syntax": "VPGATHERDQ ymm1, [base+xmm_idx*scale], ymm_mask",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 90",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "mem",
          "desc": "Base+Idx"
        },
        {
          "name": "mask",
          "desc": "YMM"
        }
      ],
      "extension": "AVX2",
      "slug": "vpgatherdq",
      "rel_url": "x86/vpgatherdq/",
      "linked_summary": "Gathers 64-<a href=\"../../armv8-a/bit/\">bit</a> integers using 32-<a href=\"../../armv8-a/bit/\">bit</a> indices.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpgatherqd",
      "architecture": "x86",
      "full_name": "Gather Packed Doubleword with Signed Quadword Indices",
      "summary": "Gathers 32-bit integers using 64-bit indices.",
      "syntax": "VPGATHERQD xmm1, [base+ymm_idx*scale], xmm_mask",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 91",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "mem",
          "desc": "Base+Idx"
        },
        {
          "name": "mask",
          "desc": "XMM"
        }
      ],
      "extension": "AVX2",
      "slug": "vpgatherqd",
      "rel_url": "x86/vpgatherqd/",
      "linked_summary": "Gathers 32-<a href=\"../../armv8-a/bit/\">bit</a> integers using 64-<a href=\"../../armv8-a/bit/\">bit</a> indices.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpgatherqq",
      "architecture": "x86",
      "full_name": "Gather Packed Quadword with Signed Quadword Indices",
      "summary": "Gathers 64-bit integers using 64-bit indices.",
      "syntax": "VPGATHERQQ ymm1, [base+ymm_idx*scale], ymm_mask",
      "encoding": {
        "format": "VEX",
        "hex_opcode": "C4 ... 91",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "YMM"
        },
        {
          "name": "mem",
          "desc": "Base+Idx"
        },
        {
          "name": "mask",
          "desc": "YMM"
        }
      ],
      "extension": "AVX2",
      "slug": "vpgatherqq",
      "rel_url": "x86/vpgatherqq/",
      "linked_summary": "Gathers 64-<a href=\"../../armv8-a/bit/\">bit</a> integers using 64-<a href=\"../../armv8-a/bit/\">bit</a> indices.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpabsq",
      "architecture": "x86",
      "full_name": "Packed Absolute Value Quadword",
      "summary": "Computes absolute value of 64-bit integers.",
      "syntax": "VPABSQ zmm1 {k1}, zmm2/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 1F",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vpabsq",
      "rel_url": "x86/vpabsq/",
      "linked_summary": "Computes absolute value of 64-<a href=\"../../armv8-a/bit/\">bit</a> integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmaxsq",
      "architecture": "x86",
      "full_name": "Maximum of Packed Signed Quadword Integers",
      "summary": "Returns maximum of signed 64-bit integers.",
      "syntax": "VPMAXSQ zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 3D",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vpmaxsq",
      "rel_url": "x86/vpmaxsq/",
      "linked_summary": "Returns maximum of signed 64-<a href=\"../../armv8-a/bit/\">bit</a> integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmaxuq",
      "architecture": "x86",
      "full_name": "Maximum of Packed Unsigned Quadword Integers",
      "summary": "Returns maximum of unsigned 64-bit integers.",
      "syntax": "VPMAXUQ zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 3F",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vpmaxuq",
      "rel_url": "x86/vpmaxuq/",
      "linked_summary": "Returns maximum of unsigned 64-<a href=\"../../armv8-a/bit/\">bit</a> integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpminsq",
      "architecture": "x86",
      "full_name": "Minimum of Packed Signed Quadword Integers",
      "summary": "Returns minimum of signed 64-bit integers.",
      "syntax": "VPMINSQ zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 39",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vpminsq",
      "rel_url": "x86/vpminsq/",
      "linked_summary": "Returns minimum of signed 64-<a href=\"../../armv8-a/bit/\">bit</a> integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpminuq",
      "architecture": "x86",
      "full_name": "Minimum of Packed Unsigned Quadword Integers",
      "summary": "Returns minimum of unsigned 64-bit integers.",
      "syntax": "VPMINUQ zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 38 3B",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src1",
          "desc": "ZMM"
        },
        {
          "name": "src2",
          "desc": "ZMM/Mem"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vpminuq",
      "rel_url": "x86/vpminuq/",
      "linked_summary": "Returns minimum of unsigned 64-<a href=\"../../armv8-a/bit/\">bit</a> integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vprolq",
      "architecture": "x86",
      "full_name": "Rotate Left Quadword",
      "summary": "Rotates 64-bit integers left.",
      "syntax": "VPROLQ zmm1 {k1}, zmm2, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 72 /2",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "ZMM"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vprolq",
      "rel_url": "x86/vprolq/",
      "linked_summary": "Rotates 64-<a href=\"../../armv8-a/bit/\">bit</a> integers left.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vprorq",
      "architecture": "x86",
      "full_name": "Rotate Right Quadword",
      "summary": "Rotates 64-bit integers right.",
      "syntax": "VPRORQ zmm1 {k1}, zmm2, imm8",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "66 0F 72 /0",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "ZMM"
        },
        {
          "name": "src",
          "desc": "ZMM"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vprorq",
      "rel_url": "x86/vprorq/",
      "linked_summary": "Rotates 64-<a href=\"../../armv8-a/bit/\">bit</a> integers right.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmovswb",
      "architecture": "x86",
      "full_name": "Truncate Signed Word to Byte",
      "summary": "Down-converts 16-bit integers to 8-bit signed saturate.",
      "syntax": "VPMOVSWB xmm1/m128 {k1}, zmm2",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "F3 0F 38 20",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "ZMM"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vpmovswb",
      "rel_url": "x86/vpmovswb/",
      "linked_summary": "Down-converts 16-<a href=\"../../armv8-a/bit/\">bit</a> integers to 8-<a href=\"../../armv8-a/bit/\">bit</a> signed saturate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmovsqb",
      "architecture": "x86",
      "full_name": "Truncate Signed Quadword to Byte",
      "summary": "Down-converts 64-bit integers to 8-bit signed saturate.",
      "syntax": "VPMOVSQB xmm1/m128 {k1}, zmm2",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "F3 0F 38 22",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "ZMM"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vpmovsqb",
      "rel_url": "x86/vpmovsqb/",
      "linked_summary": "Down-converts 64-<a href=\"../../armv8-a/bit/\">bit</a> integers to 8-<a href=\"../../armv8-a/bit/\">bit</a> signed saturate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmovuswb",
      "architecture": "x86",
      "full_name": "Truncate Unsigned Word to Byte",
      "summary": "Down-converts 16-bit integers to 8-bit unsigned saturate.",
      "syntax": "VPMOVUSWB xmm1/m128 {k1}, zmm2",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "F3 0F 38 10",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "ZMM"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vpmovuswb",
      "rel_url": "x86/vpmovuswb/",
      "linked_summary": "Down-converts 16-<a href=\"../../armv8-a/bit/\">bit</a> integers to 8-<a href=\"../../armv8-a/bit/\">bit</a> unsigned saturate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vpmovusqb",
      "architecture": "x86",
      "full_name": "Truncate Unsigned Quadword to Byte",
      "summary": "Down-converts 64-bit integers to 8-bit unsigned saturate.",
      "syntax": "VPMOVUSQB xmm1/m128 {k1}, zmm2",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "F3 0F 38 12",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "ZMM"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vpmovusqb",
      "rel_url": "x86/vpmovusqb/",
      "linked_summary": "Down-converts 64-<a href=\"../../armv8-a/bit/\">bit</a> integers to 8-<a href=\"../../armv8-a/bit/\">bit</a> unsigned saturate.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kaddw",
      "architecture": "x86",
      "full_name": "Add Masks Word",
      "summary": "Adds two 16-bit mask registers.",
      "syntax": "KADDW k1, k2, k3",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 4A",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "k-reg"
        },
        {
          "name": "src1",
          "desc": "k-reg"
        },
        {
          "name": "src2",
          "desc": "k-reg"
        }
      ],
      "extension": "AVX-512DQ",
      "slug": "kaddw",
      "rel_url": "x86/kaddw/",
      "linked_summary": "Adds two 16-<a href=\"../../armv8-a/bit/\">bit</a> mask registers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kaddb",
      "architecture": "x86",
      "full_name": "Add Masks Byte",
      "summary": "Adds two 8-bit mask registers.",
      "syntax": "KADDB k1, k2, k3",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 4A",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "k-reg"
        },
        {
          "name": "src1",
          "desc": "k-reg"
        },
        {
          "name": "src2",
          "desc": "k-reg"
        }
      ],
      "extension": "AVX-512DQ",
      "slug": "kaddb",
      "rel_url": "x86/kaddb/",
      "linked_summary": "Adds two 8-<a href=\"../../armv8-a/bit/\">bit</a> mask registers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "kunpckbw",
      "architecture": "x86",
      "full_name": "Unpack and Interleave Masks Byte to Word",
      "summary": "Interleaves 8-bit masks into 16-bit mask.",
      "syntax": "KUNPCKBW k1, k2, k3",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "0F 4B",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "k-reg"
        },
        {
          "name": "src1",
          "desc": "k-reg"
        },
        {
          "name": "src2",
          "desc": "k-reg"
        }
      ],
      "extension": "AVX-512",
      "slug": "kunpckbw",
      "rel_url": "x86/kunpckbw/",
      "linked_summary": "Interleaves 8-<a href=\"../../armv8-a/bit/\">bit</a> masks into 16-<a href=\"../../armv8-a/bit/\">bit</a> mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vaddss",
      "architecture": "x86",
      "full_name": "Add Scalar Single-Precision (EVEX)",
      "summary": "Adds scalar single precision (EVEX encoded with masking).",
      "syntax": "VADDSS xmm1 {k1}, xmm2, xmm3/m32",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "58",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src1",
          "desc": "XMM"
        },
        {
          "name": "src2",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vaddss",
      "rel_url": "x86/vaddss/",
      "linked_summary": "Adds scalar single precision (EVEX encoded with masking).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmulss",
      "architecture": "x86",
      "full_name": "Multiply Scalar Single-Precision (EVEX)",
      "summary": "Multiplies scalar single precision (EVEX encoded with masking).",
      "syntax": "VMULSS xmm1 {k1}, xmm2, xmm3/m32",
      "encoding": {
        "format": "EVEX",
        "hex_opcode": "59",
        "length": "6+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src1",
          "desc": "XMM"
        },
        {
          "name": "src2",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "AVX-512F",
      "slug": "vmulss",
      "rel_url": "x86/vmulss/",
      "linked_summary": "Multiplies scalar single precision (EVEX encoded with masking).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsaveopt",
      "architecture": "x86",
      "full_name": "Save Processor Extended States Optimized",
      "summary": "Saves state components (optimized for Modified state).",
      "syntax": "XSAVEOPT m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F AE /6",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Memory"
        }
      ],
      "extension": "XSAVEOPT",
      "slug": "xsaveopt",
      "rel_url": "x86/xsaveopt/",
      "linked_summary": "Saves state components (optimized for Modified state).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xsavec",
      "architecture": "x86",
      "full_name": "Save Processor Extended States with Compaction",
      "summary": "Saves state components using compaction.",
      "syntax": "XSAVEC m",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F C7 /4",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Memory"
        }
      ],
      "extension": "XSAVEC",
      "slug": "xsavec",
      "rel_url": "x86/xsavec/",
      "linked_summary": "Saves state components using compaction.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "vmfunc",
      "architecture": "x86",
      "full_name": "Virtual Machine Function",
      "summary": "Invoke VM function specified in EAX.",
      "syntax": "VMFUNC",
      "encoding": {
        "format": "VMX",
        "hex_opcode": "0F 01 D4",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "VMX",
      "slug": "vmfunc",
      "rel_url": "x86/vmfunc/",
      "linked_summary": "Invoke VM function specified <a href=\"../../x86/in/\">in</a> EAX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ud0",
      "architecture": "x86",
      "full_name": "Undefined Instruction 0",
      "summary": "Generates invalid opcode exception.",
      "syntax": "UD0",
      "encoding": {
        "format": "Legacy",
        "hex_opcode": "0F FF",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "Base",
      "slug": "ud0",
      "rel_url": "x86/ud0/",
      "linked_summary": "Generates invalid opcode exception.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "emms",
      "architecture": "x86",
      "full_name": "Empty MMX Technology State",
      "summary": "Clears the FPU tag word to allow FP instructions after MMX.",
      "syntax": "EMMS",
      "encoding": {
        "format": "MMX",
        "hex_opcode": "0x0F 77",
        "length": "2",
        "visual_parts": []
      },
      "operands": [],
      "extension": "MMX",
      "slug": "emms_1",
      "rel_url": "x86/emms_1/",
      "linked_summary": "Clears the FPU tag word to allow FP instructions after MMX.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movd",
      "architecture": "x86",
      "full_name": "Move Doubleword",
      "summary": "Moves 32 bits between GPR and XMM/MMX register.",
      "syntax": "MOVD mm/xmm, r32/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 6E",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM/MM"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "MMX/SSE2",
      "slug": "movd_1",
      "rel_url": "x86/movd_1/",
      "linked_summary": "Moves 32 bits between GPR <a href=\"../../armv8-a/and_6/\">and</a> XMM/MMX register.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movq",
      "architecture": "x86",
      "full_name": "Move Quadword",
      "summary": "Moves 64 bits between XMM registers or memory.",
      "syntax": "MOVQ xmm, xmm/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0xF3 0F 7E",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "movq_2",
      "rel_url": "x86/movq_2/",
      "linked_summary": "Moves 64 bits between XMM registers <a href=\"../../powerisa/or/\">or</a> memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movaps",
      "architecture": "x86",
      "full_name": "Move Aligned Packed Single-Precision",
      "summary": "Moves 128-bit packed float data (Must be 16-byte aligned).",
      "syntax": "MOVAPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 28",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "movaps_1",
      "rel_url": "x86/movaps_1/",
      "linked_summary": "Moves 128-<a href=\"../../armv8-a/bit/\">bit</a> packed float data (Must be 16-byte aligned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movups",
      "architecture": "x86",
      "full_name": "Move Unaligned Packed Single-Precision",
      "summary": "Moves 128-bit packed float data (Unaligned).",
      "syntax": "MOVUPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 10",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "movups_1",
      "rel_url": "x86/movups_1/",
      "linked_summary": "Moves 128-<a href=\"../../armv8-a/bit/\">bit</a> packed float data (Unaligned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movapd",
      "architecture": "x86",
      "full_name": "Move Aligned Packed Double-Precision",
      "summary": "Moves 128-bit packed double data (Must be 16-byte aligned).",
      "syntax": "MOVAPD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 28",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "movapd_1",
      "rel_url": "x86/movapd_1/",
      "linked_summary": "Moves 128-<a href=\"../../armv8-a/bit/\">bit</a> packed double data (Must be 16-byte aligned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movupd",
      "architecture": "x86",
      "full_name": "Move Unaligned Packed Double-Precision",
      "summary": "Moves 128-bit packed double data (Unaligned).",
      "syntax": "MOVUPD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 10",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "movupd_1",
      "rel_url": "x86/movupd_1/",
      "linked_summary": "Moves 128-<a href=\"../../armv8-a/bit/\">bit</a> packed double data (Unaligned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movdqa",
      "architecture": "x86",
      "full_name": "Move Aligned Packed Integer",
      "summary": "Moves 128-bit integer data (Aligned).",
      "syntax": "MOVDQA xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 6F",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "movdqa_1",
      "rel_url": "x86/movdqa_1/",
      "linked_summary": "Moves 128-<a href=\"../../armv8-a/bit/\">bit</a> integer data (Aligned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "movdqu",
      "architecture": "x86",
      "full_name": "Move Unaligned Packed Integer",
      "summary": "Moves 128-bit integer data (Unaligned).",
      "syntax": "MOVDQU xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0xF3 0F 6F",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "movdqu_1",
      "rel_url": "x86/movdqu_1/",
      "linked_summary": "Moves 128-<a href=\"../../armv8-a/bit/\">bit</a> integer data (Unaligned).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "addps",
      "architecture": "x86",
      "full_name": "Add Packed Single-Precision",
      "summary": "Adds four 32-bit floats.",
      "syntax": "ADDPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 58",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "addps_1",
      "rel_url": "x86/addps_1/",
      "linked_summary": "Adds four 32-<a href=\"../../armv8-a/bit/\">bit</a> floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "addpd",
      "architecture": "x86",
      "full_name": "Add Packed Double-Precision",
      "summary": "Adds two 64-bit doubles.",
      "syntax": "ADDPD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 58",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "addpd_1",
      "rel_url": "x86/addpd_1/",
      "linked_summary": "Adds two 64-<a href=\"../../armv8-a/bit/\">bit</a> doubles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "addss",
      "architecture": "x86",
      "full_name": "Add Scalar Single-Precision",
      "summary": "Adds the low 32-bit float.",
      "syntax": "ADDSS xmm, xmm/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0xF3 0F 58",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "addss_2",
      "rel_url": "x86/addss_2/",
      "linked_summary": "Adds the low 32-<a href=\"../../armv8-a/bit/\">bit</a> float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "addsd",
      "architecture": "x86",
      "full_name": "Add Scalar Double-Precision",
      "summary": "Adds the low 64-bit double.",
      "syntax": "ADDSD xmm, xmm/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0xF2 0F 58",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "addsd_2",
      "rel_url": "x86/addsd_2/",
      "linked_summary": "Adds the low 64-<a href=\"../../armv8-a/bit/\">bit</a> double.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "subps",
      "architecture": "x86",
      "full_name": "Subtract Packed Single-Precision",
      "summary": "Subtracts four 32-bit floats.",
      "syntax": "SUBPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 5C",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "subps_1",
      "rel_url": "x86/subps_1/",
      "linked_summary": "Subtracts four 32-<a href=\"../../armv8-a/bit/\">bit</a> floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "subpd",
      "architecture": "x86",
      "full_name": "Subtract Packed Double-Precision",
      "summary": "Subtracts two 64-bit doubles.",
      "syntax": "SUBPD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 5C",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "subpd_1",
      "rel_url": "x86/subpd_1/",
      "linked_summary": "Subtracts two 64-<a href=\"../../armv8-a/bit/\">bit</a> doubles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mulps",
      "architecture": "x86",
      "full_name": "Multiply Packed Single-Precision",
      "summary": "Multiplies four 32-bit floats.",
      "syntax": "MULPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 59",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "mulps_1",
      "rel_url": "x86/mulps_1/",
      "linked_summary": "Multiplies four 32-<a href=\"../../armv8-a/bit/\">bit</a> floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mulpd",
      "architecture": "x86",
      "full_name": "Multiply Packed Double-Precision",
      "summary": "Multiplies two 64-bit doubles.",
      "syntax": "MULPD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 59",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "mulpd_1",
      "rel_url": "x86/mulpd_1/",
      "linked_summary": "Multiplies two 64-<a href=\"../../armv8-a/bit/\">bit</a> doubles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "divps",
      "architecture": "x86",
      "full_name": "Divide Packed Single-Precision",
      "summary": "Divides four 32-bit floats.",
      "syntax": "DIVPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 5E",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "divps_1",
      "rel_url": "x86/divps_1/",
      "linked_summary": "Divides four 32-<a href=\"../../armv8-a/bit/\">bit</a> floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "divpd",
      "architecture": "x86",
      "full_name": "Divide Packed Double-Precision",
      "summary": "Divides two 64-bit doubles.",
      "syntax": "DIVPD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 5E",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "divpd_1",
      "rel_url": "x86/divpd_1/",
      "linked_summary": "Divides two 64-<a href=\"../../armv8-a/bit/\">bit</a> doubles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sqrtps",
      "architecture": "x86",
      "full_name": "Square Root Packed Single-Precision",
      "summary": "Computes square root of four 32-bit floats.",
      "syntax": "SQRTPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 51",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "sqrtps_1",
      "rel_url": "x86/sqrtps_1/",
      "linked_summary": "Computes square root of four 32-<a href=\"../../armv8-a/bit/\">bit</a> floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sqrtpd",
      "architecture": "x86",
      "full_name": "Square Root Packed Double-Precision",
      "summary": "Computes square root of two 64-bit doubles.",
      "syntax": "SQRTPD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 51",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "sqrtpd_1",
      "rel_url": "x86/sqrtpd_1/",
      "linked_summary": "Computes square root of two 64-<a href=\"../../armv8-a/bit/\">bit</a> doubles.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rcpps",
      "architecture": "x86",
      "full_name": "Reciprocal Packed Single-Precision",
      "summary": "Approximate reciprocal (1/x) of four 32-bit floats.",
      "syntax": "RCPPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 53",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "rcpps_1",
      "rel_url": "x86/rcpps_1/",
      "linked_summary": "Approximate reciprocal (1/x) of four 32-<a href=\"../../armv8-a/bit/\">bit</a> floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "rsqrtps",
      "architecture": "x86",
      "full_name": "Reciprocal Square Root Packed Single-Precision",
      "summary": "Approximate reciprocal sqrt (1/sqrt(x)) of four 32-bit floats.",
      "syntax": "RSQRTPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 52",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "rsqrtps_1",
      "rel_url": "x86/rsqrtps_1/",
      "linked_summary": "Approximate reciprocal sqrt (1/sqrt(x)) of four 32-<a href=\"../../armv8-a/bit/\">bit</a> floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "maxps",
      "architecture": "x86",
      "full_name": "Maximum Packed Single-Precision",
      "summary": "Returns maximum of packed floats.",
      "syntax": "MAXPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 5F",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "maxps_1",
      "rel_url": "x86/maxps_1/",
      "linked_summary": "Returns maximum of packed floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "minps",
      "architecture": "x86",
      "full_name": "Minimum Packed Single-Precision",
      "summary": "Returns minimum of packed floats.",
      "syntax": "MINPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 5D",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "minps_1",
      "rel_url": "x86/minps_1/",
      "linked_summary": "Returns minimum of packed floats.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "andps",
      "architecture": "x86",
      "full_name": "Bitwise Logical AND Packed Single-Precision",
      "summary": "Bitwise AND of 128 bits.",
      "syntax": "ANDPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 54",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "andps_1",
      "rel_url": "x86/andps_1/",
      "linked_summary": "Bitwise <a href=\"../../armv9-a/and_1/\">AND</a> of 128 bits.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "andpd",
      "architecture": "x86",
      "full_name": "Bitwise Logical AND Packed Double-Precision",
      "summary": "Bitwise AND of 128 bits.",
      "syntax": "ANDPD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 54",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "andpd_1",
      "rel_url": "x86/andpd_1/",
      "linked_summary": "Bitwise <a href=\"../../armv9-a/and_1/\">AND</a> of 128 bits.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "orps",
      "architecture": "x86",
      "full_name": "Bitwise Logical OR Packed Single-Precision",
      "summary": "Bitwise OR of 128 bits.",
      "syntax": "ORPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 56",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "orps_1",
      "rel_url": "x86/orps_1/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/or/\">OR</a> of 128 bits.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "xorps",
      "architecture": "x86",
      "full_name": "Bitwise Logical XOR Packed Single-Precision",
      "summary": "Bitwise XOR of 128 bits (Used to clear registers).",
      "syntax": "XORPS xmm, xmm/m128",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 57",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "xorps_1",
      "rel_url": "x86/xorps_1/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/xor/\">XOR</a> of 128 bits (Used to clear registers).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "paddb",
      "architecture": "x86",
      "full_name": "Packed Add Bytes",
      "summary": "Adds 16 bytes (Wraparound).",
      "syntax": "PADDB xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F FC",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "paddb_1",
      "rel_url": "x86/paddb_1/",
      "linked_summary": "Adds 16 bytes (Wraparound).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "paddw",
      "architecture": "x86",
      "full_name": "Packed Add Words",
      "summary": "Adds 8 words (Wraparound).",
      "syntax": "PADDW xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F FD",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "paddw_1",
      "rel_url": "x86/paddw_1/",
      "linked_summary": "Adds 8 words (Wraparound).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "paddd",
      "architecture": "x86",
      "full_name": "Packed Add Doublewords",
      "summary": "Adds 4 doublewords (Wraparound).",
      "syntax": "PADDD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F FE",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "paddd_1",
      "rel_url": "x86/paddd_1/",
      "linked_summary": "Adds 4 doublewords (Wraparound).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "paddq",
      "architecture": "x86",
      "full_name": "Packed Add Quadwords",
      "summary": "Adds 2 quadwords (Wraparound).",
      "syntax": "PADDQ xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F D4",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "paddq_1",
      "rel_url": "x86/paddq_1/",
      "linked_summary": "Adds 2 quadwords (Wraparound).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "paddsb",
      "architecture": "x86",
      "full_name": "Packed Add Bytes Signed Saturate",
      "summary": "Adds 16 signed bytes with saturation.",
      "syntax": "PADDSB xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F EC",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "paddsb_2",
      "rel_url": "x86/paddsb_2/",
      "linked_summary": "Adds 16 signed bytes with saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "paddusb",
      "architecture": "x86",
      "full_name": "Packed Add Bytes Unsigned Saturate",
      "summary": "Adds 16 unsigned bytes with saturation.",
      "syntax": "PADDUSB xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F DC",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "paddusb_2",
      "rel_url": "x86/paddusb_2/",
      "linked_summary": "Adds 16 unsigned bytes with saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psubb",
      "architecture": "x86",
      "full_name": "Packed Subtract Bytes",
      "summary": "Subtracts 16 bytes.",
      "syntax": "PSUBB xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F F8",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "psubb_1",
      "rel_url": "x86/psubb_1/",
      "linked_summary": "Subtracts 16 bytes.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psubw",
      "architecture": "x86",
      "full_name": "Packed Subtract Words",
      "summary": "Subtracts 8 words.",
      "syntax": "PSUBW xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F F9",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "psubw_1",
      "rel_url": "x86/psubw_1/",
      "linked_summary": "Subtracts 8 words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psubd",
      "architecture": "x86",
      "full_name": "Packed Subtract Doublewords",
      "summary": "Subtracts 4 doublewords.",
      "syntax": "PSUBD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F FA",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "psubd_1",
      "rel_url": "x86/psubd_1/",
      "linked_summary": "Subtracts 4 doublewords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pand",
      "architecture": "x86",
      "full_name": "Packed Logical AND",
      "summary": "Bitwise AND of 128-bit integers.",
      "syntax": "PAND xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F DB",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "pand_2",
      "rel_url": "x86/pand_2/",
      "linked_summary": "Bitwise <a href=\"../../armv9-a/and_1/\">AND</a> of 128-<a href=\"../../armv8-a/bit/\">bit</a> integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "por",
      "architecture": "x86",
      "full_name": "Packed Logical OR",
      "summary": "Bitwise OR of 128-bit integers.",
      "syntax": "POR xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F EB",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "por_2",
      "rel_url": "x86/por_2/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/or/\">OR</a> of 128-<a href=\"../../armv8-a/bit/\">bit</a> integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pxor",
      "architecture": "x86",
      "full_name": "Packed Logical Exclusive OR",
      "summary": "Bitwise XOR of 128-bit integers.",
      "syntax": "PXOR xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F EF",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "pxor_2",
      "rel_url": "x86/pxor_2/",
      "linked_summary": "Bitwise <a href=\"../../risc-v/xor/\">XOR</a> of 128-<a href=\"../../armv8-a/bit/\">bit</a> integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psllw",
      "architecture": "x86",
      "full_name": "Packed Shift Left Logical Word",
      "summary": "Shifts words left.",
      "syntax": "PSLLW xmm, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 71 /6",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "SSE2",
      "slug": "psllw_2",
      "rel_url": "x86/psllw_2/",
      "linked_summary": "Shifts words left.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pslld",
      "architecture": "x86",
      "full_name": "Packed Shift Left Logical Doubleword",
      "summary": "Shifts doublewords left.",
      "syntax": "PSLLD xmm, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 72 /6",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "SSE2",
      "slug": "pslld_2",
      "rel_url": "x86/pslld_2/",
      "linked_summary": "Shifts doublewords left.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psrlw",
      "architecture": "x86",
      "full_name": "Packed Shift Right Logical Word",
      "summary": "Shifts words right logical.",
      "syntax": "PSRLW xmm, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 71 /2",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "SSE2",
      "slug": "psrlw_2",
      "rel_url": "x86/psrlw_2/",
      "linked_summary": "Shifts words right logical.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psrld",
      "architecture": "x86",
      "full_name": "Packed Shift Right Logical Doubleword",
      "summary": "Shifts doublewords right logical.",
      "syntax": "PSRLD xmm, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 72 /2",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "SSE2",
      "slug": "psrld_2",
      "rel_url": "x86/psrld_2/",
      "linked_summary": "Shifts doublewords right logical.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psraw",
      "architecture": "x86",
      "full_name": "Packed Shift Right Arithmetic Word",
      "summary": "Shifts words right arithmetic (sign bit).",
      "syntax": "PSRAW xmm, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 71 /4",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "SSE2",
      "slug": "psraw_2",
      "rel_url": "x86/psraw_2/",
      "linked_summary": "Shifts words right arithmetic (sign <a href=\"../../armv8-a/bit/\">bit</a>).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "psrad",
      "architecture": "x86",
      "full_name": "Packed Shift Right Arithmetic Doubleword",
      "summary": "Shifts doublewords right arithmetic.",
      "syntax": "PSRAD xmm, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 72 /4",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "count",
          "desc": "Imm"
        }
      ],
      "extension": "SSE2",
      "slug": "psrad_2",
      "rel_url": "x86/psrad_2/",
      "linked_summary": "Shifts doublewords right arithmetic.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pcmpeqb",
      "architecture": "x86",
      "full_name": "Packed Compare Equal Byte",
      "summary": "Compares bytes for equality (Result mask 0xFF or 0x00).",
      "syntax": "PCMPEQB xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 74",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "pcmpeqb_2",
      "rel_url": "x86/pcmpeqb_2/",
      "linked_summary": "Compares bytes for equality (Result mask 0xFF <a href=\"../../powerisa/or/\">or</a> 0x00).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pcmpeqw",
      "architecture": "x86",
      "full_name": "Packed Compare Equal Word",
      "summary": "Compares words for equality.",
      "syntax": "PCMPEQW xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 75",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "pcmpeqw_2",
      "rel_url": "x86/pcmpeqw_2/",
      "linked_summary": "Compares words for equality.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pcmpeqd",
      "architecture": "x86",
      "full_name": "Packed Compare Equal Doubleword",
      "summary": "Compares doublewords for equality.",
      "syntax": "PCMPEQD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 76",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "pcmpeqd_2",
      "rel_url": "x86/pcmpeqd_2/",
      "linked_summary": "Compares doublewords for equality.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "shufps",
      "architecture": "x86",
      "full_name": "Shuffle Packed Single-Precision",
      "summary": "Shuffles 32-bit floats based on immediate mask.",
      "syntax": "SHUFPS xmm, xmm/m128, imm8",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F C6",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        },
        {
          "name": "mask",
          "desc": "Imm"
        }
      ],
      "extension": "SSE",
      "slug": "shufps_2",
      "rel_url": "x86/shufps_2/",
      "linked_summary": "Shuffles 32-<a href=\"../../armv8-a/bit/\">bit</a> floats based on immediate mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "shufpd",
      "architecture": "x86",
      "full_name": "Shuffle Packed Double-Precision",
      "summary": "Shuffles 64-bit doubles based on immediate mask.",
      "syntax": "SHUFPD xmm, xmm/m128, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F C6",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        },
        {
          "name": "mask",
          "desc": "Imm"
        }
      ],
      "extension": "SSE2",
      "slug": "shufpd_2",
      "rel_url": "x86/shufpd_2/",
      "linked_summary": "Shuffles 64-<a href=\"../../armv8-a/bit/\">bit</a> doubles based on immediate mask.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pshufd",
      "architecture": "x86",
      "full_name": "Packed Shuffle Doubleword",
      "summary": "Shuffles 32-bit integers.",
      "syntax": "PSHUFD xmm, xmm/m128, imm8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 70",
        "length": "5+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        },
        {
          "name": "mask",
          "desc": "Imm"
        }
      ],
      "extension": "SSE2",
      "slug": "pshufd_1",
      "rel_url": "x86/pshufd_1/",
      "linked_summary": "Shuffles 32-<a href=\"../../armv8-a/bit/\">bit</a> integers.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvtsi2ss",
      "architecture": "x86",
      "full_name": "Convert Doubleword Integer to Scalar Single-Precision",
      "summary": "Converts 32-bit int to float.",
      "syntax": "CVTSI2SS xmm, r/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0xF3 0F 2A",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "cvtsi2ss_1",
      "rel_url": "x86/cvtsi2ss_1/",
      "linked_summary": "Converts 32-<a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/int_1/\">int</a> to float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvtsi2sd",
      "architecture": "x86",
      "full_name": "Convert Doubleword Integer to Scalar Double-Precision",
      "summary": "Converts 32-bit int to double.",
      "syntax": "CVTSI2SD xmm, r/m32",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0xF2 0F 2A",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "Reg/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "cvtsi2sd_1",
      "rel_url": "x86/cvtsi2sd_1/",
      "linked_summary": "Converts 32-<a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/int_1/\">int</a> to double.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvttss2si",
      "architecture": "x86",
      "full_name": "Convert with Truncation Scalar Single to Integer",
      "summary": "Converts float to 32-bit int (Truncate).",
      "syntax": "CVTTSS2SI r32, xmm/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0xF3 0F 2C",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "cvttss2si_1",
      "rel_url": "x86/cvttss2si_1/",
      "linked_summary": "Converts float to 32-<a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/int_1/\">int</a> (Truncate).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvttsd2si",
      "architecture": "x86",
      "full_name": "Convert with Truncation Scalar Double to Integer",
      "summary": "Converts double to 32-bit int (Truncate).",
      "syntax": "CVTTSD2SI r32, xmm/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0xF2 0F 2C",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "cvttsd2si_1",
      "rel_url": "x86/cvttsd2si_1/",
      "linked_summary": "Converts double to 32-<a href=\"../../armv8-a/bit/\">bit</a> <a href=\"../../x86/int_1/\">int</a> (Truncate).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvtss2sd",
      "architecture": "x86",
      "full_name": "Convert Scalar Single to Scalar Double",
      "summary": "Converts float to double.",
      "syntax": "CVTSS2SD xmm, xmm/m32",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0xF3 0F 5A",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "cvtss2sd_1",
      "rel_url": "x86/cvtss2sd_1/",
      "linked_summary": "Converts float to double.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "cvtsd2ss",
      "architecture": "x86",
      "full_name": "Convert Scalar Double to Scalar Single",
      "summary": "Converts double to float.",
      "syntax": "CVTSD2SS xmm, xmm/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0xF2 0F 5A",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "cvtsd2ss_1",
      "rel_url": "x86/cvtsd2ss_1/",
      "linked_summary": "Converts double to float.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ucomiss",
      "architecture": "x86",
      "full_name": "Unordered Compare Scalar Single-Precision",
      "summary": "Compares low float and sets EFLAGS.",
      "syntax": "UCOMISS xmm, xmm/m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 2E",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src1",
          "desc": "XMM"
        },
        {
          "name": "src2",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE",
      "slug": "ucomiss_1",
      "rel_url": "x86/ucomiss_1/",
      "linked_summary": "Compares low float <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../x86/sets/\">sets</a> EFLAGS.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ucomisd",
      "architecture": "x86",
      "full_name": "Unordered Compare Scalar Double-Precision",
      "summary": "Compares low double and sets EFLAGS.",
      "syntax": "UCOMISD xmm, xmm/m64",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 2E",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src1",
          "desc": "XMM"
        },
        {
          "name": "src2",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "ucomisd_1",
      "rel_url": "x86/ucomisd_1/",
      "linked_summary": "Compares low double <a href=\"../../armv8-a/and_6/\">and</a> <a href=\"../../x86/sets/\">sets</a> EFLAGS.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "punpcklbw",
      "architecture": "x86",
      "full_name": "Unpack Low Data Bytes",
      "summary": "Interleaves low bytes from two sources.",
      "syntax": "PUNPCKLBW xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 60",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "punpcklbw_1",
      "rel_url": "x86/punpcklbw_1/",
      "linked_summary": "Interleaves low bytes from two sources.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "punpcklwd",
      "architecture": "x86",
      "full_name": "Unpack Low Data Words",
      "summary": "Interleaves low words.",
      "syntax": "PUNPCKLWD xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 61",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "punpcklwd_1",
      "rel_url": "x86/punpcklwd_1/",
      "linked_summary": "Interleaves low words.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "punpckldq",
      "architecture": "x86",
      "full_name": "Unpack Low Data Doublewords",
      "summary": "Interleaves low doublewords.",
      "syntax": "PUNPCKLDQ xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 62",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "punpckldq_1",
      "rel_url": "x86/punpckldq_1/",
      "linked_summary": "Interleaves low doublewords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "punpcklqdq",
      "architecture": "x86",
      "full_name": "Unpack Low Data Quadwords",
      "summary": "Interleaves low quadwords.",
      "syntax": "PUNPCKLQDQ xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 6C",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "punpcklqdq_1",
      "rel_url": "x86/punpcklqdq_1/",
      "linked_summary": "Interleaves low quadwords.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "packsswb",
      "architecture": "x86",
      "full_name": "Pack with Signed Saturation Word to Byte",
      "summary": "Converts words to bytes with saturation.",
      "syntax": "PACKSSWB xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 63",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "packsswb_1",
      "rel_url": "x86/packsswb_1/",
      "linked_summary": "Converts words to bytes with saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "packssdw",
      "architecture": "x86",
      "full_name": "Pack with Signed Saturation Doubleword to Word",
      "summary": "Converts doublewords to words with saturation.",
      "syntax": "PACKSSDW xmm, xmm/m128",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F 6B",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "XMM"
        },
        {
          "name": "src",
          "desc": "XMM/Mem"
        }
      ],
      "extension": "SSE2",
      "slug": "packssdw_1",
      "rel_url": "x86/packssdw_1/",
      "linked_summary": "Converts doublewords to words with saturation.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "pmovmskb",
      "architecture": "x86",
      "full_name": "Move Byte Mask",
      "summary": "Creates a mask from the MSB of each byte in XMM.",
      "syntax": "PMOVMSKB r32, xmm",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F D7",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Reg"
        },
        {
          "name": "src",
          "desc": "XMM"
        }
      ],
      "extension": "SSE2",
      "slug": "pmovmskb_1",
      "rel_url": "x86/pmovmskb_1/",
      "linked_summary": "Creates a mask from the <a href=\"../../armv9-a/msb/\">MSB</a> of each byte <a href=\"../../x86/in/\">in</a> XMM.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "maskmovdqu",
      "architecture": "x86",
      "full_name": "Store Selected Bytes of Double Quadword",
      "summary": "Non-temporal store of selected bytes (masked).",
      "syntax": "MASKMOVDQU xmm, xmm",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x66 0F F7",
        "length": "4+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "XMM"
        },
        {
          "name": "mask",
          "desc": "XMM"
        }
      ],
      "extension": "SSE2",
      "slug": "maskmovdqu_1",
      "rel_url": "x86/maskmovdqu_1/",
      "linked_summary": "Non-temporal store of selected bytes (masked).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "ldmxcsr",
      "architecture": "x86",
      "full_name": "Load MXCSR Register",
      "summary": "Loads the MXCSR control/status register from memory.",
      "syntax": "LDMXCSR m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F AE /2",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "src",
          "desc": "Memory"
        }
      ],
      "extension": "SSE",
      "slug": "ldmxcsr_1",
      "rel_url": "x86/ldmxcsr_1/",
      "linked_summary": "Loads the MXCSR control/status register from memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "stmxcsr",
      "architecture": "x86",
      "full_name": "Store MXCSR Register",
      "summary": "Stores the MXCSR register to memory.",
      "syntax": "STMXCSR m32",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F AE /3",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "dest",
          "desc": "Memory"
        }
      ],
      "extension": "SSE",
      "slug": "stmxcsr_1",
      "rel_url": "x86/stmxcsr_1/",
      "linked_summary": "Stores the MXCSR register to memory.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "prefetcht0",
      "architecture": "x86",
      "full_name": "Prefetch Data into all Cache Levels",
      "summary": "Prefetches data to L1 cache.",
      "syntax": "PREFETCHT0 m8",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 18 /1",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "mem",
          "desc": "Address"
        }
      ],
      "extension": "SSE",
      "slug": "prefetcht0_1",
      "rel_url": "x86/prefetcht0_1/",
      "linked_summary": "Prefetches data to L1 cache.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "prefetchnta",
      "architecture": "x86",
      "full_name": "Prefetch Data using Non-Temporal Access",
      "summary": "Prefetches data to non-temporal cache structure (minimize pollution).",
      "syntax": "PREFETCHNTA m8",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F 18 /0",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "mem",
          "desc": "Address"
        }
      ],
      "extension": "SSE",
      "slug": "prefetchnta_1",
      "rel_url": "x86/prefetchnta_1/",
      "linked_summary": "Prefetches data to non-temporal cache structure (minimize pollution).",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "sfence",
      "architecture": "x86",
      "full_name": "Store Fence",
      "summary": "Serializes all store operations.",
      "syntax": "SFENCE",
      "encoding": {
        "format": "SSE",
        "hex_opcode": "0x0F AE F8",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "SSE",
      "slug": "sfence_1",
      "rel_url": "x86/sfence_1/",
      "linked_summary": "Serializes all store operations.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "lfence",
      "architecture": "x86",
      "full_name": "Load Fence",
      "summary": "Serializes all load operations.",
      "syntax": "LFENCE",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x0F AE E8",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "SSE2",
      "slug": "lfence_1",
      "rel_url": "x86/lfence_1/",
      "linked_summary": "Serializes all load operations.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "mfence",
      "architecture": "x86",
      "full_name": "Memory Fence",
      "summary": "Serializes all load and store operations.",
      "syntax": "MFENCE",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x0F AE F0",
        "length": "3",
        "visual_parts": []
      },
      "operands": [],
      "extension": "SSE2",
      "slug": "mfence_1",
      "rel_url": "x86/mfence_1/",
      "linked_summary": "Serializes all load <a href=\"../../armv8-a/and_6/\">and</a> store operations.",
      "linked_pseudocode": ""
    },
    {
      "mnemonic": "clflush",
      "architecture": "x86",
      "full_name": "Flush Cache Line",
      "summary": "Flushes cache line containing address.",
      "syntax": "CLFLUSH m8",
      "encoding": {
        "format": "SSE2",
        "hex_opcode": "0x0F AE /7",
        "length": "3+",
        "visual_parts": []
      },
      "operands": [
        {
          "name": "mem",
          "desc": "Address"
        }
      ],
      "extension": "SSE2",
      "slug": "clflush_1",
      "rel_url": "x86/clflush_1/",
      "linked_summary": "Flushes cache line containing address.",
      "linked_pseudocode": ""
    }
  ]
}
