[{"label": "CSRRC (RISC-V)", "url": "risc-v/csrrc/", "summary": "Reads the old value of the CSR, then clears bits in the CSR based on the mask in rs1.", "arch": "RISC-V"}, {"label": "CSRRWI (RISC-V)", "url": "risc-v/csrrwi/", "summary": "Updates a CSR using a 5-bit unsigned immediate (zimm) instead of a register.", "arch": "RISC-V"}, {"label": "CSRRSI (RISC-V)", "url": "risc-v/csrrsi/", "summary": "Sets bits in a CSR using a 5-bit unsigned immediate.", "arch": "RISC-V"}, {"label": "CSRRCI (RISC-V)", "url": "risc-v/csrrci/", "summary": "Clears bits in a CSR using a 5-bit unsigned immediate.", "arch": "RISC-V"}, {"label": "FLD (RISC-V)", "url": "risc-v/fld/", "summary": "Loads a 64-bit double-precision floating-point value from memory.", "arch": "RISC-V"}, {"label": "FSD (RISC-V)", "url": "risc-v/fsd/", "summary": "Stores a 64-bit double-precision floating-point value to memory.", "arch": "RISC-V"}, {"label": "FADD.D (RISC-V)", "url": "risc-v/fadd_d/", "summary": "Performs double-precision floating-point addition.", "arch": "RISC-V"}, {"label": "FSUB.D (RISC-V)", "url": "risc-v/fsub_d/", "summary": "Performs double-precision floating-point subtraction.", "arch": "RISC-V"}, {"label": "FMUL.D (RISC-V)", "url": "risc-v/fmul_d/", "summary": "Performs double-precision floating-point multiplication.", "arch": "RISC-V"}, {"label": "FDIV.D (RISC-V)", "url": "risc-v/fdiv_d/", "summary": "Performs double-precision floating-point division.", "arch": "RISC-V"}, {"label": "AMOOR.W (RISC-V)", "url": "risc-v/amoor_w/", "summary": "Atomically performs bitwise OR on a word in memory.", "arch": "RISC-V"}, {"label": "AMOXOR.W (RISC-V)", "url": "risc-v/amoxor_w/", "summary": "Atomically performs bitwise XOR on a word in memory.", "arch": "RISC-V"}, {"label": "AMOMAX.W (RISC-V)", "url": "risc-v/amomax_w/", "summary": "Atomically updates memory with the maximum of the memory value and register value (Signed).", "arch": "RISC-V"}, {"label": "AMOMIN.W (RISC-V)", "url": "risc-v/amomin_w/", "summary": "Atomically updates memory with the minimum of the memory value and register value (Signed).", "arch": "RISC-V"}, {"label": "URET (RISC-V)", "url": "risc-v/uret/", "summary": "Returns from a user-mode trap handler (requires N extension).", "arch": "RISC-V"}, {"label": "AMOADD.D (RISC-V)", "url": "risc-v/amoadd_d/", "summary": "Atomically adds a value to a 64-bit doubleword in memory.", "arch": "RISC-V"}, {"label": "AMOSWAP.D (RISC-V)", "url": "risc-v/amoswap_d/", "summary": "Atomically swaps a 64-bit value in memory with a register.", "arch": "RISC-V"}, {"label": "AMOAND.D (RISC-V)", "url": "risc-v/amoand_d/", "summary": "Atomically performs bitwise AND on a 64-bit doubleword in memory.", "arch": "RISC-V"}, {"label": "AMOOR.D (RISC-V)", "url": "risc-v/amoor_d/", "summary": "Atomically performs bitwise OR on a 64-bit doubleword in memory.", "arch": "RISC-V"}, {"label": "AMOXOR.D (RISC-V)", "url": "risc-v/amoxor_d/", "summary": "Atomically performs bitwise XOR on a 64-bit doubleword in memory.", "arch": "RISC-V"}, {"label": "AMOMAX.D (RISC-V)", "url": "risc-v/amomax_d/", "summary": "Atomically updates memory with the maximum of the memory value and register value (64-bit Signed).", "arch": "RISC-V"}, {"label": "AMOMIN.D (RISC-V)", "url": "risc-v/amomin_d/", "summary": "Atomically updates memory with the minimum of the memory value and register value (64-bit Signed).", "arch": "RISC-V"}, {"label": "SC.D (RISC-V)", "url": "risc-v/sc_d/", "summary": "Conditionally stores a 64-bit value to memory if the reservation is valid.", "arch": "RISC-V"}, {"label": "FMADD.S (RISC-V)", "url": "risc-v/fmadd_s/", "summary": "Computes (rs1 * rs2) + rs3 with a single rounding.", "arch": "RISC-V"}, {"label": "FMADD.D (RISC-V)", "url": "risc-v/fmadd_d/", "summary": "Computes (rs1 * rs2) + rs3 with a single rounding (64-bit).", "arch": "RISC-V"}, {"label": "CSRR (RISC-V)", "url": "risc-v/csrr/", "summary": "Reads the value of a CSR into a register.", "arch": "RISC-V"}, {"label": "CSRW (RISC-V)", "url": "risc-v/csrw/", "summary": "Writes a register value to a CSR.", "arch": "RISC-V"}, {"label": "CSRS (RISC-V)", "url": "risc-v/csrs/", "summary": "Sets bits in a CSR (bitwise OR).", "arch": "RISC-V"}, {"label": "CSRC (RISC-V)", "url": "risc-v/csrc/", "summary": "Clears bits in a CSR (bitwise AND NOT).", "arch": "RISC-V"}, {"label": "FCVT.LU.D (RISC-V)", "url": "risc-v/fcvt_lu_d/", "summary": "Converts a double-precision float to a 64-bit unsigned integer.", "arch": "RISC-V"}, {"label": "FLH (RISC-V)", "url": "risc-v/flh/", "summary": "Loads a 16-bit half-precision float from memory.", "arch": "RISC-V"}, {"label": "FSH (RISC-V)", "url": "risc-v/fsh/", "summary": "Stores a 16-bit half-precision float to memory.", "arch": "RISC-V"}, {"label": "FADD.H (RISC-V)", "url": "risc-v/fadd_h/", "summary": "Performs 16-bit floating-point addition.", "arch": "RISC-V"}, {"label": "FCVT.S.H (RISC-V)", "url": "risc-v/fcvt_s_h/", "summary": "Converts a 16-bit half-precision float to a 32-bit single-precision float.", "arch": "RISC-V"}, {"label": "FCVT.H.S (RISC-V)", "url": "risc-v/fcvt_h_s/", "summary": "Converts a 32-bit single-precision float to a 16-bit half-precision float.", "arch": "RISC-V"}, {"label": "SUBW (RISC-V)", "url": "risc-v/subw/", "summary": "Subtracts the lower 32 bits of rs2 from rs1 and sign-extends the result to 64 bits.", "arch": "RISC-V"}, {"label": "SLLW (RISC-V)", "url": "risc-v/sllw/", "summary": "Performs a 32-bit logical left shift on rs1 by the amount in rs2 (lower 5 bits), sign-extending the result.", "arch": "RISC-V"}, {"label": "SRLW (RISC-V)", "url": "risc-v/srlw/", "summary": "Performs a 32-bit logical right shift on rs1 by the amount in rs2, sign-extending the result.", "arch": "RISC-V"}, {"label": "SRAW (RISC-V)", "url": "risc-v/sraw/", "summary": "Performs a 32-bit arithmetic right shift on rs1, sign-extending the result.", "arch": "RISC-V"}, {"label": "SLLIW (RISC-V)", "url": "risc-v/slliw/", "summary": "Shifts the lower 32 bits of rs1 left by a constant, sign-extending the result.", "arch": "RISC-V"}, {"label": "SRLIW (RISC-V)", "url": "risc-v/srliw/", "summary": "Logically shifts the lower 32 bits of rs1 right by a constant, sign-extending the result.", "arch": "RISC-V"}, {"label": "SRAIW (RISC-V)", "url": "risc-v/sraiw/", "summary": "Arithmetically shifts the lower 32 bits of rs1 right by a constant, sign-extending the result.", "arch": "RISC-V"}, {"label": "MULW (RISC-V)", "url": "risc-v/mulw/", "summary": "Performs 32-bit multiplication of rs1 and rs2, sign-extending the 32-bit result to 64 bits.", "arch": "RISC-V"}, {"label": "DIVW (RISC-V)", "url": "risc-v/divw/", "summary": "Performs 32-bit signed division of rs1 by rs2, sign-extending the result.", "arch": "RISC-V"}, {"label": "DIVUW (RISC-V)", "url": "risc-v/divuw/", "summary": "Performs 32-bit unsigned division of rs1 by rs2, sign-extending the result.", "arch": "RISC-V"}, {"label": "REMW (RISC-V)", "url": "risc-v/remw/", "summary": "Computes the remainder of 32-bit signed division, sign-extending the result.", "arch": "RISC-V"}, {"label": "REMUW (RISC-V)", "url": "risc-v/remuw/", "summary": "Computes the remainder of 32-bit unsigned division, sign-extending the result.", "arch": "RISC-V"}, {"label": "FENCE.I (RISC-V)", "url": "risc-v/fence_i/", "summary": "Synchronizes the instruction cache with the data cache (used after self-modifying code).", "arch": "RISC-V"}, {"label": "HLV.B (RISC-V)", "url": "risc-v/hlv_b/", "summary": "Loads a byte from Guest Physical Memory (VS-stage translation only).", "arch": "RISC-V"}, {"label": "HLV.W (RISC-V)", "url": "risc-v/hlv_w/", "summary": "Loads a word from Guest Physical Memory (VS-stage translation only).", "arch": "RISC-V"}, {"label": "HSV.B (RISC-V)", "url": "risc-v/hsv_b/", "summary": "Stores a byte to Guest Physical Memory.", "arch": "RISC-V"}, {"label": "HSV.W (RISC-V)", "url": "risc-v/hsv_w/", "summary": "Stores a word to Guest Physical Memory.", "arch": "RISC-V"}, {"label": "PREFETCH.I (RISC-V)", "url": "risc-v/prefetch_i/", "summary": "Hints to hardware to bring the cache block containing the instruction at the address into the instruction cache.", "arch": "RISC-V"}, {"label": "PREFETCH.R (RISC-V)", "url": "risc-v/prefetch_r/", "summary": "Hints to hardware to bring the cache block at the address into the data cache for reading.", "arch": "RISC-V"}, {"label": "PREFETCH.W (RISC-V)", "url": "risc-v/prefetch_w/", "summary": "Hints to hardware to bring the cache block at the address into the data cache for writing (exclusive ownership).", "arch": "RISC-V"}, {"label": "DRET (RISC-V)", "url": "risc-v/dret/", "summary": "Returns from Debug Mode to the mode defined in the 'dcsr' register.", "arch": "RISC-V"}, {"label": "VSETVLI (RISC-V)", "url": "risc-v/vsetvli/", "summary": "Configures the vector length (vl) and vector type (vtype) based on application needs.", "arch": "RISC-V"}, {"label": "VLE32.V (RISC-V)", "url": "risc-v/vle32_v/", "summary": "Loads a vector of 32-bit elements from memory into a vector register.", "arch": "RISC-V"}, {"label": "VSE32.V (RISC-V)", "url": "risc-v/vse32_v/", "summary": "Stores a vector of 32-bit elements from a vector register to memory.", "arch": "RISC-V"}, {"label": "VADD.VV (RISC-V)", "url": "risc-v/vadd_vv/", "summary": "Adds elements of two vector registers.", "arch": "RISC-V"}, {"label": "VMUL.VV (RISC-V)", "url": "risc-v/vmul_vv/", "summary": "Multiplies elements of two vector registers.", "arch": "RISC-V"}, {"label": "CLZ (RISC-V)", "url": "risc-v/clz/", "summary": "Counts the number of 0 bits at the MSB end of the register.", "arch": "RISC-V"}, {"label": "CTZ (RISC-V)", "url": "risc-v/ctz/", "summary": "Counts the number of 0 bits at the LSB end of the register.", "arch": "RISC-V"}, {"label": "CPOP (RISC-V)", "url": "risc-v/cpop/", "summary": "Counts the number of set bits (1s) in the register.", "arch": "RISC-V"}, {"label": "ANDN (RISC-V)", "url": "risc-v/andn/", "summary": "Performs bitwise AND with the bitwise negation of rs2 (rs1 & ~rs2).", "arch": "RISC-V"}, {"label": "ORN (RISC-V)", "url": "risc-v/orn/", "summary": "Performs bitwise OR with the bitwise negation of rs2 (rs1 | ~rs2).", "arch": "RISC-V"}, {"label": "XNOR (RISC-V)", "url": "risc-v/xnor/", "summary": "Performs bitwise exclusive-NOR (rs1 ^ ~rs2).", "arch": "RISC-V"}, {"label": "ROL (RISC-V)", "url": "risc-v/rol/", "summary": "Rotates the bits in rs1 left by the amount in rs2.", "arch": "RISC-V"}, {"label": "ROR (RISC-V)", "url": "risc-v/ror/", "summary": "Rotates the bits in rs1 right by the amount in rs2.", "arch": "RISC-V"}, {"label": "MAX (RISC-V)", "url": "risc-v/max/", "summary": "Computes the signed maximum of two registers.", "arch": "RISC-V"}, {"label": "MIN (RISC-V)", "url": "risc-v/min/", "summary": "Computes the signed minimum of two registers.", "arch": "RISC-V"}, {"label": "SEX.B (RISC-V)", "url": "risc-v/sex_b/", "summary": "Sign-extends the lowest byte (8 bits) to XLEN bits.", "arch": "RISC-V"}, {"label": "SEX.H (RISC-V)", "url": "risc-v/sex_h/", "summary": "Sign-extends the lowest halfword (16 bits) to XLEN bits.", "arch": "RISC-V"}, {"label": "ZEXT.H (RISC-V)", "url": "risc-v/zext_h/", "summary": "Zero-extends the lowest halfword (16 bits) to XLEN bits.", "arch": "RISC-V"}, {"label": "ORC.B (RISC-V)", "url": "risc-v/orc_b/", "summary": "Sets each byte of the result to 0xFF if the corresponding byte of the source is non-zero, else 0x00.", "arch": "RISC-V"}, {"label": "REV8 (RISC-V)", "url": "risc-v/rev8/", "summary": "Reverses the order of bytes in a register (Endian swap).", "arch": "RISC-V"}, {"label": "ADDI (RISC-V)", "url": "risc-v/addi/", "summary": "Adds a sign-extended 12-bit immediate to a register.", "arch": "RISC-V"}, {"label": "ADD (RISC-V)", "url": "risc-v/add/", "summary": "Adds the contents of two registers.", "arch": "RISC-V"}, {"label": "SUB (RISC-V)", "url": "risc-v/sub/", "summary": "Subtracts rs2 from rs1.", "arch": "RISC-V"}, {"label": "LUI (RISC-V)", "url": "risc-v/lui/", "summary": "Loads the 20-bit immediate into the upper 20 bits of the register.", "arch": "RISC-V"}, {"label": "AUIPC (RISC-V)", "url": "risc-v/auipc/", "summary": "Adds a 20-bit upper immediate to the Program Counter.", "arch": "RISC-V"}, {"label": "JAL (RISC-V)", "url": "risc-v/jal/", "summary": "Jumps to an offset and saves return address.", "arch": "RISC-V"}, {"label": "BEQ (RISC-V)", "url": "risc-v/beq/", "summary": "Branches if two registers are equal.", "arch": "RISC-V"}, {"label": "LW (RISC-V)", "url": "risc-v/lw/", "summary": "Loads a 32-bit word from memory.", "arch": "RISC-V"}, {"label": "SW (RISC-V)", "url": "risc-v/sw/", "summary": "Stores a 32-bit word to memory.", "arch": "RISC-V"}, {"label": "ECALL (RISC-V)", "url": "risc-v/ecall/", "summary": "Triggers a service request to the execution environment (OS).", "arch": "RISC-V"}, {"label": "FCVT.W.S (RISC-V)", "url": "risc-v/fcvt_w_s/", "summary": "Converts a single-precision floating-point number to a signed 32-bit integer.", "arch": "RISC-V"}, {"label": "FCVT.S.W (RISC-V)", "url": "risc-v/fcvt_s_w/", "summary": "Converts a signed 32-bit integer to a single-precision floating-point number.", "arch": "RISC-V"}, {"label": "FCVT.D.S (RISC-V)", "url": "risc-v/fcvt_d_s/", "summary": "Converts a single-precision float to a double-precision float.", "arch": "RISC-V"}, {"label": "FCVT.S.D (RISC-V)", "url": "risc-v/fcvt_s_d/", "summary": "Converts a double-precision float to a single-precision float.", "arch": "RISC-V"}, {"label": "FSGNJ.S (RISC-V)", "url": "risc-v/fsgnj_s/", "summary": "Injects the sign of rs2 into rs1. Used to copy values or manipulate signs.", "arch": "RISC-V"}, {"label": "FSGNJN.S (RISC-V)", "url": "risc-v/fsgnjn_s/", "summary": "Injects the *negated* sign of rs2 into rs1. Used for negation and absolute value.", "arch": "RISC-V"}, {"label": "FSGNJX.S (RISC-V)", "url": "risc-v/fsgnjx_s/", "summary": "Injects the XOR of signs of rs1 and rs2. Used to copy sign.", "arch": "RISC-V"}, {"label": "FEQ.S (RISC-V)", "url": "risc-v/feq_s/", "summary": "Sets integer rd to 1 if float rs1 equals float rs2, else 0.", "arch": "RISC-V"}, {"label": "FLT.S (RISC-V)", "url": "risc-v/flt_s/", "summary": "Sets integer rd to 1 if float rs1 is less than float rs2, else 0.", "arch": "RISC-V"}, {"label": "FLE.S (RISC-V)", "url": "risc-v/fle_s/", "summary": "Sets integer rd to 1 if float rs1 is less than or equal to float rs2, else 0.", "arch": "RISC-V"}, {"label": "FMV.X.W (RISC-V)", "url": "risc-v/fmv_x_w/", "summary": "Moves the bit pattern of a floating-point register to an integer register.", "arch": "RISC-V"}, {"label": "FMV.W.X (RISC-V)", "url": "risc-v/fmv_w_x/", "summary": "Moves the bit pattern of an integer register to a floating-point register.", "arch": "RISC-V"}, {"label": "CZERO.EQZ (RISC-V)", "url": "risc-v/czero_eqz/", "summary": "Moves rs1 to rd if rs2 is non-zero, otherwise sets rd to zero.", "arch": "RISC-V"}, {"label": "CZERO.NEZ (RISC-V)", "url": "risc-v/czero_nez/", "summary": "Moves rs1 to rd if rs2 is zero, otherwise sets rd to zero.", "arch": "RISC-V"}, {"label": "PAUSE (RISC-V)", "url": "risc-v/pause/", "summary": "Hints that the current hart is in a spin-wait loop, allowing the hardware to reduce power consumption or yield resources.", "arch": "RISC-V"}, {"label": "CBO.CLEAN (RISC-V)", "url": "risc-v/cbo_clean/", "summary": "Performs a clean operation on the cache block containing the effective address.", "arch": "RISC-V"}, {"label": "CBO.FLUSH (RISC-V)", "url": "risc-v/cbo_flush/", "summary": "Performs a flush (clean + invalidate) operation on the cache block.", "arch": "RISC-V"}, {"label": "CBO.INVAL (RISC-V)", "url": "risc-v/cbo_inval/", "summary": "Performs an invalidate operation on the cache block.", "arch": "RISC-V"}, {"label": "CBO.ZERO (RISC-V)", "url": "risc-v/cbo_zero/", "summary": "Zeros a cache block specified by the address.", "arch": "RISC-V"}, {"label": "RDCYCLE (RISC-V)", "url": "risc-v/rdcycle/", "summary": "Reads the lower 32/64 bits of the cycle counter.", "arch": "RISC-V"}, {"label": "RDTIME (RISC-V)", "url": "risc-v/rdtime/", "summary": "Reads the lower 32/64 bits of the real-time clock.", "arch": "RISC-V"}, {"label": "RDINSTRET (RISC-V)", "url": "risc-v/rdinstret/", "summary": "Reads the count of instructions retired (completed).", "arch": "RISC-V"}, {"label": "NOP (RISC-V)", "url": "risc-v/nop/", "summary": "Performs no operation. Used for alignment or timing delays.", "arch": "RISC-V"}, {"label": "MV (RISC-V)", "url": "risc-v/mv/", "summary": "Copies the value of one register into another.", "arch": "RISC-V"}, {"label": "LI (RISC-V)", "url": "risc-v/li/", "summary": "Loads an arbitrary immediate value into a register.", "arch": "RISC-V"}, {"label": "RET (RISC-V)", "url": "risc-v/ret/", "summary": "Returns from a subroutine call.", "arch": "RISC-V"}, {"label": "J (RISC-V)", "url": "risc-v/j/", "summary": "Unconditionally jumps to a target offset.", "arch": "RISC-V"}, {"label": "JR (RISC-V)", "url": "risc-v/jr/", "summary": "Unconditionally jumps to an address held in a register.", "arch": "RISC-V"}, {"label": "CALL (RISC-V)", "url": "risc-v/call/", "summary": "Calls a function by jumping to an address and saving the return address.", "arch": "RISC-V"}, {"label": "NOT (RISC-V)", "url": "risc-v/not/", "summary": "Computes the bitwise logical negation (one's complement).", "arch": "RISC-V"}, {"label": "NEG (RISC-V)", "url": "risc-v/neg/", "summary": "Computes the two's complement negation (arithmetic negative).", "arch": "RISC-V"}, {"label": "BEQZ (RISC-V)", "url": "risc-v/beqz/", "summary": "Branches if the register is zero.", "arch": "RISC-V"}, {"label": "BNEZ (RISC-V)", "url": "risc-v/bnez/", "summary": "Branches if the register is not zero.", "arch": "RISC-V"}, {"label": "SEQZ (RISC-V)", "url": "risc-v/seqz/", "summary": "Sets rd to 1 if rs is zero, otherwise 0.", "arch": "RISC-V"}, {"label": "SNEZ (RISC-V)", "url": "risc-v/snez/", "summary": "Sets rd to 1 if rs is not zero, otherwise 0.", "arch": "RISC-V"}, {"label": "AES64ES (RISC-V)", "url": "risc-v/aes64es/", "summary": "Performs one round of AES-128 encryption key schedule generation.", "arch": "RISC-V"}, {"label": "AES64DS (RISC-V)", "url": "risc-v/aes64ds/", "summary": "Performs one round of AES-128 decryption key schedule generation.", "arch": "RISC-V"}, {"label": "SHA256SIG0 (RISC-V)", "url": "risc-v/sha256sig0/", "summary": "Performs the Sigma0 transformation function for SHA-256.", "arch": "RISC-V"}, {"label": "SHA256SUM0 (RISC-V)", "url": "risc-v/sha256sum0/", "summary": "Performs the Sum0 transformation function for SHA-256.", "arch": "RISC-V"}, {"label": "FCVT.WU.S (RISC-V)", "url": "risc-v/fcvt_wu_s/", "summary": "Converts a single-precision float to a 32-bit unsigned integer.", "arch": "RISC-V"}, {"label": "FCVT.S.WU (RISC-V)", "url": "risc-v/fcvt_s_wu/", "summary": "Converts a 32-bit unsigned integer to a single-precision float.", "arch": "RISC-V"}, {"label": "FCVT.W.D (RISC-V)", "url": "risc-v/fcvt_w_d/", "summary": "Converts a double-precision float to a 32-bit signed integer.", "arch": "RISC-V"}, {"label": "FCVT.D.W (RISC-V)", "url": "risc-v/fcvt_d_w/", "summary": "Converts a 32-bit signed integer to a double-precision float.", "arch": "RISC-V"}, {"label": "SH1ADD (RISC-V)", "url": "risc-v/sh1add/", "summary": "Shifts rs1 left by 1 and adds rs2. Used for calculating addresses of 16-bit elements.", "arch": "RISC-V"}, {"label": "SH2ADD (RISC-V)", "url": "risc-v/sh2add/", "summary": "Shifts rs1 left by 2 and adds rs2. Used for calculating addresses of 32-bit elements.", "arch": "RISC-V"}, {"label": "SH3ADD (RISC-V)", "url": "risc-v/sh3add/", "summary": "Shifts rs1 left by 3 and adds rs2. Used for calculating addresses of 64-bit elements.", "arch": "RISC-V"}, {"label": "ADDUW (RISC-V)", "url": "risc-v/adduw/", "summary": "Zero-extends the lower 32 bits of rs1 and adds it to rs2. Useful for 64-bit address calculations with 32-bit unsigned indices.", "arch": "RISC-V"}, {"label": "BSET (RISC-V)", "url": "risc-v/bset/", "summary": "Sets a single bit in rs1 at the index specified by rs2.", "arch": "RISC-V"}, {"label": "BSETI (RISC-V)", "url": "risc-v/bseti/", "summary": "Sets a single bit in rs1 at the index specified by an immediate.", "arch": "RISC-V"}, {"label": "BCLR (RISC-V)", "url": "risc-v/bclr/", "summary": "Clears a single bit in rs1 at the index specified by rs2.", "arch": "RISC-V"}, {"label": "BCLRI (RISC-V)", "url": "risc-v/bclri/", "summary": "Clears a single bit in rs1 at the index specified by an immediate.", "arch": "RISC-V"}, {"label": "BINV (RISC-V)", "url": "risc-v/binv/", "summary": "Inverts (toggles) a single bit in rs1 at the index specified by rs2.", "arch": "RISC-V"}, {"label": "BINVI (RISC-V)", "url": "risc-v/binvi/", "summary": "Inverts (toggles) a single bit in rs1 at the index specified by an immediate.", "arch": "RISC-V"}, {"label": "BEXT (RISC-V)", "url": "risc-v/bext/", "summary": "Extracts the value of a single bit (0 or 1) at the index specified by rs2. The result is placed in the LSB of rd.", "arch": "RISC-V"}, {"label": "BEXTI (RISC-V)", "url": "risc-v/bexti/", "summary": "Extracts the value of a single bit (0 or 1) at the index specified by an immediate.", "arch": "RISC-V"}, {"label": "CLMUL (RISC-V)", "url": "risc-v/clmul/", "summary": "Performs carry-less multiplication of the lower bits of rs1 and rs2. Used for CRC and GCM (crypto).", "arch": "RISC-V"}, {"label": "FCLASS.S (RISC-V)", "url": "risc-v/fclass_s/", "summary": "Examines the value in a float register and generates a 10-bit bitmask indicating its class (NaN, Inf, Zero, Normal, etc.).", "arch": "RISC-V"}, {"label": "FCLASS.D (RISC-V)", "url": "risc-v/fclass_d/", "summary": "Examines a double-precision register and generates a classification bitmask.", "arch": "RISC-V"}, {"label": "FCVT.S.L (RISC-V)", "url": "risc-v/fcvt_s_l/", "summary": "Converts a 64-bit signed integer (Long) to a single-precision float.", "arch": "RISC-V"}, {"label": "FCVT.S.LU (RISC-V)", "url": "risc-v/fcvt_s_lu/", "summary": "Converts a 64-bit unsigned integer to a single-precision float.", "arch": "RISC-V"}, {"label": "FCVT.L.S (RISC-V)", "url": "risc-v/fcvt_l_s/", "summary": "Converts a single-precision float to a 64-bit signed integer.", "arch": "RISC-V"}, {"label": "FCVT.LU.S (RISC-V)", "url": "risc-v/fcvt_lu_s/", "summary": "Converts a single-precision float to a 64-bit unsigned integer.", "arch": "RISC-V"}, {"label": "FCVT.D.L (RISC-V)", "url": "risc-v/fcvt_d_l/", "summary": "Converts a 64-bit signed integer to a double-precision float.", "arch": "RISC-V"}, {"label": "FCVT.D.LU (RISC-V)", "url": "risc-v/fcvt_d_lu/", "summary": "Converts a 64-bit unsigned integer to a double-precision float.", "arch": "RISC-V"}, {"label": "FCVT.L.D (RISC-V)", "url": "risc-v/fcvt_l_d/", "summary": "Converts a double-precision float to a 64-bit signed integer.", "arch": "RISC-V"}, {"label": "FSGNJ.D (RISC-V)", "url": "risc-v/fsgnj_d/", "summary": "Injects the sign of rs2 into rs1 (Double Precision).", "arch": "RISC-V"}, {"label": "FSGNJN.D (RISC-V)", "url": "risc-v/fsgnjn_d/", "summary": "Injects the *negated* sign of rs2 into rs1 (Double Precision).", "arch": "RISC-V"}, {"label": "FEQ.D (RISC-V)", "url": "risc-v/feq_d/", "summary": "Sets integer rd to 1 if double rs1 equals double rs2, else 0.", "arch": "RISC-V"}, {"label": "FLT.D (RISC-V)", "url": "risc-v/flt_d/", "summary": "Sets integer rd to 1 if double rs1 is less than double rs2, else 0.", "arch": "RISC-V"}, {"label": "FLE.D (RISC-V)", "url": "risc-v/fle_d/", "summary": "Sets integer rd to 1 if double rs1 is less than or equal to double rs2, else 0.", "arch": "RISC-V"}, {"label": "C.ADDI4SPN (RISC-V)", "url": "risc-v/c_addi4spn/", "summary": "Adds a zero-extended non-zero immediate to the stack pointer (x2) and stores the result in a register.", "arch": "RISC-V"}, {"label": "C.LW (RISC-V)", "url": "risc-v/c_lw/", "summary": "Loads a 32-bit word from memory using a compressed encoding.", "arch": "RISC-V"}, {"label": "C.SW (RISC-V)", "url": "risc-v/c_sw/", "summary": "Stores a 32-bit word to memory using a compressed encoding.", "arch": "RISC-V"}, {"label": "C.ADDI (RISC-V)", "url": "risc-v/c_addi/", "summary": "Adds a non-zero immediate to a register.", "arch": "RISC-V"}, {"label": "C.JAL (RISC-V)", "url": "risc-v/c_jal/", "summary": "Performs a PC-relative jump and stores return address in x1 (ra). RV32 only.", "arch": "RISC-V"}, {"label": "C.LI (RISC-V)", "url": "risc-v/c_li/", "summary": "Loads a 6-bit signed immediate into a register.", "arch": "RISC-V"}, {"label": "C.ADDI16SP (RISC-V)", "url": "risc-v/c_addi16sp/", "summary": "Adds a signed non-zero immediate to the stack pointer (x2).", "arch": "RISC-V"}, {"label": "C.LUI (RISC-V)", "url": "risc-v/c_lui/", "summary": "Loads a non-zero 6-bit immediate into bits 17-12 of the destination register, clears lower 12 bits, sign-extends bit 17.", "arch": "RISC-V"}, {"label": "C.SRLI (RISC-V)", "url": "risc-v/c_srli/", "summary": "Logically shifts a register right by immediate.", "arch": "RISC-V"}, {"label": "C.SRAI (RISC-V)", "url": "risc-v/c_srai/", "summary": "Arithmetically shifts a register right by immediate.", "arch": "RISC-V"}, {"label": "C.ANDI (RISC-V)", "url": "risc-v/c_andi/", "summary": "Computes bitwise AND with a signed immediate.", "arch": "RISC-V"}, {"label": "C.SUB (RISC-V)", "url": "risc-v/c_sub/", "summary": "Subtracts two registers.", "arch": "RISC-V"}, {"label": "C.XOR (RISC-V)", "url": "risc-v/c_xor/", "summary": "Bitwise XOR of two registers.", "arch": "RISC-V"}, {"label": "C.OR (RISC-V)", "url": "risc-v/c_or/", "summary": "Bitwise OR of two registers.", "arch": "RISC-V"}, {"label": "C.AND (RISC-V)", "url": "risc-v/c_and/", "summary": "Bitwise AND of two registers.", "arch": "RISC-V"}, {"label": "C.J (RISC-V)", "url": "risc-v/c_j/", "summary": "Unconditional PC-relative jump.", "arch": "RISC-V"}, {"label": "C.BEQZ (RISC-V)", "url": "risc-v/c_beqz/", "summary": "Branches if the register is zero.", "arch": "RISC-V"}, {"label": "C.BNEZ (RISC-V)", "url": "risc-v/c_bnez/", "summary": "Branches if the register is not zero.", "arch": "RISC-V"}, {"label": "C.SLLI (RISC-V)", "url": "risc-v/c_slli/", "summary": "Logically shifts a register left by immediate.", "arch": "RISC-V"}, {"label": "C.LWSP (RISC-V)", "url": "risc-v/c_lwsp/", "summary": "Loads a word from the stack pointer (x2).", "arch": "RISC-V"}, {"label": "C.SWSP (RISC-V)", "url": "risc-v/c_swsp/", "summary": "Stores a word to the stack pointer (x2).", "arch": "RISC-V"}, {"label": "C.JR (RISC-V)", "url": "risc-v/c_jr/", "summary": "Unconditionally jumps to address in register.", "arch": "RISC-V"}, {"label": "C.MV (RISC-V)", "url": "risc-v/c_mv/", "summary": "Copies register rs2 to rd.", "arch": "RISC-V"}, {"label": "C.EBREAK (RISC-V)", "url": "risc-v/c_ebreak/", "summary": "Triggers a debugger breakpoint.", "arch": "RISC-V"}, {"label": "C.JALR (RISC-V)", "url": "risc-v/c_jalr/", "summary": "Jumps to register address and links (saves PC+2 to ra).", "arch": "RISC-V"}, {"label": "C.ADD (RISC-V)", "url": "risc-v/c_add/", "summary": "Adds two registers.", "arch": "RISC-V"}, {"label": "BEQ (RISC-V)", "url": "risc-v/beq/", "summary": "Take the branch if registers rs1 and rs2 are equal.", "arch": "RISC-V"}, {"label": "BNE (RISC-V)", "url": "risc-v/bne/", "summary": "Take the branch if registers rs1 and rs2 are not equal.", "arch": "RISC-V"}, {"label": "BLT (RISC-V)", "url": "risc-v/blt/", "summary": "Take the branch if rs1 is less than rs2 (signed).", "arch": "RISC-V"}, {"label": "BGE (RISC-V)", "url": "risc-v/bge/", "summary": "Take the branch if rs1 is greater than or equal to rs2 (signed).", "arch": "RISC-V"}, {"label": "CSRRW (RISC-V)", "url": "risc-v/csrrw/", "summary": "Atomically swaps values in the CSRs. Reads the old value of the CSR into rd, then writes rs1 to the CSR.", "arch": "RISC-V"}, {"label": "CSRRS (RISC-V)", "url": "risc-v/csrrs/", "summary": "Reads the value of the CSR into rd, then bitwise ORs the value in rs1 into the CSR (setting bits).", "arch": "RISC-V"}, {"label": "DIV (RISC-V)", "url": "risc-v/div/", "summary": "Performs signed integer division.", "arch": "RISC-V"}, {"label": "DIVU (RISC-V)", "url": "risc-v/divu/", "summary": "Performs unsigned integer division.", "arch": "RISC-V"}, {"label": "EBREAK (RISC-V)", "url": "risc-v/ebreak/", "summary": "Used by debuggers to cause control to be transferred back to a debugging environment.", "arch": "RISC-V"}, {"label": "FENCE (RISC-V)", "url": "risc-v/fence/", "summary": "Orders device I/O and memory accesses.", "arch": "RISC-V"}, {"label": "FLW (RISC-V)", "url": "risc-v/flw/", "summary": "Loads a single-precision floating-point value from memory.", "arch": "RISC-V"}, {"label": "FSW (RISC-V)", "url": "risc-v/fsw/", "summary": "Stores a single-precision floating-point value to memory.", "arch": "RISC-V"}, {"label": "FADD.S (RISC-V)", "url": "risc-v/fadd_s/", "summary": "Performs single-precision floating-point addition.", "arch": "RISC-V"}, {"label": "MUL (RISC-V)", "url": "risc-v/mul/", "summary": "Performs a 32-bit (or 64-bit) multiplication of rs1 and rs2 and stores the lower bits in rd.", "arch": "RISC-V"}, {"label": "MULH (RISC-V)", "url": "risc-v/mulh/", "summary": "Performs a signed multiplication and stores the upper bits of the result.", "arch": "RISC-V"}, {"label": "MRET (RISC-V)", "url": "risc-v/mret/", "summary": "Returns from a machine-mode trap handler.", "arch": "RISC-V"}, {"label": "OR (RISC-V)", "url": "risc-v/or/", "summary": "Performs a bitwise logical OR operation.", "arch": "RISC-V"}, {"label": "ORI (RISC-V)", "url": "risc-v/ori/", "summary": "Performs a bitwise logical OR with a sign-extended immediate.", "arch": "RISC-V"}, {"label": "REM (RISC-V)", "url": "risc-v/rem/", "summary": "Computes the signed remainder of division.", "arch": "RISC-V"}, {"label": "SB (RISC-V)", "url": "risc-v/sb/", "summary": "Stores the lowest 8 bits of a register to memory.", "arch": "RISC-V"}, {"label": "SH (RISC-V)", "url": "risc-v/sh/", "summary": "Stores the lowest 16 bits of a register to memory.", "arch": "RISC-V"}, {"label": "SW (RISC-V)", "url": "risc-v/sw/", "summary": "Stores a 32-bit word to memory.", "arch": "RISC-V"}, {"label": "SD (RISC-V)", "url": "risc-v/sd/", "summary": "Stores a 64-bit doubleword to memory.", "arch": "RISC-V"}, {"label": "SLL (RISC-V)", "url": "risc-v/sll/", "summary": "Shifts a register left by the number of bits specified in another register.", "arch": "RISC-V"}, {"label": "SLLI (RISC-V)", "url": "risc-v/slli/", "summary": "Shifts a register left by a constant amount.", "arch": "RISC-V"}, {"label": "SRL (RISC-V)", "url": "risc-v/srl/", "summary": "Shifts a register right, shifting in zeros.", "arch": "RISC-V"}, {"label": "SRA (RISC-V)", "url": "risc-v/sra/", "summary": "Shifts a register right, preserving the sign bit.", "arch": "RISC-V"}, {"label": "SLT (RISC-V)", "url": "risc-v/slt/", "summary": "Sets rd to 1 if rs1 < rs2 (signed), otherwise 0.", "arch": "RISC-V"}, {"label": "SLTI (RISC-V)", "url": "risc-v/slti/", "summary": "Sets rd to 1 if rs1 < immediate (signed), otherwise 0.", "arch": "RISC-V"}, {"label": "SC.W (RISC-V)", "url": "risc-v/sc_w/", "summary": "Conditionally stores a word to memory if the reservation (from LR) is still valid.", "arch": "RISC-V"}, {"label": "SFENCE.VMA (RISC-V)", "url": "risc-v/sfence_vma/", "summary": "Synchronizes updates to in-memory address translation data structures (TLB flush).", "arch": "RISC-V"}, {"label": "SRET (RISC-V)", "url": "risc-v/sret/", "summary": "Returns from a supervisor-mode trap handler.", "arch": "RISC-V"}, {"label": "WFI (RISC-V)", "url": "risc-v/wfi/", "summary": "Provides a hint to the implementation that the current hart can be stalled until an interrupt occurs.", "arch": "RISC-V"}, {"label": "XOR (RISC-V)", "url": "risc-v/xor/", "summary": "Performs a bitwise logical Exclusive-OR operation.", "arch": "RISC-V"}, {"label": "XORI (RISC-V)", "url": "risc-v/xori/", "summary": "Performs a bitwise logical Exclusive-OR with a sign-extended immediate.", "arch": "RISC-V"}, {"label": "HFENCE.GVMA (RISC-V)", "url": "risc-v/hfence_gvma/", "summary": "Synchronizes updates to guest physical address translation data structures.", "arch": "RISC-V"}, {"label": "HFENCE.VVMA (RISC-V)", "url": "risc-v/hfence_vvma/", "summary": "Synchronizes updates to VS-stage address translation data structures.", "arch": "RISC-V"}, {"label": "JAL (RISC-V)", "url": "risc-v/jal/", "summary": "Jumps to an offset relative to PC and saves the return address (PC+4) to rd.", "arch": "RISC-V"}, {"label": "JALR (RISC-V)", "url": "risc-v/jalr/", "summary": "Jumps to address in rs1 + offset, saving return address to rd.", "arch": "RISC-V"}, {"label": "LB (RISC-V)", "url": "risc-v/lb/", "summary": "Loads an 8-bit byte from memory and sign-extends it to the register width.", "arch": "RISC-V"}, {"label": "LH (RISC-V)", "url": "risc-v/lh/", "summary": "Loads a 16-bit halfword from memory and sign-extends it.", "arch": "RISC-V"}, {"label": "LW (RISC-V)", "url": "risc-v/lw/", "summary": "Loads a 32-bit word from memory and sign-extends it to 64 bits.", "arch": "RISC-V"}, {"label": "LBU (RISC-V)", "url": "risc-v/lbu/", "summary": "Loads an 8-bit byte from memory and zero-extends it.", "arch": "RISC-V"}, {"label": "LHU (RISC-V)", "url": "risc-v/lhu/", "summary": "Loads a 16-bit halfword from memory and zero-extends it.", "arch": "RISC-V"}, {"label": "LD (RISC-V)", "url": "risc-v/ld/", "summary": "Loads a 64-bit doubleword from memory.", "arch": "RISC-V"}, {"label": "LWU (RISC-V)", "url": "risc-v/lwu/", "summary": "Loads a 32-bit word from memory and zero-extends it to 64 bits.", "arch": "RISC-V"}, {"label": "LUI (RISC-V)", "url": "risc-v/lui/", "summary": "Loads the 20-bit immediate into the upper 20 bits of the register (lower 12 bits are zero).", "arch": "RISC-V"}, {"label": "LR.W (RISC-V)", "url": "risc-v/lr_w/", "summary": "Loads a word from memory and registers a reservation set for the address.", "arch": "RISC-V"}, {"label": "LR.D (RISC-V)", "url": "risc-v/lr_d/", "summary": "Loads a doubleword from memory and registers a reservation set.", "arch": "RISC-V"}, {"label": "ADD (RISC-V)", "url": "risc-v/add/", "summary": "Adds the contents of two registers.", "arch": "RISC-V"}, {"label": "ADDI (RISC-V)", "url": "risc-v/addi/", "summary": "Adds a register and a sign-extended 12-bit immediate value.", "arch": "RISC-V"}, {"label": "ADDW (RISC-V)", "url": "risc-v/addw/", "summary": "Adds two 32-bit registers and sign-extends the result to 64 bits.", "arch": "RISC-V"}, {"label": "ADDIW (RISC-V)", "url": "risc-v/addiw/", "summary": "Adds a 12-bit immediate to a register (32-bit arithmetic) and sign-extends to 64 bits.", "arch": "RISC-V"}, {"label": "AND (RISC-V)", "url": "risc-v/and/", "summary": "Performs a bitwise logical AND operation between two registers.", "arch": "RISC-V"}, {"label": "ANDI (RISC-V)", "url": "risc-v/andi/", "summary": "Performs a bitwise logical AND between a register and a sign-extended 12-bit immediate.", "arch": "RISC-V"}, {"label": "AUIPC (RISC-V)", "url": "risc-v/auipc/", "summary": "Adds a 20-bit upper immediate to the Program Counter, used for PC-relative addressing.", "arch": "RISC-V"}, {"label": "AMOADD.W (RISC-V)", "url": "risc-v/amoadd_w/", "summary": "Atomically adds a value to a word in memory.", "arch": "RISC-V"}, {"label": "AMOSWAP.W (RISC-V)", "url": "risc-v/amoswap_w/", "summary": "Atomically swaps a value in memory with a register.", "arch": "RISC-V"}, {"label": "AMOAND.W (RISC-V)", "url": "risc-v/amoand_w/", "summary": "Atomically performs bitwise AND on a word in memory.", "arch": "RISC-V"}, {"label": "lbz (PowerISA)", "url": "powerisa/lbz/", "summary": "Loads a byte from memory into the low 8 bits of a register and clears the upper 56 bits.", "arch": "PowerISA"}, {"label": "lhz (PowerISA)", "url": "powerisa/lhz/", "summary": "Loads a halfword (16 bits) from memory and clears the upper 48 bits.", "arch": "PowerISA"}, {"label": "lha (PowerISA)", "url": "powerisa/lha/", "summary": "Loads a halfword (16 bits) from memory and sign-extends it to 64 bits.", "arch": "PowerISA"}, {"label": "lwz (PowerISA)", "url": "powerisa/lwz/", "summary": "Loads a word (32 bits) from memory and clears the upper 32 bits.", "arch": "PowerISA"}, {"label": "lwa (PowerISA)", "url": "powerisa/lwa/", "summary": "Loads a word (32 bits) from memory and sign-extends it to 64 bits.", "arch": "PowerISA"}, {"label": "ld (PowerISA)", "url": "powerisa/ld/", "summary": "Loads a doubleword (64 bits) from memory.", "arch": "PowerISA"}, {"label": "lwarx (PowerISA)", "url": "powerisa/lwarx/", "summary": "Loads a word and creates a reservation for use with 'stwcx.'. Critical for implementing atomic primitives (mutexes).", "arch": "PowerISA"}, {"label": "ldarx (PowerISA)", "url": "powerisa/ldarx/", "summary": "Loads a doubleword and creates a reservation. 64-bit version of lwarx.", "arch": "PowerISA"}, {"label": "mtspr (PowerISA)", "url": "powerisa/mtspr/", "summary": "Copies a value from a general-purpose register to a system SPR (e.g., CTR, LR, XER).", "arch": "PowerISA"}, {"label": "mfspr (PowerISA)", "url": "powerisa/mfspr/", "summary": "Copies a value from a system SPR to a general-purpose register.", "arch": "PowerISA"}, {"label": "mullw (PowerISA)", "url": "powerisa/mullw/", "summary": "Multiplies two 32-bit integers and stores the lower 32 bits of the 64-bit result.", "arch": "PowerISA"}, {"label": "mulld (PowerISA)", "url": "powerisa/mulld/", "summary": "Multiplies two 64-bit integers and stores the lower 64 bits of the 128-bit result.", "arch": "PowerISA"}, {"label": "mr (PowerISA)", "url": "powerisa/mr/", "summary": "Copies the contents of one register to another. (Encoded as OR RA, RS, RS).", "arch": "PowerISA"}, {"label": "evaddw (PowerISA)", "url": "powerisa/evaddw/", "summary": "Adds two 64-bit vectors of two 32-bit words.", "arch": "PowerISA"}, {"label": "evsubw (PowerISA)", "url": "powerisa/evsubw/", "summary": "Subtracts two 64-bit vectors of two 32-bit words.", "arch": "PowerISA"}, {"label": "evabs (PowerISA)", "url": "powerisa/evabs/", "summary": "Computes absolute value of words in a 64-bit vector.", "arch": "PowerISA"}, {"label": "evneg (PowerISA)", "url": "powerisa/evneg/", "summary": "Negates words in a 64-bit vector.", "arch": "PowerISA"}, {"label": "evextsb (PowerISA)", "url": "powerisa/evextsb/", "summary": "Sign extends the low byte of each word to 32 bits.", "arch": "PowerISA"}, {"label": "evextsh (PowerISA)", "url": "powerisa/evextsh/", "summary": "Sign extends the low halfword of each word to 32 bits.", "arch": "PowerISA"}, {"label": "evrndw (PowerISA)", "url": "powerisa/evrndw/", "summary": "Rounds words in the vector.", "arch": "PowerISA"}, {"label": "evcntlzw (PowerISA)", "url": "powerisa/evcntlzw/", "summary": "Counts leading zeros in each word.", "arch": "PowerISA"}, {"label": "evcntlsw (PowerISA)", "url": "powerisa/evcntlsw/", "summary": "Counts leading sign bits in each word.", "arch": "PowerISA"}, {"label": "evand (PowerISA)", "url": "powerisa/evand/", "summary": "Bitwise AND of two 64-bit vectors.", "arch": "PowerISA"}, {"label": "evor (PowerISA)", "url": "powerisa/evor/", "summary": "Bitwise OR of two 64-bit vectors.", "arch": "PowerISA"}, {"label": "evxor (PowerISA)", "url": "powerisa/evxor/", "summary": "Bitwise XOR of two 64-bit vectors.", "arch": "PowerISA"}, {"label": "evnand (PowerISA)", "url": "powerisa/evnand/", "summary": "Bitwise NAND of two 64-bit vectors.", "arch": "PowerISA"}, {"label": "evnor (PowerISA)", "url": "powerisa/evnor/", "summary": "Bitwise NOR of two 64-bit vectors.", "arch": "PowerISA"}, {"label": "eveqv (PowerISA)", "url": "powerisa/eveqv/", "summary": "Bitwise Equivalence (XNOR).", "arch": "PowerISA"}, {"label": "evandc (PowerISA)", "url": "powerisa/evandc/", "summary": "RT = RA & ~RB.", "arch": "PowerISA"}, {"label": "evorc (PowerISA)", "url": "powerisa/evorc/", "summary": "RT = RA | ~RB.", "arch": "PowerISA"}, {"label": "evrlw (PowerISA)", "url": "powerisa/evrlw/", "summary": "Rotates words in RA left by amount in RB.", "arch": "PowerISA"}, {"label": "evslw (PowerISA)", "url": "powerisa/evslw/", "summary": "Shifts words in RA left by amount in RB.", "arch": "PowerISA"}, {"label": "evsrws (PowerISA)", "url": "powerisa/evsrws/", "summary": "Arithmetic right shift of words.", "arch": "PowerISA"}, {"label": "evsrwu (PowerISA)", "url": "powerisa/evsrwu/", "summary": "Logical right shift of words.", "arch": "PowerISA"}, {"label": "evrlwi (PowerISA)", "url": "powerisa/evrlwi/", "summary": "Rotates words left by immediate value.", "arch": "PowerISA"}, {"label": "evslwi (PowerISA)", "url": "powerisa/evslwi/", "summary": "Shifts words left by immediate value.", "arch": "PowerISA"}, {"label": "evsrwis (PowerISA)", "url": "powerisa/evsrwis/", "summary": "Arithmetic right shift by immediate.", "arch": "PowerISA"}, {"label": "evsrwiu (PowerISA)", "url": "powerisa/evsrwiu/", "summary": "Logical right shift by immediate.", "arch": "PowerISA"}, {"label": "evsplati (PowerISA)", "url": "powerisa/evsplati/", "summary": "Splats a signed 5-bit immediate into both words.", "arch": "PowerISA"}, {"label": "evsplatfi (PowerISA)", "url": "powerisa/evsplatfi/", "summary": "Splats a 5-bit immediate (scaled) into both words.", "arch": "PowerISA"}, {"label": "evldd (PowerISA)", "url": "powerisa/evldd/", "summary": "Loads 64 bits from memory into a vector GPR.", "arch": "PowerISA"}, {"label": "evldw (PowerISA)", "url": "powerisa/evldw/", "summary": "Loads two words from memory (aligned) into a vector.", "arch": "PowerISA"}, {"label": "evldh (PowerISA)", "url": "powerisa/evldh/", "summary": "Loads 4 halfwords from memory into a vector.", "arch": "PowerISA"}, {"label": "evlhhesplat (PowerISA)", "url": "powerisa/evlhhesplat/", "summary": "Loads a halfword and duplicates it into the even halfwords of the target.", "arch": "PowerISA"}, {"label": "evlhhousplat (PowerISA)", "url": "powerisa/evlhhousplat/", "summary": "Loads a halfword and duplicates it into the odd halfwords (zero extended).", "arch": "PowerISA"}, {"label": "evlhhossplat (PowerISA)", "url": "powerisa/evlhhossplat/", "summary": "Loads a halfword and duplicates it into the odd halfwords (sign extended).", "arch": "PowerISA"}, {"label": "evlwhe (PowerISA)", "url": "powerisa/evlwhe/", "summary": "Loads two words and places them in the even halfword positions.", "arch": "PowerISA"}, {"label": "evlwhou (PowerISA)", "url": "powerisa/evlwhou/", "summary": "Loads words into odd positions (zero extended).", "arch": "PowerISA"}, {"label": "evlwhos (PowerISA)", "url": "powerisa/evlwhos/", "summary": "Loads words into odd positions (sign extended).", "arch": "PowerISA"}, {"label": "evstdd (PowerISA)", "url": "powerisa/evstdd/", "summary": "Stores 64-bit vector to memory.", "arch": "PowerISA"}, {"label": "evstdw (PowerISA)", "url": "powerisa/evstdw/", "summary": "Stores two words from vector to memory.", "arch": "PowerISA"}, {"label": "evstdh (PowerISA)", "url": "powerisa/evstdh/", "summary": "Stores 4 halfwords from vector to memory.", "arch": "PowerISA"}, {"label": "evstwhe (PowerISA)", "url": "powerisa/evstwhe/", "summary": "Stores even halfwords to memory.", "arch": "PowerISA"}, {"label": "evstwho (PowerISA)", "url": "powerisa/evstwho/", "summary": "Stores odd halfwords to memory.", "arch": "PowerISA"}, {"label": "evstwwe (PowerISA)", "url": "powerisa/evstwwe/", "summary": "Stores the even word (upper 32-bits) to memory.", "arch": "PowerISA"}, {"label": "evstwwo (PowerISA)", "url": "powerisa/evstwwo/", "summary": "Stores the odd word (lower 32-bits) to memory.", "arch": "PowerISA"}, {"label": "evmhegsmfaa (PowerISA)", "url": "powerisa/evmhegsmfaa/", "summary": "Fractional multiply accumulate (DSP).", "arch": "PowerISA"}, {"label": "evmhegsmfan (PowerISA)", "url": "powerisa/evmhegsmfan/", "summary": "Fractional multiply negative accumulate.", "arch": "PowerISA"}, {"label": "evmhegum (PowerISA)", "url": "powerisa/evmhegum/", "summary": "Unsigned multiply.", "arch": "PowerISA"}, {"label": "evmhesmia (PowerISA)", "url": "powerisa/evmhesmia/", "summary": "Integer multiply accumulate.", "arch": "PowerISA"}, {"label": "evmhesmian (PowerISA)", "url": "powerisa/evmhesmian/", "summary": "Integer multiply negative accumulate.", "arch": "PowerISA"}, {"label": "evmheumia (PowerISA)", "url": "powerisa/evmheumia/", "summary": "Unsigned multiply accumulate.", "arch": "PowerISA"}, {"label": "evmheumian (PowerISA)", "url": "powerisa/evmheumian/", "summary": "Unsigned multiply negative accumulate.", "arch": "PowerISA"}, {"label": "evmhossf (PowerISA)", "url": "powerisa/evmhossf/", "summary": "Saturating fractional multiply.", "arch": "PowerISA"}, {"label": "evmhossfa (PowerISA)", "url": "powerisa/evmhossfa/", "summary": "Saturating fractional multiply accumulate.", "arch": "PowerISA"}, {"label": "evmhosm (PowerISA)", "url": "powerisa/evmhosm/", "summary": "Signed modulo multiply.", "arch": "PowerISA"}, {"label": "evmhosmi (PowerISA)", "url": "powerisa/evmhosmi/", "summary": "Signed integer modulo multiply.", "arch": "PowerISA"}, {"label": "evmhoumi (PowerISA)", "url": "powerisa/evmhoumi/", "summary": "Unsigned integer modulo multiply.", "arch": "PowerISA"}, {"label": "evmwhsm (PowerISA)", "url": "powerisa/evmwhsm/", "summary": "Multiplies high 16-bits of words.", "arch": "PowerISA"}, {"label": "evmwhsmi (PowerISA)", "url": "powerisa/evmwhsmi/", "summary": "Multiplies high 16-bits of words (integer).", "arch": "PowerISA"}, {"label": "evmwhssf (PowerISA)", "url": "powerisa/evmwhssf/", "summary": "Fractional multiply of high words.", "arch": "PowerISA"}, {"label": "evmwhssfa (PowerISA)", "url": "powerisa/evmwhssfa/", "summary": "Fractional multiply accumulate of high words.", "arch": "PowerISA"}, {"label": "evmwlumi (PowerISA)", "url": "powerisa/evmwlumi/", "summary": "Multiplies low 16-bits of words.", "arch": "PowerISA"}, {"label": "evmwlumia (PowerISA)", "url": "powerisa/evmwlumia/", "summary": "Multiply accumulate low words.", "arch": "PowerISA"}, {"label": "evmwlumiaa (PowerISA)", "url": "powerisa/evmwlumiaa/", "summary": "Multiply and double accumulate low words.", "arch": "PowerISA"}, {"label": "evmwlusiaaw (PowerISA)", "url": "powerisa/evmwlusiaaw/", "summary": "Complex mixed-sign accumulation.", "arch": "PowerISA"}, {"label": "evmwsmia (PowerISA)", "url": "powerisa/evmwsmia/", "summary": "Signed integer multiply accumulate.", "arch": "PowerISA"}, {"label": "evmwsmiaa (PowerISA)", "url": "powerisa/evmwsmiaa/", "summary": "Signed integer multiply double accumulate.", "arch": "PowerISA"}, {"label": "evmwsmiaaw (PowerISA)", "url": "powerisa/evmwsmiaaw/", "summary": "Signed integer multiply accumulate word.", "arch": "PowerISA"}, {"label": "evmwssfaa (PowerISA)", "url": "powerisa/evmwssfaa/", "summary": "Saturating fractional multiply double accumulate.", "arch": "PowerISA"}, {"label": "evmwssfaaw (PowerISA)", "url": "powerisa/evmwssfaaw/", "summary": "Saturating fractional multiply accumulate word.", "arch": "PowerISA"}, {"label": "evmwumia (PowerISA)", "url": "powerisa/evmwumia/", "summary": "Unsigned multiply accumulate.", "arch": "PowerISA"}, {"label": "evmwumiaa (PowerISA)", "url": "powerisa/evmwumiaa/", "summary": "Unsigned multiply double accumulate.", "arch": "PowerISA"}, {"label": "evmwumiaaw (PowerISA)", "url": "powerisa/evmwumiaaw/", "summary": "Unsigned multiply accumulate word.", "arch": "PowerISA"}, {"label": "evsubfsmiaaw (PowerISA)", "url": "powerisa/evsubfsmiaaw/", "summary": "Complex subtraction accumulate.", "arch": "PowerISA"}, {"label": "evsubfssiaaw (PowerISA)", "url": "powerisa/evsubfssiaaw/", "summary": "Complex subtraction saturate accumulate.", "arch": "PowerISA"}, {"label": "evsubfw (PowerISA)", "url": "powerisa/evsubfw/", "summary": "Subtracts words (Alternate syntax for evsubw).", "arch": "PowerISA"}, {"label": "evsubifw (PowerISA)", "url": "powerisa/evsubifw/", "summary": "Subtracts immediate from word.", "arch": "PowerISA"}, {"label": "efsadd (PowerISA)", "url": "powerisa/efsadd/", "summary": "Single precision add (SPE Float).", "arch": "PowerISA"}, {"label": "efssub (PowerISA)", "url": "powerisa/efssub/", "summary": "Single precision subtract (SPE Float).", "arch": "PowerISA"}, {"label": "efsmul (PowerISA)", "url": "powerisa/efsmul/", "summary": "Single precision multiply (SPE Float).", "arch": "PowerISA"}, {"label": "efsdiv (PowerISA)", "url": "powerisa/efsdiv/", "summary": "Single precision divide (SPE Float).", "arch": "PowerISA"}, {"label": "efdadd (PowerISA)", "url": "powerisa/efdadd/", "summary": "Double precision add (SPE Float).", "arch": "PowerISA"}, {"label": "efdsub (PowerISA)", "url": "powerisa/efdsub/", "summary": "Double precision subtract (SPE Float).", "arch": "PowerISA"}, {"label": "efdmul (PowerISA)", "url": "powerisa/efdmul/", "summary": "Double precision multiply (SPE Float).", "arch": "PowerISA"}, {"label": "efddiv (PowerISA)", "url": "powerisa/efddiv/", "summary": "Double precision divide (SPE Float).", "arch": "PowerISA"}, {"label": "efsabs (PowerISA)", "url": "powerisa/efsabs/", "summary": "Single precision absolute value.", "arch": "PowerISA"}, {"label": "efdabs (PowerISA)", "url": "powerisa/efdabs/", "summary": "Double precision absolute value.", "arch": "PowerISA"}, {"label": "efsneg (PowerISA)", "url": "powerisa/efsneg/", "summary": "Single precision negate.", "arch": "PowerISA"}, {"label": "efdneg (PowerISA)", "url": "powerisa/efdneg/", "summary": "Double precision negate.", "arch": "PowerISA"}, {"label": "efscmpeq (PowerISA)", "url": "powerisa/efscmpeq/", "summary": "Single precision compare equal.", "arch": "PowerISA"}, {"label": "efdcmpeq (PowerISA)", "url": "powerisa/efdcmpeq/", "summary": "Double precision compare equal.", "arch": "PowerISA"}, {"label": "efscmpgt (PowerISA)", "url": "powerisa/efscmpgt/", "summary": "Single precision compare greater than.", "arch": "PowerISA"}, {"label": "efdcmpgt (PowerISA)", "url": "powerisa/efdcmpgt/", "summary": "Double precision compare greater than.", "arch": "PowerISA"}, {"label": "efscmplt (PowerISA)", "url": "powerisa/efscmplt/", "summary": "Single precision compare less than.", "arch": "PowerISA"}, {"label": "efdcmplt (PowerISA)", "url": "powerisa/efdcmplt/", "summary": "Double precision compare less than.", "arch": "PowerISA"}, {"label": "darn (PowerISA)", "url": "powerisa/darn/", "summary": "Returns a random number from the hardware RNG. (L=3: Raw, L=1: Conditioned, L=0: 32-bit).", "arch": "PowerISA"}, {"label": "mffs (PowerISA)", "url": "powerisa/mffs/", "summary": "Copies the Floating-Point Status and Control Register to a float register.", "arch": "PowerISA"}, {"label": "mtfsf (PowerISA)", "url": "powerisa/mtfsf/", "summary": "Writes fields of the FPSCR from a float register.", "arch": "PowerISA"}, {"label": "mtfsfi (PowerISA)", "url": "powerisa/mtfsfi/", "summary": "Writes a 4-bit immediate to a specific FPSCR field.", "arch": "PowerISA"}, {"label": "mtfsb0 (PowerISA)", "url": "powerisa/mtfsb0/", "summary": "Clears a specific bit in the FPSCR.", "arch": "PowerISA"}, {"label": "mtfsb1 (PowerISA)", "url": "powerisa/mtfsb1/", "summary": "Sets a specific bit in the FPSCR.", "arch": "PowerISA"}, {"label": "hrfid (PowerISA)", "url": "powerisa/hrfid/", "summary": "Returns from a hypervisor interrupt.", "arch": "PowerISA"}, {"label": "copy (PowerISA)", "url": "powerisa/copy/", "summary": "Initiates a hardware copy (accelerator) operation.", "arch": "PowerISA"}, {"label": "paste (PowerISA)", "url": "powerisa/paste/", "summary": "Completes a hardware copy (paste) operation.", "arch": "PowerISA"}, {"label": "vclzb (PowerISA)", "url": "powerisa/vclzb/", "summary": "Counts leading zeros in each byte.", "arch": "PowerISA"}, {"label": "vclzh (PowerISA)", "url": "powerisa/vclzh/", "summary": "Counts leading zeros in each halfword.", "arch": "PowerISA"}, {"label": "vclzw (PowerISA)", "url": "powerisa/vclzw/", "summary": "Counts leading zeros in each word.", "arch": "PowerISA"}, {"label": "vclzd (PowerISA)", "url": "powerisa/vclzd/", "summary": "Counts leading zeros in each doubleword.", "arch": "PowerISA"}, {"label": "vctzb (PowerISA)", "url": "powerisa/vctzb/", "summary": "Counts trailing zeros in each byte.", "arch": "PowerISA"}, {"label": "vctzh (PowerISA)", "url": "powerisa/vctzh/", "summary": "Counts trailing zeros in each halfword.", "arch": "PowerISA"}, {"label": "vctzw (PowerISA)", "url": "powerisa/vctzw/", "summary": "Counts trailing zeros in each word.", "arch": "PowerISA"}, {"label": "vctzd (PowerISA)", "url": "powerisa/vctzd/", "summary": "Counts trailing zeros in each doubleword.", "arch": "PowerISA"}, {"label": "vpopcntb (PowerISA)", "url": "powerisa/vpopcntb/", "summary": "Counts set bits in each byte.", "arch": "PowerISA"}, {"label": "vpopcnth (PowerISA)", "url": "powerisa/vpopcnth/", "summary": "Counts set bits in each halfword.", "arch": "PowerISA"}, {"label": "vpopcntw (PowerISA)", "url": "powerisa/vpopcntw/", "summary": "Counts set bits in each word.", "arch": "PowerISA"}, {"label": "vpopcntd (PowerISA)", "url": "powerisa/vpopcntd/", "summary": "Counts set bits in each doubleword.", "arch": "PowerISA"}, {"label": "vextractub (PowerISA)", "url": "powerisa/vextractub/", "summary": "Extracts a specific byte from a vector into a GPR.", "arch": "PowerISA"}, {"label": "vextractuh (PowerISA)", "url": "powerisa/vextractuh/", "summary": "Extracts a halfword from a vector into a GPR.", "arch": "PowerISA"}, {"label": "vextractuw (PowerISA)", "url": "powerisa/vextractuw/", "summary": "Extracts a word from a vector into a GPR.", "arch": "PowerISA"}, {"label": "vextractd (PowerISA)", "url": "powerisa/vextractd/", "summary": "Extracts a doubleword from a vector into a GPR.", "arch": "PowerISA"}, {"label": "vinsertb (PowerISA)", "url": "powerisa/vinsertb/", "summary": "Inserts a byte from a GPR into a vector.", "arch": "PowerISA"}, {"label": "vinserth (PowerISA)", "url": "powerisa/vinserth/", "summary": "Inserts a halfword from a GPR into a vector.", "arch": "PowerISA"}, {"label": "vinsertw (PowerISA)", "url": "powerisa/vinsertw/", "summary": "Inserts a word from a GPR into a vector.", "arch": "PowerISA"}, {"label": "vinsertd (PowerISA)", "url": "powerisa/vinsertd/", "summary": "Inserts a doubleword from a GPR into a vector.", "arch": "PowerISA"}, {"label": "vaddcuw (PowerISA)", "url": "powerisa/vaddcuw/", "summary": "Calculates carry-out for word addition.", "arch": "PowerISA"}, {"label": "vaddcuq (PowerISA)", "url": "powerisa/vaddcuq/", "summary": "Calculates carry-out for quadword addition.", "arch": "PowerISA"}, {"label": "vsubcuw (PowerISA)", "url": "powerisa/vsubcuw/", "summary": "Calculates carry-out for word subtraction.", "arch": "PowerISA"}, {"label": "vsubcuq (PowerISA)", "url": "powerisa/vsubcuq/", "summary": "Calculates carry-out for quadword subtraction.", "arch": "PowerISA"}, {"label": "vprtybw (PowerISA)", "url": "powerisa/vprtybw/", "summary": "Computes parity of bytes within words.", "arch": "PowerISA"}, {"label": "vprtybd (PowerISA)", "url": "powerisa/vprtybd/", "summary": "Computes parity of bytes within doublewords.", "arch": "PowerISA"}, {"label": "vprtybq (PowerISA)", "url": "powerisa/vprtybq/", "summary": "Computes parity of bytes within quadword.", "arch": "PowerISA"}, {"label": "vbcdadd (PowerISA)", "url": "powerisa/vbcdadd/", "summary": "Adds two BCD (Binary Coded Decimal) vectors.", "arch": "PowerISA"}, {"label": "vbcdsub (PowerISA)", "url": "powerisa/vbcdsub/", "summary": "Subtracts two BCD vectors.", "arch": "PowerISA"}, {"label": "dtstsfi (PowerISA)", "url": "powerisa/dtstsfi/", "summary": "Tests DFP significance (number of digits).", "arch": "PowerISA"}, {"label": "dtstsfiq (PowerISA)", "url": "powerisa/dtstsfiq/", "summary": "Tests DFP Quad significance.", "arch": "PowerISA"}, {"label": "cmpeqb (PowerISA)", "url": "powerisa/cmpeqb/", "summary": "Compares bytes in two GPRs for equality (Scalar).", "arch": "PowerISA"}, {"label": "cmpb (PowerISA)", "url": "powerisa/cmpb/", "summary": "Compares bytes in two GPRs, result is byte mask.", "arch": "PowerISA"}, {"label": "prtyw (PowerISA)", "url": "powerisa/prtyw/", "summary": "Calculates parity of a word (Scalar).", "arch": "PowerISA"}, {"label": "prtyd (PowerISA)", "url": "powerisa/prtyd/", "summary": "Calculates parity of a doubleword (Scalar).", "arch": "PowerISA"}, {"label": "modsw (PowerISA)", "url": "powerisa/modsw/", "summary": "Calculates remainder of signed word division.", "arch": "PowerISA"}, {"label": "moduw (PowerISA)", "url": "powerisa/moduw/", "summary": "Calculates remainder of unsigned word division.", "arch": "PowerISA"}, {"label": "modsd (PowerISA)", "url": "powerisa/modsd/", "summary": "Calculates remainder of signed doubleword division.", "arch": "PowerISA"}, {"label": "modud (PowerISA)", "url": "powerisa/modud/", "summary": "Calculates remainder of unsigned doubleword division.", "arch": "PowerISA"}, {"label": "ftdiv (PowerISA)", "url": "powerisa/ftdiv/", "summary": "Tests for conditions that would cause a divide exception.", "arch": "PowerISA"}, {"label": "ftsqrt (PowerISA)", "url": "powerisa/ftsqrt/", "summary": "Tests for conditions that would cause a sqrt exception.", "arch": "PowerISA"}, {"label": "fre (PowerISA)", "url": "powerisa/fre/", "summary": "Estimates 1/x (Double Precision).", "arch": "PowerISA"}, {"label": "fres (PowerISA)", "url": "powerisa/fres/", "summary": "Estimates 1/x (Single Precision).", "arch": "PowerISA"}, {"label": "frsqrte (PowerISA)", "url": "powerisa/frsqrte/", "summary": "Estimates 1/sqrt(x) (Double Precision).", "arch": "PowerISA"}, {"label": "frsqrtes (PowerISA)", "url": "powerisa/frsqrtes/", "summary": "Estimates 1/sqrt(x) (Single Precision).", "arch": "PowerISA"}, {"label": "rfebb (PowerISA)", "url": "powerisa/rfebb/", "summary": "Returns from an event handler (EBB).", "arch": "PowerISA"}, {"label": "setb (PowerISA)", "url": "powerisa/setb/", "summary": "Sets RT to -1, 0, or 1 based on CR field.", "arch": "PowerISA"}, {"label": "divde (PowerISA)", "url": "powerisa/divde/", "summary": "64-bit extended division.", "arch": "PowerISA"}, {"label": "divdeu (PowerISA)", "url": "powerisa/divdeu/", "summary": "64-bit extended unsigned division.", "arch": "PowerISA"}, {"label": "divwe (PowerISA)", "url": "powerisa/divwe/", "summary": "32-bit extended division.", "arch": "PowerISA"}, {"label": "divweu (PowerISA)", "url": "powerisa/divweu/", "summary": "32-bit extended unsigned division.", "arch": "PowerISA"}, {"label": "vand (PowerISA)", "url": "powerisa/vand/", "summary": "Bitwise AND of two 128-bit vectors.", "arch": "PowerISA"}, {"label": "vor (PowerISA)", "url": "powerisa/vor/", "summary": "Bitwise OR of two 128-bit vectors.", "arch": "PowerISA"}, {"label": "vxor (PowerISA)", "url": "powerisa/vxor/", "summary": "Bitwise XOR of two 128-bit vectors.", "arch": "PowerISA"}, {"label": "vnor (PowerISA)", "url": "powerisa/vnor/", "summary": "Bitwise NOR of two 128-bit vectors. (NOT (A OR B)).", "arch": "PowerISA"}, {"label": "vandc (PowerISA)", "url": "powerisa/vandc/", "summary": "Bitwise AND of vA with the ones' complement of vB (vA & ~vB).", "arch": "PowerISA"}, {"label": "vcmpequb (PowerISA)", "url": "powerisa/vcmpequb/", "summary": "Compares 16 bytes. Result is 0xFF (True) or 0x00 (False) per byte.", "arch": "PowerISA"}, {"label": "vcmpequh (PowerISA)", "url": "powerisa/vcmpequh/", "summary": "Compares 8 halfwords for equality.", "arch": "PowerISA"}, {"label": "vcmpequd (PowerISA)", "url": "powerisa/vcmpequd/", "summary": "Compares 2 doublewords for equality.", "arch": "PowerISA"}, {"label": "vcmpgtub (PowerISA)", "url": "powerisa/vcmpgtub/", "summary": "Unsigned > comparison for 16 bytes.", "arch": "PowerISA"}, {"label": "vcmpgtsb (PowerISA)", "url": "powerisa/vcmpgtsb/", "summary": "Signed > comparison for 16 bytes.", "arch": "PowerISA"}, {"label": "vcmpgtuh (PowerISA)", "url": "powerisa/vcmpgtuh/", "summary": "Unsigned > comparison for 8 halfwords.", "arch": "PowerISA"}, {"label": "vcmpgtsh (PowerISA)", "url": "powerisa/vcmpgtsh/", "summary": "Signed > comparison for 8 halfwords.", "arch": "PowerISA"}, {"label": "vcmpgtuw (PowerISA)", "url": "powerisa/vcmpgtuw/", "summary": "Unsigned > comparison for 4 words.", "arch": "PowerISA"}, {"label": "vcmpgtsw (PowerISA)", "url": "powerisa/vcmpgtsw/", "summary": "Signed > comparison for 4 words.", "arch": "PowerISA"}, {"label": "vcmpgtud (PowerISA)", "url": "powerisa/vcmpgtud/", "summary": "Unsigned > comparison for 2 doublewords.", "arch": "PowerISA"}, {"label": "vcmpgtsd (PowerISA)", "url": "powerisa/vcmpgtsd/", "summary": "Signed > comparison for 2 doublewords.", "arch": "PowerISA"}, {"label": "vavgub (PowerISA)", "url": "powerisa/vavgub/", "summary": "Computes (a+b+1)/2 for bytes.", "arch": "PowerISA"}, {"label": "vavgsb (PowerISA)", "url": "powerisa/vavgsb/", "summary": "Computes (a+b+1)/2 for signed bytes.", "arch": "PowerISA"}, {"label": "vavguh (PowerISA)", "url": "powerisa/vavguh/", "summary": "Computes (a+b+1)/2 for halfwords.", "arch": "PowerISA"}, {"label": "vavgsh (PowerISA)", "url": "powerisa/vavgsh/", "summary": "Computes (a+b+1)/2 for signed halfwords.", "arch": "PowerISA"}, {"label": "vavguw (PowerISA)", "url": "powerisa/vavguw/", "summary": "Computes (a+b+1)/2 for words.", "arch": "PowerISA"}, {"label": "vavgsw (PowerISA)", "url": "powerisa/vavgsw/", "summary": "Computes (a+b+1)/2 for signed words.", "arch": "PowerISA"}, {"label": "vminub (PowerISA)", "url": "powerisa/vminub/", "summary": "Selects minimum value per byte (unsigned).", "arch": "PowerISA"}, {"label": "vminsb (PowerISA)", "url": "powerisa/vminsb/", "summary": "Selects minimum value per byte (signed).", "arch": "PowerISA"}, {"label": "vminuh (PowerISA)", "url": "powerisa/vminuh/", "summary": "Selects minimum value per halfword (unsigned).", "arch": "PowerISA"}, {"label": "vminsh (PowerISA)", "url": "powerisa/vminsh/", "summary": "Selects minimum value per halfword (signed).", "arch": "PowerISA"}, {"label": "vminuw (PowerISA)", "url": "powerisa/vminuw/", "summary": "Selects minimum value per word (unsigned).", "arch": "PowerISA"}, {"label": "vminsw (PowerISA)", "url": "powerisa/vminsw/", "summary": "Selects minimum value per word (signed).", "arch": "PowerISA"}, {"label": "vmaxub (PowerISA)", "url": "powerisa/vmaxub/", "summary": "Selects maximum value per byte (unsigned).", "arch": "PowerISA"}, {"label": "vmaxsb (PowerISA)", "url": "powerisa/vmaxsb/", "summary": "Selects maximum value per byte (signed).", "arch": "PowerISA"}, {"label": "vmaxuh (PowerISA)", "url": "powerisa/vmaxuh/", "summary": "Selects maximum value per halfword (unsigned).", "arch": "PowerISA"}, {"label": "vmaxsh (PowerISA)", "url": "powerisa/vmaxsh/", "summary": "Selects maximum value per halfword (signed).", "arch": "PowerISA"}, {"label": "vmaxuw (PowerISA)", "url": "powerisa/vmaxuw/", "summary": "Selects maximum value per word (unsigned).", "arch": "PowerISA"}, {"label": "vmaxsw (PowerISA)", "url": "powerisa/vmaxsw/", "summary": "Selects maximum value per word (signed).", "arch": "PowerISA"}, {"label": "vmrghb (PowerISA)", "url": "powerisa/vmrghb/", "summary": "Interleaves high-order bytes from two vectors (Permutation).", "arch": "PowerISA"}, {"label": "vmrghh (PowerISA)", "url": "powerisa/vmrghh/", "summary": "Interleaves high-order halfwords.", "arch": "PowerISA"}, {"label": "vmrghw (PowerISA)", "url": "powerisa/vmrghw/", "summary": "Interleaves high-order words.", "arch": "PowerISA"}, {"label": "vmrglb (PowerISA)", "url": "powerisa/vmrglb/", "summary": "Interleaves low-order bytes.", "arch": "PowerISA"}, {"label": "vmrglh (PowerISA)", "url": "powerisa/vmrglh/", "summary": "Interleaves low-order halfwords.", "arch": "PowerISA"}, {"label": "vmrglw (PowerISA)", "url": "powerisa/vmrglw/", "summary": "Interleaves low-order words.", "arch": "PowerISA"}, {"label": "vpkuhum (PowerISA)", "url": "powerisa/vpkuhum/", "summary": "Truncates 8 halfwords to 16 bytes (modulo 256).", "arch": "PowerISA"}, {"label": "vpkuwum (PowerISA)", "url": "powerisa/vpkuwum/", "summary": "Truncates 4 words to 8 halfwords.", "arch": "PowerISA"}, {"label": "vpkuhus (PowerISA)", "url": "powerisa/vpkuhus/", "summary": "Saturates 8 halfwords to 16 unsigned bytes.", "arch": "PowerISA"}, {"label": "vpkshss (PowerISA)", "url": "powerisa/vpkshss/", "summary": "Saturates 8 signed halfwords to 16 signed bytes.", "arch": "PowerISA"}, {"label": "vpkswss (PowerISA)", "url": "powerisa/vpkswss/", "summary": "Saturates 4 signed words to 8 signed halfwords.", "arch": "PowerISA"}, {"label": "vupkhsb (PowerISA)", "url": "powerisa/vupkhsb/", "summary": "Unpacks high 8 signed bytes to 8 signed halfwords.", "arch": "PowerISA"}, {"label": "vupkhsh (PowerISA)", "url": "powerisa/vupkhsh/", "summary": "Unpacks high 4 signed halfwords to 4 signed words.", "arch": "PowerISA"}, {"label": "vupklsb (PowerISA)", "url": "powerisa/vupklsb/", "summary": "Unpacks low 8 signed bytes to 8 signed halfwords.", "arch": "PowerISA"}, {"label": "vupklsh (PowerISA)", "url": "powerisa/vupklsh/", "summary": "Unpacks low 4 signed halfwords to 4 signed words.", "arch": "PowerISA"}, {"label": "vaddubm (PowerISA)", "url": "powerisa/vaddubm/", "summary": "Adds 16 bytes modulo 256.", "arch": "PowerISA"}, {"label": "vadduhm (PowerISA)", "url": "powerisa/vadduhm/", "summary": "Adds 8 halfwords modulo 65536.", "arch": "PowerISA"}, {"label": "vadduwm (PowerISA)", "url": "powerisa/vadduwm/", "summary": "Adds 4 words modulo 2^32.", "arch": "PowerISA"}, {"label": "vaddudm (PowerISA)", "url": "powerisa/vaddudm/", "summary": "Adds 2 doublewords modulo 2^64.", "arch": "PowerISA"}, {"label": "vaddubs (PowerISA)", "url": "powerisa/vaddubs/", "summary": "Adds 16 unsigned bytes with saturation (0..255).", "arch": "PowerISA"}, {"label": "vadduhs (PowerISA)", "url": "powerisa/vadduhs/", "summary": "Adds 8 unsigned halfwords with saturation.", "arch": "PowerISA"}, {"label": "vadduws (PowerISA)", "url": "powerisa/vadduws/", "summary": "Adds 4 unsigned words with saturation.", "arch": "PowerISA"}, {"label": "vaddsbs (PowerISA)", "url": "powerisa/vaddsbs/", "summary": "Adds 16 signed bytes with saturation (-128..127).", "arch": "PowerISA"}, {"label": "vaddshs (PowerISA)", "url": "powerisa/vaddshs/", "summary": "Adds 8 signed halfwords with saturation.", "arch": "PowerISA"}, {"label": "vaddsws (PowerISA)", "url": "powerisa/vaddsws/", "summary": "Adds 4 signed words with saturation.", "arch": "PowerISA"}, {"label": "vsububm (PowerISA)", "url": "powerisa/vsububm/", "summary": "Subtracts 16 bytes modulo 256.", "arch": "PowerISA"}, {"label": "vsubuhm (PowerISA)", "url": "powerisa/vsubuhm/", "summary": "Subtracts 8 halfwords modulo 65536.", "arch": "PowerISA"}, {"label": "vsubudm (PowerISA)", "url": "powerisa/vsubudm/", "summary": "Subtracts 2 doublewords modulo 2^64.", "arch": "PowerISA"}, {"label": "vsububs (PowerISA)", "url": "powerisa/vsububs/", "summary": "Subtracts 16 unsigned bytes with saturation.", "arch": "PowerISA"}, {"label": "vsubuhs (PowerISA)", "url": "powerisa/vsubuhs/", "summary": "Subtracts 8 unsigned halfwords with saturation.", "arch": "PowerISA"}, {"label": "vsubuws (PowerISA)", "url": "powerisa/vsubuws/", "summary": "Subtracts 4 unsigned words with saturation.", "arch": "PowerISA"}, {"label": "vsubsbs (PowerISA)", "url": "powerisa/vsubsbs/", "summary": "Subtracts 16 signed bytes with saturation.", "arch": "PowerISA"}, {"label": "vsubshs (PowerISA)", "url": "powerisa/vsubshs/", "summary": "Subtracts 8 signed halfwords with saturation.", "arch": "PowerISA"}, {"label": "vsubsws (PowerISA)", "url": "powerisa/vsubsws/", "summary": "Subtracts 4 signed words with saturation.", "arch": "PowerISA"}, {"label": "xsaddsp (PowerISA)", "url": "powerisa/xsaddsp/", "summary": "Scalar float addition (32-bit).", "arch": "PowerISA"}, {"label": "xssubsp (PowerISA)", "url": "powerisa/xssubsp/", "summary": "Scalar float subtraction (32-bit).", "arch": "PowerISA"}, {"label": "xsmulsp (PowerISA)", "url": "powerisa/xsmulsp/", "summary": "Scalar float multiplication (32-bit).", "arch": "PowerISA"}, {"label": "xsdivsp (PowerISA)", "url": "powerisa/xsdivsp/", "summary": "Scalar float division (32-bit).", "arch": "PowerISA"}, {"label": "xsmaxdp (PowerISA)", "url": "powerisa/xsmaxdp/", "summary": "Scalar maximum (64-bit float).", "arch": "PowerISA"}, {"label": "xsmindp (PowerISA)", "url": "powerisa/xsmindp/", "summary": "Scalar minimum (64-bit float).", "arch": "PowerISA"}, {"label": "xssqrtdp (PowerISA)", "url": "powerisa/xssqrtdp/", "summary": "Scalar square root (64-bit float).", "arch": "PowerISA"}, {"label": "xsabsdp (PowerISA)", "url": "powerisa/xsabsdp/", "summary": "Scalar absolute value (64-bit float).", "arch": "PowerISA"}, {"label": "xsnegdp (PowerISA)", "url": "powerisa/xsnegdp/", "summary": "Scalar negation (64-bit float).", "arch": "PowerISA"}, {"label": "xscmpodp (PowerISA)", "url": "powerisa/xscmpodp/", "summary": "Scalar compare (Exceptions on NaN).", "arch": "PowerISA"}, {"label": "xscmpudp (PowerISA)", "url": "powerisa/xscmpudp/", "summary": "Scalar compare (No exceptions on NaN).", "arch": "PowerISA"}, {"label": "vsl (PowerISA)", "url": "powerisa/vsl/", "summary": "Shifts vector left by octet count in vB.", "arch": "PowerISA"}, {"label": "vsr (PowerISA)", "url": "powerisa/vsr/", "summary": "Shifts vector right by octet count in vB.", "arch": "PowerISA"}, {"label": "vslo (PowerISA)", "url": "powerisa/vslo/", "summary": "Shifts vector left by byte count.", "arch": "PowerISA"}, {"label": "vsro (PowerISA)", "url": "powerisa/vsro/", "summary": "Shifts vector right by byte count.", "arch": "PowerISA"}, {"label": "vrlb (PowerISA)", "url": "powerisa/vrlb/", "summary": "Rotates each byte left.", "arch": "PowerISA"}, {"label": "vrlh (PowerISA)", "url": "powerisa/vrlh/", "summary": "Rotates each halfword left.", "arch": "PowerISA"}, {"label": "vrlw (PowerISA)", "url": "powerisa/vrlw/", "summary": "Rotates each word left.", "arch": "PowerISA"}, {"label": "vrld (PowerISA)", "url": "powerisa/vrld/", "summary": "Rotates each doubleword left.", "arch": "PowerISA"}, {"label": "daddq (PowerISA)", "url": "powerisa/daddq/", "summary": "Adds two 128-bit DFP numbers.", "arch": "PowerISA"}, {"label": "dsubq (PowerISA)", "url": "powerisa/dsubq/", "summary": "Subtracts two 128-bit DFP numbers.", "arch": "PowerISA"}, {"label": "dmulq (PowerISA)", "url": "powerisa/dmulq/", "summary": "Multiplies two 128-bit DFP numbers.", "arch": "PowerISA"}, {"label": "ddivq (PowerISA)", "url": "powerisa/ddivq/", "summary": "Divides two 128-bit DFP numbers.", "arch": "PowerISA"}, {"label": "dcmpuq (PowerISA)", "url": "powerisa/dcmpuq/", "summary": "Compares two 128-bit DFP numbers (Non-signaling).", "arch": "PowerISA"}, {"label": "dcmpoq (PowerISA)", "url": "powerisa/dcmpoq/", "summary": "Compares two 128-bit DFP numbers (Signaling).", "arch": "PowerISA"}, {"label": "dquaq (PowerISA)", "url": "powerisa/dquaq/", "summary": "Adjusts exponent of 128-bit DFP number.", "arch": "PowerISA"}, {"label": "drrndq (PowerISA)", "url": "powerisa/drrndq/", "summary": "Rerounds a 128-bit DFP number to fewer digits.", "arch": "PowerISA"}, {"label": "dcffixq (PowerISA)", "url": "powerisa/dcffixq/", "summary": "Converts 64-bit integer to 128-bit DFP.", "arch": "PowerISA"}, {"label": "dctfixq (PowerISA)", "url": "powerisa/dctfixq/", "summary": "Converts 128-bit DFP to 64-bit integer.", "arch": "PowerISA"}, {"label": "dxexq (PowerISA)", "url": "powerisa/dxexq/", "summary": "Extracts exponent from 128-bit DFP.", "arch": "PowerISA"}, {"label": "diexq (PowerISA)", "url": "powerisa/diexq/", "summary": "Inserts exponent into 128-bit DFP.", "arch": "PowerISA"}, {"label": "denbcdq (PowerISA)", "url": "powerisa/denbcdq/", "summary": "Encodes 128-bit DFP to BCD.", "arch": "PowerISA"}, {"label": "ddedpdq (PowerISA)", "url": "powerisa/ddedpdq/", "summary": "Decodes BCD to 128-bit DFP.", "arch": "PowerISA"}, {"label": "vspltb (PowerISA)", "url": "powerisa/vspltb/", "summary": "Duplicates a byte element across the vector.", "arch": "PowerISA"}, {"label": "vsplth (PowerISA)", "url": "powerisa/vsplth/", "summary": "Duplicates a halfword element across the vector.", "arch": "PowerISA"}, {"label": "vspltisb (PowerISA)", "url": "powerisa/vspltisb/", "summary": "Fills vector with immediate 5-bit signed value (-16 to 15).", "arch": "PowerISA"}, {"label": "vspltish (PowerISA)", "url": "powerisa/vspltish/", "summary": "Fills vector with immediate 5-bit signed value.", "arch": "PowerISA"}, {"label": "vspltisw (PowerISA)", "url": "powerisa/vspltisw/", "summary": "Fills vector with immediate 5-bit signed value.", "arch": "PowerISA"}, {"label": "vslb (PowerISA)", "url": "powerisa/vslb/", "summary": "Shifts each byte left.", "arch": "PowerISA"}, {"label": "vslh (PowerISA)", "url": "powerisa/vslh/", "summary": "Shifts each halfword left.", "arch": "PowerISA"}, {"label": "vsrb (PowerISA)", "url": "powerisa/vsrb/", "summary": "Shifts each byte right.", "arch": "PowerISA"}, {"label": "vsrh (PowerISA)", "url": "powerisa/vsrh/", "summary": "Shifts each halfword right.", "arch": "PowerISA"}, {"label": "vsrw (PowerISA)", "url": "powerisa/vsrw/", "summary": "Shifts each word right.", "arch": "PowerISA"}, {"label": "vsrab (PowerISA)", "url": "powerisa/vsrab/", "summary": "Arithmetic right shift of bytes.", "arch": "PowerISA"}, {"label": "vsrah (PowerISA)", "url": "powerisa/vsrah/", "summary": "Arithmetic right shift of halfwords.", "arch": "PowerISA"}, {"label": "vsraw (PowerISA)", "url": "powerisa/vsraw/", "summary": "Arithmetic right shift of words.", "arch": "PowerISA"}, {"label": "vmrgew (PowerISA)", "url": "powerisa/vmrgew/", "summary": "Merges even words from two vectors.", "arch": "PowerISA"}, {"label": "vmrgow (PowerISA)", "url": "powerisa/vmrgow/", "summary": "Merges odd words from two vectors.", "arch": "PowerISA"}, {"label": "vmulesb (PowerISA)", "url": "powerisa/vmulesb/", "summary": "Multiplies even signed bytes to halfwords.", "arch": "PowerISA"}, {"label": "vmuleub (PowerISA)", "url": "powerisa/vmuleub/", "summary": "Multiplies even unsigned bytes to halfwords.", "arch": "PowerISA"}, {"label": "vmulesh (PowerISA)", "url": "powerisa/vmulesh/", "summary": "Multiplies even signed halfwords to words.", "arch": "PowerISA"}, {"label": "vmuleuh (PowerISA)", "url": "powerisa/vmuleuh/", "summary": "Multiplies even unsigned halfwords to words.", "arch": "PowerISA"}, {"label": "vmulosb (PowerISA)", "url": "powerisa/vmulosb/", "summary": "Multiplies odd signed bytes to halfwords.", "arch": "PowerISA"}, {"label": "vmuloub (PowerISA)", "url": "powerisa/vmuloub/", "summary": "Multiplies odd unsigned bytes to halfwords.", "arch": "PowerISA"}, {"label": "vmulosh (PowerISA)", "url": "powerisa/vmulosh/", "summary": "Multiplies odd signed halfwords to words.", "arch": "PowerISA"}, {"label": "vmulouh (PowerISA)", "url": "powerisa/vmulouh/", "summary": "Multiplies odd unsigned halfwords to words.", "arch": "PowerISA"}, {"label": "vabsdub (PowerISA)", "url": "powerisa/vabsdub/", "summary": "Computes |A - B| for bytes.", "arch": "PowerISA"}, {"label": "vabsduh (PowerISA)", "url": "powerisa/vabsduh/", "summary": "Computes |A - B| for halfwords.", "arch": "PowerISA"}, {"label": "vabsduw (PowerISA)", "url": "powerisa/vabsduw/", "summary": "Computes |A - B| for words.", "arch": "PowerISA"}, {"label": "xsmaxcqp (PowerISA)", "url": "powerisa/xsmaxcqp/", "summary": "Max of Quad float (IEEE 754-2008 specific rules).", "arch": "PowerISA"}, {"label": "xsmincqp (PowerISA)", "url": "powerisa/xsmincqp/", "summary": "Min of Quad float (IEEE 754-2008 specific rules).", "arch": "PowerISA"}, {"label": "xscpsgnqp (PowerISA)", "url": "powerisa/xscpsgnqp/", "summary": "Copies sign from B to A (128-bit).", "arch": "PowerISA"}, {"label": "xststdcqp (PowerISA)", "url": "powerisa/xststdcqp/", "summary": "Tests class of Quad float (NaN/Inf/Zero).", "arch": "PowerISA"}, {"label": "xscmpexpqp (PowerISA)", "url": "powerisa/xscmpexpqp/", "summary": "Compares exponents of two Quad floats.", "arch": "PowerISA"}, {"label": "tcheck (PowerISA)", "url": "powerisa/tcheck/", "summary": "Checks transaction status and updates CR.", "arch": "PowerISA"}, {"label": "tsuspend (PowerISA)", "url": "powerisa/tsuspend/", "summary": "Suspends the current transaction.", "arch": "PowerISA"}, {"label": "tresume (PowerISA)", "url": "powerisa/tresume/", "summary": "Resumes a suspended transaction.", "arch": "PowerISA"}, {"label": "dcbtls (PowerISA)", "url": "powerisa/dcbtls/", "summary": "Locks a cache line in the L1 cache.", "arch": "PowerISA"}, {"label": "icbtls (PowerISA)", "url": "powerisa/icbtls/", "summary": "Locks an instruction cache line.", "arch": "PowerISA"}, {"label": "tlbsync (PowerISA)", "url": "powerisa/tlbsync/", "summary": "Ensures TLB invalidations have propagated to all processors.", "arch": "PowerISA"}, {"label": "slbsync (PowerISA)", "url": "powerisa/slbsync/", "summary": "Ensures SLB invalidations have propagated.", "arch": "PowerISA"}, {"label": "lbarx (PowerISA)", "url": "powerisa/lbarx/", "summary": "Atomic Load Byte.", "arch": "PowerISA"}, {"label": "lharx (PowerISA)", "url": "powerisa/lharx/", "summary": "Atomic Load Halfword.", "arch": "PowerISA"}, {"label": "lqarx (PowerISA)", "url": "powerisa/lqarx/", "summary": "Atomic Load 128-bit Quadword.", "arch": "PowerISA"}, {"label": "stbcx. (PowerISA)", "url": "powerisa/stbcx_/", "summary": "Atomic Store Byte.", "arch": "PowerISA"}, {"label": "sthcx. (PowerISA)", "url": "powerisa/sthcx_/", "summary": "Atomic Store Halfword.", "arch": "PowerISA"}, {"label": "efststeq (PowerISA)", "url": "powerisa/efststeq/", "summary": "Tests if two single-precision floats are equal, setting CR field.", "arch": "PowerISA"}, {"label": "efststgt (PowerISA)", "url": "powerisa/efststgt/", "summary": "Tests if single-precision A > B.", "arch": "PowerISA"}, {"label": "efststlt (PowerISA)", "url": "powerisa/efststlt/", "summary": "Tests if single-precision A < B.", "arch": "PowerISA"}, {"label": "efdtsteq (PowerISA)", "url": "powerisa/efdtsteq/", "summary": "Tests if two double-precision floats are equal.", "arch": "PowerISA"}, {"label": "efdtstgt (PowerISA)", "url": "powerisa/efdtstgt/", "summary": "Tests if double-precision A > B.", "arch": "PowerISA"}, {"label": "efdtstlt (PowerISA)", "url": "powerisa/efdtstlt/", "summary": "Tests if double-precision A < B.", "arch": "PowerISA"}, {"label": "efscfd (PowerISA)", "url": "powerisa/efscfd/", "summary": "Converts double-precision to single-precision.", "arch": "PowerISA"}, {"label": "efdcfs (PowerISA)", "url": "powerisa/efdcfs/", "summary": "Converts single-precision to double-precision.", "arch": "PowerISA"}, {"label": "efscfsi (PowerISA)", "url": "powerisa/efscfsi/", "summary": "Converts signed 32-bit integer to single-precision float.", "arch": "PowerISA"}, {"label": "efscfui (PowerISA)", "url": "powerisa/efscfui/", "summary": "Converts unsigned 32-bit integer to single-precision float.", "arch": "PowerISA"}, {"label": "efsctsi (PowerISA)", "url": "powerisa/efsctsi/", "summary": "Converts single-precision float to signed 32-bit integer.", "arch": "PowerISA"}, {"label": "efsctui (PowerISA)", "url": "powerisa/efsctui/", "summary": "Converts single-precision float to unsigned 32-bit integer.", "arch": "PowerISA"}, {"label": "efsctsiz (PowerISA)", "url": "powerisa/efsctsiz/", "summary": "Converts float to integer (Truncate).", "arch": "PowerISA"}, {"label": "efsctuiz (PowerISA)", "url": "powerisa/efsctuiz/", "summary": "Converts float to unsigned integer (Truncate).", "arch": "PowerISA"}, {"label": "efscfsf (PowerISA)", "url": "powerisa/efscfsf/", "summary": "Converts 32-bit signed fractional to float.", "arch": "PowerISA"}, {"label": "efscfuf (PowerISA)", "url": "powerisa/efscfuf/", "summary": "Converts 32-bit unsigned fractional to float.", "arch": "PowerISA"}, {"label": "evcmpeq (PowerISA)", "url": "powerisa/evcmpeq/", "summary": "Compares two vectors for equality, setting CR field.", "arch": "PowerISA"}, {"label": "evcmpgtu (PowerISA)", "url": "powerisa/evcmpgtu/", "summary": "Compares vectors (unsigned A > B).", "arch": "PowerISA"}, {"label": "evcmpgts (PowerISA)", "url": "powerisa/evcmpgts/", "summary": "Compares vectors (signed A > B).", "arch": "PowerISA"}, {"label": "evcmpltu (PowerISA)", "url": "powerisa/evcmpltu/", "summary": "Compares vectors (unsigned A < B).", "arch": "PowerISA"}, {"label": "evcmplts (PowerISA)", "url": "powerisa/evcmplts/", "summary": "Compares vectors (signed A < B).", "arch": "PowerISA"}, {"label": "evsel (PowerISA)", "url": "powerisa/evsel/", "summary": "Selects bits from RA or RB based on CR field.", "arch": "PowerISA"}, {"label": "evfsadd (PowerISA)", "url": "powerisa/evfsadd/", "summary": "Adds two vectors of single-precision floats.", "arch": "PowerISA"}, {"label": "evfssub (PowerISA)", "url": "powerisa/evfssub/", "summary": "Subtracts two vectors of single-precision floats.", "arch": "PowerISA"}, {"label": "evfsmul (PowerISA)", "url": "powerisa/evfsmul/", "summary": "Multiplies two vectors of single-precision floats.", "arch": "PowerISA"}, {"label": "evfsdiv (PowerISA)", "url": "powerisa/evfsdiv/", "summary": "Divides two vectors of single-precision floats.", "arch": "PowerISA"}, {"label": "evfsabs (PowerISA)", "url": "powerisa/evfsabs/", "summary": "Computes absolute value of floats in vector.", "arch": "PowerISA"}, {"label": "evfsneg (PowerISA)", "url": "powerisa/evfsneg/", "summary": "Negates floats in vector.", "arch": "PowerISA"}, {"label": "evfscfsi (PowerISA)", "url": "powerisa/evfscfsi/", "summary": "Converts vector of signed integers to floats.", "arch": "PowerISA"}, {"label": "evfsctsi (PowerISA)", "url": "powerisa/evfsctsi/", "summary": "Converts vector of floats to signed integers.", "arch": "PowerISA"}, {"label": "macchw (PowerISA)", "url": "powerisa/macchw/", "summary": "Multiply bottom half of RA by top half of RB, add to RT.", "arch": "PowerISA"}, {"label": "macchws (PowerISA)", "url": "powerisa/macchws/", "summary": "Signed Multiply Accumulate Cross Halfword with Saturation.", "arch": "PowerISA"}, {"label": "macchwu (PowerISA)", "url": "powerisa/macchwu/", "summary": "Unsigned Multiply Accumulate Cross Halfword.", "arch": "PowerISA"}, {"label": "macchwsu (PowerISA)", "url": "powerisa/macchwsu/", "summary": "Mixed Sign Multiply Accumulate Cross Halfword with Saturation.", "arch": "PowerISA"}, {"label": "machhw (PowerISA)", "url": "powerisa/machhw/", "summary": "Multiply top half of RA by top half of RB, add to RT.", "arch": "PowerISA"}, {"label": "machhws (PowerISA)", "url": "powerisa/machhws/", "summary": "Signed Multiply Accumulate High Halfword with Saturation.", "arch": "PowerISA"}, {"label": "machhwu (PowerISA)", "url": "powerisa/machhwu/", "summary": "Unsigned Multiply Accumulate High Halfword.", "arch": "PowerISA"}, {"label": "machhwsu (PowerISA)", "url": "powerisa/machhwsu/", "summary": "Mixed Sign Multiply Accumulate High Halfword with Saturation.", "arch": "PowerISA"}, {"label": "maclhw (PowerISA)", "url": "powerisa/maclhw/", "summary": "Multiply bottom half of RA by bottom half of RB, add to RT.", "arch": "PowerISA"}, {"label": "maclhws (PowerISA)", "url": "powerisa/maclhws/", "summary": "Signed Multiply Accumulate Low Halfword with Saturation.", "arch": "PowerISA"}, {"label": "maclhwu (PowerISA)", "url": "powerisa/maclhwu/", "summary": "Unsigned Multiply Accumulate Low Halfword.", "arch": "PowerISA"}, {"label": "maclhwsu (PowerISA)", "url": "powerisa/maclhwsu/", "summary": "Mixed Sign Multiply Accumulate Low Halfword with Saturation.", "arch": "PowerISA"}, {"label": "mulchw (PowerISA)", "url": "powerisa/mulchw/", "summary": "Multiply bottom half of RA by top half of RB.", "arch": "PowerISA"}, {"label": "mulchwu (PowerISA)", "url": "powerisa/mulchwu/", "summary": "Unsigned Multiply Cross Halfword.", "arch": "PowerISA"}, {"label": "mulhhw (PowerISA)", "url": "powerisa/mulhhw/", "summary": "Multiply top half of RA by top half of RB.", "arch": "PowerISA"}, {"label": "mulhhwu (PowerISA)", "url": "powerisa/mulhhwu/", "summary": "Unsigned Multiply High Halfword.", "arch": "PowerISA"}, {"label": "mullhw (PowerISA)", "url": "powerisa/mullhw/", "summary": "Multiply bottom half of RA by bottom half of RB.", "arch": "PowerISA"}, {"label": "mullhwu (PowerISA)", "url": "powerisa/mullhwu/", "summary": "Unsigned Multiply Low Halfword.", "arch": "PowerISA"}, {"label": "nmacchw (PowerISA)", "url": "powerisa/nmacchw/", "summary": "Negate product of cross halfwords and add to accumulator.", "arch": "PowerISA"}, {"label": "nmacchws (PowerISA)", "url": "powerisa/nmacchws/", "summary": "Negate product of cross halfwords and add to accumulator (Signed Saturation).", "arch": "PowerISA"}, {"label": "nmachhw (PowerISA)", "url": "powerisa/nmachhw/", "summary": "Negate product of high halfwords and add to accumulator.", "arch": "PowerISA"}, {"label": "nmachhws (PowerISA)", "url": "powerisa/nmachhws/", "summary": "Negate product of high halfwords and add to accumulator (Signed Saturation).", "arch": "PowerISA"}, {"label": "nmaclhw (PowerISA)", "url": "powerisa/nmaclhw/", "summary": "Negate product of low halfwords and add to accumulator.", "arch": "PowerISA"}, {"label": "nmaclhws (PowerISA)", "url": "powerisa/nmaclhws/", "summary": "Negate product of low halfwords and add to accumulator (Signed Saturation).", "arch": "PowerISA"}, {"label": "dccci (PowerISA)", "url": "powerisa/dccci/", "summary": "Invalidates a congruence class in the data cache (Embedded).", "arch": "PowerISA"}, {"label": "dcread (PowerISA)", "url": "powerisa/dcread/", "summary": "Reads a data cache tag or data (Debug).", "arch": "PowerISA"}, {"label": "iccci (PowerISA)", "url": "powerisa/iccci/", "summary": "Invalidates a congruence class in the instruction cache (Embedded).", "arch": "PowerISA"}, {"label": "icread (PowerISA)", "url": "powerisa/icread/", "summary": "Reads an instruction cache tag or data (Debug).", "arch": "PowerISA"}, {"label": "tlbre (PowerISA)", "url": "powerisa/tlbre/", "summary": "Reads a TLB entry into MAS registers.", "arch": "PowerISA"}, {"label": "tlbwe (PowerISA)", "url": "powerisa/tlbwe/", "summary": "Writes a TLB entry from MAS registers.", "arch": "PowerISA"}, {"label": "tlbsx (PowerISA)", "url": "powerisa/tlbsx/", "summary": "Searches the TLB for an address.", "arch": "PowerISA"}, {"label": "tlbivax (PowerISA)", "url": "powerisa/tlbivax/", "summary": "Invalidates a TLB entry by virtual address.", "arch": "PowerISA"}, {"label": "wrtee (PowerISA)", "url": "powerisa/wrtee/", "summary": "Updates the EE bit of the MSR from a GPR.", "arch": "PowerISA"}, {"label": "wrteei (PowerISA)", "url": "powerisa/wrteei/", "summary": "Updates the EE bit of the MSR from an immediate.", "arch": "PowerISA"}, {"label": "mfdcr (PowerISA)", "url": "powerisa/mfdcr/", "summary": "Reads an on-chip peripheral register (DCR).", "arch": "PowerISA"}, {"label": "mtdcr (PowerISA)", "url": "powerisa/mtdcr/", "summary": "Writes an on-chip peripheral register (DCR).", "arch": "PowerISA"}, {"label": "slw (PowerISA)", "url": "powerisa/slw/", "summary": "Shifts a 32-bit register left by the amount specified in RB.", "arch": "PowerISA"}, {"label": "sld (PowerISA)", "url": "powerisa/sld/", "summary": "Shifts a 64-bit register left by the amount specified in RB.", "arch": "PowerISA"}, {"label": "srw (PowerISA)", "url": "powerisa/srw/", "summary": "Performs a logical right shift (zeros shifted in) on a 32-bit word.", "arch": "PowerISA"}, {"label": "sraw (PowerISA)", "url": "powerisa/sraw/", "summary": "Performs an arithmetic right shift (sign bit replicated) on a 32-bit word. Updates Carry (CA) if bits are shifted out.", "arch": "PowerISA"}, {"label": "srawi (PowerISA)", "url": "powerisa/srawi/", "summary": "Performs an arithmetic right shift on a 32-bit word by a constant amount.", "arch": "PowerISA"}, {"label": "srad (PowerISA)", "url": "powerisa/srad/", "summary": "Performs an arithmetic right shift on a 64-bit doubleword.", "arch": "PowerISA"}, {"label": "sradi (PowerISA)", "url": "powerisa/sradi/", "summary": "Performs an arithmetic right shift on a 64-bit doubleword by a constant amount.", "arch": "PowerISA"}, {"label": "stb (PowerISA)", "url": "powerisa/stb/", "summary": "Stores the low 8 bits of a register to memory.", "arch": "PowerISA"}, {"label": "sth (PowerISA)", "url": "powerisa/sth/", "summary": "Stores the low 16 bits of a register to memory.", "arch": "PowerISA"}, {"label": "stw (PowerISA)", "url": "powerisa/stw/", "summary": "Stores the low 32 bits of a register to memory.", "arch": "PowerISA"}, {"label": "std (PowerISA)", "url": "powerisa/std/", "summary": "Stores a 64-bit doubleword to memory.", "arch": "PowerISA"}, {"label": "stwcx. (PowerISA)", "url": "powerisa/stwcx_/", "summary": "Stores a word only if the reservation created by 'lwarx' still exists. Used for atomic operations. Sets CR0.", "arch": "PowerISA"}, {"label": "stdcx. (PowerISA)", "url": "powerisa/stdcx_/", "summary": "Stores a doubleword only if the reservation exists. 64-bit version of stwcx.", "arch": "PowerISA"}, {"label": "sc (PowerISA)", "url": "powerisa/sc/", "summary": "Interrupts the program to request a service from the operating system (Supervisor Call).", "arch": "PowerISA"}, {"label": "trap (PowerISA)", "url": "powerisa/trap/", "summary": "Unconditional trap. Forces an exception. (Encoded as tw 31, 0, 0).", "arch": "PowerISA"}, {"label": "td (PowerISA)", "url": "powerisa/td/", "summary": "Traps if the condition specified by TO (Trap Options) is met between two 64-bit registers.", "arch": "PowerISA"}, {"label": "xor (PowerISA)", "url": "powerisa/xor/", "summary": "Performs a bitwise Exclusive OR comparison.", "arch": "PowerISA"}, {"label": "xori (PowerISA)", "url": "powerisa/xori/", "summary": "Performs a bitwise XOR with a 16-bit unsigned immediate.", "arch": "PowerISA"}, {"label": "xoris (PowerISA)", "url": "powerisa/xoris/", "summary": "Performs a bitwise XOR with a 16-bit immediate shifted left by 16 bits.", "arch": "PowerISA"}, {"label": "xvsubdp (PowerISA)", "url": "powerisa/xvsubdp/", "summary": "Subtracts two pairs of double-precision floats. (vD = vA - vB)", "arch": "PowerISA"}, {"label": "xvmuldp (PowerISA)", "url": "powerisa/xvmuldp/", "summary": "Multiplies two pairs of double-precision floats.", "arch": "PowerISA"}, {"label": "xvdivdp (PowerISA)", "url": "powerisa/xvdivdp/", "summary": "Divides two pairs of double-precision floats.", "arch": "PowerISA"}, {"label": "xvabsdp (PowerISA)", "url": "powerisa/xvabsdp/", "summary": "Computes absolute value for two double-precision floats.", "arch": "PowerISA"}, {"label": "xvnegdp (PowerISA)", "url": "powerisa/xvnegdp/", "summary": "Negates two double-precision floats.", "arch": "PowerISA"}, {"label": "xvsqrtdp (PowerISA)", "url": "powerisa/xvsqrtdp/", "summary": "Computes square root for two double-precision floats.", "arch": "PowerISA"}, {"label": "xvmaxdp (PowerISA)", "url": "powerisa/xvmaxdp/", "summary": "Selects maximum value for two pairs of doubles.", "arch": "PowerISA"}, {"label": "xvmindp (PowerISA)", "url": "powerisa/xvmindp/", "summary": "Selects minimum value for two pairs of doubles.", "arch": "PowerISA"}, {"label": "xvcmpeqdp (PowerISA)", "url": "powerisa/xvcmpeqdp/", "summary": "Compares doubles for equality. Sets result to all 1s or 0s.", "arch": "PowerISA"}, {"label": "xvcmpgtdp (PowerISA)", "url": "powerisa/xvcmpgtdp/", "summary": "Compares doubles (A > B).", "arch": "PowerISA"}, {"label": "xvcmpgedp (PowerISA)", "url": "powerisa/xvcmpgedp/", "summary": "Compares doubles (A >= B).", "arch": "PowerISA"}, {"label": "xvaddsp (PowerISA)", "url": "powerisa/xvaddsp/", "summary": "Adds four single-precision floats.", "arch": "PowerISA"}, {"label": "xvsubsp (PowerISA)", "url": "powerisa/xvsubsp/", "summary": "Subtracts four single-precision floats.", "arch": "PowerISA"}, {"label": "xvmulsp (PowerISA)", "url": "powerisa/xvmulsp/", "summary": "Multiplies four single-precision floats.", "arch": "PowerISA"}, {"label": "xvdivsp (PowerISA)", "url": "powerisa/xvdivsp/", "summary": "Divides four single-precision floats.", "arch": "PowerISA"}, {"label": "xvabssp (PowerISA)", "url": "powerisa/xvabssp/", "summary": "Computes absolute value for four single-precision floats.", "arch": "PowerISA"}, {"label": "xvnegsp (PowerISA)", "url": "powerisa/xvnegsp/", "summary": "Negates four single-precision floats.", "arch": "PowerISA"}, {"label": "xvsqrtsp (PowerISA)", "url": "powerisa/xvsqrtsp/", "summary": "Computes square root for four single-precision floats.", "arch": "PowerISA"}, {"label": "xvmaxsp (PowerISA)", "url": "powerisa/xvmaxsp/", "summary": "Selects maximum value for four floats.", "arch": "PowerISA"}, {"label": "xvminsp (PowerISA)", "url": "powerisa/xvminsp/", "summary": "Selects minimum value for four floats.", "arch": "PowerISA"}, {"label": "xvcmpeqsp (PowerISA)", "url": "powerisa/xvcmpeqsp/", "summary": "Compares four floats for equality.", "arch": "PowerISA"}, {"label": "xvcmpgtsp (PowerISA)", "url": "powerisa/xvcmpgtsp/", "summary": "Compares four floats (A > B).", "arch": "PowerISA"}, {"label": "xvcmpgesp (PowerISA)", "url": "powerisa/xvcmpgesp/", "summary": "Compares four floats (A >= B).", "arch": "PowerISA"}, {"label": "xscvdpsxds (PowerISA)", "url": "powerisa/xscvdpsxds/", "summary": "Converts scalar Double to 64-bit Signed Integer.", "arch": "PowerISA"}, {"label": "xscvdpuxds (PowerISA)", "url": "powerisa/xscvdpuxds/", "summary": "Converts scalar Double to 64-bit Unsigned Integer.", "arch": "PowerISA"}, {"label": "xscvspdp (PowerISA)", "url": "powerisa/xscvspdp/", "summary": "Promotes a Single to a Double.", "arch": "PowerISA"}, {"label": "xscvdpsp (PowerISA)", "url": "powerisa/xscvdpsp/", "summary": "Demotes a Double to a Single.", "arch": "PowerISA"}, {"label": "xvcvdpsp (PowerISA)", "url": "powerisa/xvcvdpsp/", "summary": "Converts two doubles to two floats.", "arch": "PowerISA"}, {"label": "xvcvspdp (PowerISA)", "url": "powerisa/xvcvspdp/", "summary": "Converts two floats to two doubles.", "arch": "PowerISA"}, {"label": "xvcvdpsxds (PowerISA)", "url": "powerisa/xvcvdpsxds/", "summary": "Converts two doubles to two 64-bit signed integers.", "arch": "PowerISA"}, {"label": "xvcvdpuxds (PowerISA)", "url": "powerisa/xvcvdpuxds/", "summary": "Converts two doubles to two 64-bit unsigned integers.", "arch": "PowerISA"}, {"label": "xvcvspsxds (PowerISA)", "url": "powerisa/xvcvspsxds/", "summary": "Converts two floats to two 64-bit signed integers.", "arch": "PowerISA"}, {"label": "xvcvsxwsp (PowerISA)", "url": "powerisa/xvcvsxwsp/", "summary": "Converts four 32-bit signed integers to four floats.", "arch": "PowerISA"}, {"label": "xvcvuxwsp (PowerISA)", "url": "powerisa/xvcvuxwsp/", "summary": "Converts four 32-bit unsigned integers to four floats.", "arch": "PowerISA"}, {"label": "xxspltiw (PowerISA)", "url": "powerisa/xxspltiw/", "summary": "Spatially duplicates a 32-bit immediate into all 4 words of the target.", "arch": "PowerISA"}, {"label": "xxspltidp (PowerISA)", "url": "powerisa/xxspltidp/", "summary": "Spatially duplicates a 32-bit immediate (converted to double) into both double elements.", "arch": "PowerISA"}, {"label": "xxmrghd (PowerISA)", "url": "powerisa/xxmrghd/", "summary": "Merges high doublewords from XA and XB.", "arch": "PowerISA"}, {"label": "xxmrgld (PowerISA)", "url": "powerisa/xxmrgld/", "summary": "Merges low doublewords from XA and XB.", "arch": "PowerISA"}, {"label": "xxswapd (PowerISA)", "url": "powerisa/xxswapd/", "summary": "Swaps the two doublewords in the register.", "arch": "PowerISA"}, {"label": "xxsel (PowerISA)", "url": "powerisa/xxsel/", "summary": "Bitwise select between XA and XB based on XC.", "arch": "PowerISA"}, {"label": "xxlor (PowerISA)", "url": "powerisa/xxlor/", "summary": "Bitwise OR.", "arch": "PowerISA"}, {"label": "xxlxor (PowerISA)", "url": "powerisa/xxlxor/", "summary": "Bitwise XOR.", "arch": "PowerISA"}, {"label": "xxland (PowerISA)", "url": "powerisa/xxland/", "summary": "Bitwise AND.", "arch": "PowerISA"}, {"label": "xxlnor (PowerISA)", "url": "powerisa/xxlnor/", "summary": "Bitwise NOR.", "arch": "PowerISA"}, {"label": "vmulouw (PowerISA)", "url": "powerisa/vmulouw/", "summary": "Multiplies odd words (1,3) to 64-bit result.", "arch": "PowerISA"}, {"label": "vmulosw (PowerISA)", "url": "powerisa/vmulosw/", "summary": "Multiplies odd words (1,3) to 64-bit signed result.", "arch": "PowerISA"}, {"label": "vmuleuw (PowerISA)", "url": "powerisa/vmuleuw/", "summary": "Multiplies even words (0,2) to 64-bit result.", "arch": "PowerISA"}, {"label": "vmulesw (PowerISA)", "url": "powerisa/vmulesw/", "summary": "Multiplies even words (0,2) to 64-bit signed result.", "arch": "PowerISA"}, {"label": "vmsumubm (PowerISA)", "url": "powerisa/vmsumubm/", "summary": "Multiplies bytes and sums adjacent results into words.", "arch": "PowerISA"}, {"label": "vmsumshm (PowerISA)", "url": "powerisa/vmsumshm/", "summary": "Multiplies halfwords and sums adjacent results into words.", "arch": "PowerISA"}, {"label": "vmsumshs (PowerISA)", "url": "powerisa/vmsumshs/", "summary": "Multiplies halfwords and sums with saturation.", "arch": "PowerISA"}, {"label": "vsum4ubs (PowerISA)", "url": "powerisa/vsum4ubs/", "summary": "Sums every 4 bytes into a word.", "arch": "PowerISA"}, {"label": "vsum4sbs (PowerISA)", "url": "powerisa/vsum4sbs/", "summary": "Sums every 4 signed bytes into a word.", "arch": "PowerISA"}, {"label": "vsum4shs (PowerISA)", "url": "powerisa/vsum4shs/", "summary": "Sums every 2 halfwords into a word.", "arch": "PowerISA"}, {"label": "vsum2sws (PowerISA)", "url": "powerisa/vsum2sws/", "summary": "Sums pairs of words into signed words.", "arch": "PowerISA"}, {"label": "vsumsws (PowerISA)", "url": "powerisa/vsumsws/", "summary": "Sums all 4 words into a single word result.", "arch": "PowerISA"}, {"label": "vaddfp (PowerISA)", "url": "powerisa/vaddfp/", "summary": "Adds four single-precision floats (Classic VMX).", "arch": "PowerISA"}, {"label": "vsubfp (PowerISA)", "url": "powerisa/vsubfp/", "summary": "Subtracts four single-precision floats (Classic VMX).", "arch": "PowerISA"}, {"label": "vmulfp (PowerISA)", "url": "powerisa/vmulfp/", "summary": "Multiplies four single-precision floats (Classic VMX).", "arch": "PowerISA"}, {"label": "vctuxs (PowerISA)", "url": "powerisa/vctuxs/", "summary": "Converts 4 floats to 4 unsigned 32-bit integers.", "arch": "PowerISA"}, {"label": "vctsxs (PowerISA)", "url": "powerisa/vctsxs/", "summary": "Converts 4 floats to 4 signed 32-bit integers.", "arch": "PowerISA"}, {"label": "vcfux (PowerISA)", "url": "powerisa/vcfux/", "summary": "Converts 4 unsigned 32-bit integers to floats.", "arch": "PowerISA"}, {"label": "vcfsx (PowerISA)", "url": "powerisa/vcfsx/", "summary": "Converts 4 signed 32-bit integers to floats.", "arch": "PowerISA"}, {"label": "vrfim (PowerISA)", "url": "powerisa/vrfim/", "summary": "Rounds 4 floats to integer (floor).", "arch": "PowerISA"}, {"label": "vrfin (PowerISA)", "url": "powerisa/vrfin/", "summary": "Rounds 4 floats to nearest integer.", "arch": "PowerISA"}, {"label": "vrfip (PowerISA)", "url": "powerisa/vrfip/", "summary": "Rounds 4 floats to integer (ceil).", "arch": "PowerISA"}, {"label": "vrfiz (PowerISA)", "url": "powerisa/vrfiz/", "summary": "Rounds 4 floats to integer (trunc).", "arch": "PowerISA"}, {"label": "vcmpeqfp (PowerISA)", "url": "powerisa/vcmpeqfp/", "summary": "Compares 4 floats for equality.", "arch": "PowerISA"}, {"label": "vcmpgtfp (PowerISA)", "url": "powerisa/vcmpgtfp/", "summary": "Compares 4 floats (A > B).", "arch": "PowerISA"}, {"label": "vcmpgefp (PowerISA)", "url": "powerisa/vcmpgefp/", "summary": "Compares 4 floats (A >= B).", "arch": "PowerISA"}, {"label": "vcmpbfp (PowerISA)", "url": "powerisa/vcmpbfp/", "summary": "Compares 4 floats to see if they are within bounds.", "arch": "PowerISA"}, {"label": "vpkpx (PowerISA)", "url": "powerisa/vpkpx/", "summary": "Packs 8 words into 8 pixels (1/5/5/5 format).", "arch": "PowerISA"}, {"label": "vupkhpx (PowerISA)", "url": "powerisa/vupkhpx/", "summary": "Unpacks high 4 pixels to 4 words.", "arch": "PowerISA"}, {"label": "vupklpx (PowerISA)", "url": "powerisa/vupklpx/", "summary": "Unpacks low 4 pixels to 4 words.", "arch": "PowerISA"}, {"label": "vpermr (PowerISA)", "url": "powerisa/vpermr/", "summary": "Bitwise byte shuffle similar to vperm but for little-endian access optimization.", "arch": "PowerISA"}, {"label": "vpmsumb (PowerISA)", "url": "powerisa/vpmsumb/", "summary": "Performs GF(2) polynomial arithmetic (Carryless Multiply) on bytes.", "arch": "PowerISA"}, {"label": "vpmsumh (PowerISA)", "url": "powerisa/vpmsumh/", "summary": "Performs GF(2) polynomial arithmetic on halfwords.", "arch": "PowerISA"}, {"label": "vpmsumw (PowerISA)", "url": "powerisa/vpmsumw/", "summary": "Performs GF(2) polynomial arithmetic on words.", "arch": "PowerISA"}, {"label": "vpmsumd (PowerISA)", "url": "powerisa/vpmsumd/", "summary": "Performs GF(2) polynomial arithmetic on doublewords.", "arch": "PowerISA"}, {"label": "lxv (PowerISA)", "url": "powerisa/lxv/", "summary": "Loads a 128-bit vector from memory (VSX aligned offset).", "arch": "PowerISA"}, {"label": "stxv (PowerISA)", "url": "powerisa/stxv/", "summary": "Stores a 128-bit vector to memory (VSX aligned offset).", "arch": "PowerISA"}, {"label": "lxvdsx (PowerISA)", "url": "powerisa/lxvdsx/", "summary": "Loads a doubleword and duplicates it to fill the vector.", "arch": "PowerISA"}, {"label": "lxvw4x (PowerISA)", "url": "powerisa/lxvw4x/", "summary": "Loads four words into a vector (unaligned).", "arch": "PowerISA"}, {"label": "stxvw4x (PowerISA)", "url": "powerisa/stxvw4x/", "summary": "Stores four words from a vector (unaligned).", "arch": "PowerISA"}, {"label": "lxsiwax (PowerISA)", "url": "powerisa/lxsiwax/", "summary": "Loads a 32-bit signed integer into a VSX register (scalar).", "arch": "PowerISA"}, {"label": "lxsiwzx (PowerISA)", "url": "powerisa/lxsiwzx/", "summary": "Loads a 32-bit unsigned integer into a VSX register (scalar).", "arch": "PowerISA"}, {"label": "stxsiwx (PowerISA)", "url": "powerisa/stxsiwx/", "summary": "Stores the low 32 bits of a VSX register to memory.", "arch": "PowerISA"}, {"label": "mfvsrd (PowerISA)", "url": "powerisa/mfvsrd/", "summary": "Moves 64 bits from a VSR to a GPR.", "arch": "PowerISA"}, {"label": "mtvsrd (PowerISA)", "url": "powerisa/mtvsrd/", "summary": "Moves 64 bits from a GPR to a VSR.", "arch": "PowerISA"}, {"label": "mfvsrwz (PowerISA)", "url": "powerisa/mfvsrwz/", "summary": "Moves low 32 bits from VSR to GPR (zero extend).", "arch": "PowerISA"}, {"label": "mtvsrwa (PowerISA)", "url": "powerisa/mtvsrwa/", "summary": "Moves low 32 bits from GPR to VSR (sign extend).", "arch": "PowerISA"}, {"label": "cmp (PowerISA)", "url": "powerisa/cmp/", "summary": "Compares two registers as signed integers and records the result in the specified Condition Register Field.", "arch": "PowerISA"}, {"label": "cmpi (PowerISA)", "url": "powerisa/cmpi/", "summary": "Compares a register to a 16-bit signed immediate.", "arch": "PowerISA"}, {"label": "cmpl (PowerISA)", "url": "powerisa/cmpl/", "summary": "Compares two registers as unsigned integers.", "arch": "PowerISA"}, {"label": "cmpli (PowerISA)", "url": "powerisa/cmpli/", "summary": "Compares a register to a 16-bit unsigned immediate.", "arch": "PowerISA"}, {"label": "cntlzw (PowerISA)", "url": "powerisa/cntlzw/", "summary": "Counts the number of consecutive 0 bits starting from bit 32 (MSB of the low word).", "arch": "PowerISA"}, {"label": "cntlzd (PowerISA)", "url": "powerisa/cntlzd/", "summary": "Counts the number of consecutive 0 bits starting from bit 0 (MSB of 64-bit reg).", "arch": "PowerISA"}, {"label": "crand (PowerISA)", "url": "powerisa/crand/", "summary": "Performs a bitwise AND between two bits in the Condition Register.", "arch": "PowerISA"}, {"label": "cror (PowerISA)", "url": "powerisa/cror/", "summary": "Performs a bitwise OR between two bits in the Condition Register.", "arch": "PowerISA"}, {"label": "crxor (PowerISA)", "url": "powerisa/crxor/", "summary": "Performs a bitwise XOR between two bits in the Condition Register. Used to clear CR bits (crxor x,x,x).", "arch": "PowerISA"}, {"label": "se_add (PowerISA)", "url": "powerisa/se_add/", "summary": "Adds two registers (16-bit encoding). RX = RX + RY.", "arch": "PowerISA"}, {"label": "se_sub (PowerISA)", "url": "powerisa/se_sub/", "summary": "Subtracts two registers (16-bit). RX = RX - RY.", "arch": "PowerISA"}, {"label": "se_neg (PowerISA)", "url": "powerisa/se_neg/", "summary": "Negates a register (16-bit). RX = -RX.", "arch": "PowerISA"}, {"label": "se_not (PowerISA)", "url": "powerisa/se_not/", "summary": "Bitwise NOT (16-bit). RX = ~RX.", "arch": "PowerISA"}, {"label": "se_slw (PowerISA)", "url": "powerisa/se_slw/", "summary": "Shifts word left (16-bit). RX = RX << RY.", "arch": "PowerISA"}, {"label": "se_srw (PowerISA)", "url": "powerisa/se_srw/", "summary": "Shifts word right (16-bit). RX = RX >> RY.", "arch": "PowerISA"}, {"label": "se_and (PowerISA)", "url": "powerisa/se_and/", "summary": "Bitwise AND (16-bit). RX = RX & RY.", "arch": "PowerISA"}, {"label": "se_or (PowerISA)", "url": "powerisa/se_or/", "summary": "Bitwise OR (16-bit). RX = RX | RY.", "arch": "PowerISA"}, {"label": "se_xor (PowerISA)", "url": "powerisa/se_xor/", "summary": "Bitwise XOR (16-bit). RX = RX ^ RY.", "arch": "PowerISA"}, {"label": "se_mullw (PowerISA)", "url": "powerisa/se_mullw/", "summary": "Multiplies two words (16-bit). RX = RX * RY.", "arch": "PowerISA"}, {"label": "se_mfctr (PowerISA)", "url": "powerisa/se_mfctr/", "summary": "Moves CTR to RX (16-bit).", "arch": "PowerISA"}, {"label": "se_mtctr (PowerISA)", "url": "powerisa/se_mtctr/", "summary": "Moves RX to CTR (16-bit).", "arch": "PowerISA"}, {"label": "se_mflr (PowerISA)", "url": "powerisa/se_mflr/", "summary": "Moves LR to RX (16-bit).", "arch": "PowerISA"}, {"label": "se_mtlr (PowerISA)", "url": "powerisa/se_mtlr/", "summary": "Moves RX to LR (16-bit).", "arch": "PowerISA"}, {"label": "se_addaddi (PowerISA)", "url": "powerisa/se_addaddi/", "summary": "Complex add (RX = RX + RY + OIM).", "arch": "PowerISA"}, {"label": "se_cmpl (PowerISA)", "url": "powerisa/se_cmpl/", "summary": "Unsigned comparison of RX and RY.", "arch": "PowerISA"}, {"label": "se_cmp (PowerISA)", "url": "powerisa/se_cmp/", "summary": "Signed comparison of RX and RY.", "arch": "PowerISA"}, {"label": "se_bgeni (PowerISA)", "url": "powerisa/se_bgeni/", "summary": "Generates a value with a single bit set.", "arch": "PowerISA"}, {"label": "se_bmaski (PowerISA)", "url": "powerisa/se_bmaski/", "summary": "Generates a mask of ones.", "arch": "PowerISA"}, {"label": "se_andi (PowerISA)", "url": "powerisa/se_andi/", "summary": "RX = RX & Immediate.", "arch": "PowerISA"}, {"label": "se_addi (PowerISA)", "url": "powerisa/se_addi/", "summary": "RX = RX + Immediate.", "arch": "PowerISA"}, {"label": "se_cmpi (PowerISA)", "url": "powerisa/se_cmpi/", "summary": "Compares RX with immediate.", "arch": "PowerISA"}, {"label": "se_cmpli (PowerISA)", "url": "powerisa/se_cmpli/", "summary": "Unsigned comparison of RX with immediate.", "arch": "PowerISA"}, {"label": "se_li (PowerISA)", "url": "powerisa/se_li/", "summary": "Loads a 7-bit immediate into RX.", "arch": "PowerISA"}, {"label": "se_b (PowerISA)", "url": "powerisa/se_b/", "summary": "Unconditional short branch (8-bit displacement).", "arch": "PowerISA"}, {"label": "se_bl (PowerISA)", "url": "powerisa/se_bl/", "summary": "Function call (8-bit displacement).", "arch": "PowerISA"}, {"label": "se_blr (PowerISA)", "url": "powerisa/se_blr/", "summary": "Return from function.", "arch": "PowerISA"}, {"label": "se_bctr (PowerISA)", "url": "powerisa/se_bctr/", "summary": "Computed jump.", "arch": "PowerISA"}, {"label": "se_bc (PowerISA)", "url": "powerisa/se_bc/", "summary": "Branches if CR bit is set/clear.", "arch": "PowerISA"}, {"label": "se_lwz (PowerISA)", "url": "powerisa/se_lwz/", "summary": "Loads word with 4-bit compressed offset.", "arch": "PowerISA"}, {"label": "se_stw (PowerISA)", "url": "powerisa/se_stw/", "summary": "Stores word with 4-bit compressed offset.", "arch": "PowerISA"}, {"label": "se_lhz (PowerISA)", "url": "powerisa/se_lhz/", "summary": "Loads halfword with 4-bit offset.", "arch": "PowerISA"}, {"label": "se_sth (PowerISA)", "url": "powerisa/se_sth/", "summary": "Stores halfword with 4-bit offset.", "arch": "PowerISA"}, {"label": "se_lbz (PowerISA)", "url": "powerisa/se_lbz/", "summary": "Loads byte with 4-bit offset.", "arch": "PowerISA"}, {"label": "se_stb (PowerISA)", "url": "powerisa/se_stb/", "summary": "Stores byte with 4-bit offset.", "arch": "PowerISA"}, {"label": "e_add16i (PowerISA)", "url": "powerisa/e_add16i/", "summary": "Adds a 16-bit immediate to a register.", "arch": "PowerISA"}, {"label": "e_addi (PowerISA)", "url": "powerisa/e_addi/", "summary": "Adds immediate to register.", "arch": "PowerISA"}, {"label": "e_b (PowerISA)", "url": "powerisa/e_b/", "summary": "Unconditional branch (long range).", "arch": "PowerISA"}, {"label": "e_bl (PowerISA)", "url": "powerisa/e_bl/", "summary": "Function call (long range).", "arch": "PowerISA"}, {"label": "e_bc (PowerISA)", "url": "powerisa/e_bc/", "summary": "Conditional branch.", "arch": "PowerISA"}, {"label": "e_lmw (PowerISA)", "url": "powerisa/e_lmw/", "summary": "Loads words from memory into registers RT through R31.", "arch": "PowerISA"}, {"label": "e_stmw (PowerISA)", "url": "powerisa/e_stmw/", "summary": "Stores words from registers RT through R31 to memory.", "arch": "PowerISA"}, {"label": "e_lwz (PowerISA)", "url": "powerisa/e_lwz/", "summary": "Loads word with 16-bit offset.", "arch": "PowerISA"}, {"label": "e_stw (PowerISA)", "url": "powerisa/e_stw/", "summary": "Stores word with 16-bit offset.", "arch": "PowerISA"}, {"label": "e_lhz (PowerISA)", "url": "powerisa/e_lhz/", "summary": "Loads halfword with 16-bit offset.", "arch": "PowerISA"}, {"label": "e_sth (PowerISA)", "url": "powerisa/e_sth/", "summary": "Stores halfword with 16-bit offset.", "arch": "PowerISA"}, {"label": "e_lbz (PowerISA)", "url": "powerisa/e_lbz/", "summary": "Loads byte with 16-bit offset.", "arch": "PowerISA"}, {"label": "e_stb (PowerISA)", "url": "powerisa/e_stb/", "summary": "Stores byte with 16-bit offset.", "arch": "PowerISA"}, {"label": "e_or2i (PowerISA)", "url": "powerisa/e_or2i/", "summary": "OR with 16-bit immediate.", "arch": "PowerISA"}, {"label": "e_and2i (PowerISA)", "url": "powerisa/e_and2i/", "summary": "AND with 16-bit immediate.", "arch": "PowerISA"}, {"label": "e_xor2i (PowerISA)", "url": "powerisa/e_xor2i/", "summary": "XOR with 16-bit immediate.", "arch": "PowerISA"}, {"label": "e_lis (PowerISA)", "url": "powerisa/e_lis/", "summary": "Loads immediate into upper 16 bits.", "arch": "PowerISA"}, {"label": "e_rlwimi (PowerISA)", "url": "powerisa/e_rlwimi/", "summary": "Rotate and insert (Masking).", "arch": "PowerISA"}, {"label": "e_rlwinm (PowerISA)", "url": "powerisa/e_rlwinm/", "summary": "Rotate and mask.", "arch": "PowerISA"}, {"label": "e_mullw (PowerISA)", "url": "powerisa/e_mullw/", "summary": "Multiplies two words.", "arch": "PowerISA"}, {"label": "e_divw (PowerISA)", "url": "powerisa/e_divw/", "summary": "Divides two words.", "arch": "PowerISA"}, {"label": "e_slw (PowerISA)", "url": "powerisa/e_slw/", "summary": "Shifts word left.", "arch": "PowerISA"}, {"label": "e_srw (PowerISA)", "url": "powerisa/e_srw/", "summary": "Shifts word right.", "arch": "PowerISA"}, {"label": "e_sraw (PowerISA)", "url": "powerisa/e_sraw/", "summary": "Arithmetic right shift.", "arch": "PowerISA"}, {"label": "e_crand (PowerISA)", "url": "powerisa/e_crand/", "summary": "CR AND operation.", "arch": "PowerISA"}, {"label": "e_cror (PowerISA)", "url": "powerisa/e_cror/", "summary": "CR OR operation.", "arch": "PowerISA"}, {"label": "e_stwu (PowerISA)", "url": "powerisa/e_stwu/", "summary": "Stores word and updates base register.", "arch": "PowerISA"}, {"label": "e_lwzu (PowerISA)", "url": "powerisa/e_lwzu/", "summary": "Loads word and updates base register.", "arch": "PowerISA"}, {"label": "b (PowerISA)", "url": "powerisa/b/", "summary": "Unconditionally branches to a target address relative to the current instruction pointer.", "arch": "PowerISA"}, {"label": "ba (PowerISA)", "url": "powerisa/ba/", "summary": "Unconditionally branches to an absolute address.", "arch": "PowerISA"}, {"label": "bl (PowerISA)", "url": "powerisa/bl/", "summary": "Branches to a target address and saves the return address (CIA + 4) in the Link Register (LR). Used for function calls.", "arch": "PowerISA"}, {"label": "bc (PowerISA)", "url": "powerisa/bc/", "summary": "Branches conditionally based on the Count Register (CTR) and/or a bit in the Condition Register (CR).", "arch": "PowerISA"}, {"label": "bclr (PowerISA)", "url": "powerisa/bclr/", "summary": "Branches to the address in the Link Register (LR) if the condition is met. Used for function returns.", "arch": "PowerISA"}, {"label": "bcctr (PowerISA)", "url": "powerisa/bcctr/", "summary": "Branches to the address in the Count Register (CTR) if the condition is met. Used for computed jumps and switch statements.", "arch": "PowerISA"}, {"label": "bpermd (PowerISA)", "url": "powerisa/bpermd/", "summary": "Permutes bits from RS based on the index values in RB. Highly optimized for bit shuffling.", "arch": "PowerISA"}, {"label": "cfuged (PowerISA)", "url": "powerisa/cfuged/", "summary": "Separates bits of the source register into two groups based on a mask (Power10 Scalar).", "arch": "PowerISA"}, {"label": "pdepd (PowerISA)", "url": "powerisa/pdepd/", "summary": "Deposits bits from RS to RA under control of mask RB (Scalar).", "arch": "PowerISA"}, {"label": "pextd (PowerISA)", "url": "powerisa/pextd/", "summary": "Extracts bits from RS to RA under control of mask RB (Scalar).", "arch": "PowerISA"}, {"label": "cntlzdm (PowerISA)", "url": "powerisa/cntlzdm/", "summary": "Counts leading zeros in RS, but only considering bits set in mask RB.", "arch": "PowerISA"}, {"label": "cnttzdm (PowerISA)", "url": "powerisa/cnttzdm/", "summary": "Counts trailing zeros in RS, but only considering bits set in mask RB.", "arch": "PowerISA"}, {"label": "crc32b (PowerISA)", "url": "powerisa/crc32b/", "summary": "Accumulates a CRC32 checksum using the low byte of RS.", "arch": "PowerISA"}, {"label": "crc32h (PowerISA)", "url": "powerisa/crc32h/", "summary": "Accumulates a CRC32 checksum using the low halfword of RS.", "arch": "PowerISA"}, {"label": "crc32w (PowerISA)", "url": "powerisa/crc32w/", "summary": "Accumulates a CRC32 checksum using the word in RS.", "arch": "PowerISA"}, {"label": "crc32d (PowerISA)", "url": "powerisa/crc32d/", "summary": "Accumulates a CRC32 checksum using the doubleword in RS.", "arch": "PowerISA"}, {"label": "pli (PowerISA)", "url": "powerisa/pli/", "summary": "Loads a 34-bit signed immediate into a register. (Replaces multiple 'lis/ori' instructions).", "arch": "PowerISA"}, {"label": "xxpermx (PowerISA)", "url": "powerisa/xxpermx/", "summary": "Permutes bytes from two source vectors using a control vector and a 3-bit selector.", "arch": "PowerISA"}, {"label": "xxblendvb (PowerISA)", "url": "powerisa/xxblendvb/", "summary": "Selects bytes from XA or XB based on the MSB of bytes in XC.", "arch": "PowerISA"}, {"label": "xxblendvh (PowerISA)", "url": "powerisa/xxblendvh/", "summary": "Selects halfwords from XA or XB based on the MSB of halfwords in XC.", "arch": "PowerISA"}, {"label": "xxblendvw (PowerISA)", "url": "powerisa/xxblendvw/", "summary": "Selects words from XA or XB based on the MSB of words in XC.", "arch": "PowerISA"}, {"label": "xxblendvd (PowerISA)", "url": "powerisa/xxblendvd/", "summary": "Selects doublewords from XA or XB based on the MSB of doublewords in XC.", "arch": "PowerISA"}, {"label": "lxvwsx (PowerISA)", "url": "powerisa/lxvwsx/", "summary": "Loads a 32-bit word and replicates it across the vector.", "arch": "PowerISA"}, {"label": "mtvsrws (PowerISA)", "url": "powerisa/mtvsrws/", "summary": "Moves a 32-bit word from a GPR and replicates it across the vector.", "arch": "PowerISA"}, {"label": "xsmaxcdp (PowerISA)", "url": "powerisa/xsmaxcdp/", "summary": "Max of two doubles (IEEE 754-2008 compliant).", "arch": "PowerISA"}, {"label": "xsmincdp (PowerISA)", "url": "powerisa/xsmincdp/", "summary": "Min of two doubles (IEEE 754-2008 compliant).", "arch": "PowerISA"}, {"label": "xsmaxjdp (PowerISA)", "url": "powerisa/xsmaxjdp/", "summary": "Max of two doubles (Java compliant).", "arch": "PowerISA"}, {"label": "xsminjdp (PowerISA)", "url": "powerisa/xsminjdp/", "summary": "Min of two doubles (Java compliant).", "arch": "PowerISA"}, {"label": "xxgenpcvbm (PowerISA)", "url": "powerisa/xxgenpcvbm/", "summary": "Generates a Permute Control Vector from a byte mask.", "arch": "PowerISA"}, {"label": "xxgenpcvhm (PowerISA)", "url": "powerisa/xxgenpcvhm/", "summary": "Generates a Permute Control Vector from a halfword mask.", "arch": "PowerISA"}, {"label": "xxgenpcvwm (PowerISA)", "url": "powerisa/xxgenpcvwm/", "summary": "Generates a Permute Control Vector from a word mask.", "arch": "PowerISA"}, {"label": "xxgenpcvdm (PowerISA)", "url": "powerisa/xxgenpcvdm/", "summary": "Generates a Permute Control Vector from a doubleword mask.", "arch": "PowerISA"}, {"label": "vclzlsbb (PowerISA)", "url": "powerisa/vclzlsbb/", "summary": "Counts leading zeros on the LSB of each byte.", "arch": "PowerISA"}, {"label": "vctzlsbb (PowerISA)", "url": "powerisa/vctzlsbb/", "summary": "Counts trailing zeros on the LSB of each byte.", "arch": "PowerISA"}, {"label": "vstril (PowerISA)", "url": "powerisa/vstril/", "summary": "Isolates the leftmost element that matches the condition.", "arch": "PowerISA"}, {"label": "vstrir (PowerISA)", "url": "powerisa/vstrir/", "summary": "Isolates the rightmost element that matches the condition.", "arch": "PowerISA"}, {"label": "vstril_p (PowerISA)", "url": "powerisa/vstril_p/", "summary": "Isolates the leftmost element and updates CR6.", "arch": "PowerISA"}, {"label": "vstrir_p (PowerISA)", "url": "powerisa/vstrir_p/", "summary": "Isolates the rightmost element and updates CR6.", "arch": "PowerISA"}, {"label": "vinserth_p (PowerISA)", "url": "powerisa/vinserth_p/", "summary": "Inserts halfword from GPR into Vector.", "arch": "PowerISA"}, {"label": "vinsertw_p (PowerISA)", "url": "powerisa/vinsertw_p/", "summary": "Inserts word from GPR into Vector.", "arch": "PowerISA"}, {"label": "vinsertd_p (PowerISA)", "url": "powerisa/vinsertd_p/", "summary": "Inserts doubleword from GPR into Vector.", "arch": "PowerISA"}, {"label": "xxsplti32dx (PowerISA)", "url": "powerisa/xxsplti32dx/", "summary": "Splats a 32-bit immediate into a doubleword index.", "arch": "PowerISA"}, {"label": "xxspltib (PowerISA)", "url": "powerisa/xxspltib/", "summary": "Splats an 8-bit immediate into all bytes.", "arch": "PowerISA"}, {"label": "xxlxor (PowerISA)", "url": "powerisa/xxlxor/", "summary": "Bitwise XOR.", "arch": "PowerISA"}, {"label": "xxlnor (PowerISA)", "url": "powerisa/xxlnor/", "summary": "Bitwise NOR.", "arch": "PowerISA"}, {"label": "hashchk (PowerISA)", "url": "powerisa/hashchk/", "summary": "Checks the hash of the Return Address Stack (ROP Protection).", "arch": "PowerISA"}, {"label": "hashchkp (PowerISA)", "url": "powerisa/hashchkp/", "summary": "Privileged version of hash check.", "arch": "PowerISA"}, {"label": "hashst (PowerISA)", "url": "powerisa/hashst/", "summary": "Stores the hash of the Return Address.", "arch": "PowerISA"}, {"label": "hashstp (PowerISA)", "url": "powerisa/hashstp/", "summary": "Privileged version of hash store.", "arch": "PowerISA"}, {"label": "psq_l (PowerISA)", "url": "powerisa/psq_l/", "summary": "Loads a paired single from memory (Embedded/Legacy).", "arch": "PowerISA"}, {"label": "psq_st (PowerISA)", "url": "powerisa/psq_st/", "summary": "Stores a paired single to memory (Embedded/Legacy).", "arch": "PowerISA"}, {"label": "ps_add (PowerISA)", "url": "powerisa/ps_add/", "summary": "Adds two paired singles.", "arch": "PowerISA"}, {"label": "ps_sub (PowerISA)", "url": "powerisa/ps_sub/", "summary": "Subtracts two paired singles.", "arch": "PowerISA"}, {"label": "ps_mul (PowerISA)", "url": "powerisa/ps_mul/", "summary": "Multiplies two paired singles.", "arch": "PowerISA"}, {"label": "ps_madd (PowerISA)", "url": "powerisa/ps_madd/", "summary": "Multiply-Add on paired singles.", "arch": "PowerISA"}, {"label": "extsb (PowerISA)", "url": "powerisa/extsb/", "summary": "Sign-extends the low byte (8 bits) of a register to 64 bits.", "arch": "PowerISA"}, {"label": "extsh (PowerISA)", "url": "powerisa/extsh/", "summary": "Sign-extends the low halfword (16 bits) of a register to 64 bits.", "arch": "PowerISA"}, {"label": "extsw (PowerISA)", "url": "powerisa/extsw/", "summary": "Sign-extends the low word (32 bits) of a register to 64 bits.", "arch": "PowerISA"}, {"label": "eqv (PowerISA)", "url": "powerisa/eqv/", "summary": "Performs a bitwise Equivalence (XNOR) operation. (RA = ~(RS ^ RB)).", "arch": "PowerISA"}, {"label": "eieio (PowerISA)", "url": "powerisa/eieio/", "summary": "Ensures that load/store instructions preceding the EIEIO complete before those following it. Used for Memory-Mapped I/O synchronization.", "arch": "PowerISA"}, {"label": "fadd (PowerISA)", "url": "powerisa/fadd/", "summary": "Adds two double-precision floating-point registers.", "arch": "PowerISA"}, {"label": "fmul (PowerISA)", "url": "powerisa/fmul/", "summary": "Multiplies two double-precision floating-point registers.", "arch": "PowerISA"}, {"label": "fmadd (PowerISA)", "url": "powerisa/fmadd/", "summary": "Performs (A * C) + B with a single rounding step. (The classic FMA).", "arch": "PowerISA"}, {"label": "fcmpu (PowerISA)", "url": "powerisa/fcmpu/", "summary": "Compares two floating-point registers and sets the Condition Register (CR) field. Does not trap on NaNs.", "arch": "PowerISA"}, {"label": "fctiw (PowerISA)", "url": "powerisa/fctiw/", "summary": "Converts a float to a 32-bit signed integer (using the current rounding mode) and stores it in the lower half of the FPR.", "arch": "PowerISA"}, {"label": "isel (PowerISA)", "url": "powerisa/isel/", "summary": "Conditionally copies RA or RB to RT based on a CR bit. (Equivalent to C ternary operator 'cond ? a : b').", "arch": "PowerISA"}, {"label": "icbi (PowerISA)", "url": "powerisa/icbi/", "summary": "Invalidates the instruction cache block associated with the address. Critical for self-modifying code or JITs.", "arch": "PowerISA"}, {"label": "isync (PowerISA)", "url": "powerisa/isync/", "summary": "Waits for all previous instructions to complete and discards any prefetched instructions. Used after modifying code or changing context.", "arch": "PowerISA"}, {"label": "mcrf (PowerISA)", "url": "powerisa/mcrf/", "summary": "Copies the contents of one Condition Register field to another. Used to save comparison results.", "arch": "PowerISA"}, {"label": "mfcr (PowerISA)", "url": "powerisa/mfcr/", "summary": "Copies the entire 32-bit Condition Register into a General Purpose Register.", "arch": "PowerISA"}, {"label": "mtcrf (PowerISA)", "url": "powerisa/mtcrf/", "summary": "Copies bits from a register into the Condition Register, updated only the fields specified by the mask (FXM).", "arch": "PowerISA"}, {"label": "xsaddqp (PowerISA)", "url": "powerisa/xsaddqp/", "summary": "Adds two 128-bit Quad-Precision floating-point numbers held in VSX registers (pairs).", "arch": "PowerISA"}, {"label": "xsmulqp (PowerISA)", "url": "powerisa/xsmulqp/", "summary": "Multiplies two 128-bit Quad-Precision floating-point numbers.", "arch": "PowerISA"}, {"label": "xscvdpqp (PowerISA)", "url": "powerisa/xscvdpqp/", "summary": "Converts a 64-bit Double to a 128-bit Quad float.", "arch": "PowerISA"}, {"label": "dadd (PowerISA)", "url": "powerisa/dadd/", "summary": "Adds two 64-bit Decimal Floating Point (DFP) numbers. Used in financial calculations to avoid rounding errors.", "arch": "PowerISA"}, {"label": "dmul (PowerISA)", "url": "powerisa/dmul/", "summary": "Multiplies two 64-bit Decimal Floating Point numbers.", "arch": "PowerISA"}, {"label": "dqua (PowerISA)", "url": "powerisa/dqua/", "summary": "Adjusts the exponent of a DFP number to match a reference. Critical for aligning decimal points before addition.", "arch": "PowerISA"}, {"label": "vbrh (PowerISA)", "url": "powerisa/vbrh/", "summary": "Reverses bytes within each halfword (Endian Swap).", "arch": "PowerISA"}, {"label": "vbrw (PowerISA)", "url": "powerisa/vbrw/", "summary": "Reverses bytes within each word.", "arch": "PowerISA"}, {"label": "vbrd (PowerISA)", "url": "powerisa/vbrd/", "summary": "Reverses bytes within each doubleword.", "arch": "PowerISA"}, {"label": "vbrq (PowerISA)", "url": "powerisa/vbrq/", "summary": "Reverses bytes within the entire 128-bit quadword.", "arch": "PowerISA"}, {"label": "vextsb2w (PowerISA)", "url": "powerisa/vextsb2w/", "summary": "Sign-extends bytes to words.", "arch": "PowerISA"}, {"label": "vextsh2w (PowerISA)", "url": "powerisa/vextsh2w/", "summary": "Sign-extends halfwords to words.", "arch": "PowerISA"}, {"label": "vextsb2d (PowerISA)", "url": "powerisa/vextsb2d/", "summary": "Sign-extends bytes to doublewords.", "arch": "PowerISA"}, {"label": "vextsh2d (PowerISA)", "url": "powerisa/vextsh2d/", "summary": "Sign-extends halfwords to doublewords.", "arch": "PowerISA"}, {"label": "vextsw2d (PowerISA)", "url": "powerisa/vextsw2d/", "summary": "Sign-extends words to doublewords.", "arch": "PowerISA"}, {"label": "vcmpneb (PowerISA)", "url": "powerisa/vcmpneb/", "summary": "Compares bytes for inequality.", "arch": "PowerISA"}, {"label": "vcmpneh (PowerISA)", "url": "powerisa/vcmpneh/", "summary": "Compares halfwords for inequality.", "arch": "PowerISA"}, {"label": "vcmpnew (PowerISA)", "url": "powerisa/vcmpnew/", "summary": "Compares words for inequality.", "arch": "PowerISA"}, {"label": "vadduqm (PowerISA)", "url": "powerisa/vadduqm/", "summary": "Adds two 128-bit integers.", "arch": "PowerISA"}, {"label": "vsubuqm (PowerISA)", "url": "powerisa/vsubuqm/", "summary": "Subtracts two 128-bit integers.", "arch": "PowerISA"}, {"label": "vrlq (PowerISA)", "url": "powerisa/vrlq/", "summary": "Rotates a 128-bit quadword left.", "arch": "PowerISA"}, {"label": "vslq (PowerISA)", "url": "powerisa/vslq/", "summary": "Shifts a 128-bit quadword left.", "arch": "PowerISA"}, {"label": "vsrq (PowerISA)", "url": "powerisa/vsrq/", "summary": "Shifts a 128-bit quadword right.", "arch": "PowerISA"}, {"label": "vsraq (PowerISA)", "url": "powerisa/vsraq/", "summary": "Arithmetic right shift of a 128-bit quadword.", "arch": "PowerISA"}, {"label": "vmulhsw (PowerISA)", "url": "powerisa/vmulhsw/", "summary": "Multiplies signed words, returning the high 32 bits.", "arch": "PowerISA"}, {"label": "vmulhuw (PowerISA)", "url": "powerisa/vmulhuw/", "summary": "Multiplies unsigned words, returning the high 32 bits.", "arch": "PowerISA"}, {"label": "vmulhsd (PowerISA)", "url": "powerisa/vmulhsd/", "summary": "Multiplies signed doublewords, returning the high 64 bits.", "arch": "PowerISA"}, {"label": "vmulhud (PowerISA)", "url": "powerisa/vmulhud/", "summary": "Multiplies unsigned doublewords, returning the high 64 bits.", "arch": "PowerISA"}, {"label": "xxlandc (PowerISA)", "url": "powerisa/xxlandc/", "summary": "vD = vA & ~vB", "arch": "PowerISA"}, {"label": "xxlorc (PowerISA)", "url": "powerisa/xxlorc/", "summary": "vD = vA | ~vB", "arch": "PowerISA"}, {"label": "xxlnand (PowerISA)", "url": "powerisa/xxlnand/", "summary": "vD = ~(vA & vB)", "arch": "PowerISA"}, {"label": "xxleqv (PowerISA)", "url": "powerisa/xxleqv/", "summary": "vD = ~(vA ^ vB) (XNOR)", "arch": "PowerISA"}, {"label": "vgbbd (PowerISA)", "url": "powerisa/vgbbd/", "summary": "Gathers the LSB of each byte into a single word. (Highly specific permutation).", "arch": "PowerISA"}, {"label": "vpdepd (PowerISA)", "url": "powerisa/vpdepd/", "summary": "Deposits bits from source to target under control of a mask (Power10).", "arch": "PowerISA"}, {"label": "vpextd (PowerISA)", "url": "powerisa/vpextd/", "summary": "Extracts bits from source based on a mask (Power10).", "arch": "PowerISA"}, {"label": "vcfuged (PowerISA)", "url": "powerisa/vcfuged/", "summary": "Separates bits of source into two groups based on mask (Power10).", "arch": "PowerISA"}, {"label": "vgnb (PowerISA)", "url": "powerisa/vgnb/", "summary": "Gathers non-zero bytes from a vector into the bottom of the target.", "arch": "PowerISA"}, {"label": "vclrlb (PowerISA)", "url": "powerisa/vclrlb/", "summary": "Clears the N leftmost bytes of a vector.", "arch": "PowerISA"}, {"label": "vclrrb (PowerISA)", "url": "powerisa/vclrrb/", "summary": "Clears the N rightmost bytes of a vector.", "arch": "PowerISA"}, {"label": "plq (PowerISA)", "url": "powerisa/plq/", "summary": "Loads 128 bits into two GPRs using a 34-bit offset.", "arch": "PowerISA"}, {"label": "pstq (PowerISA)", "url": "powerisa/pstq/", "summary": "Stores 128 bits from two GPRs using a 34-bit offset.", "arch": "PowerISA"}, {"label": "xxmrghw (PowerISA)", "url": "powerisa/xxmrghw/", "summary": "Merges high words from two VSRs.", "arch": "PowerISA"}, {"label": "xxmrglw (PowerISA)", "url": "powerisa/xxmrglw/", "summary": "Merges low words from two VSRs.", "arch": "PowerISA"}, {"label": "vexpandbm (PowerISA)", "url": "powerisa/vexpandbm/", "summary": "Expands bits from a GPR mask into a byte-element vector.", "arch": "PowerISA"}, {"label": "vexpandhm (PowerISA)", "url": "powerisa/vexpandhm/", "summary": "Expands bits from a GPR mask into a halfword-element vector.", "arch": "PowerISA"}, {"label": "vexpandwm (PowerISA)", "url": "powerisa/vexpandwm/", "summary": "Expands bits from a GPR mask into a word-element vector.", "arch": "PowerISA"}, {"label": "vexpanddm (PowerISA)", "url": "powerisa/vexpanddm/", "summary": "Expands bits from a GPR mask into a doubleword-element vector.", "arch": "PowerISA"}, {"label": "vexpandqm (PowerISA)", "url": "powerisa/vexpandqm/", "summary": "Expands bits from a GPR mask into a quadword-element vector.", "arch": "PowerISA"}, {"label": "vextractbm (PowerISA)", "url": "powerisa/vextractbm/", "summary": "Extracts MSB of each byte into a GPR mask.", "arch": "PowerISA"}, {"label": "vextracthm (PowerISA)", "url": "powerisa/vextracthm/", "summary": "Extracts MSB of each halfword into a GPR mask.", "arch": "PowerISA"}, {"label": "vextractwm (PowerISA)", "url": "powerisa/vextractwm/", "summary": "Extracts MSB of each word into a GPR mask.", "arch": "PowerISA"}, {"label": "vextractdm (PowerISA)", "url": "powerisa/vextractdm/", "summary": "Extracts MSB of each doubleword into a GPR mask.", "arch": "PowerISA"}, {"label": "vextractqm (PowerISA)", "url": "powerisa/vextractqm/", "summary": "Extracts MSB of quadword into a GPR mask.", "arch": "PowerISA"}, {"label": "mtvsrdd (PowerISA)", "url": "powerisa/mtvsrdd/", "summary": "Moves two 64-bit GPRs into one 128-bit VSR.", "arch": "PowerISA"}, {"label": "mfvsrld (PowerISA)", "url": "powerisa/mfvsrld/", "summary": "Extracts the lower 64-bits of a VSR to a GPR.", "arch": "PowerISA"}, {"label": "vstribl (PowerISA)", "url": "powerisa/vstribl/", "summary": "Identifies the first zero byte from the left.", "arch": "PowerISA"}, {"label": "vstribr (PowerISA)", "url": "powerisa/vstribr/", "summary": "Identifies the first zero byte from the right.", "arch": "PowerISA"}, {"label": "xststdcsp (PowerISA)", "url": "powerisa/xststdcsp/", "summary": "Tests a Single-Precision float for class membership (NaN, Inf, etc.).", "arch": "PowerISA"}, {"label": "tlbiel (PowerISA)", "url": "powerisa/tlbiel/", "summary": "Invalidates a TLB entry on the current processor only.", "arch": "PowerISA"}, {"label": "msgsync (PowerISA)", "url": "powerisa/msgsync/", "summary": "Waits for previous messages to be accepted.", "arch": "PowerISA"}, {"label": "msgslp (PowerISA)", "url": "powerisa/msgslp/", "summary": "Transitions the processor to a sleep state via message.", "arch": "PowerISA"}, {"label": "vnegw (PowerISA)", "url": "powerisa/vnegw/", "summary": "Negates each word integer.", "arch": "PowerISA"}, {"label": "vnegd (PowerISA)", "url": "powerisa/vnegd/", "summary": "Negates each doubleword integer.", "arch": "PowerISA"}, {"label": "mtocrf (PowerISA)", "url": "powerisa/mtocrf/", "summary": "Moves a GPR field to a single CR field.", "arch": "PowerISA"}, {"label": "mfocrf (PowerISA)", "url": "powerisa/mfocrf/", "summary": "Moves a single CR field to a GPR.", "arch": "PowerISA"}, {"label": "nand (PowerISA)", "url": "powerisa/nand/", "summary": "Performs a bitwise NAND comparison. (RA <- ~(RS & RB)).", "arch": "PowerISA"}, {"label": "neg (PowerISA)", "url": "powerisa/neg/", "summary": "Computes the two's complement negation of a register (0 - RT).", "arch": "PowerISA"}, {"label": "nor (PowerISA)", "url": "powerisa/nor/", "summary": "Performs a bitwise NOR comparison. (RA <- ~(RS | RB)). Useful for bitwise NOT (nor r3, r4, r4).", "arch": "PowerISA"}, {"label": "or (PowerISA)", "url": "powerisa/or/", "summary": "Performs a bitwise OR comparison.", "arch": "PowerISA"}, {"label": "orc (PowerISA)", "url": "powerisa/orc/", "summary": "Performs a bitwise OR between RS and the complement of RB.", "arch": "PowerISA"}, {"label": "ori (PowerISA)", "url": "powerisa/ori/", "summary": "Performs a bitwise OR with a 16-bit unsigned immediate.", "arch": "PowerISA"}, {"label": "oris (PowerISA)", "url": "powerisa/oris/", "summary": "Performs a bitwise OR with a 16-bit immediate shifted left by 16 bits.", "arch": "PowerISA"}, {"label": "popcntd (PowerISA)", "url": "powerisa/popcntd/", "summary": "Counts the number of set bits (1s) in a 64-bit register.", "arch": "PowerISA"}, {"label": "popcntw (PowerISA)", "url": "powerisa/popcntw/", "summary": "Counts the number of set bits (1s) in the lower 32 bits of a register.", "arch": "PowerISA"}, {"label": "rlwinm (PowerISA)", "url": "powerisa/rlwinm/", "summary": "The ultimate bit-manipulation instruction. Rotates RS left by SH, then ANDs with a mask defined by MB (Mask Begin) and ME (Mask End).", "arch": "PowerISA"}, {"label": "rlwimi (PowerISA)", "url": "powerisa/rlwimi/", "summary": "Rotates RS left by SH, then inserts bits into RA under the control of a mask. Used to merge bitfields from two registers.", "arch": "PowerISA"}, {"label": "rldic (PowerISA)", "url": "powerisa/rldic/", "summary": "Rotates a 64-bit register left, then clears bits based on a mask. 64-bit equivalent of rlwinm.", "arch": "PowerISA"}, {"label": "rldicl (PowerISA)", "url": "powerisa/rldicl/", "summary": "Rotates 64-bit RS left by SH, then clears the high-order bits (0 to MB-1). Often used to extract bitfields.", "arch": "PowerISA"}, {"label": "rldicr (PowerISA)", "url": "powerisa/rldicr/", "summary": "Rotates 64-bit RS left by SH, then clears the low-order bits (ME+1 to 63).", "arch": "PowerISA"}, {"label": "add (PowerISA)", "url": "powerisa/add/", "summary": "Adds the contents of two registers.", "arch": "PowerISA"}, {"label": "addc (PowerISA)", "url": "powerisa/addc/", "summary": "Adds two registers and updates the Carry Architecture (CA) bit.", "arch": "PowerISA"}, {"label": "adde (PowerISA)", "url": "powerisa/adde/", "summary": "Adds two registers plus the current Carry bit.", "arch": "PowerISA"}, {"label": "addi (PowerISA)", "url": "powerisa/addi/", "summary": "Adds a 16-bit signed immediate value to a register.", "arch": "PowerISA"}, {"label": "addic (PowerISA)", "url": "powerisa/addic/", "summary": "Adds an immediate to a register and updates the Carry bit.", "arch": "PowerISA"}, {"label": "addic. (PowerISA)", "url": "powerisa/addic_/", "summary": "Adds an immediate, updates Carry, and updates Condition Register Field 0 (CR0).", "arch": "PowerISA"}, {"label": "addis (PowerISA)", "url": "powerisa/addis/", "summary": "Adds a 16-bit immediate shifted left by 16 bits to a register.", "arch": "PowerISA"}, {"label": "addme (PowerISA)", "url": "powerisa/addme/", "summary": "Adds a register, -1, and the Carry bit.", "arch": "PowerISA"}, {"label": "addze (PowerISA)", "url": "powerisa/addze/", "summary": "Adds a register, 0, and the Carry bit.", "arch": "PowerISA"}, {"label": "and (PowerISA)", "url": "powerisa/and/", "summary": "Performs a bitwise AND between two registers.", "arch": "PowerISA"}, {"label": "andc (PowerISA)", "url": "powerisa/andc/", "summary": "Performs a bitwise AND between RS and the one's complement of RB.", "arch": "PowerISA"}, {"label": "andi. (PowerISA)", "url": "powerisa/andi_/", "summary": "Performs a bitwise AND between a register and a 16-bit unsigned immediate (zero-extended). Always updates CR0.", "arch": "PowerISA"}, {"label": "andis. (PowerISA)", "url": "powerisa/andis_/", "summary": "Performs a bitwise AND between a register and a 16-bit immediate shifted left by 16 bits. Always updates CR0.", "arch": "PowerISA"}, {"label": "paddi (PowerISA)", "url": "powerisa/paddi/", "summary": "Adds a 34-bit signed immediate to a register. Supports PC-relative addressing (LEA).", "arch": "PowerISA"}, {"label": "pla (PowerISA)", "url": "powerisa/pla/", "summary": "Pseudo-instruction for paddi with R=1. Loads the address of a label.", "arch": "PowerISA"}, {"label": "pld (PowerISA)", "url": "powerisa/pld/", "summary": "Loads a 64-bit value from memory using a 34-bit immediate offset (PC-relative or absolute).", "arch": "PowerISA"}, {"label": "pststd (PowerISA)", "url": "powerisa/pststd/", "summary": "Stores a 64-bit value to memory using a 34-bit immediate offset.", "arch": "PowerISA"}, {"label": "plwz (PowerISA)", "url": "powerisa/plwz/", "summary": "Loads a 32-bit word and zero-extends it to 64 bits, using a 34-bit offset.", "arch": "PowerISA"}, {"label": "plbz (PowerISA)", "url": "powerisa/plbz/", "summary": "Loads a byte and zero-extends it, using a 34-bit offset.", "arch": "PowerISA"}, {"label": "pmxvbf16ger2 (PowerISA)", "url": "powerisa/pmxvbf16ger2/", "summary": "Matrix Multiply Assist (MMA) instruction. Computes ACC <- ACC + (A * B) using BF16 inputs.", "arch": "PowerISA"}, {"label": "xxeval (PowerISA)", "url": "powerisa/xxeval/", "summary": "Performs an arbitrary 3-input boolean logic function (LUT3) on vectors. The 8-bit immediate 'IMM' defines the truth table.", "arch": "PowerISA"}, {"label": "divw (PowerISA)", "url": "powerisa/divw/", "summary": "Divides the lower 32 bits of RA by the lower 32 bits of RB (Signed).", "arch": "PowerISA"}, {"label": "divwu (PowerISA)", "url": "powerisa/divwu/", "summary": "Divides the lower 32 bits of RA by the lower 32 bits of RB (Unsigned).", "arch": "PowerISA"}, {"label": "divd (PowerISA)", "url": "powerisa/divd/", "summary": "Divides the 64-bit value in RA by the 64-bit value in RB (Signed).", "arch": "PowerISA"}, {"label": "divdu (PowerISA)", "url": "powerisa/divdu/", "summary": "Divides the 64-bit value in RA by the 64-bit value in RB (Unsigned).", "arch": "PowerISA"}, {"label": "dcbz (PowerISA)", "url": "powerisa/dcbz/", "summary": "Zeros out an entire cache block (usually 128 bytes) in memory. Critical for optimizing memory clears (memset).", "arch": "PowerISA"}, {"label": "dcbt (PowerISA)", "url": "powerisa/dcbt/", "summary": "Hints to the hardware to prefetch the cache block at the specified address into the cache.", "arch": "PowerISA"}, {"label": "dcbf (PowerISA)", "url": "powerisa/dcbf/", "summary": "Flushes the cache block from the data cache to main memory and invalidates it. Used for DMA coherency.", "arch": "PowerISA"}, {"label": "dcbst (PowerISA)", "url": "powerisa/dcbst/", "summary": "Writes the cache block to main memory if it is modified (Clean), but keeps it in the cache.", "arch": "PowerISA"}, {"label": "xxsetaccz (PowerISA)", "url": "powerisa/xxsetaccz/", "summary": "Clears a 512-bit Accumulator register (composed of 4 VSRs) to zero.", "arch": "PowerISA"}, {"label": "xxmtacc (PowerISA)", "url": "powerisa/xxmtacc/", "summary": "Copies data from 4 adjacent VSRs into an Accumulator.", "arch": "PowerISA"}, {"label": "xxmfacc (PowerISA)", "url": "powerisa/xxmfacc/", "summary": "Copies data from an Accumulator back to 4 adjacent VSRs.", "arch": "PowerISA"}, {"label": "xvi8ger4 (PowerISA)", "url": "powerisa/xvi8ger4/", "summary": "Performs an 8-bit integer outer product (GER) and accumulates into a 512-bit register.", "arch": "PowerISA"}, {"label": "xvi8ger4pp (PowerISA)", "url": "powerisa/xvi8ger4pp/", "summary": "Signed/Unsigned variations of 8-bit matrix multiply accumulate.", "arch": "PowerISA"}, {"label": "xvi16ger2 (PowerISA)", "url": "powerisa/xvi16ger2/", "summary": "Performs a 16-bit integer outer product and accumulates.", "arch": "PowerISA"}, {"label": "xvi16ger2s (PowerISA)", "url": "powerisa/xvi16ger2s/", "summary": "Performs a 16-bit integer outer product with saturation.", "arch": "PowerISA"}, {"label": "xvf16ger2 (PowerISA)", "url": "powerisa/xvf16ger2/", "summary": "Performs IEEE Float16 matrix multiply accumulate.", "arch": "PowerISA"}, {"label": "xvbf16ger2 (PowerISA)", "url": "powerisa/xvbf16ger2/", "summary": "Performs BFloat16 (Brain Float) matrix multiply accumulate.", "arch": "PowerISA"}, {"label": "xvf32ger (PowerISA)", "url": "powerisa/xvf32ger/", "summary": "Performs Single-Precision Float matrix multiply accumulate.", "arch": "PowerISA"}, {"label": "xvf64ger (PowerISA)", "url": "powerisa/xvf64ger/", "summary": "Performs Double-Precision Float matrix multiply accumulate.", "arch": "PowerISA"}, {"label": "pmxvi8ger4 (PowerISA)", "url": "powerisa/pmxvi8ger4/", "summary": "Masked version of 8-bit integer MMA.", "arch": "PowerISA"}, {"label": "pmxvf64ger (PowerISA)", "url": "powerisa/pmxvf64ger/", "summary": "Masked version of Double-Precision MMA.", "arch": "PowerISA"}, {"label": "cnttzw (PowerISA)", "url": "powerisa/cnttzw/", "summary": "Counts the number of trailing zeros in the low 32-bits.", "arch": "PowerISA"}, {"label": "cnttzd (PowerISA)", "url": "powerisa/cnttzd/", "summary": "Counts the number of trailing zeros in 64-bits.", "arch": "PowerISA"}, {"label": "bctar (PowerISA)", "url": "powerisa/bctar/", "summary": "Branches to the address in the TAR. Used for fast indirect jumps (JIT).", "arch": "PowerISA"}, {"label": "mttar (PowerISA)", "url": "powerisa/mttar/", "summary": "Moves a GPR value to the TAR.", "arch": "PowerISA"}, {"label": "mftar (PowerISA)", "url": "powerisa/mftar/", "summary": "Reads the TAR into a GPR.", "arch": "PowerISA"}, {"label": "cmprb (PowerISA)", "url": "powerisa/cmprb/", "summary": "Compares a byte against a range of values. (Is byte in [min, max]?)", "arch": "PowerISA"}, {"label": "paste. (PowerISA)", "url": "powerisa/paste_/", "summary": "Paste operation that updates CR0 to indicate success/fail.", "arch": "PowerISA"}, {"label": "stqcx. (PowerISA)", "url": "powerisa/stqcx_/", "summary": "Atomic 128-bit store. Stores if reservation exists.", "arch": "PowerISA"}, {"label": "lq (PowerISA)", "url": "powerisa/lq/", "summary": "Loads 128 bits into two adjacent GPRs (Even/Odd pair).", "arch": "PowerISA"}, {"label": "stq (PowerISA)", "url": "powerisa/stq/", "summary": "Stores 128 bits from two adjacent GPRs.", "arch": "PowerISA"}, {"label": "plh (PowerISA)", "url": "powerisa/plh/", "summary": "Loads 16-bit halfword using 34-bit offset.", "arch": "PowerISA"}, {"label": "plha (PowerISA)", "url": "powerisa/plha/", "summary": "Loads 16-bit halfword (Sign Extended) using 34-bit offset.", "arch": "PowerISA"}, {"label": "plwa (PowerISA)", "url": "powerisa/plwa/", "summary": "Loads 32-bit word (Sign Extended) using 34-bit offset.", "arch": "PowerISA"}, {"label": "pstb (PowerISA)", "url": "powerisa/pstb/", "summary": "Stores byte using 34-bit offset.", "arch": "PowerISA"}, {"label": "psth (PowerISA)", "url": "powerisa/psth/", "summary": "Stores halfword using 34-bit offset.", "arch": "PowerISA"}, {"label": "pstw (PowerISA)", "url": "powerisa/pstw/", "summary": "Stores word using 34-bit offset.", "arch": "PowerISA"}, {"label": "paddi (PowerISA)", "url": "powerisa/paddi/", "summary": "Adds 34-bit immediate.", "arch": "PowerISA"}, {"label": "xscvudqp (PowerISA)", "url": "powerisa/xscvudqp/", "summary": "Converts 64-bit Unsigned Integer to 128-bit Float.", "arch": "PowerISA"}, {"label": "xscvsdqp (PowerISA)", "url": "powerisa/xscvsdqp/", "summary": "Converts 64-bit Signed Integer to 128-bit Float.", "arch": "PowerISA"}, {"label": "xscvqpud (PowerISA)", "url": "powerisa/xscvqpud/", "summary": "Converts 128-bit Float to 64-bit Unsigned Integer.", "arch": "PowerISA"}, {"label": "xscvqpsd (PowerISA)", "url": "powerisa/xscvqpsd/", "summary": "Converts 128-bit Float to 64-bit Signed Integer.", "arch": "PowerISA"}, {"label": "xscvqpdp (PowerISA)", "url": "powerisa/xscvqpdp/", "summary": "Demotes 128-bit Float to 64-bit Float.", "arch": "PowerISA"}, {"label": "xsaddqpo (PowerISA)", "url": "powerisa/xsaddqpo/", "summary": "Used for Quad-Precision arithmetic on hardware that splits quads.", "arch": "PowerISA"}, {"label": "xssubqpo (PowerISA)", "url": "powerisa/xssubqpo/", "summary": "Used for Quad-Precision arithmetic on hardware that splits quads.", "arch": "PowerISA"}, {"label": "xsdivqpo (PowerISA)", "url": "powerisa/xsdivqpo/", "summary": "Used for Quad-Precision arithmetic on hardware that splits quads.", "arch": "PowerISA"}, {"label": "xssqrtqpo (PowerISA)", "url": "powerisa/xssqrtqpo/", "summary": "Used for Quad-Precision arithmetic on hardware that splits quads.", "arch": "PowerISA"}, {"label": "xsrqpi (PowerISA)", "url": "powerisa/xsrqpi/", "summary": "Rounds a Quad float to a Quad integer.", "arch": "PowerISA"}, {"label": "xsrqpix (PowerISA)", "url": "powerisa/xsrqpix/", "summary": "Rounds a Quad float to a Quad integer (Exact).", "arch": "PowerISA"}, {"label": "fmr (PowerISA)", "url": "powerisa/fmr/", "summary": "Copies a float register (Pseudo: for FRB).", "arch": "PowerISA"}, {"label": "fabs (PowerISA)", "url": "powerisa/fabs/", "summary": "Computes absolute value of a float.", "arch": "PowerISA"}, {"label": "fneg (PowerISA)", "url": "powerisa/fneg/", "summary": "Negates a float.", "arch": "PowerISA"}, {"label": "fnabs (PowerISA)", "url": "powerisa/fnabs/", "summary": "Computes negative absolute value of a float.", "arch": "PowerISA"}, {"label": "fcpsgn (PowerISA)", "url": "powerisa/fcpsgn/", "summary": "Copies sign from FRB to FRA.", "arch": "PowerISA"}, {"label": "fsel (PowerISA)", "url": "powerisa/fsel/", "summary": "Selects FRA if FRC >= 0, else FRB (Optional).", "arch": "PowerISA"}, {"label": "fsqrt (PowerISA)", "url": "powerisa/fsqrt/", "summary": "Computes square root (Double).", "arch": "PowerISA"}, {"label": "fsqrts (PowerISA)", "url": "powerisa/fsqrts/", "summary": "Computes square root (Single).", "arch": "PowerISA"}, {"label": "fmadd (PowerISA)", "url": "powerisa/fmadd/", "summary": "A*C + B", "arch": "PowerISA"}, {"label": "fmsub (PowerISA)", "url": "powerisa/fmsub/", "summary": "A*C - B", "arch": "PowerISA"}, {"label": "fnmadd (PowerISA)", "url": "powerisa/fnmadd/", "summary": "-(A*C + B)", "arch": "PowerISA"}, {"label": "fnmsub (PowerISA)", "url": "powerisa/fnmsub/", "summary": "-(A*C - B)", "arch": "PowerISA"}, {"label": "frsp (PowerISA)", "url": "powerisa/frsp/", "summary": "Rounds Double to Single.", "arch": "PowerISA"}, {"label": "fctid (PowerISA)", "url": "powerisa/fctid/", "summary": "Converts Double to 64-bit Int.", "arch": "PowerISA"}, {"label": "fctidz (PowerISA)", "url": "powerisa/fctidz/", "summary": "Converts Double to 64-bit Int (Truncate).", "arch": "PowerISA"}, {"label": "fctiwz (PowerISA)", "url": "powerisa/fctiwz/", "summary": "Converts Double to 32-bit Int (Truncate).", "arch": "PowerISA"}, {"label": "fcfid (PowerISA)", "url": "powerisa/fcfid/", "summary": "Converts 64-bit Int to Double.", "arch": "PowerISA"}, {"label": "fcfids (PowerISA)", "url": "powerisa/fcfids/", "summary": "Converts 64-bit Int to Single.", "arch": "PowerISA"}, {"label": "fcfidu (PowerISA)", "url": "powerisa/fcfidu/", "summary": "Converts 64-bit Unsigned Int to Double.", "arch": "PowerISA"}, {"label": "fcfidus (PowerISA)", "url": "powerisa/fcfidus/", "summary": "Converts 64-bit Unsigned Int to Single.", "arch": "PowerISA"}, {"label": "lvx (PowerISA)", "url": "powerisa/lvx/", "summary": "Loads a 128-bit vector from memory into a Vector Register. Address must be 16-byte aligned (bits 60-63 of effective address are ignored).", "arch": "PowerISA"}, {"label": "stvx (PowerISA)", "url": "powerisa/stvx/", "summary": "Stores a 128-bit vector to memory. Address must be 16-byte aligned.", "arch": "PowerISA"}, {"label": "vaddubm (PowerISA)", "url": "powerisa/vaddubm/", "summary": "Adds sixteen 8-bit integers from two vectors. Arithmetic is modulo 256 (wraps around).", "arch": "PowerISA"}, {"label": "vsubuwm (PowerISA)", "url": "powerisa/vsubuwm/", "summary": "Subtracts four 32-bit integers in parallel.", "arch": "PowerISA"}, {"label": "vmulouw (PowerISA)", "url": "powerisa/vmulouw/", "summary": "Multiplies the 1st and 3rd words of the source vectors to produce two 64-bit results.", "arch": "PowerISA"}, {"label": "vspltw (PowerISA)", "url": "powerisa/vspltw/", "summary": "Copies a single word element from the source vector into all four word elements of the destination.", "arch": "PowerISA"}, {"label": "vperm (PowerISA)", "url": "powerisa/vperm/", "summary": "The signature AltiVec instruction. Constructs a new vector by selecting bytes from two source vectors based on a permute control vector.", "arch": "PowerISA"}, {"label": "vslw (PowerISA)", "url": "powerisa/vslw/", "summary": "Shifts each of the four words in vA left by the number of bits specified in the corresponding word of vB.", "arch": "PowerISA"}, {"label": "vcmpequw (PowerISA)", "url": "powerisa/vcmpequw/", "summary": "Compares words for equality. Sets result bits to all 1s (True) or all 0s (False).", "arch": "PowerISA"}, {"label": "vsel (PowerISA)", "url": "powerisa/vsel/", "summary": "Bitwise selection. copies bits from vA if the corresponding bit in vC is 0, or from vB if vC is 1. (Like 'mux').", "arch": "PowerISA"}, {"label": "lxvd2x (PowerISA)", "url": "powerisa/lxvd2x/", "summary": "Loads a 128-bit vector from memory into a VSX register. Does NOT require 16-byte alignment (unlike lvx).", "arch": "PowerISA"}, {"label": "stxvd2x (PowerISA)", "url": "powerisa/stxvd2x/", "summary": "Stores a 128-bit VSX register to memory. Does NOT require alignment.", "arch": "PowerISA"}, {"label": "xvadddp (PowerISA)", "url": "powerisa/xvadddp/", "summary": "Adds two pairs of double-precision floating-point numbers.", "arch": "PowerISA"}, {"label": "xvmaddadp (PowerISA)", "url": "powerisa/xvmaddadp/", "summary": "Performs (A * B) + T on vectors of doubles.", "arch": "PowerISA"}, {"label": "xxpermdi (PowerISA)", "url": "powerisa/xxpermdi/", "summary": "Selects two doublewords from the four available in source registers XA and XB based on a 2-bit selector.", "arch": "PowerISA"}, {"label": "xsadddp (PowerISA)", "url": "powerisa/xsadddp/", "summary": "Adds the low doubleword of two VSX registers (scalar operation). The high doublewords are undefined or zeroed.", "arch": "PowerISA"}, {"label": "dsub (PowerISA)", "url": "powerisa/dsub/", "summary": "Subtracts two 64-bit Decimal Floating Point numbers.", "arch": "PowerISA"}, {"label": "ddiv (PowerISA)", "url": "powerisa/ddiv/", "summary": "Divides two 64-bit Decimal Floating Point numbers.", "arch": "PowerISA"}, {"label": "dcmpu (PowerISA)", "url": "powerisa/dcmpu/", "summary": "Compares two DFP numbers (Non-signaling on NaN).", "arch": "PowerISA"}, {"label": "dcmpo (PowerISA)", "url": "powerisa/dcmpo/", "summary": "Compares two DFP numbers (Signaling on NaN).", "arch": "PowerISA"}, {"label": "dctdp (PowerISA)", "url": "powerisa/dctdp/", "summary": "Converts DFP Short (32-bit compressed) to DFP Long (64-bit).", "arch": "PowerISA"}, {"label": "drsp (PowerISA)", "url": "powerisa/drsp/", "summary": "Rounds DFP Long (64-bit) to DFP Short (32-bit compressed).", "arch": "PowerISA"}, {"label": "dcffix (PowerISA)", "url": "powerisa/dcffix/", "summary": "Converts a 64-bit integer to DFP.", "arch": "PowerISA"}, {"label": "dctfix (PowerISA)", "url": "powerisa/dctfix/", "summary": "Converts DFP to a 64-bit integer.", "arch": "PowerISA"}, {"label": "denbcd (PowerISA)", "url": "powerisa/denbcd/", "summary": "Encodes a DFP number into BCD format.", "arch": "PowerISA"}, {"label": "ddedpd (PowerISA)", "url": "powerisa/ddedpd/", "summary": "Decodes BCD to DFP format.", "arch": "PowerISA"}, {"label": "diex (PowerISA)", "url": "powerisa/diex/", "summary": "Combines a sign/coefficient from FRA and exponent from FRB.", "arch": "PowerISA"}, {"label": "dxex (PowerISA)", "url": "powerisa/dxex/", "summary": "Extracts the exponent from a DFP number.", "arch": "PowerISA"}, {"label": "dscli (PowerISA)", "url": "powerisa/dscli/", "summary": "Shifts the coefficient of a DFP number left.", "arch": "PowerISA"}, {"label": "dsri (PowerISA)", "url": "powerisa/dsri/", "summary": "Shifts the coefficient of a DFP number right.", "arch": "PowerISA"}, {"label": "xssubqp (PowerISA)", "url": "powerisa/xssubqp/", "summary": "Subtracts two 128-bit Quad-Precision floats.", "arch": "PowerISA"}, {"label": "xsdivqp (PowerISA)", "url": "powerisa/xsdivqp/", "summary": "Divides two 128-bit Quad-Precision floats.", "arch": "PowerISA"}, {"label": "xssqrtqp (PowerISA)", "url": "powerisa/xssqrtqp/", "summary": "Computes square root of a 128-bit Quad-Precision float.", "arch": "PowerISA"}, {"label": "xscmpuqp (PowerISA)", "url": "powerisa/xscmpuqp/", "summary": "Compares Quad floats (Non-signaling on NaN).", "arch": "PowerISA"}, {"label": "xscmpopoqp (PowerISA)", "url": "powerisa/xscmpopoqp/", "summary": "Compares Quad floats (Signaling on NaN).", "arch": "PowerISA"}, {"label": "xsnegqp (PowerISA)", "url": "powerisa/xsnegqp/", "summary": "Negates a 128-bit Quad float.", "arch": "PowerISA"}, {"label": "xsabsqp (PowerISA)", "url": "powerisa/xsabsqp/", "summary": "Computes absolute value of a Quad float.", "arch": "PowerISA"}, {"label": "xsmaxqp (PowerISA)", "url": "powerisa/xsmaxqp/", "summary": "Selects maximum of two Quad floats.", "arch": "PowerISA"}, {"label": "xsminqp (PowerISA)", "url": "powerisa/xsminqp/", "summary": "Selects minimum of two Quad floats.", "arch": "PowerISA"}, {"label": "xxinsertw (PowerISA)", "url": "powerisa/xxinsertw/", "summary": "Inserts a 32-bit word from a GPR into a specific element of a VSR.", "arch": "PowerISA"}, {"label": "xxextractuw (PowerISA)", "url": "powerisa/xxextractuw/", "summary": "Extracts a 32-bit word from a VSR into a GPR.", "arch": "PowerISA"}, {"label": "xxspltw (PowerISA)", "url": "powerisa/xxspltw/", "summary": "Replicates one word element across the entire vector.", "arch": "PowerISA"}, {"label": "lmw (PowerISA)", "url": "powerisa/lmw/", "summary": "Loads words from memory into registers RT through R31 (Context Switch).", "arch": "PowerISA"}, {"label": "stmw (PowerISA)", "url": "powerisa/stmw/", "summary": "Stores words from registers RT through R31 to memory (Context Switch).", "arch": "PowerISA"}, {"label": "lswi (PowerISA)", "url": "powerisa/lswi/", "summary": "Loads N bytes from memory into registers.", "arch": "PowerISA"}, {"label": "stswi (PowerISA)", "url": "powerisa/stswi/", "summary": "Stores N bytes from registers to memory.", "arch": "PowerISA"}, {"label": "slbia (PowerISA)", "url": "powerisa/slbia/", "summary": "Invalidates all Segment Lookaside Buffer entries (OS Management).", "arch": "PowerISA"}, {"label": "slbmte (PowerISA)", "url": "powerisa/slbmte/", "summary": "Writes an SLB entry (Mapping effective to virtual address).", "arch": "PowerISA"}, {"label": "msgclr (PowerISA)", "url": "powerisa/msgclr/", "summary": "Clears a pending doorbell interrupt (Inter-processor comms).", "arch": "PowerISA"}, {"label": "msgsnd (PowerISA)", "url": "powerisa/msgsnd/", "summary": "Sends a doorbell interrupt to another processor.", "arch": "PowerISA"}, {"label": "icbt (PowerISA)", "url": "powerisa/icbt/", "summary": "Prefetches an instruction cache block.", "arch": "PowerISA"}, {"label": "dcbtst (PowerISA)", "url": "powerisa/dcbtst/", "summary": "Prefetches a cache block signaling intent to modify (RFO - Read For Ownership).", "arch": "PowerISA"}, {"label": "mftb (PowerISA)", "url": "powerisa/mftb/", "summary": "Reads the hardware timebase register (Timestamp).", "arch": "PowerISA"}, {"label": "attn (PowerISA)", "url": "powerisa/attn/", "summary": "Stops execution and alerts the hardware debugger.", "arch": "PowerISA"}, {"label": "clrbhrb (PowerISA)", "url": "powerisa/clrbhrb/", "summary": "Clears the hardware branch history buffer (Performance tuning).", "arch": "PowerISA"}, {"label": "tabortwc (PowerISA)", "url": "powerisa/tabortwc/", "summary": "Aborts a transaction if the condition is met (Word comparison).", "arch": "PowerISA"}, {"label": "tabortdc (PowerISA)", "url": "powerisa/tabortdc/", "summary": "Aborts a transaction if the condition is met (Doubleword comparison).", "arch": "PowerISA"}, {"label": "trechkpt (PowerISA)", "url": "powerisa/trechkpt/", "summary": "Updates the transaction checkpoint.", "arch": "PowerISA"}, {"label": "lxvl (PowerISA)", "url": "powerisa/lxvl/", "summary": "Loads N bytes into a vector, where N is specified in a GPR.", "arch": "PowerISA"}, {"label": "stxvl (PowerISA)", "url": "powerisa/stxvl/", "summary": "Stores N bytes from a vector to memory.", "arch": "PowerISA"}, {"label": "xxperm (PowerISA)", "url": "powerisa/xxperm/", "summary": "General permute for VSX registers.", "arch": "PowerISA"}, {"label": "xxpermr (PowerISA)", "url": "powerisa/xxpermr/", "summary": "Little-endian optimized permute.", "arch": "PowerISA"}, {"label": "lswx (PowerISA)", "url": "powerisa/lswx/", "summary": "Loads N bytes from memory (N in XER).", "arch": "PowerISA"}, {"label": "stswx (PowerISA)", "url": "powerisa/stswx/", "summary": "Stores N bytes to memory (N in XER).", "arch": "PowerISA"}, {"label": "wait (PowerISA)", "url": "powerisa/wait/", "summary": "Pauses execution to save power.", "arch": "PowerISA"}, {"label": "doze (PowerISA)", "url": "powerisa/doze/", "summary": "Enters Doze power-saving mode (Supervisor only).", "arch": "PowerISA"}, {"label": "nap (PowerISA)", "url": "powerisa/nap/", "summary": "Enters Nap power-saving mode (Supervisor only).", "arch": "PowerISA"}, {"label": "sleep (PowerISA)", "url": "powerisa/sleep/", "summary": "Enters Sleep power-saving mode (Supervisor only).", "arch": "PowerISA"}, {"label": "ripv (PowerISA)", "url": "powerisa/ripv/", "summary": "Enters Deep Sleep mode (Supervisor only).", "arch": "PowerISA"}, {"label": "dcbzl (PowerISA)", "url": "powerisa/dcbzl/", "summary": "Zeros a cache block (implementation defined size).", "arch": "PowerISA"}, {"label": "slbmfee (PowerISA)", "url": "powerisa/slbmfee/", "summary": "Reads the ESID part of an SLB entry.", "arch": "PowerISA"}, {"label": "slbmfev (PowerISA)", "url": "powerisa/slbmfev/", "summary": "Reads the VSID part of an SLB entry.", "arch": "PowerISA"}, {"label": "msgclrp (PowerISA)", "url": "powerisa/msgclrp/", "summary": "Clears a privileged doorbell interrupt.", "arch": "PowerISA"}, {"label": "msgsndp (PowerISA)", "url": "powerisa/msgsndp/", "summary": "Sends a privileged doorbell interrupt.", "arch": "PowerISA"}, {"label": "mfsr (PowerISA)", "url": "powerisa/mfsr/", "summary": "Legacy 32-bit segment register read.", "arch": "PowerISA"}, {"label": "mtsr (PowerISA)", "url": "powerisa/mtsr/", "summary": "Legacy 32-bit segment register write.", "arch": "PowerISA"}, {"label": "mfsrin (PowerISA)", "url": "powerisa/mfsrin/", "summary": "Indirect read of segment register using RB.", "arch": "PowerISA"}, {"label": "mtsrin (PowerISA)", "url": "powerisa/mtsrin/", "summary": "Indirect write of segment register using RB.", "arch": "PowerISA"}, {"label": "mfbhrbe (PowerISA)", "url": "powerisa/mfbhrbe/", "summary": "Reads a specific entry from the BHRB.", "arch": "PowerISA"}, {"label": "tsr (PowerISA)", "url": "powerisa/tsr/", "summary": "Suspends or resumes a transaction based on L.", "arch": "PowerISA"}, {"label": "tabortwci (PowerISA)", "url": "powerisa/tabortwci/", "summary": "Aborts transaction if word condition (Immediate) is met.", "arch": "PowerISA"}, {"label": "tabortdci (PowerISA)", "url": "powerisa/tabortdci/", "summary": "Aborts transaction if doubleword condition (Immediate) is met.", "arch": "PowerISA"}, {"label": "xsrintqp (PowerISA)", "url": "powerisa/xsrintqp/", "summary": "Rounds Quad float to nearest Integer.", "arch": "PowerISA"}, {"label": "dctqpq (PowerISA)", "url": "powerisa/dctqpq/", "summary": "Converts DFP Long (64-bit) to DFP Quad (128-bit).", "arch": "PowerISA"}, {"label": "drdpq (PowerISA)", "url": "powerisa/drdpq/", "summary": "Rounds DFP Quad (128-bit) to DFP Long (64-bit).", "arch": "PowerISA"}, {"label": "vcipherlast (PowerISA)", "url": "powerisa/vcipherlast/", "summary": "Performs the final round of AES encryption (SubBytes, ShiftRows, AddRoundKey). No MixColumns.", "arch": "PowerISA"}, {"label": "vncipherlast (PowerISA)", "url": "powerisa/vncipherlast/", "summary": "Performs the final round of AES decryption.", "arch": "PowerISA"}, {"label": "vsbox (PowerISA)", "url": "powerisa/vsbox/", "summary": "Performs the SubBytes operation (S-Box lookup) on a vector.", "arch": "PowerISA"}, {"label": "vshasigmad (PowerISA)", "url": "powerisa/vshasigmad/", "summary": "Performs the Sigma0/Sigma1 functions for SHA-512.", "arch": "PowerISA"}, {"label": "vpermxor (PowerISA)", "url": "powerisa/vpermxor/", "summary": "Permutes bytes from vA and vB, then XORs with vC. Used for finite field arithmetic.", "arch": "PowerISA"}, {"label": "bcdcfn. (PowerISA)", "url": "powerisa/bcdcfn_/", "summary": "Converts BCD National format to Signed Packed BCD.", "arch": "PowerISA"}, {"label": "bcdctn. (PowerISA)", "url": "powerisa/bcdctn_/", "summary": "Converts Signed Packed BCD to National format.", "arch": "PowerISA"}, {"label": "bcdcfz. (PowerISA)", "url": "powerisa/bcdcfz_/", "summary": "Converts BCD Zoned format to Signed Packed BCD.", "arch": "PowerISA"}, {"label": "bcdctz. (PowerISA)", "url": "powerisa/bcdctz_/", "summary": "Converts Signed Packed BCD to Zoned format.", "arch": "PowerISA"}, {"label": "bcdcfsq. (PowerISA)", "url": "powerisa/bcdcfsq_/", "summary": "Converts a 128-bit signed integer to BCD.", "arch": "PowerISA"}, {"label": "bcdctsq. (PowerISA)", "url": "powerisa/bcdctsq_/", "summary": "Converts BCD to a 128-bit signed integer.", "arch": "PowerISA"}, {"label": "mulhd (PowerISA)", "url": "powerisa/mulhd/", "summary": "Multiplies two 64-bit integers and returns the upper 64 bits of the 128-bit result (Signed).", "arch": "PowerISA"}, {"label": "mulhdu (PowerISA)", "url": "powerisa/mulhdu/", "summary": "Multiplies two 64-bit integers and returns the upper 64 bits of the 128-bit result (Unsigned).", "arch": "PowerISA"}, {"label": "mulhw (PowerISA)", "url": "powerisa/mulhw/", "summary": "Multiplies two 32-bit integers and returns the upper 32 bits (Signed).", "arch": "PowerISA"}, {"label": "mulhwu (PowerISA)", "url": "powerisa/mulhwu/", "summary": "Multiplies two 32-bit integers and returns the upper 32 bits (Unsigned).", "arch": "PowerISA"}, {"label": "divsq (PowerISA)", "url": "powerisa/divsq/", "summary": "Divides a 128-bit signed integer by a 128-bit signed integer (using VSX pairs).", "arch": "PowerISA"}, {"label": "divuq (PowerISA)", "url": "powerisa/divuq/", "summary": "Divides a 128-bit unsigned integer by a 128-bit unsigned integer.", "arch": "PowerISA"}, {"label": "modsq (PowerISA)", "url": "powerisa/modsq/", "summary": "Computes remainder of 128-bit signed division.", "arch": "PowerISA"}, {"label": "moduq (PowerISA)", "url": "powerisa/moduq/", "summary": "Computes remainder of 128-bit unsigned division.", "arch": "PowerISA"}, {"label": "lbzci (PowerISA)", "url": "powerisa/lbzci/", "summary": "Loads a byte bypassing the cache. Used for memory-mapped I/O.", "arch": "PowerISA"}, {"label": "lhzci (PowerISA)", "url": "powerisa/lhzci/", "summary": "Loads a halfword bypassing the cache.", "arch": "PowerISA"}, {"label": "lwzci (PowerISA)", "url": "powerisa/lwzci/", "summary": "Loads a word bypassing the cache.", "arch": "PowerISA"}, {"label": "ldci (PowerISA)", "url": "powerisa/ldci/", "summary": "Loads a doubleword bypassing the cache.", "arch": "PowerISA"}, {"label": "stbci (PowerISA)", "url": "powerisa/stbci/", "summary": "Stores a byte bypassing the cache.", "arch": "PowerISA"}, {"label": "sthci (PowerISA)", "url": "powerisa/sthci/", "summary": "Stores a halfword bypassing the cache.", "arch": "PowerISA"}, {"label": "stwci (PowerISA)", "url": "powerisa/stwci/", "summary": "Stores a word bypassing the cache.", "arch": "PowerISA"}, {"label": "stdci (PowerISA)", "url": "powerisa/stdci/", "summary": "Stores a doubleword bypassing the cache.", "arch": "PowerISA"}, {"label": "cp_abort (PowerISA)", "url": "powerisa/cp_abort/", "summary": "Aborts a hardware accelerator copy-paste sequence.", "arch": "PowerISA"}, {"label": "mcrxrx (PowerISA)", "url": "powerisa/mcrxrx/", "summary": "Copies XER[OV, SO] to a Condition Register field.", "arch": "PowerISA"}, {"label": "scv (PowerISA)", "url": "powerisa/scv/", "summary": "Performs a system call to a fixed vector address (Faster than 'sc').", "arch": "PowerISA"}, {"label": "rfscv (PowerISA)", "url": "powerisa/rfscv/", "summary": "Returns from a vectored system call.", "arch": "PowerISA"}, {"label": "stop (PowerISA)", "url": "powerisa/stop/", "summary": "Stops instruction execution and enters a power-saving state (replaces nap/doze on P9+).", "arch": "PowerISA"}, {"label": "urfid (PowerISA)", "url": "powerisa/urfid/", "summary": "Returns from an ultravisor interrupt.", "arch": "PowerISA"}, {"label": "setbc (PowerISA)", "url": "powerisa/setbc/", "summary": "Sets RT to 1 if CR bit is set, else 0. (Branchless logic).", "arch": "PowerISA"}, {"label": "setbcr (PowerISA)", "url": "powerisa/setbcr/", "summary": "Sets RT to 1 if CR bit is clear, else 0.", "arch": "PowerISA"}, {"label": "setnbc (PowerISA)", "url": "powerisa/setnbc/", "summary": "Sets RT to -1 if CR bit is set, else 0.", "arch": "PowerISA"}, {"label": "setnbcr (PowerISA)", "url": "powerisa/setnbcr/", "summary": "Sets RT to -1 if CR bit is clear, else 0.", "arch": "PowerISA"}, {"label": "xscmpexpdp (PowerISA)", "url": "powerisa/xscmpexpdp/", "summary": "Compares exponents of two double-precision floats.", "arch": "PowerISA"}, {"label": "xsiexpdp (PowerISA)", "url": "powerisa/xsiexpdp/", "summary": "Inserts exponent from one double into another.", "arch": "PowerISA"}, {"label": "xsxexpdp (PowerISA)", "url": "powerisa/xsxexpdp/", "summary": "Extracts exponent from double as an integer.", "arch": "PowerISA"}, {"label": "xsxsigdp (PowerISA)", "url": "powerisa/xsxsigdp/", "summary": "Extracts significand from double as an integer.", "arch": "PowerISA"}, {"label": "xststdcdp (PowerISA)", "url": "powerisa/xststdcdp/", "summary": "Tests if a double falls into a specific class (NaN, Inf, Zero, Denormal).", "arch": "PowerISA"}, {"label": "lxvp (PowerISA)", "url": "powerisa/lxvp/", "summary": "Loads a 256-bit vector pair (two VSRs).", "arch": "PowerISA"}, {"label": "stxvp (PowerISA)", "url": "powerisa/stxvp/", "summary": "Stores a 256-bit vector pair.", "arch": "PowerISA"}, {"label": "plxvp (PowerISA)", "url": "powerisa/plxvp/", "summary": "Loads a 256-bit vector pair with 34-bit offset.", "arch": "PowerISA"}, {"label": "pstxvp (PowerISA)", "url": "powerisa/pstxvp/", "summary": "Stores a 256-bit vector pair with 34-bit offset.", "arch": "PowerISA"}, {"label": "xscvhpdp (PowerISA)", "url": "powerisa/xscvhpdp/", "summary": "Converts a 16-bit float to 64-bit double.", "arch": "PowerISA"}, {"label": "xscvdphp (PowerISA)", "url": "powerisa/xscvdphp/", "summary": "Converts a 64-bit double to 16-bit float.", "arch": "PowerISA"}, {"label": "xvcvhpsp (PowerISA)", "url": "powerisa/xvcvhpsp/", "summary": "Converts four 16-bit floats to four 32-bit floats.", "arch": "PowerISA"}, {"label": "xvcvsphp (PowerISA)", "url": "powerisa/xvcvsphp/", "summary": "Converts four 32-bit floats to four 16-bit floats.", "arch": "PowerISA"}, {"label": "sync (PowerISA)", "url": "powerisa/sync/", "summary": "The master memory barrier. Ensures all previous instructions appear to complete before any subsequent instructions start. (L=0: Heavyweight, L=1: Lightweight/LWSYNC).", "arch": "PowerISA"}, {"label": "lwsync (PowerISA)", "url": "powerisa/lwsync/", "summary": "Orders loads with loads, stores with stores, and loads with stores. Does NOT order stores with loads. (Encoded as sync 1).", "arch": "PowerISA"}, {"label": "rfid (PowerISA)", "url": "powerisa/rfid/", "summary": "Returns from an interrupt handler. Restores PC from SRR0 and MSR from SRR1.", "arch": "PowerISA"}, {"label": "tlbie (PowerISA)", "url": "powerisa/tlbie/", "summary": "Invalidates a TLB entry corresponding to the address in RB.", "arch": "PowerISA"}, {"label": "slbie (PowerISA)", "url": "powerisa/slbie/", "summary": "Invalidates an SLB entry. Critical for memory management on Power systems.", "arch": "PowerISA"}, {"label": "wait (PowerISA)", "url": "powerisa/wait/", "summary": "Stops instruction execution and places the processor in a lower power state until an interrupt occurs.", "arch": "PowerISA"}, {"label": "tbegin. (PowerISA)", "url": "powerisa/tbegin_/", "summary": "Initiates a hardware transaction. If the transaction fails, execution rolls back to this point. Sets CR0 based on success/failure.", "arch": "PowerISA"}, {"label": "tend. (PowerISA)", "url": "powerisa/tend_/", "summary": "Commits the current hardware transaction. If successful, memory changes become visible atomically.", "arch": "PowerISA"}, {"label": "tabort. (PowerISA)", "url": "powerisa/tabort_/", "summary": "Forces a transaction failure and rollback.", "arch": "PowerISA"}, {"label": "vcipher (PowerISA)", "url": "powerisa/vcipher/", "summary": "Performs one round of AES encryption (SubBytes, ShiftRows, MixColumns, AddRoundKey).", "arch": "PowerISA"}, {"label": "vncipher (PowerISA)", "url": "powerisa/vncipher/", "summary": "Performs one round of AES decryption.", "arch": "PowerISA"}, {"label": "vshasigmaw (PowerISA)", "url": "powerisa/vshasigmaw/", "summary": "Performs the Sigma0/Sigma1/sigma0/sigma1 functions for SHA-256.", "arch": "PowerISA"}, {"label": "MOV (x86-64)", "url": "x86-64/mov/", "summary": "Copies data from source to destination.", "arch": "x86-64"}, {"label": "ADD (x86-64)", "url": "x86-64/add/", "summary": "Adds source to destination.", "arch": "x86-64"}, {"label": "SUB (x86-64)", "url": "x86-64/sub/", "summary": "Subtracts source from destination.", "arch": "x86-64"}, {"label": "LEA (x86-64)", "url": "x86-64/lea/", "summary": "Computes effective address and stores it in register.", "arch": "x86-64"}, {"label": "JMP (x86-64)", "url": "x86-64/jmp/", "summary": "Unconditionally jumps to target address.", "arch": "x86-64"}, {"label": "JE (x86-64)", "url": "x86-64/je/", "summary": "Jumps if ZF (Zero Flag) is set.", "arch": "x86-64"}, {"label": "PUSH (x86-64)", "url": "x86-64/push/", "summary": "Pushes a value onto the stack.", "arch": "x86-64"}, {"label": "POP (x86-64)", "url": "x86-64/pop/", "summary": "Pops a value from the stack.", "arch": "x86-64"}, {"label": "CALL (x86-64)", "url": "x86-64/call/", "summary": "Pushes return address and jumps to target.", "arch": "x86-64"}, {"label": "RET (x86-64)", "url": "x86-64/ret/", "summary": "Returns from procedure.", "arch": "x86-64"}, {"label": "ADD (shifted) (ARMv8)", "url": "armv8/add_(shifted)/", "summary": "Adds a register value and an optionally-shifted register value.", "arch": "ARMv8"}, {"label": "SUB (extended) (ARMv8)", "url": "armv8/sub_(extended)/", "summary": "Subtracts an optionally-extended register value.", "arch": "ARMv8"}, {"label": "MOV (register) (ARMv8)", "url": "armv8/mov_(register)/", "summary": "Copies a value from one register to another (Alias of ORR).", "arch": "ARMv8"}, {"label": "LDR (register) (ARMv8)", "url": "armv8/ldr_(register)/", "summary": "Loads a word or doubleword from memory.", "arch": "ARMv8"}, {"label": "STR (immediate) (ARMv8)", "url": "armv8/str_(immediate)/", "summary": "Stores a word or doubleword to memory.", "arch": "ARMv8"}, {"label": "B (ARMv8)", "url": "armv8/b/", "summary": "Unconditionally branches to a PC-relative offset.", "arch": "ARMv8"}, {"label": "BL (ARMv8)", "url": "armv8/bl/", "summary": "Calls a subroutine, storing return address in X30 (LR).", "arch": "ARMv8"}, {"label": "CBZ (ARMv8)", "url": "armv8/cbz/", "summary": "Branches if the register is zero.", "arch": "ARMv8"}, {"label": "CMP (immediate) (ARMv8)", "url": "armv8/cmp_(immediate)/", "summary": "Compares register with immediate (Alias of SUBS).", "arch": "ARMv8"}, {"label": "ADR (ARMv8)", "url": "armv8/adr/", "summary": "Calculates the address of a label.", "arch": "ARMv8"}]