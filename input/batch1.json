{
  "instructions": [
    {
      "mnemonic": "ADDI",
      "architecture": "RISC-V",
      "full_name": "Add Immediate",
      "summary": "Adds a sign-extended 12-bit immediate to a register.",
      "syntax": "ADDI rd, rs1, imm",
      "encoding": { "format": "I-Type", "binary_pattern": "imm[11:0] | rs1 | 000 | rd | 0010011", "hex_opcode": "0x13" },
      "operands": [{ "name": "rd", "desc": "Dest" }, { "name": "rs1", "desc": "Source" }, { "name": "imm", "desc": "12-bit Signed Value" }],
      "pseudocode": "R[rd] = R[rs1] + sext(imm);",
      "example": "ADDI x5, x10, 20",
      "example_note": "Adds 20 to the value in x10 and stores result in x5."
    },
    {
      "mnemonic": "ADD",
      "architecture": "RISC-V",
      "full_name": "Add",
      "summary": "Adds the contents of two registers.",
      "syntax": "ADD rd, rs1, rs2",
      "encoding": { "format": "R-Type", "binary_pattern": "0000000 | rs2 | rs1 | 000 | rd | 0110011", "hex_opcode": "0x33" },
      "operands": [{ "name": "rd", "desc": "Dest" }, { "name": "rs1", "desc": "Source 1" }, { "name": "rs2", "desc": "Source 2" }],
      "pseudocode": "R[rd] = R[rs1] + R[rs2];",
      "example": "ADD x6, x5, x4",
      "example_note": "x6 = x5 + x4"
    },
    {
      "mnemonic": "SUB",
      "architecture": "RISC-V",
      "full_name": "Subtract",
      "summary": "Subtracts rs2 from rs1.",
      "syntax": "SUB rd, rs1, rs2",
      "encoding": { "format": "R-Type", "binary_pattern": "0100000 | rs2 | rs1 | 000 | rd | 0110011", "hex_opcode": "0x33" },
      "operands": [{ "name": "rd", "desc": "Dest" }, { "name": "rs1", "desc": "Minuend" }, { "name": "rs2", "desc": "Subtrahend" }],
      "pseudocode": "R[rd] = R[rs1] - R[rs2];",
      "example": "SUB x10, x11, x12",
      "example_note": "x10 = x11 - x12"
    },
    {
      "mnemonic": "LUI",
      "architecture": "RISC-V",
      "full_name": "Load Upper Immediate",
      "summary": "Loads the 20-bit immediate into the upper 20 bits of the register.",
      "syntax": "LUI rd, imm",
      "encoding": { "format": "U-Type", "binary_pattern": "imm[31:12] | rd | 0110111", "hex_opcode": "0x37" },
      "operands": [{ "name": "rd", "desc": "Dest" }, { "name": "imm", "desc": "20-bit Upper Value" }],
      "pseudocode": "R[rd] = imm << 12;",
      "example": "LUI x5, 0x12345",
      "example_note": "Loads 0x12345000 into x5."
    },
    {
      "mnemonic": "AUIPC",
      "architecture": "RISC-V",
      "full_name": "Add Upper Immediate to PC",
      "summary": "Adds a 20-bit upper immediate to the Program Counter.",
      "syntax": "AUIPC rd, imm",
      "encoding": { "format": "U-Type", "binary_pattern": "imm[31:12] | rd | 0010111", "hex_opcode": "0x17" },
      "operands": [{ "name": "rd", "desc": "Dest" }, { "name": "imm", "desc": "20-bit offset" }],
      "pseudocode": "R[rd] = PC + (imm << 12);",
      "example": "AUIPC x10, 0",
      "example_note": "Loads the current PC value into x10."
    },
    {
      "mnemonic": "JAL",
      "architecture": "RISC-V",
      "full_name": "Jump and Link",
      "summary": "Jumps to an offset and saves return address.",
      "syntax": "JAL rd, offset",
      "encoding": { "format": "J-Type", "binary_pattern": "imm | rd | 1101111", "hex_opcode": "0x6F" },
      "operands": [{ "name": "rd", "desc": "Return Address Dest" }, { "name": "offset", "desc": "Jump Offset" }],
      "pseudocode": "R[rd] = PC + 4; PC += sext(offset);",
      "example": "JAL x1, 1024",
      "example_note": "Calls function at PC+1024, saves return address in RA (x1)."
    },
    {
      "mnemonic": "BEQ",
      "architecture": "RISC-V",
      "full_name": "Branch if Equal",
      "summary": "Branches if two registers are equal.",
      "syntax": "BEQ rs1, rs2, offset",
      "encoding": { "format": "B-Type", "binary_pattern": "imm | rs2 | rs1 | 000 | imm | 1100011", "hex_opcode": "0x63" },
      "operands": [{ "name": "rs1", "desc": "Source 1" }, { "name": "rs2", "desc": "Source 2" }, { "name": "offset", "desc": "Branch target" }],
      "pseudocode": "if (R[rs1] == R[rs2]) PC += sext(offset);",
      "example": "BEQ x5, x6, 100",
      "example_note": "Jump 100 bytes forward if x5 equals x6."
    },
    {
      "mnemonic": "LW",
      "architecture": "RISC-V",
      "full_name": "Load Word",
      "summary": "Loads a 32-bit word from memory.",
      "syntax": "LW rd, offset(rs1)",
      "encoding": { "format": "I-Type", "binary_pattern": "offset | rs1 | 010 | rd | 0000011", "hex_opcode": "0x03" },
      "operands": [{ "name": "rd", "desc": "Dest" }, { "name": "rs1", "desc": "Base Address" }, { "name": "offset", "desc": "Byte Offset" }],
      "pseudocode": "R[rd] = M[R[rs1] + sext(offset)][31:0];",
      "example": "LW x5, 8(x2)",
      "example_note": "Load value from memory at address (StackPointer + 8) into x5."
    },
    {
      "mnemonic": "SW",
      "architecture": "RISC-V",
      "full_name": "Store Word",
      "summary": "Stores a 32-bit word to memory.",
      "syntax": "SW rs2, offset(rs1)",
      "encoding": { "format": "S-Type", "binary_pattern": "imm | rs2 | rs1 | 010 | imm | 0100011", "hex_opcode": "0x23" },
      "operands": [{ "name": "rs2", "desc": "Source Data" }, { "name": "rs1", "desc": "Base Address" }, { "name": "offset", "desc": "Byte Offset" }],
      "pseudocode": "M[R[rs1] + sext(offset)] = R[rs2][31:0];",
      "example": "SW x5, 12(x2)",
      "example_note": "Store x5 into stack memory at offset 12."
    },
    {
      "mnemonic": "ECALL",
      "architecture": "RISC-V",
      "full_name": "Environment Call",
      "summary": "Triggers a service request to the execution environment (OS).",
      "syntax": "ECALL",
      "encoding": { "format": "I-Type", "binary_pattern": "000000000000 | 00000 | 000 | 00000 | 1110011", "hex_opcode": "0x73" },
      "operands": [],
      "pseudocode": "RaiseException(EnvironmentCall);",
      "example": "ECALL",
      "example_note": "Used to make syscalls (e.g. print, exit)."
    },

    {
      "mnemonic": "MOV",
      "architecture": "x86-64",
      "full_name": "Move",
      "summary": "Copies data from source to destination.",
      "syntax": "MOV r/m64, r64",
      "encoding": { "format": "CISC Variable", "binary_pattern": "REX.W + 89 /r", "hex_opcode": "89" },
      "operands": [{ "name": "dest", "desc": "Dest" }, { "name": "src", "desc": "Source" }],
      "pseudocode": "DEST = SRC;",
      "example": "MOV RAX, RBX",
      "example_note": "Copies value of RBX into RAX."
    },
    {
      "mnemonic": "ADD",
      "architecture": "x86-64",
      "full_name": "Add",
      "summary": "Adds source to destination.",
      "syntax": "ADD r/m64, r64",
      "encoding": { "format": "CISC Variable", "binary_pattern": "REX.W + 01 /r", "hex_opcode": "01" },
      "operands": [{ "name": "dest", "desc": "Dest/Src1" }, { "name": "src", "desc": "Src2" }],
      "pseudocode": "DEST = DEST + SRC;",
      "example": "ADD RAX, 5",
      "example_note": "Adds 5 to RAX."
    },
    {
      "mnemonic": "SUB",
      "architecture": "x86-64",
      "full_name": "Subtract",
      "summary": "Subtracts source from destination.",
      "syntax": "SUB r/m64, r64",
      "encoding": { "format": "CISC Variable", "binary_pattern": "REX.W + 29 /r", "hex_opcode": "29" },
      "operands": [{ "name": "dest", "desc": "Dest/Minuend" }, { "name": "src", "desc": "Subtrahend" }],
      "pseudocode": "DEST = DEST - SRC;",
      "example": "SUB RSP, 16",
      "example_note": "Allocates 16 bytes on stack."
    },
    {
      "mnemonic": "LEA",
      "architecture": "x86-64",
      "full_name": "Load Effective Address",
      "summary": "Computes effective address and stores it in register.",
      "syntax": "LEA r64, m",
      "encoding": { "format": "CISC Variable", "binary_pattern": "REX.W + 8D /r", "hex_opcode": "8D" },
      "operands": [{ "name": "dest", "desc": "Dest Register" }, { "name": "src", "desc": "Memory Address Calculation" }],
      "pseudocode": "DEST = EffectiveAddress(SRC);",
      "example": "LEA RAX, [RBX+8]",
      "example_note": "Calculates address RBX+8 and puts it in RAX (does not access memory)."
    },
    {
      "mnemonic": "JMP",
      "architecture": "x86-64",
      "full_name": "Jump",
      "summary": "Unconditionally jumps to target address.",
      "syntax": "JMP rel32",
      "encoding": { "format": "CISC Variable", "binary_pattern": "E9 cd", "hex_opcode": "E9" },
      "operands": [{ "name": "target", "desc": "Relative Address" }],
      "pseudocode": "RIP = RIP + sign_ext(rel32);",
      "example": "JMP Label",
      "example_note": "Transfers control flow to 'Label'."
    },
    {
      "mnemonic": "JE",
      "architecture": "x86-64",
      "full_name": "Jump if Equal",
      "summary": "Jumps if ZF (Zero Flag) is set.",
      "syntax": "JE rel8",
      "encoding": { "format": "CISC Variable", "binary_pattern": "74 cb", "hex_opcode": "74" },
      "operands": [{ "name": "target", "desc": "Relative Address" }],
      "pseudocode": "IF ZF=1 THEN RIP = RIP + sign_ext(rel8);",
      "example": "JE Done",
      "example_note": "Jump to 'Done' if previous comparison was equal."
    },
    {
      "mnemonic": "PUSH",
      "architecture": "x86-64",
      "full_name": "Push Word",
      "summary": "Pushes a value onto the stack.",
      "syntax": "PUSH r64",
      "encoding": { "format": "CISC Variable", "binary_pattern": "50+rd", "hex_opcode": "50" },
      "operands": [{ "name": "src", "desc": "Register" }],
      "pseudocode": "RSP = RSP - 8; Memory[RSP] = SRC;",
      "example": "PUSH RBP",
      "example_note": "Saves Base Pointer to stack."
    },
    {
      "mnemonic": "POP",
      "architecture": "x86-64",
      "full_name": "Pop Word",
      "summary": "Pops a value from the stack.",
      "syntax": "POP r64",
      "encoding": { "format": "CISC Variable", "binary_pattern": "58+rd", "hex_opcode": "58" },
      "operands": [{ "name": "dest", "desc": "Register" }],
      "pseudocode": "DEST = Memory[RSP]; RSP = RSP + 8;",
      "example": "POP RBP",
      "example_note": "Restores Base Pointer from stack."
    },
    {
      "mnemonic": "CALL",
      "architecture": "x86-64",
      "full_name": "Call Procedure",
      "summary": "Pushes return address and jumps to target.",
      "syntax": "CALL rel32",
      "encoding": { "format": "CISC Variable", "binary_pattern": "E8 cd", "hex_opcode": "E8" },
      "operands": [{ "name": "target", "desc": "Function Address" }],
      "pseudocode": "PUSH(RIP_next); RIP = RIP + sext(rel32);",
      "example": "CALL printf",
      "example_note": "Calls the printf function."
    },
    {
      "mnemonic": "RET",
      "architecture": "x86-64",
      "full_name": "Return",
      "summary": "Returns from procedure.",
      "syntax": "RET",
      "encoding": { "format": "CISC Variable", "binary_pattern": "C3", "hex_opcode": "C3" },
      "operands": [],
      "pseudocode": "POP(RIP);",
      "example": "RET",
      "example_note": "Returns control to the caller."
    },

    {
      "mnemonic": "ADD (shifted)",
      "architecture": "ARMv8",
      "full_name": "Add (Shifted Register)",
      "summary": "Adds a register value and an optionally-shifted register value.",
      "syntax": "ADD <Xd>, <Xn>, <Xm>{, <shift> #<amount>}",
      "encoding": { "format": "Data Proc", "binary_pattern": "sf 0001011 shift 0 Rm imm6 Rn Rd", "hex_opcode": "0x8B (Base)" },
      "operands": [{ "name": "Xd", "desc": "Dest" }, { "name": "Xn", "desc": "Src1" }, { "name": "Xm", "desc": "Src2" }],
      "pseudocode": "Xd = Xn + Shift(Xm, shift, amount);",
      "example": "ADD X0, X1, X2, LSL #2",
      "example_note": "X0 = X1 + (X2 << 2)"
    },
    {
      "mnemonic": "SUB (extended)",
      "architecture": "ARMv8",
      "full_name": "Subtract (Extended Register)",
      "summary": "Subtracts an optionally-extended register value.",
      "syntax": "SUB <Xd>, <Xn>, <Wm>, <extend> {#<amount>}",
      "encoding": { "format": "Data Proc", "binary_pattern": "sf 0001011 001 Rm option imm3 Rn Rd", "hex_opcode": "0xCB" },
      "operands": [{ "name": "Xd", "desc": "Dest" }, { "name": "Xn", "desc": "Src1" }, { "name": "Wm", "desc": "Src2 (32-bit)" }],
      "pseudocode": "Xd = Xn - Extend(Wm, amount);",
      "example": "SUB X0, X1, W2, UXTW",
      "example_note": "Subtracts W2 (zero extended) from X1."
    },
    {
      "mnemonic": "MOV (register)",
      "architecture": "ARMv8",
      "full_name": "Move (Register)",
      "summary": "Copies a value from one register to another (Alias of ORR).",
      "syntax": "MOV <Xd>, <Xm>",
      "encoding": { "format": "Alias", "binary_pattern": "sf 0101010 00 Rm 000000 Rn Rd (ORR)", "hex_opcode": "0xAA (ORR)" },
      "operands": [{ "name": "Xd", "desc": "Dest" }, { "name": "Xm", "desc": "Source" }],
      "pseudocode": "Xd = Xm;",
      "example": "MOV X0, X1",
      "example_note": "Copies X1 to X0."
    },
    {
      "mnemonic": "LDR (register)",
      "architecture": "ARMv8",
      "full_name": "Load Register (Register offset)",
      "summary": "Loads a word or doubleword from memory.",
      "syntax": "LDR <Xt>, [<Xn>, <Xm>]",
      "encoding": { "format": "Load/Store", "binary_pattern": "1x 111000 011 Rm 011 S 10 Rn Rt", "hex_opcode": "0xB8" },
      "operands": [{ "name": "Xt", "desc": "Target Reg" }, { "name": "Xn", "desc": "Base Addr" }, { "name": "Xm", "desc": "Offset Reg" }],
      "pseudocode": "Xt = Mem[Xn + Xm];",
      "example": "LDR X0, [X1, X2]",
      "example_note": "Load from address X1+X2 into X0."
    },
    {
      "mnemonic": "STR (immediate)",
      "architecture": "ARMv8",
      "full_name": "Store Register (Immediate offset)",
      "summary": "Stores a word or doubleword to memory.",
      "syntax": "STR <Xt>, [<Xn>, #<simm>]",
      "encoding": { "format": "Load/Store", "binary_pattern": "1x 111001 00 imm12 Rn Rt", "hex_opcode": "0xF9" },
      "operands": [{ "name": "Xt", "desc": "Source Reg" }, { "name": "Xn", "desc": "Base Addr" }, { "name": "simm", "desc": "Offset" }],
      "pseudocode": "Mem[Xn + simm] = Xt;",
      "example": "STR X0, [SP, #8]",
      "example_note": "Store X0 to StackPointer + 8."
    },
    {
      "mnemonic": "B",
      "architecture": "ARMv8",
      "full_name": "Branch",
      "summary": "Unconditionally branches to a PC-relative offset.",
      "syntax": "B <label>",
      "encoding": { "format": "Branch", "binary_pattern": "000101 imm26", "hex_opcode": "0x14" },
      "operands": [{ "name": "label", "desc": "Target" }],
      "pseudocode": "PC = PC + offset;",
      "example": "B LoopStart",
      "example_note": "Jump to LoopStart."
    },
    {
      "mnemonic": "BL",
      "architecture": "ARMv8",
      "full_name": "Branch with Link",
      "summary": "Calls a subroutine, storing return address in X30 (LR).",
      "syntax": "BL <label>",
      "encoding": { "format": "Branch", "binary_pattern": "100101 imm26", "hex_opcode": "0x94" },
      "operands": [{ "name": "label", "desc": "Target" }],
      "pseudocode": "X30 = PC + 4; PC = PC + offset;",
      "example": "BL printf",
      "example_note": "Call printf, return addr in X30."
    },
    {
      "mnemonic": "CBZ",
      "architecture": "ARMv8",
      "full_name": "Compare and Branch on Zero",
      "summary": "Branches if the register is zero.",
      "syntax": "CBZ <Xt>, <label>",
      "encoding": { "format": "Branch", "binary_pattern": "sf 011010 imm19 Rt", "hex_opcode": "0x34" },
      "operands": [{ "name": "Xt", "desc": "Register to test" }, { "name": "label", "desc": "Target" }],
      "pseudocode": "if (Xt == 0) PC = PC + offset;",
      "example": "CBZ X0, ErrorHandler",
      "example_note": "If X0 is 0, jump to ErrorHandler."
    },
    {
      "mnemonic": "CMP (immediate)",
      "architecture": "ARMv8",
      "full_name": "Compare (Immediate)",
      "summary": "Compares register with immediate (Alias of SUBS).",
      "syntax": "CMP <Xn>, #<imm>",
      "encoding": { "format": "Alias", "binary_pattern": "sf 110001 00 imm12 Rn 11111 (SUBS)", "hex_opcode": "0xF1 (SUBS)" },
      "operands": [{ "name": "Xn", "desc": "Source" }, { "name": "imm", "desc": "Value" }],
      "pseudocode": "Discard(Xn - imm); // Update flags",
      "example": "CMP X0, #10",
      "example_note": "Check if X0 == 10 (updates flags)."
    },
    {
      "mnemonic": "ADR",
      "architecture": "ARMv8",
      "full_name": "Form PC-relative Address",
      "summary": "Calculates the address of a label.",
      "syntax": "ADR <Xd>, <label>",
      "encoding": { "format": "Data Proc", "binary_pattern": "0 immlo 10000 immhi Rd", "hex_opcode": "0x10" },
      "operands": [{ "name": "Xd", "desc": "Dest" }, { "name": "label", "desc": "Target" }],
      "pseudocode": "Xd = PC + offset;",
      "example": "ADR X0, MyData",
      "example_note": "Get pointer to MyData into X0."
    }
  ]
}
