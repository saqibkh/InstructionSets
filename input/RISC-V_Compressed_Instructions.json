{
  "instructions": [
    {
      "mnemonic": "C.ADDI4SPN",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Add Immediate to Stack Pointer (Non-zero)",
      "summary": "Adds a zero-extended non-zero immediate to the stack pointer (x2) and stores the result in a register.",
      "syntax": "C.ADDI4SPN rd', uimm",
      "encoding": {
        "format": "CIW",
        "binary_pattern": "000 | uimm | rd' | 00",
        "hex_opcode": "00"
      },
      "operands": [
        { "name": "rd'", "desc": "Dest (x8-x15)" },
        { "name": "uimm", "desc": "Immediate" }
      ],
      "pseudocode": "R[rd'] = R[2] + zext(uimm);",
      "example": "C.ADDI4SPN x8, 16",
      "example_note": "Load address of stack object."
    },
    {
      "mnemonic": "C.LW",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Load Word",
      "summary": "Loads a 32-bit word from memory using a compressed encoding.",
      "syntax": "C.LW rd', offset(rs1')",
      "encoding": {
        "format": "CL",
        "binary_pattern": "010 | imm | rs1' | imm | rd' | 00",
        "hex_opcode": "00"
      },
      "operands": [
        { "name": "rd'", "desc": "Dest (x8-x15)" },
        { "name": "rs1'", "desc": "Base (x8-x15)" },
        { "name": "offset", "desc": "Offset" }
      ],
      "pseudocode": "R[rd'] = M[R[rs1'] + offset][31:0];",
      "example": "C.LW x8, 4(x9)",
      "example_note": "16-bit encoding of LW."
    },
    {
      "mnemonic": "C.SW",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Store Word",
      "summary": "Stores a 32-bit word to memory using a compressed encoding.",
      "syntax": "C.SW rs2', offset(rs1')",
      "encoding": {
        "format": "CS",
        "binary_pattern": "110 | imm | rs1' | imm | rs2' | 00",
        "hex_opcode": "00"
      },
      "operands": [
        { "name": "rs2'", "desc": "Source (x8-x15)" },
        { "name": "rs1'", "desc": "Base (x8-x15)" },
        { "name": "offset", "desc": "Offset" }
      ],
      "pseudocode": "M[R[rs1'] + offset][31:0] = R[rs2'];",
      "example": "C.SW x8, 4(x9)",
      "example_note": "16-bit encoding of SW."
    },
    {
      "mnemonic": "C.ADDI",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Add Immediate",
      "summary": "Adds a non-zero immediate to a register.",
      "syntax": "C.ADDI rd, imm",
      "encoding": {
        "format": "CI",
        "binary_pattern": "000 | imm | rd | imm | 01",
        "hex_opcode": "01"
      },
      "operands": [
        { "name": "rd", "desc": "Dest/Source" },
        { "name": "imm", "desc": "6-bit Signed Imm" }
      ],
      "pseudocode": "R[rd] = R[rd] + sext(imm);",
      "example": "C.ADDI x10, 1",
      "example_note": "Increment x10."
    },
    {
      "mnemonic": "C.JAL",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Jump and Link",
      "summary": "Performs a PC-relative jump and stores return address in x1 (ra). RV32 only.",
      "syntax": "C.JAL offset",
      "encoding": {
        "format": "CJ",
        "binary_pattern": "001 | imm | 01",
        "hex_opcode": "01"
      },
      "operands": [
        { "name": "offset", "desc": "Jump Target" }
      ],
      "pseudocode": "R[1] = PC + 2; PC += sext(offset);",
      "example": "C.JAL func",
      "example_note": "Compressed function call."
    },
    {
      "mnemonic": "C.LI",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Load Immediate",
      "summary": "Loads a 6-bit signed immediate into a register.",
      "syntax": "C.LI rd, imm",
      "encoding": {
        "format": "CI",
        "binary_pattern": "010 | imm | rd | imm | 01",
        "hex_opcode": "01"
      },
      "operands": [
        { "name": "rd", "desc": "Dest" },
        { "name": "imm", "desc": "Immediate" }
      ],
      "pseudocode": "R[rd] = sext(imm);",
      "example": "C.LI x10, 1",
      "example_note": "Set x10 to 1."
    },
    {
      "mnemonic": "C.ADDI16SP",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Add Immediate to Stack Pointer",
      "summary": "Adds a signed non-zero immediate to the stack pointer (x2).",
      "syntax": "C.ADDI16SP imm",
      "encoding": {
        "format": "CI",
        "binary_pattern": "011 | imm | 00010 | imm | 01",
        "hex_opcode": "01"
      },
      "operands": [
        { "name": "imm", "desc": "Signed Imm * 16" }
      ],
      "pseudocode": "R[2] = R[2] + sext(imm);",
      "example": "C.ADDI16SP -64",
      "example_note": "Allocate 64 bytes on stack."
    },
    {
      "mnemonic": "C.LUI",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Load Upper Immediate",
      "summary": "Loads a non-zero 6-bit immediate into bits 17-12 of the destination register, clears lower 12 bits, sign-extends bit 17.",
      "syntax": "C.LUI rd, imm",
      "encoding": {
        "format": "CI",
        "binary_pattern": "011 | imm | rd | imm | 01",
        "hex_opcode": "01"
      },
      "operands": [
        { "name": "rd", "desc": "Dest" },
        { "name": "imm", "desc": "Immediate" }
      ],
      "pseudocode": "R[rd] = sext(imm << 12);",
      "example": "C.LUI x10, 1",
      "example_note": "Loads 0x1000 into x10."
    },
    {
      "mnemonic": "C.SRLI",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Shift Right Logical Immediate",
      "summary": "Logically shifts a register right by immediate.",
      "syntax": "C.SRLI rd', imm",
      "encoding": {
        "format": "CB",
        "binary_pattern": "100 | imm | 00 | imm | rd' | 01",
        "hex_opcode": "01"
      },
      "operands": [
        { "name": "rd'", "desc": "Dest/Source (x8-x15)" },
        { "name": "imm", "desc": "Shift Amount" }
      ],
      "pseudocode": "R[rd'] = R[rd'] >> imm;",
      "example": "C.SRLI x8, 2",
      "example_note": "x8 = x8 >> 2"
    },
    {
      "mnemonic": "C.SRAI",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Shift Right Arithmetic Immediate",
      "summary": "Arithmetically shifts a register right by immediate.",
      "syntax": "C.SRAI rd', imm",
      "encoding": {
        "format": "CB",
        "binary_pattern": "100 | imm | 01 | imm | rd' | 01",
        "hex_opcode": "01"
      },
      "operands": [
        { "name": "rd'", "desc": "Dest/Source" },
        { "name": "imm", "desc": "Shift Amount" }
      ],
      "pseudocode": "R[rd'] = R[rd'] >>s imm;",
      "example": "C.SRAI x8, 2",
      "example_note": "x8 = x8 >>s 2"
    },
    {
      "mnemonic": "C.ANDI",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed AND Immediate",
      "summary": "Computes bitwise AND with a signed immediate.",
      "syntax": "C.ANDI rd', imm",
      "encoding": {
        "format": "CB",
        "binary_pattern": "100 | imm | 10 | imm | rd' | 01",
        "hex_opcode": "01"
      },
      "operands": [
        { "name": "rd'", "desc": "Dest/Source" },
        { "name": "imm", "desc": "Signed Imm" }
      ],
      "pseudocode": "R[rd'] = R[rd'] & sext(imm);",
      "example": "C.ANDI x8, 15",
      "example_note": "Keep lowest 4 bits."
    },
    {
      "mnemonic": "C.SUB",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Subtract",
      "summary": "Subtracts two registers.",
      "syntax": "C.SUB rd', rs2'",
      "encoding": {
        "format": "CA",
        "binary_pattern": "100011 | rd' | 00 | rs2' | 01",
        "hex_opcode": "01"
      },
      "operands": [
        { "name": "rd'", "desc": "Dest/Src1" },
        { "name": "rs2'", "desc": "Src2" }
      ],
      "pseudocode": "R[rd'] = R[rd'] - R[rs2'];",
      "example": "C.SUB x8, x9",
      "example_note": "x8 = x8 - x9"
    },
    {
      "mnemonic": "C.XOR",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed XOR",
      "summary": "Bitwise XOR of two registers.",
      "syntax": "C.XOR rd', rs2'",
      "encoding": {
        "format": "CA",
        "binary_pattern": "100011 | rd' | 01 | rs2' | 01",
        "hex_opcode": "01"
      },
      "operands": [
        { "name": "rd'", "desc": "Dest/Src1" },
        { "name": "rs2'", "desc": "Src2" }
      ],
      "pseudocode": "R[rd'] = R[rd'] ^ R[rs2'];",
      "example": "C.XOR x8, x9",
      "example_note": "x8 = x8 ^ x9"
    },
    {
      "mnemonic": "C.OR",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed OR",
      "summary": "Bitwise OR of two registers.",
      "syntax": "C.OR rd', rs2'",
      "encoding": {
        "format": "CA",
        "binary_pattern": "100011 | rd' | 10 | rs2' | 01",
        "hex_opcode": "01"
      },
      "operands": [
        { "name": "rd'", "desc": "Dest/Src1" },
        { "name": "rs2'", "desc": "Src2" }
      ],
      "pseudocode": "R[rd'] = R[rd'] | R[rs2'];",
      "example": "C.OR x8, x9",
      "example_note": "x8 = x8 | x9"
    },
    {
      "mnemonic": "C.AND",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed AND",
      "summary": "Bitwise AND of two registers.",
      "syntax": "C.AND rd', rs2'",
      "encoding": {
        "format": "CA",
        "binary_pattern": "100011 | rd' | 11 | rs2' | 01",
        "hex_opcode": "01"
      },
      "operands": [
        { "name": "rd'", "desc": "Dest/Src1" },
        { "name": "rs2'", "desc": "Src2" }
      ],
      "pseudocode": "R[rd'] = R[rd'] & R[rs2'];",
      "example": "C.AND x8, x9",
      "example_note": "x8 = x8 & x9"
    },
    {
      "mnemonic": "C.J",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Jump",
      "summary": "Unconditional PC-relative jump.",
      "syntax": "C.J offset",
      "encoding": {
        "format": "CJ",
        "binary_pattern": "101 | imm | 01",
        "hex_opcode": "01"
      },
      "operands": [
        { "name": "offset", "desc": "Target" }
      ],
      "pseudocode": "PC += sext(offset);",
      "example": "C.J label",
      "example_note": "Jump to label."
    },
    {
      "mnemonic": "C.BEQZ",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Branch if Equal to Zero",
      "summary": "Branches if the register is zero.",
      "syntax": "C.BEQZ rs1', offset",
      "encoding": {
        "format": "CB",
        "binary_pattern": "110 | imm | rs1' | imm | 01",
        "hex_opcode": "01"
      },
      "operands": [
        { "name": "rs1'", "desc": "Source" },
        { "name": "offset", "desc": "Target" }
      ],
      "pseudocode": "if (R[rs1'] == 0) PC += sext(offset);",
      "example": "C.BEQZ x8, exit",
      "example_note": "Jump if x8 is 0."
    },
    {
      "mnemonic": "C.BNEZ",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Branch if Not Equal to Zero",
      "summary": "Branches if the register is not zero.",
      "syntax": "C.BNEZ rs1', offset",
      "encoding": {
        "format": "CB",
        "binary_pattern": "111 | imm | rs1' | imm | 01",
        "hex_opcode": "01"
      },
      "operands": [
        { "name": "rs1'", "desc": "Source" },
        { "name": "offset", "desc": "Target" }
      ],
      "pseudocode": "if (R[rs1'] != 0) PC += sext(offset);",
      "example": "C.BNEZ x8, loop",
      "example_note": "Jump if x8 is not 0."
    },
    {
      "mnemonic": "C.SLLI",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Shift Left Logical Immediate",
      "summary": "Logically shifts a register left by immediate.",
      "syntax": "C.SLLI rd, imm",
      "encoding": {
        "format": "CI",
        "binary_pattern": "000 | imm | rd | imm | 10",
        "hex_opcode": "02"
      },
      "operands": [
        { "name": "rd", "desc": "Dest/Source" },
        { "name": "imm", "desc": "Shift Amount" }
      ],
      "pseudocode": "R[rd] = R[rd] << imm;",
      "example": "C.SLLI x10, 2",
      "example_note": "x10 = x10 << 2"
    },
    {
      "mnemonic": "C.LWSP",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Load Word from Stack Pointer",
      "summary": "Loads a word from the stack pointer (x2).",
      "syntax": "C.LWSP rd, offset(x2)",
      "encoding": {
        "format": "CI",
        "binary_pattern": "010 | imm | rd | imm | 10",
        "hex_opcode": "02"
      },
      "operands": [
        { "name": "rd", "desc": "Dest" },
        { "name": "offset", "desc": "Offset" }
      ],
      "pseudocode": "R[rd] = M[R[2] + offset][31:0];",
      "example": "C.LWSP x10, 4(x2)",
      "example_note": "Load from stack."
    },
    {
      "mnemonic": "C.SWSP",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Store Word to Stack Pointer",
      "summary": "Stores a word to the stack pointer (x2).",
      "syntax": "C.SWSP rs2, offset(x2)",
      "encoding": {
        "format": "CSS",
        "binary_pattern": "110 | imm | rs2 | 10",
        "hex_opcode": "02"
      },
      "operands": [
        { "name": "rs2", "desc": "Source" },
        { "name": "offset", "desc": "Offset" }
      ],
      "pseudocode": "M[R[2] + offset][31:0] = R[rs2];",
      "example": "C.SWSP x10, 8(x2)",
      "example_note": "Store to stack."
    },
    {
      "mnemonic": "C.JR",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Jump Register",
      "summary": "Unconditionally jumps to address in register.",
      "syntax": "C.JR rs1",
      "encoding": {
        "format": "CR",
        "binary_pattern": "1000 | rs1 | 00000 | 10",
        "hex_opcode": "02"
      },
      "operands": [
        { "name": "rs1", "desc": "Address" }
      ],
      "pseudocode": "PC = R[rs1];",
      "example": "C.JR x1",
      "example_note": "Return (if x1 is ra)."
    },
    {
      "mnemonic": "C.MV",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Move",
      "summary": "Copies register rs2 to rd.",
      "syntax": "C.MV rd, rs2",
      "encoding": {
        "format": "CR",
        "binary_pattern": "1000 | rd | rs2 | 10",
        "hex_opcode": "02"
      },
      "operands": [
        { "name": "rd", "desc": "Dest" },
        { "name": "rs2", "desc": "Source" }
      ],
      "pseudocode": "R[rd] = R[rs2];",
      "example": "C.MV x10, x11",
      "example_note": "Copy x11 to x10."
    },
    {
      "mnemonic": "C.EBREAK",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Environment Break",
      "summary": "Triggers a debugger breakpoint.",
      "syntax": "C.EBREAK",
      "encoding": {
        "format": "CR",
        "binary_pattern": "1001000000000010",
        "hex_opcode": "9002"
      },
      "operands": [],
      "pseudocode": "RaiseException(Breakpoint);",
      "example": "C.EBREAK",
      "example_note": "Break."
    },
    {
      "mnemonic": "C.JALR",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Jump and Link Register",
      "summary": "Jumps to register address and links (saves PC+2 to ra).",
      "syntax": "C.JALR rs1",
      "encoding": {
        "format": "CR",
        "binary_pattern": "1001 | rs1 | 00000 | 10",
        "hex_opcode": "02"
      },
      "operands": [
        { "name": "rs1", "desc": "Address" }
      ],
      "pseudocode": "t = PC + 2; PC = R[rs1]; R[1] = t;",
      "example": "C.JALR x10",
      "example_note": "Call function pointer in x10."
    },
    {
      "mnemonic": "C.ADD",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Add",
      "summary": "Adds two registers.",
      "syntax": "C.ADD rd, rs2",
      "encoding": {
        "format": "CR",
        "binary_pattern": "1001 | rd | rs2 | 10",
        "hex_opcode": "02"
      },
      "operands": [
        { "name": "rd", "desc": "Dest/Src1" },
        { "name": "rs2", "desc": "Src2" }
      ],
      "pseudocode": "R[rd] = R[rd] + R[rs2];",
      "example": "C.ADD x10, x11",
      "example_note": "x10 = x10 + x11"
    }
  ]
}
