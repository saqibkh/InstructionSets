{
  "instructions": [
    {
      "mnemonic": "mov",
      "architecture": "x86",
      "full_name": "Move",
      "summary": "Copies data from source to destination.",
      "syntax": "MOV r/m, r",
      "encoding": { "format": "Legacy", "hex_opcode": "88/89/8A/8B" },
      "extension": "Base"
    },
    {
      "mnemonic": "add",
      "architecture": "x86",
      "full_name": "Add",
      "summary": "Adds source to destination.",
      "syntax": "ADD r/m, r",
      "encoding": { "format": "Legacy", "hex_opcode": "00-05" },
      "extension": "Base"
    },
    {
      "mnemonic": "sub",
      "architecture": "x86",
      "full_name": "Subtract",
      "summary": "Subtracts source from destination.",
      "syntax": "SUB r/m, r",
      "encoding": { "format": "Legacy", "hex_opcode": "28-2D" },
      "extension": "Base"
    },
    {
      "mnemonic": "inc",
      "architecture": "x86",
      "full_name": "Increment",
      "summary": "Increments operand by 1.",
      "syntax": "INC r/m",
      "encoding": { "format": "Legacy", "hex_opcode": "FF /0" },
      "extension": "Base"
    },
    {
      "mnemonic": "dec",
      "architecture": "x86",
      "full_name": "Decrement",
      "summary": "Decrements operand by 1.",
      "syntax": "DEC r/m",
      "encoding": { "format": "Legacy", "hex_opcode": "FF /1" },
      "extension": "Base"
    },
    {
      "mnemonic": "mul",
      "architecture": "x86",
      "full_name": "Unsigned Multiply",
      "summary": "Unsigned multiply (AX = AL * src).",
      "syntax": "MUL r/m",
      "encoding": { "format": "Legacy", "hex_opcode": "F7 /4" },
      "extension": "Base"
    },
    {
      "mnemonic": "imul",
      "architecture": "x86",
      "full_name": "Signed Multiply",
      "summary": "Signed multiply.",
      "syntax": "IMUL r, r/m",
      "encoding": { "format": "Legacy", "hex_opcode": "0F AF" },
      "extension": "Base"
    },
    {
      "mnemonic": "div",
      "architecture": "x86",
      "full_name": "Unsigned Divide",
      "summary": "Unsigned divide (AX / src).",
      "syntax": "DIV r/m",
      "encoding": { "format": "Legacy", "hex_opcode": "F7 /6" },
      "extension": "Base"
    },
    {
      "mnemonic": "idiv",
      "architecture": "x86",
      "full_name": "Signed Divide",
      "summary": "Signed divide (AX / src).",
      "syntax": "IDIV r/m",
      "encoding": { "format": "Legacy", "hex_opcode": "F7 /7" },
      "extension": "Base"
    },
    {
      "mnemonic": "and",
      "architecture": "x86",
      "full_name": "Logical AND",
      "summary": "Performs bitwise AND.",
      "syntax": "AND r/m, r",
      "encoding": { "format": "Legacy", "hex_opcode": "20-25" },
      "extension": "Base"
    },
    {
      "mnemonic": "or",
      "architecture": "x86",
      "full_name": "Logical OR",
      "summary": "Performs bitwise OR.",
      "syntax": "OR r/m, r",
      "encoding": { "format": "Legacy", "hex_opcode": "08-0D" },
      "extension": "Base"
    },
    {
      "mnemonic": "xor",
      "architecture": "x86",
      "full_name": "Logical Exclusive OR",
      "summary": "Performs bitwise XOR.",
      "syntax": "XOR r/m, r",
      "encoding": { "format": "Legacy", "hex_opcode": "30-35" },
      "extension": "Base"
    },
    {
      "mnemonic": "not",
      "architecture": "x86",
      "full_name": "One's Complement Negation",
      "summary": "Reverses bits of operand.",
      "syntax": "NOT r/m",
      "encoding": { "format": "Legacy", "hex_opcode": "F7 /2" },
      "extension": "Base"
    },
    {
      "mnemonic": "neg",
      "architecture": "x86",
      "full_name": "Two's Complement Negation",
      "summary": "Negates value (0 - operand).",
      "syntax": "NEG r/m",
      "encoding": { "format": "Legacy", "hex_opcode": "F7 /3" },
      "extension": "Base"
    },
    {
      "mnemonic": "shl",
      "architecture": "x86",
      "full_name": "Shift Logical Left",
      "summary": "Shifts bits left (same as SAL).",
      "syntax": "SHL r/m, imm8",
      "encoding": { "format": "Legacy", "hex_opcode": "C1 /4" },
      "extension": "Base"
    },
    {
      "mnemonic": "shr",
      "architecture": "x86",
      "full_name": "Shift Logical Right",
      "summary": "Shifts bits right, filling with zeros.",
      "syntax": "SHR r/m, imm8",
      "encoding": { "format": "Legacy", "hex_opcode": "C1 /5" },
      "extension": "Base"
    },
    {
      "mnemonic": "sar",
      "architecture": "x86",
      "full_name": "Shift Arithmetic Right",
      "summary": "Shifts bits right, preserving sign bit.",
      "syntax": "SAR r/m, imm8",
      "encoding": { "format": "Legacy", "hex_opcode": "C1 /7" },
      "extension": "Base"
    },
    {
      "mnemonic": "cmp",
      "architecture": "x86",
      "full_name": "Compare Two Operands",
      "summary": "Subtracts src from dest and updates flags (dest not modified).",
      "syntax": "CMP r/m, r",
      "encoding": { "format": "Legacy", "hex_opcode": "38-3D" },
      "extension": "Base"
    },
    {
      "mnemonic": "test",
      "architecture": "x86",
      "full_name": "Logical Compare",
      "summary": "ANDs operands and updates flags (result discarded).",
      "syntax": "TEST r/m, r",
      "encoding": { "format": "Legacy", "hex_opcode": "84-85" },
      "extension": "Base"
    },
    {
      "mnemonic": "jmp",
      "architecture": "x86",
      "full_name": "Jump",
      "summary": "Unconditional jump to target.",
      "syntax": "JMP rel",
      "encoding": { "format": "Legacy", "hex_opcode": "EB / E9" },
      "extension": "Base"
    },
    {
      "mnemonic": "je",
      "architecture": "x86",
      "full_name": "Jump if Equal",
      "summary": "Jump if ZF=1 (Same as JZ).",
      "syntax": "JE rel",
      "encoding": { "format": "Legacy", "hex_opcode": "74" },
      "extension": "Base"
    },
    {
      "mnemonic": "jne",
      "architecture": "x86",
      "full_name": "Jump if Not Equal",
      "summary": "Jump if ZF=0 (Same as JNZ).",
      "syntax": "JNE rel",
      "encoding": { "format": "Legacy", "hex_opcode": "75" },
      "extension": "Base"
    },
    {
      "mnemonic": "jg",
      "architecture": "x86",
      "full_name": "Jump if Greater",
      "summary": "Jump if ZF=0 and SF=OF (Signed >).",
      "syntax": "JG rel",
      "encoding": { "format": "Legacy", "hex_opcode": "7F" },
      "extension": "Base"
    },
    {
      "mnemonic": "jl",
      "architecture": "x86",
      "full_name": "Jump if Less",
      "summary": "Jump if SF!=OF (Signed <).",
      "syntax": "JL rel",
      "encoding": { "format": "Legacy", "hex_opcode": "7C" },
      "extension": "Base"
    },
    {
      "mnemonic": "ja",
      "architecture": "x86",
      "full_name": "Jump if Above",
      "summary": "Jump if CF=0 and ZF=0 (Unsigned >).",
      "syntax": "JA rel",
      "encoding": { "format": "Legacy", "hex_opcode": "77" },
      "extension": "Base"
    },
    {
      "mnemonic": "jb",
      "architecture": "x86",
      "full_name": "Jump if Below",
      "summary": "Jump if CF=1 (Unsigned <).",
      "syntax": "JB rel",
      "encoding": { "format": "Legacy", "hex_opcode": "72" },
      "extension": "Base"
    },
    {
      "mnemonic": "call",
      "architecture": "x86",
      "full_name": "Call Procedure",
      "summary": "Push EIP/RIP and jump to target.",
      "syntax": "CALL rel",
      "encoding": { "format": "Legacy", "hex_opcode": "E8" },
      "extension": "Base"
    },
    {
      "mnemonic": "ret",
      "architecture": "x86",
      "full_name": "Return from Procedure",
      "summary": "Pop EIP/RIP and resume execution.",
      "syntax": "RET",
      "encoding": { "format": "Legacy", "hex_opcode": "C3" },
      "extension": "Base"
    },
    {
      "mnemonic": "push",
      "architecture": "x86",
      "full_name": "Push Value Onto Stack",
      "summary": "Decrements SP and stores operand on stack.",
      "syntax": "PUSH r/m",
      "encoding": { "format": "Legacy", "hex_opcode": "FF /6" },
      "extension": "Base"
    },
    {
      "mnemonic": "pop",
      "architecture": "x86",
      "full_name": "Pop Value from Stack",
      "summary": "Loads operand from stack and increments SP.",
      "syntax": "POP r/m",
      "encoding": { "format": "Legacy", "hex_opcode": "8F /0" },
      "extension": "Base"
    },
    {
      "mnemonic": "lea",
      "architecture": "x86",
      "full_name": "Load Effective Address",
      "summary": "Computes effective address and stores in register.",
      "syntax": "LEA r, m",
      "encoding": { "format": "Legacy", "hex_opcode": "8D" },
      "extension": "Base"
    },
    {
      "mnemonic": "nop",
      "architecture": "x86",
      "full_name": "No Operation",
      "summary": "Does nothing (alias for XCHG EAX, EAX).",
      "syntax": "NOP",
      "encoding": { "format": "Legacy", "hex_opcode": "90" },
      "extension": "Base"
    },
    {
      "mnemonic": "xchg",
      "architecture": "x86",
      "full_name": "Exchange Register/Memory with Register",
      "summary": "Exchanges content of two operands.",
      "syntax": "XCHG r/m, r",
      "encoding": { "format": "Legacy", "hex_opcode": "87" },
      "extension": "Base"
    },
    {
      "mnemonic": "cpuid",
      "architecture": "x86",
      "full_name": "CPU Identification",
      "summary": "Returns processor information based on EAX value.",
      "syntax": "CPUID",
      "encoding": { "format": "Legacy", "hex_opcode": "0F A2" },
      "extension": "Base"
    },
    {
      "mnemonic": "rdtsc",
      "architecture": "x86",
      "full_name": "Read Time-Stamp Counter",
      "summary": "Reads the time-stamp counter into EDX:EAX.",
      "syntax": "RDTSC",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 31" },
      "extension": "Base"
    },
    {
      "mnemonic": "movsx",
      "architecture": "x86",
      "full_name": "Move with Sign-Extension",
      "summary": "Copies and sign-extends a smaller value to a larger register.",
      "syntax": "MOVSX r, r/m",
      "encoding": { "format": "Legacy", "hex_opcode": "0F BE" },
      "extension": "Base"
    },
    {
      "mnemonic": "movzx",
      "architecture": "x86",
      "full_name": "Move with Zero-Extension",
      "summary": "Copies and zero-extends a smaller value to a larger register.",
      "syntax": "MOVZX r, r/m",
      "encoding": { "format": "Legacy", "hex_opcode": "0F B6" },
      "extension": "Base"
    },
    {
      "mnemonic": "cwtl",
      "architecture": "x86",
      "full_name": "Convert Word to Long",
      "summary": "Sign-extends AX into EAX (also CWDE).",
      "syntax": "CWTL",
      "encoding": { "format": "Legacy", "hex_opcode": "98" },
      "extension": "Base"
    },
    {
      "mnemonic": "cltd",
      "architecture": "x86",
      "full_name": "Convert Long to Double Long",
      "summary": "Sign-extends EAX into EDX:EAX (also CDQ).",
      "syntax": "CLTD",
      "encoding": { "format": "Legacy", "hex_opcode": "99" },
      "extension": "Base"
    },
    {
      "mnemonic": "cqto",
      "architecture": "x86",
      "full_name": "Convert Quadword to Octoword",
      "summary": "Sign-extends RAX into RDX:RAX (also CQO).",
      "syntax": "CQTO",
      "encoding": { "format": "Legacy", "hex_opcode": "48 99" },
      "extension": "Base (64-bit)"
    },
    {
      "mnemonic": "bswap",
      "architecture": "x86",
      "full_name": "Byte Swap",
      "summary": "Reverses the byte order of a register (Endian swap).",
      "syntax": "BSWAP r32",
      "encoding": { "format": "Legacy", "hex_opcode": "0F C8+rd" },
      "extension": "Base"
    },
    {
      "mnemonic": "xadd",
      "architecture": "x86",
      "full_name": "Exchange and Add",
      "summary": "Exchanges dest and src, then loads sum into dest.",
      "syntax": "XADD r/m, r",
      "encoding": { "format": "Legacy", "hex_opcode": "0F C1" },
      "extension": "Base"
    },
    {
      "mnemonic": "cmpxchg",
      "architecture": "x86",
      "full_name": "Compare and Exchange",
      "summary": "Compares accumulator with dest; if equal, dest = src; else accumulator = dest.",
      "syntax": "CMPXCHG r/m, r",
      "encoding": { "format": "Legacy", "hex_opcode": "0F B1" },
      "extension": "Base"
    },
    {
      "mnemonic": "cmovcc",
      "architecture": "x86",
      "full_name": "Conditional Move",
      "summary": "Moves data if condition code is met (e.g., CMOVE, CMOVNE).",
      "syntax": "CMOVcc r, r/m",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 4x" },
      "extension": "CMOV"
    },
    {
      "mnemonic": "setcc",
      "architecture": "x86",
      "full_name": "Set Byte on Condition",
      "summary": "Sets byte to 1 if condition met, else 0 (e.g., SETE, SETZ).",
      "syntax": "SETcc r/m8",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 9x" },
      "extension": "Base"
    },
    {
      "mnemonic": "hlt",
      "architecture": "x86",
      "full_name": "Halt",
      "summary": "Stops instruction execution and places processor in HALT state.",
      "syntax": "HLT",
      "encoding": { "format": "Legacy", "hex_opcode": "F4" },
      "extension": "Base"
    },
    {
      "mnemonic": "int",
      "architecture": "x86",
      "full_name": "Interrupt",
      "summary": "Calls to interrupt procedure.",
      "syntax": "INT imm8",
      "encoding": { "format": "Legacy", "hex_opcode": "CD" },
      "extension": "Base"
    },
    {
      "mnemonic": "int3",
      "architecture": "x86",
      "full_name": "Breakpoint",
      "summary": "Calls to interrupt vector 3 (Debugger breakpoint).",
      "syntax": "INT3",
      "encoding": { "format": "Legacy", "hex_opcode": "CC" },
      "extension": "Base"
    },
    {
      "mnemonic": "ud2",
      "architecture": "x86",
      "full_name": "Undefined Instruction",
      "summary": "Generates an invalid opcode exception.",
      "syntax": "UD2",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 0B" },
      "extension": "Base"
    },
    {
      "mnemonic": "pause",
      "architecture": "x86",
      "full_name": "Spin Loop Hint",
      "summary": "Improves performance of spin-wait loops (alias for REP NOP).",
      "syntax": "PAUSE",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 90" },
      "extension": "Base"
    },
    {
      "mnemonic": "clc",
      "architecture": "x86",
      "full_name": "Clear Carry Flag",
      "summary": "Sets the CF flag to 0.",
      "syntax": "CLC",
      "encoding": { "format": "Legacy", "hex_opcode": "F8" },
      "extension": "Base"
    },
    {
      "mnemonic": "stc",
      "architecture": "x86",
      "full_name": "Set Carry Flag",
      "summary": "Sets the CF flag to 1.",
      "syntax": "STC",
      "encoding": { "format": "Legacy", "hex_opcode": "F9" },
      "extension": "Base"
    },
    {
      "mnemonic": "cmc",
      "architecture": "x86",
      "full_name": "Complement Carry Flag",
      "summary": "Toggles the CF flag.",
      "syntax": "CMC",
      "encoding": { "format": "Legacy", "hex_opcode": "F5" },
      "extension": "Base"
    },
    {
      "mnemonic": "cld",
      "architecture": "x86",
      "full_name": "Clear Direction Flag",
      "summary": "Sets DF to 0 (String operations increment).",
      "syntax": "CLD",
      "encoding": { "format": "Legacy", "hex_opcode": "FC" },
      "extension": "Base"
    },
    {
      "mnemonic": "std",
      "architecture": "x86",
      "full_name": "Set Direction Flag",
      "summary": "Sets DF to 1 (String operations decrement).",
      "syntax": "STD",
      "encoding": { "format": "Legacy", "hex_opcode": "FD" },
      "extension": "Base"
    },
    {
      "mnemonic": "cli",
      "architecture": "x86",
      "full_name": "Clear Interrupt Flag",
      "summary": "Disables maskable hardware interrupts.",
      "syntax": "CLI",
      "encoding": { "format": "Legacy", "hex_opcode": "FA" },
      "extension": "Base"
    },
    {
      "mnemonic": "sti",
      "architecture": "x86",
      "full_name": "Set Interrupt Flag",
      "summary": "Enables maskable hardware interrupts.",
      "syntax": "STI",
      "encoding": { "format": "Legacy", "hex_opcode": "FB" },
      "extension": "Base"
    },
    {
      "mnemonic": "sahf",
      "architecture": "x86",
      "full_name": "Store AH into Flags",
      "summary": "Loads SF, ZF, AF, PF, and CF from AH.",
      "syntax": "SAHF",
      "encoding": { "format": "Legacy", "hex_opcode": "9E" },
      "extension": "Base"
    },
    {
      "mnemonic": "lahf",
      "architecture": "x86",
      "full_name": "Load Flags into AH",
      "summary": "Loads bits 0, 2, 4, 6, and 7 of EFLAGS into AH.",
      "syntax": "LAHF",
      "encoding": { "format": "Legacy", "hex_opcode": "9F" },
      "extension": "Base"
    },
    {
      "mnemonic": "loop",
      "architecture": "x86",
      "full_name": "Loop",
      "summary": "Decrements ECX/RCX and jumps if not zero.",
      "syntax": "LOOP rel",
      "encoding": { "format": "Legacy", "hex_opcode": "E2" },
      "extension": "Base"
    },
    {
      "mnemonic": "loope",
      "architecture": "x86",
      "full_name": "Loop if Equal",
      "summary": "Decrements count; jumps if count!=0 and ZF=1.",
      "syntax": "LOOPE rel",
      "encoding": { "format": "Legacy", "hex_opcode": "E1" },
      "extension": "Base"
    },
    {
      "mnemonic": "loopne",
      "architecture": "x86",
      "full_name": "Loop if Not Equal",
      "summary": "Decrements count; jumps if count!=0 and ZF=0.",
      "syntax": "LOOPNE rel",
      "encoding": { "format": "Legacy", "hex_opcode": "E0" },
      "extension": "Base"
    },
    {
      "mnemonic": "jecxz",
      "architecture": "x86",
      "full_name": "Jump if ECX is Zero",
      "summary": "Jumps if ECX register is 0.",
      "syntax": "JECXZ rel",
      "encoding": { "format": "Legacy", "hex_opcode": "E3" },
      "extension": "Base"
    },
    {
      "mnemonic": "enter",
      "architecture": "x86",
      "full_name": "Make Stack Frame",
      "summary": "Creates a stack frame for procedure parameters.",
      "syntax": "ENTER imm16, imm8",
      "encoding": { "format": "Legacy", "hex_opcode": "C8" },
      "extension": "Base"
    },
    {
      "mnemonic": "leave",
      "architecture": "x86",
      "full_name": "High Level Procedure Exit",
      "summary": "Releases stack frame (MOV ESP, EBP; POP EBP).",
      "syntax": "LEAVE",
      "encoding": { "format": "Legacy", "hex_opcode": "C9" },
      "extension": "Base"
    },
    {
      "mnemonic": "rep movs",
      "architecture": "x86",
      "full_name": "Repeat Move String",
      "summary": "Moves ECX bytes/words from [ESI] to [EDI].",
      "syntax": "REP MOVS m, m",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 A4/A5" },
      "extension": "Base"
    },
    {
      "mnemonic": "rep stos",
      "architecture": "x86",
      "full_name": "Repeat Store String",
      "summary": "Fills [EDI] with AL/AX/EAX for ECX repeats.",
      "syntax": "REP STOS m",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 AA/AB" },
      "extension": "Base"
    },
    {
      "mnemonic": "repe cmps",
      "architecture": "x86",
      "full_name": "Repeat Compare String Equal",
      "summary": "Compares [ESI] and [EDI] until mismatch or ECX=0.",
      "syntax": "REPE CMPS m, m",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 A6/A7" },
      "extension": "Base"
    },
    {
      "mnemonic": "repne scas",
      "architecture": "x86",
      "full_name": "Repeat Scan String Not Equal",
      "summary": "Scans [EDI] for AL/AX/EAX until match or ECX=0.",
      "syntax": "REPNE SCAS m",
      "encoding": { "format": "Legacy", "hex_opcode": "F2 AE/AF" },
      "extension": "Base"
    },
    {
      "mnemonic": "rol",
      "architecture": "x86",
      "full_name": "Rotate Left",
      "summary": "Rotates bits left.",
      "syntax": "ROL r/m, imm8",
      "encoding": { "format": "Legacy", "hex_opcode": "C1 /0" },
      "extension": "Base"
    },
    {
      "mnemonic": "ror",
      "architecture": "x86",
      "full_name": "Rotate Right",
      "summary": "Rotates bits right.",
      "syntax": "ROR r/m, imm8",
      "encoding": { "format": "Legacy", "hex_opcode": "C1 /1" },
      "extension": "Base"
    },
    {
      "mnemonic": "rcl",
      "architecture": "x86",
      "full_name": "Rotate Carry Left",
      "summary": "Rotates bits left through Carry Flag.",
      "syntax": "RCL r/m, imm8",
      "encoding": { "format": "Legacy", "hex_opcode": "C1 /2" },
      "extension": "Base"
    },
    {
      "mnemonic": "rcr",
      "architecture": "x86",
      "full_name": "Rotate Carry Right",
      "summary": "Rotates bits right through Carry Flag.",
      "syntax": "RCR r/m, imm8",
      "encoding": { "format": "Legacy", "hex_opcode": "C1 /3" },
      "extension": "Base"
    },
    {
      "mnemonic": "bt",
      "architecture": "x86",
      "full_name": "Bit Test",
      "summary": "Selects a bit and stores it in CF.",
      "syntax": "BT r/m, r",
      "encoding": { "format": "Legacy", "hex_opcode": "0F A3" },
      "extension": "Base"
    },
    {
      "mnemonic": "bts",
      "architecture": "x86",
      "full_name": "Bit Test and Set",
      "summary": "Stores bit in CF and sets bit to 1.",
      "syntax": "BTS r/m, r",
      "encoding": { "format": "Legacy", "hex_opcode": "0F AB" },
      "extension": "Base"
    },
    {
      "mnemonic": "btr",
      "architecture": "x86",
      "full_name": "Bit Test and Reset",
      "summary": "Stores bit in CF and clears bit to 0.",
      "syntax": "BTR r/m, r",
      "encoding": { "format": "Legacy", "hex_opcode": "0F B3" },
      "extension": "Base"
    },
    {
      "mnemonic": "btc",
      "architecture": "x86",
      "full_name": "Bit Test and Complement",
      "summary": "Stores bit in CF and complements the bit.",
      "syntax": "BTC r/m, r",
      "encoding": { "format": "Legacy", "hex_opcode": "0F BB" },
      "extension": "Base"
    },
    {
      "mnemonic": "bsf",
      "architecture": "x86",
      "full_name": "Bit Scan Forward",
      "summary": "Scans for LSB set to 1.",
      "syntax": "BSF r, r/m",
      "encoding": { "format": "Legacy", "hex_opcode": "0F BC" },
      "extension": "Base"
    },
    {
      "mnemonic": "bsr",
      "architecture": "x86",
      "full_name": "Bit Scan Reverse",
      "summary": "Scans for MSB set to 1.",
      "syntax": "BSR r, r/m",
      "encoding": { "format": "Legacy", "hex_opcode": "0F BD" },
      "extension": "Base"
    },
    {
      "mnemonic": "lzcnt",
      "architecture": "x86",
      "full_name": "Count Leading Zeros",
      "summary": "Counts number of leading zeros.",
      "syntax": "LZCNT r, r/m",
      "encoding": { "format": "VEX", "hex_opcode": "F3 0F BD" },
      "extension": "ABM/BMI"
    },
    {
      "mnemonic": "popcnt",
      "architecture": "x86",
      "full_name": "Population Count",
      "summary": "Counts number of bits set to 1.",
      "syntax": "POPCNT r, r/m",
      "encoding": { "format": "VEX", "hex_opcode": "F3 0F B8" },
      "extension": "SSE4.2"
    },
    {
      "mnemonic": "xlat",
      "architecture": "x86",
      "full_name": "Table Look-up Translation",
      "summary": "Replaces AL with byte from table at [EBX+AL].",
      "syntax": "XLAT m8",
      "encoding": { "format": "Legacy", "hex_opcode": "D7" },
      "extension": "Base"
    },
    {
      "mnemonic": "pushf",
      "architecture": "x86",
      "full_name": "Push Flags",
      "summary": "Pushes EFLAGS onto stack.",
      "syntax": "PUSHF",
      "encoding": { "format": "Legacy", "hex_opcode": "9C" },
      "extension": "Base"
    },
    {
      "mnemonic": "popf",
      "architecture": "x86",
      "full_name": "Pop Flags",
      "summary": "Pops stack into EFLAGS.",
      "syntax": "POPF",
      "encoding": { "format": "Legacy", "hex_opcode": "9D" },
      "extension": "Base"
    },
    {
      "mnemonic": "pusha",
      "architecture": "x86",
      "full_name": "Push All General-Purpose Registers",
      "summary": "Pushes AX, CX, DX, BX, SP, BP, SI, DI (Invalid in 64-bit).",
      "syntax": "PUSHA",
      "encoding": { "format": "Legacy", "hex_opcode": "60" },
      "extension": "Base (32-bit only)"
    },
    {
      "mnemonic": "popa",
      "architecture": "x86",
      "full_name": "Pop All General-Purpose Registers",
      "summary": "Pops into DI, SI, BP, SP, BX, DX, CX, AX (Invalid in 64-bit).",
      "syntax": "POPA",
      "encoding": { "format": "Legacy", "hex_opcode": "61" },
      "extension": "Base (32-bit only)"
    },
    {
      "mnemonic": "bound",
      "architecture": "x86",
      "full_name": "Check Array Index Against Bounds",
      "summary": "Checks if operand is within bounds defined in memory.",
      "syntax": "BOUND r, m",
      "encoding": { "format": "Legacy", "hex_opcode": "62" },
      "extension": "Base (32-bit only)"
    },
    {
      "mnemonic": "aaa",
      "architecture": "x86",
      "full_name": "ASCII Adjust After Addition",
      "summary": "Adjusts AL after addition for unpacked BCD.",
      "syntax": "AAA",
      "encoding": { "format": "Legacy", "hex_opcode": "37" },
      "extension": "Base (Legacy)"
    },
    {
      "mnemonic": "aas",
      "architecture": "x86",
      "full_name": "ASCII Adjust After Subtraction",
      "summary": "Adjusts AL after subtraction for unpacked BCD.",
      "syntax": "AAS",
      "encoding": { "format": "Legacy", "hex_opcode": "3F" },
      "extension": "Base (Legacy)"
    },
    {
      "mnemonic": "daa",
      "architecture": "x86",
      "full_name": "Decimal Adjust After Addition",
      "summary": "Adjusts AL after addition for packed BCD.",
      "syntax": "DAA",
      "encoding": { "format": "Legacy", "hex_opcode": "27" },
      "extension": "Base (Legacy)"
    },
    {
      "mnemonic": "das",
      "architecture": "x86",
      "full_name": "Decimal Adjust After Subtraction",
      "summary": "Adjusts AL after subtraction for packed BCD.",
      "syntax": "DAS",
      "encoding": { "format": "Legacy", "hex_opcode": "2F" },
      "extension": "Base (Legacy)"
    },
    {
      "mnemonic": "aam",
      "architecture": "x86",
      "full_name": "ASCII Adjust After Multiply",
      "summary": "Adjusts AX after multiply for unpacked BCD.",
      "syntax": "AAM imm8",
      "encoding": { "format": "Legacy", "hex_opcode": "D4" },
      "extension": "Base (Legacy)"
    },
    {
      "mnemonic": "aad",
      "architecture": "x86",
      "full_name": "ASCII Adjust Before Division",
      "summary": "Adjusts AX before division for unpacked BCD.",
      "syntax": "AAD imm8",
      "encoding": { "format": "Legacy", "hex_opcode": "D5" },
      "extension": "Base (Legacy)"
    },
    {
      "mnemonic": "cbw",
      "architecture": "x86",
      "full_name": "Convert Byte to Word",
      "summary": "Sign-extends AL into AX.",
      "syntax": "CBW",
      "encoding": { "format": "Legacy", "hex_opcode": "98" },
      "extension": "Base"
    },
    {
      "mnemonic": "cwd",
      "architecture": "x86",
      "full_name": "Convert Word to Doubleword",
      "summary": "Sign-extends AX into DX:AX.",
      "syntax": "CWD",
      "encoding": { "format": "Legacy", "hex_opcode": "99" },
      "extension": "Base"
    },
    {
      "mnemonic": "wait",
      "architecture": "x86",
      "full_name": "Wait",
      "summary": "Wait for FPU (same as FWAIT).",
      "syntax": "WAIT",
      "encoding": { "format": "Legacy", "hex_opcode": "9B" },
      "extension": "Base"
    },
    {
      "mnemonic": "ldtilecfg",
      "architecture": "x86",
      "full_name": "Load Tile Configuration",
      "summary": "Loads AMX tile configuration from memory.",
      "syntax": "LDTILECFG m512",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... 49" },
      "extension": "AMX-TILE"
    },
    {
      "mnemonic": "sttilecfg",
      "architecture": "x86",
      "full_name": "Store Tile Configuration",
      "summary": "Stores AMX tile configuration to memory.",
      "syntax": "STTILECFG m512",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... 49" },
      "extension": "AMX-TILE"
    },
    {
      "mnemonic": "tileloadd",
      "architecture": "x86",
      "full_name": "Load Tile Data",
      "summary": "Loads data into an AMX tile register.",
      "syntax": "TILELOADD tmm1, m",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... 4B" },
      "extension": "AMX-TILE"
    },
    {
      "mnemonic": "tilestored",
      "architecture": "x86",
      "full_name": "Store Tile Data",
      "summary": "Stores data from an AMX tile register to memory.",
      "syntax": "TILESTORED m, tmm1",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... 4B" },
      "extension": "AMX-TILE"
    },
    {
      "mnemonic": "tilezero",
      "architecture": "x86",
      "full_name": "Zero Tile",
      "summary": "Clears an AMX tile register.",
      "syntax": "TILEZERO tmm1",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... 49" },
      "extension": "AMX-TILE"
    },
    {
      "mnemonic": "tdpbssd",
      "architecture": "x86",
      "full_name": "Tile Dot Product Byte Signed Signed Doubleword",
      "summary": "Matrix multiply (Signed Int8 * Signed Int8) accumulating to Int32.",
      "syntax": "TDPBSSD tmm1, tmm2, tmm3",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... 5E" },
      "extension": "AMX-INT8"
    },
    {
      "mnemonic": "tdpbsud",
      "architecture": "x86",
      "full_name": "Tile Dot Product Byte Signed Unsigned Doubleword",
      "summary": "Matrix multiply (Signed * Unsigned) accumulating to Int32.",
      "syntax": "TDPBSUD tmm1, tmm2, tmm3",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... 5E" },
      "extension": "AMX-INT8"
    },
    {
      "mnemonic": "tdpbf16ps",
      "architecture": "x86",
      "full_name": "Tile Dot Product BFloat16 Packed Single",
      "summary": "Matrix multiply (BFloat16) accumulating to Float32.",
      "syntax": "TDPBF16PS tmm1, tmm2, tmm3",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... 5C" },
      "extension": "AMX-BF16"
    },
    {
      "mnemonic": "endbr64",
      "architecture": "x86",
      "full_name": "End Branch 64-bit",
      "summary": "Marker instruction for Indirect Branch Tracking (IBT).",
      "syntax": "ENDBR64",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 0F 1E FA" },
      "extension": "CET-IBT"
    },
    {
      "mnemonic": "endbr32",
      "architecture": "x86",
      "full_name": "End Branch 32-bit",
      "summary": "Marker instruction for Indirect Branch Tracking (IBT).",
      "syntax": "ENDBR32",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 0F 1E FB" },
      "extension": "CET-IBT"
    },
    {
      "mnemonic": "rdsspq",
      "architecture": "x86",
      "full_name": "Read Shadow Stack Pointer (Quadword)",
      "summary": "Reads the current shadow stack pointer into a register.",
      "syntax": "RDSSPQ r64",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 0F 1E /1" },
      "extension": "CET-SS"
    },
    {
      "mnemonic": "incsspq",
      "architecture": "x86",
      "full_name": "Increment Shadow Stack Pointer (Quadword)",
      "summary": "Adjusts the shadow stack pointer.",
      "syntax": "INCSSPQ r64",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 0F AE /5" },
      "extension": "CET-SS"
    },
    {
      "mnemonic": "rstorssp",
      "architecture": "x86",
      "full_name": "Restore Shadow Stack Pointer",
      "summary": "Restores SSP from memory token.",
      "syntax": "RSTORSSP m64",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 0F 01 /5" },
      "extension": "CET-SS"
    },
    {
      "mnemonic": "saveprevssp",
      "architecture": "x86",
      "full_name": "Save Previous Shadow Stack Pointer",
      "summary": "Saves the previous SSP to the shadow stack token.",
      "syntax": "SAVEPREVSSP",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 0F 01 EA" },
      "extension": "CET-SS"
    },
    {
      "mnemonic": "clwb",
      "architecture": "x86",
      "full_name": "Cache Line Write Back",
      "summary": "Writes back modified cache line without flushing (Persistent Memory).",
      "syntax": "CLWB m8",
      "encoding": { "format": "Legacy", "hex_opcode": "66 0F AE /6" },
      "extension": "CLWB"
    },
    {
      "mnemonic": "clflushopt",
      "architecture": "x86",
      "full_name": "Optimized Cache Line Flush",
      "summary": "Optimized version of CLFLUSH (Higher throughput).",
      "syntax": "CLFLUSHOPT m8",
      "encoding": { "format": "Legacy", "hex_opcode": "66 0F AE /7" },
      "extension": "CLFLUSHOPT"
    },
    {
      "mnemonic": "cldemote",
      "architecture": "x86",
      "full_name": "Cache Line Demote",
      "summary": "Hints to move cache line to lower cache level.",
      "syntax": "CLDEMOTE m8",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 1C /0" },
      "extension": "CLDEMOTE"
    },
    {
      "mnemonic": "movdiri",
      "architecture": "x86",
      "full_name": "Move Direct Store Integer",
      "summary": "Moves 32/64-bit data avoiding cache pollution (Direct IO).",
      "syntax": "MOVDIRI m, r",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 38 F9" },
      "extension": "MOVDIRI"
    },
    {
      "mnemonic": "movdir64b",
      "architecture": "x86",
      "full_name": "Move Direct Store 64-Bytes",
      "summary": "Atomically moves 64-byte block avoiding cache pollution.",
      "syntax": "MOVDIR64B m512, m512",
      "encoding": { "format": "Legacy", "hex_opcode": "66 0F 38 F8" },
      "extension": "MOVDIR64B"
    },
    {
      "mnemonic": "xbegin",
      "architecture": "x86",
      "full_name": "Transaction Begin",
      "summary": "Specifies start of Restricted Transactional Memory region.",
      "syntax": "XBEGIN rel",
      "encoding": { "format": "Legacy", "hex_opcode": "C7 F8" },
      "extension": "RTM (TSX)"
    },
    {
      "mnemonic": "xend",
      "architecture": "x86",
      "full_name": "Transaction End",
      "summary": "Specifies end of RTM region.",
      "syntax": "XEND",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 01 D5" },
      "extension": "RTM (TSX)"
    },
    {
      "mnemonic": "xabort",
      "architecture": "x86",
      "full_name": "Transaction Abort",
      "summary": "Forces an RTM abort.",
      "syntax": "XABORT imm8",
      "encoding": { "format": "Legacy", "hex_opcode": "C6 F8" },
      "extension": "RTM (TSX)"
    },
    {
      "mnemonic": "xtest",
      "architecture": "x86",
      "full_name": "Test If In Transaction",
      "summary": "Sets ZF if processor is in transactional region.",
      "syntax": "XTEST",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 01 D6" },
      "extension": "TSX"
    },
    {
      "mnemonic": "umonitor",
      "architecture": "x86",
      "full_name": "User Level Monitor",
      "summary": "Sets up a monitor address for User Wait instructions.",
      "syntax": "UMONITOR r64",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 0F AE /6" },
      "extension": "WAITPKG"
    },
    {
      "mnemonic": "umwait",
      "architecture": "x86",
      "full_name": "User Level Monitor Wait",
      "summary": "Waits for store to monitored address (Low power state).",
      "syntax": "UMWAIT r32",
      "encoding": { "format": "Legacy", "hex_opcode": "F2 0F AE /6" },
      "extension": "WAITPKG"
    },
    {
      "mnemonic": "tpause",
      "architecture": "x86",
      "full_name": "Timed Pause",
      "summary": "Pauses execution for a specified time or until trigger.",
      "syntax": "TPAUSE r32",
      "encoding": { "format": "Legacy", "hex_opcode": "66 0F AE /6" },
      "extension": "WAITPKG"
    },
    {
      "mnemonic": "vaddph",
      "architecture": "x86",
      "full_name": "Add Packed FP16 Values",
      "summary": "Adds half-precision floating-point values.",
      "syntax": "VADDPH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "58" },
      "extension": "AVX512-FP16"
    },
    {
      "mnemonic": "vsubph",
      "architecture": "x86",
      "full_name": "Subtract Packed FP16 Values",
      "summary": "Subtracts half-precision floating-point values.",
      "syntax": "VSUBPH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "5C" },
      "extension": "AVX512-FP16"
    },
    {
      "mnemonic": "vmulph",
      "architecture": "x86",
      "full_name": "Multiply Packed FP16 Values",
      "summary": "Multiplies half-precision floating-point values.",
      "syntax": "VMULPH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "59" },
      "extension": "AVX512-FP16"
    },
    {
      "mnemonic": "vdivph",
      "architecture": "x86",
      "full_name": "Divide Packed FP16 Values",
      "summary": "Divides half-precision floating-point values.",
      "syntax": "VDIVPH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "5E" },
      "extension": "AVX512-FP16"
    },
    {
      "mnemonic": "vsqrtph",
      "architecture": "x86",
      "full_name": "Square Root Packed FP16 Values",
      "summary": "Square root of half-precision values.",
      "syntax": "VSQRTPH zmm1 {k1}, zmm2/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "51" },
      "extension": "AVX512-FP16"
    },
    {
      "mnemonic": "vminph",
      "architecture": "x86",
      "full_name": "Minimum Packed FP16 Values",
      "summary": "Minimum of half-precision values.",
      "syntax": "VMINPH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "5D" },
      "extension": "AVX512-FP16"
    },
    {
      "mnemonic": "vmaxph",
      "architecture": "x86",
      "full_name": "Maximum Packed FP16 Values",
      "summary": "Maximum of half-precision values.",
      "syntax": "VMAXPH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "5F" },
      "extension": "AVX512-FP16"
    },
    {
      "mnemonic": "vfmadd132ph",
      "architecture": "x86",
      "full_name": "Fused Multiply-Add (132) Packed FP16",
      "summary": "Computes (Dest * Src2) + Src1 in half-precision.",
      "syntax": "VFMADD132PH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "98" },
      "extension": "AVX512-FP16"
    },
    {
      "mnemonic": "vfmadd213ph",
      "architecture": "x86",
      "full_name": "Fused Multiply-Add (213) Packed FP16",
      "summary": "Computes (Src1 * Dest) + Src2 in half-precision.",
      "syntax": "VFMADD213PH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "A8" },
      "extension": "AVX512-FP16"
    },
    {
      "mnemonic": "vfmadd231ph",
      "architecture": "x86",
      "full_name": "Fused Multiply-Add (231) Packed FP16",
      "summary": "Computes (Src1 * Src2) + Dest in half-precision.",
      "syntax": "VFMADD231PH zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "B8" },
      "extension": "AVX512-FP16"
    },
    {
      "mnemonic": "vcvtne2ps2bf16",
      "architecture": "x86",
      "full_name": "Convert Two Packed Single to Packed BFloat16",
      "summary": "Converts two float vectors to one BFloat16 vector.",
      "syntax": "VCVTNE2PS2BF16 zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "72" },
      "extension": "AVX512-BF16"
    },
    {
      "mnemonic": "vdpbf16ps",
      "architecture": "x86",
      "full_name": "Dot Product BFloat16 to Packed Single",
      "summary": "BFloat16 dot product accumulating to Float32.",
      "syntax": "VDPBF16PS zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "52" },
      "extension": "AVX512-BF16"
    },
    {
      "mnemonic": "vaesenc",
      "architecture": "x86",
      "full_name": "Vector AES Encrypt (AVX512)",
      "summary": "AES Encrypt on 512-bit vector.",
      "syntax": "VAESENC zmm1, zmm2, zmm3/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "DC" },
      "extension": "AVX512-VAES"
    },
    {
      "mnemonic": "vaesdec",
      "architecture": "x86",
      "full_name": "Vector AES Decrypt (AVX512)",
      "summary": "AES Decrypt on 512-bit vector.",
      "syntax": "VAESDEC zmm1, zmm2, zmm3/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "DE" },
      "extension": "AVX512-VAES"
    },
    {
      "mnemonic": "vpclmulqdq",
      "architecture": "x86",
      "full_name": "Vector Carry-Less Multiplication (AVX512)",
      "summary": "Carry-less multiply on 512-bit vector.",
      "syntax": "VPCLMULQDQ zmm1, zmm2, zmm3/m512, imm8",
      "encoding": { "format": "EVEX", "hex_opcode": "44" },
      "extension": "AVX512-VPCLMULQDQ"
    },
    {
      "mnemonic": "vsha512msg1",
      "architecture": "x86",
      "full_name": "SHA512 Message Schedule 1",
      "summary": "SHA512 intermediate calculation (AVX512).",
      "syntax": "VSHA512MSG1 ymm1, xmm2",
      "encoding": { "format": "EVEX", "hex_opcode": "CC" },
      "extension": "SHA512"
    },
    {
      "mnemonic": "vsha512msg2",
      "architecture": "x86",
      "full_name": "SHA512 Message Schedule 2",
      "summary": "SHA512 final calculation (AVX512).",
      "syntax": "VSHA512MSG2 ymm1, ymm2",
      "encoding": { "format": "EVEX", "hex_opcode": "CD" },
      "extension": "SHA512"
    },
    {
      "mnemonic": "vsha512rnds2",
      "architecture": "x86",
      "full_name": "SHA512 Rounds 2",
      "summary": "SHA512 2 rounds calculation (AVX512).",
      "syntax": "VSHA512RNDS2 ymm1, ymm2, xmm3",
      "encoding": { "format": "EVEX", "hex_opcode": "CB" },
      "extension": "SHA512"
    },
    {
      "mnemonic": "vsm3msg1",
      "architecture": "x86",
      "full_name": "SM3 Message Schedule 1",
      "summary": "SM3 crypto message schedule part 1.",
      "syntax": "VSM3MSG1 xmm1, xmm2, xmm3",
      "encoding": { "format": "VEX", "hex_opcode": "DA" },
      "extension": "SM3"
    },
    {
      "mnemonic": "vsm3rnds2",
      "architecture": "x86",
      "full_name": "SM3 Rounds 2",
      "summary": "SM3 crypto 2 rounds.",
      "syntax": "VSM3RNDS2 xmm1, xmm2, imm8",
      "encoding": { "format": "VEX", "hex_opcode": "DE" },
      "extension": "SM3"
    },
    {
      "mnemonic": "vsm4e",
      "architecture": "x86",
      "full_name": "SM4 Encrypt",
      "summary": "SM4 crypto encryption round.",
      "syntax": "VSM4E xmm1, xmm2",
      "encoding": { "format": "VEX", "hex_opcode": "DA" },
      "extension": "SM4"
    },
    {
      "mnemonic": "vsm4key4",
      "architecture": "x86",
      "full_name": "SM4 Key Generation",
      "summary": "SM4 key generation.",
      "syntax": "VSM4KEY4 xmm1, xmm2",
      "encoding": { "format": "VEX", "hex_opcode": "DA" },
      "extension": "SM4"
    },
    {
      "mnemonic": "loadiwkey",
      "architecture": "x86",
      "full_name": "Load Internal Wrapping Key",
      "summary": "Loads the Key Locker internal wrapping key.",
      "syntax": "LOADIWKEY xmm1, xmm2",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 0F 38 DC" },
      "extension": "KEYLOCKER"
    },
    {
      "mnemonic": "encodekey128",
      "architecture": "x86",
      "full_name": "Encode 128-bit Key",
      "summary": "Wraps a 128-bit AES key into a handle.",
      "syntax": "ENCODEKEY128 r32, r32",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 0F 38 FA" },
      "extension": "KEYLOCKER"
    },
    {
      "mnemonic": "aesenc128kl",
      "architecture": "x86",
      "full_name": "AES Encrypt 128-bit Key Locker",
      "summary": "Encrypts data using Key Locker handle.",
      "syntax": "AESENC128KL m128, xmm",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 0F 38 DD" },
      "extension": "KEYLOCKER"
    },
    {
      "mnemonic": "aesdec128kl",
      "architecture": "x86",
      "full_name": "AES Decrypt 128-bit Key Locker",
      "summary": "Decrypts data using Key Locker handle.",
      "syntax": "AESDEC128KL m128, xmm",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 0F 38 DE" },
      "extension": "KEYLOCKER"
    },
    {
      "mnemonic": "hreset",
      "architecture": "x86",
      "full_name": "History Reset",
      "summary": "Resets processor history (prediction) structures.",
      "syntax": "HRESET imm8",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 0F 3A F0" },
      "extension": "HRESET"
    },
    {
      "mnemonic": "serialize",
      "architecture": "x86",
      "full_name": "Serialize Instruction Execution",
      "summary": "Forces serialization of instruction fetch/execution.",
      "syntax": "SERIALIZE",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 01 E8" },
      "extension": "SERIALIZE"
    },
    {
      "mnemonic": "rdpid",
      "architecture": "x86",
      "full_name": "Read Processor ID",
      "summary": "Reads the processor ID (TSC_AUX) into register.",
      "syntax": "RDPID r32",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 0F C7 /7" },
      "extension": "RDPID"
    },
    {
      "mnemonic": "xsaves",
      "architecture": "x86",
      "full_name": "Save Supervisor States",
      "summary": "Saves supervisor state components to memory (Compact).",
      "syntax": "XSAVES m",
      "encoding": { "format": "Legacy", "hex_opcode": "0F C7 /5" },
      "extension": "XSAVES"
    },
    {
      "mnemonic": "xrstors",
      "architecture": "x86",
      "full_name": "Restore Supervisor States",
      "summary": "Restores supervisor state components from memory (Compact).",
      "syntax": "XRSTORS m",
      "encoding": { "format": "Legacy", "hex_opcode": "0F C7 /3" },
      "extension": "XSAVES"
    },
    {
      "mnemonic": "ptwrite",
      "architecture": "x86",
      "full_name": "Write Data to Processor Trace",
      "summary": "Writes data to the Intel Processor Trace stream.",
      "syntax": "PTWRITE r32/r64",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 0F AE /4" },
      "extension": "PTWRITE"
    },
    {
      "mnemonic": "uiret",
      "architecture": "x86",
      "full_name": "User Interrupt Return",
      "summary": "Returns from a User Interrupt handler.",
      "syntax": "UIRET",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 0F 01 EC" },
      "extension": "UINTR"
    },
    {
      "mnemonic": "senduipi",
      "architecture": "x86",
      "full_name": "Send User Inter-Processor Interrupt",
      "summary": "Sends a User IPI to another processor.",
      "syntax": "SENDUIPI r64",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 0F C7 /6" },
      "extension": "UINTR"
    },
    {
      "mnemonic": "in",
      "architecture": "x86",
      "full_name": "Input from Port",
      "summary": "Reads data from an I/O port into AL/AX/EAX.",
      "syntax": "IN AL, imm8",
      "encoding": { "format": "Legacy", "hex_opcode": "E4" },
      "extension": "Base"
    },
    {
      "mnemonic": "out",
      "architecture": "x86",
      "full_name": "Output to Port",
      "summary": "Writes data from AL/AX/EAX to an I/O port.",
      "syntax": "OUT imm8, AL",
      "encoding": { "format": "Legacy", "hex_opcode": "E6" },
      "extension": "Base"
    },
    {
      "mnemonic": "ins",
      "architecture": "x86",
      "full_name": "Input String from Port",
      "summary": "Reads string from I/O port to memory at [EDI].",
      "syntax": "INSB",
      "encoding": { "format": "Legacy", "hex_opcode": "6C" },
      "extension": "Base"
    },
    {
      "mnemonic": "outs",
      "architecture": "x86",
      "full_name": "Output String to Port",
      "summary": "Writes string from memory at [ESI] to I/O port.",
      "syntax": "OUTSB",
      "encoding": { "format": "Legacy", "hex_opcode": "6E" },
      "extension": "Base"
    },
    {
      "mnemonic": "lods",
      "architecture": "x86",
      "full_name": "Load String",
      "summary": "Loads byte/word/dword from [ESI] into AL/AX/EAX.",
      "syntax": "LODSB",
      "encoding": { "format": "Legacy", "hex_opcode": "AC" },
      "extension": "Base"
    },
    {
      "mnemonic": "stos",
      "architecture": "x86",
      "full_name": "Store String",
      "summary": "Stores AL/AX/EAX to memory at [EDI].",
      "syntax": "STOSB",
      "encoding": { "format": "Legacy", "hex_opcode": "AA" },
      "extension": "Base"
    },
    {
      "mnemonic": "scas",
      "architecture": "x86",
      "full_name": "Scan String",
      "summary": "Compares AL/AX/EAX with memory at [EDI].",
      "syntax": "SCASB",
      "encoding": { "format": "Legacy", "hex_opcode": "AE" },
      "extension": "Base"
    },
    {
      "mnemonic": "cmps",
      "architecture": "x86",
      "full_name": "Compare String",
      "summary": "Compares byte/word at [ESI] with [EDI].",
      "syntax": "CMPSB",
      "encoding": { "format": "Legacy", "hex_opcode": "A6" },
      "extension": "Base"
    },
    {
      "mnemonic": "lds",
      "architecture": "x86",
      "full_name": "Load Far Pointer using DS",
      "summary": "Loads pointer into DS and register.",
      "syntax": "LDS r, m",
      "encoding": { "format": "Legacy", "hex_opcode": "C5" },
      "extension": "Base (Legacy)"
    },
    {
      "mnemonic": "les",
      "architecture": "x86",
      "full_name": "Load Far Pointer using ES",
      "summary": "Loads pointer into ES and register.",
      "syntax": "LES r, m",
      "encoding": { "format": "Legacy", "hex_opcode": "C4" },
      "extension": "Base (Legacy)"
    },
    {
      "mnemonic": "lfs",
      "architecture": "x86",
      "full_name": "Load Far Pointer using FS",
      "summary": "Loads pointer into FS and register.",
      "syntax": "LFS r, m",
      "encoding": { "format": "Legacy", "hex_opcode": "0F B4" },
      "extension": "Base"
    },
    {
      "mnemonic": "lgs",
      "architecture": "x86",
      "full_name": "Load Far Pointer using GS",
      "summary": "Loads pointer into GS and register.",
      "syntax": "LGS r, m",
      "encoding": { "format": "Legacy", "hex_opcode": "0F B5" },
      "extension": "Base"
    },
    {
      "mnemonic": "lss",
      "architecture": "x86",
      "full_name": "Load Far Pointer using SS",
      "summary": "Loads pointer into SS and register.",
      "syntax": "LSS r, m",
      "encoding": { "format": "Legacy", "hex_opcode": "0F B2" },
      "extension": "Base"
    },
    {
      "mnemonic": "swapgs",
      "architecture": "x86",
      "full_name": "Swap GS Base Register",
      "summary": "Swaps user/kernel GS base address (System).",
      "syntax": "SWAPGS",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 01 F8" },
      "extension": "Base (64-bit System)"
    },
    {
      "mnemonic": "rdfsbase",
      "architecture": "x86",
      "full_name": "Read FS Base",
      "summary": "Reads the FS base address into a register.",
      "syntax": "RDFSBASE r64",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 0F AE /0" },
      "extension": "FSGSBASE"
    },
    {
      "mnemonic": "rdgsbase",
      "architecture": "x86",
      "full_name": "Read GS Base",
      "summary": "Reads the GS base address into a register.",
      "syntax": "RDGSBASE r64",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 0F AE /1" },
      "extension": "FSGSBASE"
    },
    {
      "mnemonic": "wrfsbase",
      "architecture": "x86",
      "full_name": "Write FS Base",
      "summary": "Writes a register to the FS base address.",
      "syntax": "WRFSBASE r64",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 0F AE /2" },
      "extension": "FSGSBASE"
    },
    {
      "mnemonic": "wrgsbase",
      "architecture": "x86",
      "full_name": "Write GS Base",
      "summary": "Writes a register to the GS base address.",
      "syntax": "WRGSBASE r64",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 0F AE /3" },
      "extension": "FSGSBASE"
    },
    {
      "mnemonic": "monitor",
      "architecture": "x86",
      "full_name": "Monitor",
      "summary": "Sets up a linear address range to be monitored.",
      "syntax": "MONITOR",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 01 C8" },
      "extension": "SSE3"
    },
    {
      "mnemonic": "mwait",
      "architecture": "x86",
      "full_name": "Monitor Wait",
      "summary": "Waits for a write to a monitored address.",
      "syntax": "MWAIT",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 01 C9" },
      "extension": "SSE3"
    },
    {
      "mnemonic": "getsec",
      "architecture": "x86",
      "full_name": "Get Security Extensions",
      "summary": "Entry point for Safer Mode Extensions (Trusted Execution).",
      "syntax": "GETSEC",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 37" },
      "extension": "SMX"
    },
    {
      "mnemonic": "bndmk",
      "architecture": "x86",
      "full_name": "Make Bounds",
      "summary": "Creates bounds data for MPX.",
      "syntax": "BNDMK b, m",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 0F 1B" },
      "extension": "MPX"
    },
    {
      "mnemonic": "bndcl",
      "architecture": "x86",
      "full_name": "Check Lower Bound",
      "summary": "Checks if address is within lower bound.",
      "syntax": "BNDCL b, r/m",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 0F 1A" },
      "extension": "MPX"
    },
    {
      "mnemonic": "bndcu",
      "architecture": "x86",
      "full_name": "Check Upper Bound",
      "summary": "Checks if address is within upper bound.",
      "syntax": "BNDCU b, r/m",
      "encoding": { "format": "Legacy", "hex_opcode": "F2 0F 1A" },
      "extension": "MPX"
    },
    {
      "mnemonic": "bndmov",
      "architecture": "x86",
      "full_name": "Move Bounds",
      "summary": "Moves MPX bounds data.",
      "syntax": "BNDMOV b, b/m",
      "encoding": { "format": "Legacy", "hex_opcode": "66 0F 1A" },
      "extension": "MPX"
    },
    {
      "mnemonic": "rdpkru",
      "architecture": "x86",
      "full_name": "Read Protection Key Rights",
      "summary": "Reads PKRU register into EAX (User-mode pages).",
      "syntax": "RDPKRU",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 01 EE" },
      "extension": "PKU"
    },
    {
      "mnemonic": "wrpkru",
      "architecture": "x86",
      "full_name": "Write Protection Key Rights",
      "summary": "Writes EAX/EDX to PKRU register.",
      "syntax": "WRPKRU",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 01 EF" },
      "extension": "PKU"
    },
    {
      "mnemonic": "vpdpbusd",
      "architecture": "x86",
      "full_name": "Multiply and Add Unsigned and Signed Bytes",
      "summary": "Dot product of unsigned/signed bytes, accum to dword.",
      "syntax": "VPDPBUSD zmm1, zmm2, zmm3/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 38 50" },
      "extension": "AVX512_VNNI"
    },
    {
      "mnemonic": "vpdpbusds",
      "architecture": "x86",
      "full_name": "Multiply and Add Unsigned and Signed Bytes with Saturation",
      "summary": "Dot product of unsigned/signed bytes, accum to dword (Saturate).",
      "syntax": "VPDPBUSDS zmm1, zmm2, zmm3/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 38 51" },
      "extension": "AVX512_VNNI"
    },
    {
      "mnemonic": "vpdpwssd",
      "architecture": "x86",
      "full_name": "Multiply and Add Signed Words",
      "summary": "Dot product of signed words, accum to dword.",
      "syntax": "VPDPWSSD zmm1, zmm2, zmm3/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 38 52" },
      "extension": "AVX512_VNNI"
    },
    {
      "mnemonic": "vpdpwssds",
      "architecture": "x86",
      "full_name": "Multiply and Add Signed Words with Saturation",
      "summary": "Dot product of signed words, accum to dword (Saturate).",
      "syntax": "VPDPWSSDS zmm1, zmm2, zmm3/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 38 53" },
      "extension": "AVX512_VNNI"
    },
    {
      "mnemonic": "gf2p8affineinvqb",
      "architecture": "x86",
      "full_name": "Galois Field Affine Transformation Inverse",
      "summary": "Computes inverse affine transformation in GF(2^8).",
      "syntax": "GF2P8AFFINEINVQB xmm1, xmm2/m128, imm8",
      "encoding": { "format": "VEX", "hex_opcode": "66 0F 3A CF" },
      "extension": "GFNI"
    },
    {
      "mnemonic": "prefetchw",
      "architecture": "x86",
      "full_name": "Prefetch Data into Caches in Anticipation of a Write",
      "summary": "Prefetches data with intent to write (RFO).",
      "syntax": "PREFETCHW m8",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 0D /1" },
      "extension": "PREFETCHW"
    },
    {
      "mnemonic": "prefetchwt1",
      "architecture": "x86",
      "full_name": "Prefetch Hint T1 with Intent to Write",
      "summary": "Prefetches data to L2 (T1 hint) with intent to write.",
      "syntax": "PREFETCHWT1 m8",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 0D /2" },
      "extension": "PREFETCHWT1"
    },
    {
      "mnemonic": "vscatterdps",
      "architecture": "x86",
      "full_name": "Scatter Packed Single Precision",
      "summary": "Stores floats to non-contiguous memory locations.",
      "syntax": "VSCATTERDPS [base+zmm_idx*scale] {k1}, zmm1",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 38 A2" },
      "extension": "AVX512F"
    },
    {
      "mnemonic": "vscatterdpd",
      "architecture": "x86",
      "full_name": "Scatter Packed Double Precision",
      "summary": "Stores doubles to non-contiguous memory locations.",
      "syntax": "VSCATTERDPD [base+zmm_idx*scale] {k1}, zmm1",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 38 A2" },
      "extension": "AVX512F"
    },
    {
      "mnemonic": "vscatterqps",
      "architecture": "x86",
      "full_name": "Scatter Packed Single Precision (Quadword Indices)",
      "summary": "Stores floats using 64-bit indices.",
      "syntax": "VSCATTERQPS [base+zmm_idx*scale] {k1}, zmm1",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 38 A3" },
      "extension": "AVX512F"
    },
    {
      "mnemonic": "vscatterqpd",
      "architecture": "x86",
      "full_name": "Scatter Packed Double Precision (Quadword Indices)",
      "summary": "Stores doubles using 64-bit indices.",
      "syntax": "VSCATTERQPD [base+zmm_idx*scale] {k1}, zmm1",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 38 A3" },
      "extension": "AVX512F"
    },
    {
      "mnemonic": "vfpclassps",
      "architecture": "x86",
      "full_name": "Floating-Point Class Single",
      "summary": "Tests for category (NaN, Inf, Denormal) for floats.",
      "syntax": "VFPCLASSPS k1 {k2}, zmm2/m512, imm8",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 3A 66" },
      "extension": "AVX512DQ"
    },
    {
      "mnemonic": "vfpclasspd",
      "architecture": "x86",
      "full_name": "Floating-Point Class Double",
      "summary": "Tests for category (NaN, Inf, Denormal) for doubles.",
      "syntax": "VFPCLASSPD k1 {k2}, zmm2/m512, imm8",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 3A 67" },
      "extension": "AVX512DQ"
    },
    {
      "mnemonic": "vrangeps",
      "architecture": "x86",
      "full_name": "Range Restriction Calculation Packed Single",
      "summary": "Calculates range (min/max/abs) of float values.",
      "syntax": "VRANGEPS zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 3A 50" },
      "extension": "AVX512DQ"
    },
    {
      "mnemonic": "vreduceps",
      "architecture": "x86",
      "full_name": "Perform Reduction Transformation Packed Single",
      "summary": "Performs reduction on floats (e.g. range reduction for trig).",
      "syntax": "VREDUCEPS zmm1 {k1}, zmm2/m512, imm8",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 3A 56" },
      "extension": "AVX512DQ"
    },
    {
      "mnemonic": "vfixupimmps",
      "architecture": "x86",
      "full_name": "Fix Up Special Packed Float32 Values",
      "summary": "Fixes special cases (NaN, Inf) using a table (Float32).",
      "syntax": "VFIXUPIMMPS zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 3A 54" },
      "extension": "AVX512F"
    },
    {
      "mnemonic": "vrsqrt14ps",
      "architecture": "x86",
      "full_name": "Compute Approximate Reciprocal Square Root (14-bit)",
      "summary": "Approximate 1/sqrt(x) with 2^-14 error.",
      "syntax": "VRSQRT14PS zmm1 {k1}, zmm2/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 38 4E" },
      "extension": "AVX512F"
    },
    {
      "mnemonic": "vrcp14ps",
      "architecture": "x86",
      "full_name": "Compute Approximate Reciprocal (14-bit)",
      "summary": "Approximate 1/x with 2^-14 error.",
      "syntax": "VRCP14PS zmm1 {k1}, zmm2/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 38 4C" },
      "extension": "AVX512F"
    },
    {
      "mnemonic": "clui",
      "architecture": "x86",
      "full_name": "Clear User Interrupt Flag",
      "summary": "Clears the User Interrupt Flag (UIF).",
      "syntax": "CLUI",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 0F 01 EE" },
      "extension": "UINTR"
    },
    {
      "mnemonic": "stui",
      "architecture": "x86",
      "full_name": "Set User Interrupt Flag",
      "summary": "Sets the User Interrupt Flag (UIF).",
      "syntax": "STUI",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 0F 01 EF" },
      "extension": "UINTR"
    },
    {
      "mnemonic": "testui",
      "architecture": "x86",
      "full_name": "Test User Interrupt",
      "summary": "Sets CF if UIF is 1, ZF if User Interrupt Pending.",
      "syntax": "TESTUI",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 0F 01 ED" },
      "extension": "UINTR"
    },
    {
      "mnemonic": "fld",
      "architecture": "x86",
      "full_name": "Load Floating Point Value",
      "summary": "Pushes a floating-point value onto the FPU register stack (ST0).",
      "syntax": "FLD m32fp/m64fp/m80fp",
      "encoding": { "format": "Legacy", "hex_opcode": "D9 /0" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "fst",
      "architecture": "x86",
      "full_name": "Store Floating Point Value",
      "summary": "Copies the value in ST(0) to memory or another register.",
      "syntax": "FST m32fp/m64fp",
      "encoding": { "format": "Legacy", "hex_opcode": "D9 /2" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "fstp",
      "architecture": "x86",
      "full_name": "Store Floating Point Value and Pop",
      "summary": "Copies ST(0) to destination and pops the register stack.",
      "syntax": "FSTP m32fp/m64fp/m80fp",
      "encoding": { "format": "Legacy", "hex_opcode": "D9 /3" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "fild",
      "architecture": "x86",
      "full_name": "Load Integer",
      "summary": "Converts integer in memory to double-extended-precision float and pushes to ST(0).",
      "syntax": "FILD m16int/m32int/m64int",
      "encoding": { "format": "Legacy", "hex_opcode": "DF /0" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "fist",
      "architecture": "x86",
      "full_name": "Store Integer",
      "summary": "Converts ST(0) to integer and stores in memory.",
      "syntax": "FIST m16int/m32int",
      "encoding": { "format": "Legacy", "hex_opcode": "DF /2" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "fistp",
      "architecture": "x86",
      "full_name": "Store Integer and Pop",
      "summary": "Converts ST(0) to integer, stores in memory, and pops stack.",
      "syntax": "FISTP m16int/m32int/m64int",
      "encoding": { "format": "Legacy", "hex_opcode": "DF /3" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "fadd",
      "architecture": "x86",
      "full_name": "Add Floating Point",
      "summary": "Adds src to dest (ST(0) += src).",
      "syntax": "FADD m32fp/m64fp",
      "encoding": { "format": "Legacy", "hex_opcode": "D8 /0" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "fsub",
      "architecture": "x86",
      "full_name": "Subtract Floating Point",
      "summary": "Subtracts src from dest.",
      "syntax": "FSUB m32fp/m64fp",
      "encoding": { "format": "Legacy", "hex_opcode": "D8 /4" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "fmul",
      "architecture": "x86",
      "full_name": "Multiply Floating Point",
      "summary": "Multiplies dest by src.",
      "syntax": "FMUL m32fp/m64fp",
      "encoding": { "format": "Legacy", "hex_opcode": "D8 /1" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "fdiv",
      "architecture": "x86",
      "full_name": "Divide Floating Point",
      "summary": "Divides dest by src.",
      "syntax": "FDIV m32fp/m64fp",
      "encoding": { "format": "Legacy", "hex_opcode": "D8 /6" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "fprem",
      "architecture": "x86",
      "full_name": "Partial Remainder",
      "summary": "Computes remainder of ST(0) / ST(1).",
      "syntax": "FPREM",
      "encoding": { "format": "Legacy", "hex_opcode": "D9 F8" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "fabs",
      "architecture": "x86",
      "full_name": "Absolute Value",
      "summary": "Replaces ST(0) with its absolute value.",
      "syntax": "FABS",
      "encoding": { "format": "Legacy", "hex_opcode": "D9 E1" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "fchs",
      "architecture": "x86",
      "full_name": "Change Sign",
      "summary": "Reverses the sign of ST(0).",
      "syntax": "FCHS",
      "encoding": { "format": "Legacy", "hex_opcode": "D9 E0" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "fsqrt",
      "architecture": "x86",
      "full_name": "Square Root",
      "summary": "Computes square root of ST(0).",
      "syntax": "FSQRT",
      "encoding": { "format": "Legacy", "hex_opcode": "D9 FA" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "fsin",
      "architecture": "x86",
      "full_name": "Sine",
      "summary": "Computes sine of ST(0) (in radians).",
      "syntax": "FSIN",
      "encoding": { "format": "Legacy", "hex_opcode": "D9 FE" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "fcos",
      "architecture": "x86",
      "full_name": "Cosine",
      "summary": "Computes cosine of ST(0) (in radians).",
      "syntax": "FCOS",
      "encoding": { "format": "Legacy", "hex_opcode": "D9 FF" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "fsincos",
      "architecture": "x86",
      "full_name": "Sine and Cosine",
      "summary": "Computes sine and cosine of ST(0), pushing both to stack.",
      "syntax": "FSINCOS",
      "encoding": { "format": "Legacy", "hex_opcode": "D9 FB" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "fptan",
      "architecture": "x86",
      "full_name": "Partial Tangent",
      "summary": "Computes tangent of ST(0) and pushes 1.0.",
      "syntax": "FPTAN",
      "encoding": { "format": "Legacy", "hex_opcode": "D9 F2" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "fpatan",
      "architecture": "x86",
      "full_name": "Partial Arctangent",
      "summary": "Computes arctan(ST(1)/ST(0)).",
      "syntax": "FPATAN",
      "encoding": { "format": "Legacy", "hex_opcode": "D9 F3" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "fyl2x",
      "architecture": "x86",
      "full_name": "Y * log2(X)",
      "summary": "Computes ST(1) * log2(ST(0)).",
      "syntax": "FYL2X",
      "encoding": { "format": "Legacy", "hex_opcode": "D9 F1" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "fxch",
      "architecture": "x86",
      "full_name": "Exchange Register",
      "summary": "Exchanges contents of ST(0) and ST(i).",
      "syntax": "FXCH ST(i)",
      "encoding": { "format": "Legacy", "hex_opcode": "D9 C8+i" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "fcom",
      "architecture": "x86",
      "full_name": "Compare Real",
      "summary": "Compares ST(0) with source.",
      "syntax": "FCOM m32fp/m64fp",
      "encoding": { "format": "Legacy", "hex_opcode": "D8 /2" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "fcomi",
      "architecture": "x86",
      "full_name": "Compare Real and Set EFLAGS",
      "summary": "Compares ST(0) with ST(i) and sets CPU EFLAGS directly.",
      "syntax": "FCOMI ST(0), ST(i)",
      "encoding": { "format": "Legacy", "hex_opcode": "DB F0+i" },
      "extension": "x87 FPU (P6+)"
    },
    {
      "mnemonic": "finit",
      "architecture": "x86",
      "full_name": "Initialize FPU",
      "summary": "Resets FPU to default state.",
      "syntax": "FINIT",
      "encoding": { "format": "Legacy", "hex_opcode": "9B DB E3" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "fclex",
      "architecture": "x86",
      "full_name": "Clear Exceptions",
      "summary": "Clears floating-point exception flags.",
      "syntax": "FCLEX",
      "encoding": { "format": "Legacy", "hex_opcode": "9B DB E2" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "fstsw",
      "architecture": "x86",
      "full_name": "Store Status Word",
      "summary": "Stores FPU status word to AX or memory.",
      "syntax": "FSTSW AX",
      "encoding": { "format": "Legacy", "hex_opcode": "9B DF E0" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "fldcw",
      "architecture": "x86",
      "full_name": "Load Control Word",
      "summary": "Loads FPU control word from memory.",
      "syntax": "FLDCW m2byte",
      "encoding": { "format": "Legacy", "hex_opcode": "D9 /5" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "fstcw",
      "architecture": "x86",
      "full_name": "Store Control Word",
      "summary": "Stores FPU control word to memory.",
      "syntax": "FSTCW m2byte",
      "encoding": { "format": "Legacy", "hex_opcode": "9B D9 /7" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "frstor",
      "architecture": "x86",
      "full_name": "Restore FPU State",
      "summary": "Loads FPU state from memory.",
      "syntax": "FRSTOR m108byte",
      "encoding": { "format": "Legacy", "hex_opcode": "DD /4" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "fsave",
      "architecture": "x86",
      "full_name": "Save FPU State",
      "summary": "Stores FPU state to memory and re-initializes FPU.",
      "syntax": "FSAVE m108byte",
      "encoding": { "format": "Legacy", "hex_opcode": "9B DD /6" },
      "extension": "x87 FPU"
    },
    {
      "mnemonic": "lgdt",
      "architecture": "x86",
      "full_name": "Load Global Descriptor Table Register",
      "summary": "Loads the GDT register (Privileged).",
      "syntax": "LGDT m16&32",
      "encoding": { "format": "System", "hex_opcode": "0F 01 /2" },
      "extension": "System"
    },
    {
      "mnemonic": "lidt",
      "architecture": "x86",
      "full_name": "Load Interrupt Descriptor Table Register",
      "summary": "Loads the IDT register (Privileged).",
      "syntax": "LIDT m16&32",
      "encoding": { "format": "System", "hex_opcode": "0F 01 /3" },
      "extension": "System"
    },
    {
      "mnemonic": "sgdt",
      "architecture": "x86",
      "full_name": "Store Global Descriptor Table Register",
      "summary": "Stores GDT limit and base address to memory.",
      "syntax": "SGDT m",
      "encoding": { "format": "System", "hex_opcode": "0F 01 /0" },
      "extension": "System"
    },
    {
      "mnemonic": "sidt",
      "architecture": "x86",
      "full_name": "Store Interrupt Descriptor Table Register",
      "summary": "Stores IDT limit and base address to memory.",
      "syntax": "SIDT m",
      "encoding": { "format": "System", "hex_opcode": "0F 01 /1" },
      "extension": "System"
    },
    {
      "mnemonic": "lldt",
      "architecture": "x86",
      "full_name": "Load Local Descriptor Table Register",
      "summary": "Loads LDT segment selector (Privileged).",
      "syntax": "LLDT r/m16",
      "encoding": { "format": "System", "hex_opcode": "0F 00 /2" },
      "extension": "System"
    },
    {
      "mnemonic": "sldt",
      "architecture": "x86",
      "full_name": "Store Local Descriptor Table Register",
      "summary": "Stores LDT segment selector.",
      "syntax": "SLDT r/m16",
      "encoding": { "format": "System", "hex_opcode": "0F 00 /0" },
      "extension": "System"
    },
    {
      "mnemonic": "ltr",
      "architecture": "x86",
      "full_name": "Load Task Register",
      "summary": "Loads Task Register (Privileged).",
      "syntax": "LTR r/m16",
      "encoding": { "format": "System", "hex_opcode": "0F 00 /3" },
      "extension": "System"
    },
    {
      "mnemonic": "str",
      "architecture": "x86",
      "full_name": "Store Task Register",
      "summary": "Stores Task Register.",
      "syntax": "STR r/m16",
      "encoding": { "format": "System", "hex_opcode": "0F 00 /1" },
      "extension": "System"
    },
    {
      "mnemonic": "mov cr",
      "architecture": "x86",
      "full_name": "Move Control Register",
      "summary": "Moves data to/from Control Registers (CR0, CR3, etc.) (Privileged).",
      "syntax": "MOV CRn, r",
      "encoding": { "format": "System", "hex_opcode": "0F 22 /r" },
      "extension": "System"
    },
    {
      "mnemonic": "mov dr",
      "architecture": "x86",
      "full_name": "Move Debug Register",
      "summary": "Moves data to/from Debug Registers (DR0-DR7) (Privileged).",
      "syntax": "MOV DRn, r",
      "encoding": { "format": "System", "hex_opcode": "0F 23 /r" },
      "extension": "System"
    },
    {
      "mnemonic": "lmsw",
      "architecture": "x86",
      "full_name": "Load Machine Status Word",
      "summary": "Loads Machine Status Word (Legacy CR0 modification).",
      "syntax": "LMSW r/m16",
      "encoding": { "format": "System", "hex_opcode": "0F 01 /6" },
      "extension": "System"
    },
    {
      "mnemonic": "smsw",
      "architecture": "x86",
      "full_name": "Store Machine Status Word",
      "summary": "Stores Machine Status Word.",
      "syntax": "SMSW r/m16",
      "encoding": { "format": "System", "hex_opcode": "0F 01 /4" },
      "extension": "System"
    },
    {
      "mnemonic": "clts",
      "architecture": "x86",
      "full_name": "Clear Task-Switched Flag",
      "summary": "Clears the TS flag in CR0 (Privileged).",
      "syntax": "CLTS",
      "encoding": { "format": "System", "hex_opcode": "0F 06" },
      "extension": "System"
    },
    {
      "mnemonic": "invd",
      "architecture": "x86",
      "full_name": "Invalidate Internal Caches",
      "summary": "Flushes internal caches without writing back data (Privileged).",
      "syntax": "INVD",
      "encoding": { "format": "System", "hex_opcode": "0F 08" },
      "extension": "System"
    },
    {
      "mnemonic": "wbinvd",
      "architecture": "x86",
      "full_name": "Write Back and Invalidate Cache",
      "summary": "Writes back modified data and invalidates caches (Privileged).",
      "syntax": "WBINVD",
      "encoding": { "format": "System", "hex_opcode": "0F 09" },
      "extension": "System"
    },
    {
      "mnemonic": "invlpg",
      "architecture": "x86",
      "full_name": "Invalidate TLB Entry",
      "summary": "Invalidates a specific TLB entry (Privileged).",
      "syntax": "INVLPG m",
      "encoding": { "format": "System", "hex_opcode": "0F 01 /7" },
      "extension": "System"
    },
    {
      "mnemonic": "rdmsr",
      "architecture": "x86",
      "full_name": "Read Model Specific Register",
      "summary": "Reads MSR specified by ECX into EDX:EAX (Privileged).",
      "syntax": "RDMSR",
      "encoding": { "format": "System", "hex_opcode": "0F 32" },
      "extension": "System"
    },
    {
      "mnemonic": "wrmsr",
      "architecture": "x86",
      "full_name": "Write Model Specific Register",
      "summary": "Writes EDX:EAX to MSR specified by ECX (Privileged).",
      "syntax": "WRMSR",
      "encoding": { "format": "System", "hex_opcode": "0F 30" },
      "extension": "System"
    },
    {
      "mnemonic": "rdpmc",
      "architecture": "x86",
      "full_name": "Read Performance-Monitoring Counters",
      "summary": "Reads performance counter specified by ECX into EDX:EAX.",
      "syntax": "RDPMC",
      "encoding": { "format": "System", "hex_opcode": "0F 33" },
      "extension": "System"
    },
    {
      "mnemonic": "sysenter",
      "architecture": "x86",
      "full_name": "Fast System Call",
      "summary": "Fast call to level 0 system procedures.",
      "syntax": "SYSENTER",
      "encoding": { "format": "System", "hex_opcode": "0F 34" },
      "extension": "System"
    },
    {
      "mnemonic": "sysexit",
      "architecture": "x86",
      "full_name": "Fast Return from System Call",
      "summary": "Fast return to level 3 user code.",
      "syntax": "SYSEXIT",
      "encoding": { "format": "System", "hex_opcode": "0F 35" },
      "extension": "System"
    },
    {
      "mnemonic": "lar",
      "architecture": "x86",
      "full_name": "Load Access Rights Byte",
      "summary": "Reads access rights from segment descriptor.",
      "syntax": "LAR r, r/m16",
      "encoding": { "format": "System", "hex_opcode": "0F 02" },
      "extension": "System"
    },
    {
      "mnemonic": "lsl",
      "architecture": "x86",
      "full_name": "Load Segment Limit",
      "summary": "Reads segment limit from descriptor.",
      "syntax": "LSL r, r/m16",
      "encoding": { "format": "System", "hex_opcode": "0F 03" },
      "extension": "System"
    },
    {
      "mnemonic": "verr",
      "architecture": "x86",
      "full_name": "Verify Segment for Reading",
      "summary": "Checks if segment can be read; sets ZF.",
      "syntax": "VERR r/m16",
      "encoding": { "format": "System", "hex_opcode": "0F 00 /4" },
      "extension": "System"
    },
    {
      "mnemonic": "verw",
      "architecture": "x86",
      "full_name": "Verify Segment for Writing",
      "summary": "Checks if segment can be written; sets ZF.",
      "syntax": "VERW r/m16",
      "encoding": { "format": "System", "hex_opcode": "0F 00 /5" },
      "extension": "System"
    },
    {
      "mnemonic": "arpl",
      "architecture": "x86",
      "full_name": "Adjust Requested Privilege Level",
      "summary": "Adjusts RPL of selector to match current CPL (Legacy).",
      "syntax": "ARPL r/m16, r16",
      "encoding": { "format": "System", "hex_opcode": "63" },
      "extension": "System (32-bit)"
    },
    {
      "mnemonic": "rsm",
      "architecture": "x86",
      "full_name": "Resume from System Management Mode",
      "summary": "Exits SMM and returns to previous state (Privileged).",
      "syntax": "RSM",
      "encoding": { "format": "System", "hex_opcode": "0F AA" },
      "extension": "System (SMM)"
    },
    {
      "mnemonic": "bswap",
      "architecture": "x86",
      "full_name": "Byte Swap",
      "summary": "Reverses the byte order of a 32/64-bit register.",
      "syntax": "BSWAP r",
      "encoding": { "format": "Legacy", "hex_opcode": "0F C8" },
      "extension": "Base"
    },
    {
      "mnemonic": "cmpxchg8b",
      "architecture": "x86",
      "full_name": "Compare and Exchange 8 Bytes",
      "summary": "Atomically compares EDX:EAX with memory; swaps if equal.",
      "syntax": "CMPXCHG8B m64",
      "encoding": { "format": "Legacy", "hex_opcode": "0F C7 /1" },
      "extension": "Base"
    },
    {
      "mnemonic": "addsubps",
      "architecture": "x86",
      "full_name": "Packed Single-FP Add/Subtract",
      "summary": "Adds odd elements, subtracts even elements (Complex Math).",
      "syntax": "ADDSUBPS xmm1, xmm2/m128",
      "encoding": { "format": "SSE3", "hex_opcode": "F2 0F D0" },
      "extension": "SSE3"
    },
    {
      "mnemonic": "haddps",
      "architecture": "x86",
      "full_name": "Horizontal Add Packed Single-Precision",
      "summary": "Adds adjacent float elements horizontally.",
      "syntax": "HADDPS xmm1, xmm2/m128",
      "encoding": { "format": "SSE3", "hex_opcode": "F2 0F 7C" },
      "extension": "SSE3"
    },
    {
      "mnemonic": "movddup",
      "architecture": "x86",
      "full_name": "Move One Double-FP and Duplicate",
      "summary": "Loads 64-bit double and duplicates it to fill 128-bit register.",
      "syntax": "MOVDDUP xmm1, xmm2/m64",
      "encoding": { "format": "SSE3", "hex_opcode": "F2 0F 12" },
      "extension": "SSE3"
    },
    {
      "mnemonic": "lddqu",
      "architecture": "x86",
      "full_name": "Load Unaligned Integer 128-bit",
      "summary": "Loads unaligned data avoiding split-line penalties.",
      "syntax": "LDDQU xmm1, m128",
      "encoding": { "format": "SSE3", "hex_opcode": "F2 0F F0" },
      "extension": "SSE3"
    },
    {
      "mnemonic": "pshufb",
      "architecture": "x86",
      "full_name": "Packed Shuffle Bytes",
      "summary": "Shuffles bytes according to indices in source operand.",
      "syntax": "PSHUFB xmm1, xmm2/m128",
      "encoding": { "format": "SSSE3", "hex_opcode": "66 0F 38 00" },
      "extension": "SSSE3"
    },
    {
      "mnemonic": "phaddw",
      "architecture": "x86",
      "full_name": "Packed Horizontal Add Word",
      "summary": "Adds adjacent 16-bit integers horizontally.",
      "syntax": "PHADDW xmm1, xmm2/m128",
      "encoding": { "format": "SSSE3", "hex_opcode": "66 0F 38 01" },
      "extension": "SSSE3"
    },
    {
      "mnemonic": "palignr",
      "architecture": "x86",
      "full_name": "Packed Align Right",
      "summary": "Concatenates dest and src, extracts 128 bits byte-aligned.",
      "syntax": "PALIGNR xmm1, xmm2/m128, imm8",
      "encoding": { "format": "SSSE3", "hex_opcode": "66 0F 3A 0F" },
      "extension": "SSSE3"
    },
    {
      "mnemonic": "pmulhrsw",
      "architecture": "x86",
      "full_name": "Packed Multiply High with Round and Scale",
      "summary": "Multiplies signed 16-bit words, rounds, and scales.",
      "syntax": "PMULHRSW xmm1, xmm2/m128",
      "encoding": { "format": "SSSE3", "hex_opcode": "66 0F 38 0B" },
      "extension": "SSSE3"
    },
    {
      "mnemonic": "psignb",
      "architecture": "x86",
      "full_name": "Packed Sign Byte",
      "summary": "Negates/Zeroes bytes in dest based on sign of src.",
      "syntax": "PSIGNB xmm1, xmm2/m128",
      "encoding": { "format": "SSSE3", "hex_opcode": "66 0F 38 08" },
      "extension": "SSSE3"
    },
    {
      "mnemonic": "pabsb",
      "architecture": "x86",
      "full_name": "Packed Absolute Value Byte",
      "summary": "Computes absolute value of bytes.",
      "syntax": "PABSB xmm1, xmm2/m128",
      "encoding": { "format": "SSSE3", "hex_opcode": "66 0F 38 1C" },
      "extension": "SSSE3"
    },
    {
      "mnemonic": "blendps",
      "architecture": "x86",
      "full_name": "Blend Packed Single-Precision",
      "summary": "Selects floats from two sources based on immediate mask.",
      "syntax": "BLENDPS xmm1, xmm2/m128, imm8",
      "encoding": { "format": "SSE4.1", "hex_opcode": "66 0F 3A 0C" },
      "extension": "SSE4.1"
    },
    {
      "mnemonic": "pblendw",
      "architecture": "x86",
      "full_name": "Packed Blend Words",
      "summary": "Selects words from two sources based on immediate mask.",
      "syntax": "PBLENDW xmm1, xmm2/m128, imm8",
      "encoding": { "format": "SSE4.1", "hex_opcode": "66 0F 3A 0E" },
      "extension": "SSE4.1"
    },
    {
      "mnemonic": "pmulld",
      "architecture": "x86",
      "full_name": "Packed Multiply Low Doubleword",
      "summary": "Multiplies 32-bit integers, stores low 32-bit result.",
      "syntax": "PMULLD xmm1, xmm2/m128",
      "encoding": { "format": "SSE4.1", "hex_opcode": "66 0F 38 40" },
      "extension": "SSE4.1"
    },
    {
      "mnemonic": "pmovsxbw",
      "architecture": "x86",
      "full_name": "Packed Move with Sign Extend Byte to Word",
      "summary": "Sign extends 8-bit integers to 16-bit.",
      "syntax": "PMOVSXBW xmm1, xmm2/m64",
      "encoding": { "format": "SSE4.1", "hex_opcode": "66 0F 38 20" },
      "extension": "SSE4.1"
    },
    {
      "mnemonic": "pmovzxbw",
      "architecture": "x86",
      "full_name": "Packed Move with Zero Extend Byte to Word",
      "summary": "Zero extends 8-bit integers to 16-bit.",
      "syntax": "PMOVZXBW xmm1, xmm2/m64",
      "encoding": { "format": "SSE4.1", "hex_opcode": "66 0F 38 30" },
      "extension": "SSE4.1"
    },
    {
      "mnemonic": "extractps",
      "architecture": "x86",
      "full_name": "Extract Packed Single-Precision",
      "summary": "Extracts a single float from XMM to integer register.",
      "syntax": "EXTRACTPS r32/m32, xmm1, imm8",
      "encoding": { "format": "SSE4.1", "hex_opcode": "66 0F 3A 17" },
      "extension": "SSE4.1"
    },
    {
      "mnemonic": "insertps",
      "architecture": "x86",
      "full_name": "Insert Packed Single-Precision",
      "summary": "Inserts a float into XMM from another XMM or memory.",
      "syntax": "INSERTPS xmm1, xmm2/m32, imm8",
      "encoding": { "format": "SSE4.1", "hex_opcode": "66 0F 3A 21" },
      "extension": "SSE4.1"
    },
    {
      "mnemonic": "pinsrb",
      "architecture": "x86",
      "full_name": "Packed Insert Byte",
      "summary": "Inserts a byte from integer register into XMM.",
      "syntax": "PINSRB xmm1, r32/m8, imm8",
      "encoding": { "format": "SSE4.1", "hex_opcode": "66 0F 3A 20" },
      "extension": "SSE4.1"
    },
    {
      "mnemonic": "pextrb",
      "architecture": "x86",
      "full_name": "Packed Extract Byte",
      "summary": "Extracts a byte from XMM to integer register.",
      "syntax": "PEXTRB r32/m8, xmm1, imm8",
      "encoding": { "format": "SSE4.1", "hex_opcode": "66 0F 3A 14" },
      "extension": "SSE4.1"
    },
    {
      "mnemonic": "roundps",
      "architecture": "x86",
      "full_name": "Round Packed Single-Precision",
      "summary": "Rounds floats according to immediate mode (ceil/floor/trunc).",
      "syntax": "ROUNDPS xmm1, xmm2/m128, imm8",
      "encoding": { "format": "SSE4.1", "hex_opcode": "66 0F 3A 08" },
      "extension": "SSE4.1"
    },
    {
      "mnemonic": "dpps",
      "architecture": "x86",
      "full_name": "Dot Product Packed Single-Precision",
      "summary": "Calculates dot product of float vectors.",
      "syntax": "DPPS xmm1, xmm2/m128, imm8",
      "encoding": { "format": "SSE4.1", "hex_opcode": "66 0F 3A 40" },
      "extension": "SSE4.1"
    },
    {
      "mnemonic": "ptest",
      "architecture": "x86",
      "full_name": "Packed Logical Comparison",
      "summary": "Bitwise compare of 128-bit value (AND) setting flags.",
      "syntax": "PTEST xmm1, xmm2/m128",
      "encoding": { "format": "SSE4.1", "hex_opcode": "66 0F 38 17" },
      "extension": "SSE4.1"
    },
    {
      "mnemonic": "pcmpeqq",
      "architecture": "x86",
      "full_name": "Packed Compare Equal Quadword",
      "summary": "Compares 64-bit integers for equality.",
      "syntax": "PCMPEQQ xmm1, xmm2/m128",
      "encoding": { "format": "SSE4.1", "hex_opcode": "66 0F 38 29" },
      "extension": "SSE4.1"
    },
    {
      "mnemonic": "crc32",
      "architecture": "x86",
      "full_name": "Accumulate CRC32 Value",
      "summary": "Accumulates CRC32C (Castagnoli) value.",
      "syntax": "CRC32 r32, r/m",
      "encoding": { "format": "SSE4.2", "hex_opcode": "F2 0F 38 F1" },
      "extension": "SSE4.2"
    },
    {
      "mnemonic": "pcmpestri",
      "architecture": "x86",
      "full_name": "Packed Compare Explicit Length Strings, Return Index",
      "summary": "String compare/search, returns index (ECX).",
      "syntax": "PCMPESTRI xmm1, xmm2/m128, imm8",
      "encoding": { "format": "SSE4.2", "hex_opcode": "66 0F 3A 61" },
      "extension": "SSE4.2"
    },
    {
      "mnemonic": "pcmpestrm",
      "architecture": "x86",
      "full_name": "Packed Compare Explicit Length Strings, Return Mask",
      "summary": "String compare/search, returns mask (XMM0).",
      "syntax": "PCMPESTRM xmm1, xmm2/m128, imm8",
      "encoding": { "format": "SSE4.2", "hex_opcode": "66 0F 3A 60" },
      "extension": "SSE4.2"
    },
    {
      "mnemonic": "aesenc",
      "architecture": "x86",
      "full_name": "AES Encrypt",
      "summary": "Performs one round of AES encryption flow.",
      "syntax": "AESENC xmm1, xmm2/m128",
      "encoding": { "format": "AES-NI", "hex_opcode": "66 0F 38 DC" },
      "extension": "AES-NI"
    },
    {
      "mnemonic": "aesenclast",
      "architecture": "x86",
      "full_name": "AES Encrypt Last Round",
      "summary": "Performs the last round of AES encryption.",
      "syntax": "AESENCLAST xmm1, xmm2/m128",
      "encoding": { "format": "AES-NI", "hex_opcode": "66 0F 38 DD" },
      "extension": "AES-NI"
    },
    {
      "mnemonic": "aesdec",
      "architecture": "x86",
      "full_name": "AES Decrypt",
      "summary": "Performs one round of AES decryption flow.",
      "syntax": "AESDEC xmm1, xmm2/m128",
      "encoding": { "format": "AES-NI", "hex_opcode": "66 0F 38 DE" },
      "extension": "AES-NI"
    },
    {
      "mnemonic": "aeskeygenassist",
      "architecture": "x86",
      "full_name": "AES Key Generation Assist",
      "summary": "Generates round key for AES encryption.",
      "syntax": "AESKEYGENASSIST xmm1, xmm2/m128, imm8",
      "encoding": { "format": "AES-NI", "hex_opcode": "66 0F 3A DF" },
      "extension": "AES-NI"
    },
    {
      "mnemonic": "pclmulqdq",
      "architecture": "x86",
      "full_name": "Carry-Less Multiplication Quadword",
      "summary": "Performs carry-less multiply (Galois Field math for GCM).",
      "syntax": "PCLMULQDQ xmm1, xmm2/m128, imm8",
      "encoding": { "format": "PCLMUL", "hex_opcode": "66 0F 3A 44" },
      "extension": "PCLMULQDQ"
    },
    {
      "mnemonic": "vaddps",
      "architecture": "x86",
      "full_name": "Add Packed Single-Precision (AVX)",
      "summary": "Adds packed floats (256-bit YMM support).",
      "syntax": "VADDPS ymm1, ymm2, ymm3/m256",
      "encoding": { "format": "VEX", "hex_opcode": "C5 /r 58" },
      "extension": "AVX"
    },
    {
      "mnemonic": "vmulps",
      "architecture": "x86",
      "full_name": "Multiply Packed Single-Precision (AVX)",
      "summary": "Multiplies packed floats (256-bit).",
      "syntax": "VMULPS ymm1, ymm2, ymm3/m256",
      "encoding": { "format": "VEX", "hex_opcode": "C5 /r 59" },
      "extension": "AVX"
    },
    {
      "mnemonic": "vfmadd231ps",
      "architecture": "x86",
      "full_name": "Fused Multiply-Add (132)",
      "summary": "Computes (Dest * Src2) + Src1.",
      "syntax": "VFMADD231PS ymm1, ymm2, ymm3/m256",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... B8" },
      "extension": "FMA3"
    },
    {
      "mnemonic": "vinsertf128",
      "architecture": "x86",
      "full_name": "Insert Float 128-bit",
      "summary": "Inserts 128-bits into a YMM register.",
      "syntax": "VINSERTF128 ymm1, ymm2, xmm3/m128, imm8",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... 18" },
      "extension": "AVX"
    },
    {
      "mnemonic": "vextractf128",
      "architecture": "x86",
      "full_name": "Extract Float 128-bit",
      "summary": "Extracts 128-bits from YMM register.",
      "syntax": "VEXTRACTF128 xmm1/m128, ymm2, imm8",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... 19" },
      "extension": "AVX"
    },
    {
      "mnemonic": "vbroadcastss",
      "architecture": "x86",
      "full_name": "Broadcast Scalar Single",
      "summary": "Broadcasts a single float to all elements of YMM.",
      "syntax": "VBROADCASTSS ymm1, m32",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... 18" },
      "extension": "AVX"
    },
    {
      "mnemonic": "vzeroupper",
      "architecture": "x86",
      "full_name": "Zero Upper Bits of YMM Registers",
      "summary": "Clears bits 128-255 of all YMM registers (Avoids AVX-SSE transition penalty).",
      "syntax": "VZEROUPPER",
      "encoding": { "format": "VEX", "hex_opcode": "C5 F8 77" },
      "extension": "AVX"
    },
    {
      "mnemonic": "vzeroall",
      "architecture": "x86",
      "full_name": "Zero All YMM Registers",
      "summary": "Clears all YMM registers.",
      "syntax": "VZEROALL",
      "encoding": { "format": "VEX", "hex_opcode": "C5 FC 77" },
      "extension": "AVX"
    },
    {
      "mnemonic": "emms",
      "architecture": "x86",
      "full_name": "Empty MMX Technology State",
      "summary": "Clears the FPU tag word to allow FP instructions after MMX.",
      "syntax": "EMMS",
      "encoding": { "format": "MMX", "hex_opcode": "0F 77" },
      "extension": "MMX"
    },
    {
      "mnemonic": "movd",
      "architecture": "x86",
      "full_name": "Move Doubleword",
      "summary": "Moves 32 bits between GPR and XMM/MMX register.",
      "syntax": "MOVD mm/xmm, r32/m32",
      "encoding": { "format": "SSE", "hex_opcode": "0F 6E" },
      "extension": "MMX/SSE2"
    },
    {
      "mnemonic": "movq",
      "architecture": "x86",
      "full_name": "Move Quadword",
      "summary": "Moves 64 bits between XMM registers or memory.",
      "syntax": "MOVQ xmm, xmm/m64",
      "encoding": { "format": "SSE2", "hex_opcode": "F3 0F 7E" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "movaps",
      "architecture": "x86",
      "full_name": "Move Aligned Packed Single-Precision",
      "summary": "Moves 128-bit packed float data (Must be 16-byte aligned).",
      "syntax": "MOVAPS xmm, xmm/m128",
      "encoding": { "format": "SSE", "hex_opcode": "0F 28" },
      "extension": "SSE"
    },
    {
      "mnemonic": "movups",
      "architecture": "x86",
      "full_name": "Move Unaligned Packed Single-Precision",
      "summary": "Moves 128-bit packed float data (Unaligned).",
      "syntax": "MOVUPS xmm, xmm/m128",
      "encoding": { "format": "SSE", "hex_opcode": "0F 10" },
      "extension": "SSE"
    },
    {
      "mnemonic": "movapd",
      "architecture": "x86",
      "full_name": "Move Aligned Packed Double-Precision",
      "summary": "Moves 128-bit packed double data (Must be 16-byte aligned).",
      "syntax": "MOVAPD xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F 28" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "movupd",
      "architecture": "x86",
      "full_name": "Move Unaligned Packed Double-Precision",
      "summary": "Moves 128-bit packed double data (Unaligned).",
      "syntax": "MOVUPD xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F 10" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "movdqa",
      "architecture": "x86",
      "full_name": "Move Aligned Packed Integer",
      "summary": "Moves 128-bit integer data (Aligned).",
      "syntax": "MOVDQA xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F 6F" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "movdqu",
      "architecture": "x86",
      "full_name": "Move Unaligned Packed Integer",
      "summary": "Moves 128-bit integer data (Unaligned).",
      "syntax": "MOVDQU xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "F3 0F 6F" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "addps",
      "architecture": "x86",
      "full_name": "Add Packed Single-Precision",
      "summary": "Adds four 32-bit floats.",
      "syntax": "ADDPS xmm, xmm/m128",
      "encoding": { "format": "SSE", "hex_opcode": "0F 58" },
      "extension": "SSE"
    },
    {
      "mnemonic": "addpd",
      "architecture": "x86",
      "full_name": "Add Packed Double-Precision",
      "summary": "Adds two 64-bit doubles.",
      "syntax": "ADDPD xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F 58" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "addss",
      "architecture": "x86",
      "full_name": "Add Scalar Single-Precision",
      "summary": "Adds the low 32-bit float.",
      "syntax": "ADDSS xmm, xmm/m32",
      "encoding": { "format": "SSE", "hex_opcode": "F3 0F 58" },
      "extension": "SSE"
    },
    {
      "mnemonic": "addsd",
      "architecture": "x86",
      "full_name": "Add Scalar Double-Precision",
      "summary": "Adds the low 64-bit double.",
      "syntax": "ADDSD xmm, xmm/m64",
      "encoding": { "format": "SSE2", "hex_opcode": "F2 0F 58" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "subps",
      "architecture": "x86",
      "full_name": "Subtract Packed Single-Precision",
      "summary": "Subtracts four 32-bit floats.",
      "syntax": "SUBPS xmm, xmm/m128",
      "encoding": { "format": "SSE", "hex_opcode": "0F 5C" },
      "extension": "SSE"
    },
    {
      "mnemonic": "subpd",
      "architecture": "x86",
      "full_name": "Subtract Packed Double-Precision",
      "summary": "Subtracts two 64-bit doubles.",
      "syntax": "SUBPD xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F 5C" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "mulps",
      "architecture": "x86",
      "full_name": "Multiply Packed Single-Precision",
      "summary": "Multiplies four 32-bit floats.",
      "syntax": "MULPS xmm, xmm/m128",
      "encoding": { "format": "SSE", "hex_opcode": "0F 59" },
      "extension": "SSE"
    },
    {
      "mnemonic": "mulpd",
      "architecture": "x86",
      "full_name": "Multiply Packed Double-Precision",
      "summary": "Multiplies two 64-bit doubles.",
      "syntax": "MULPD xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F 59" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "divps",
      "architecture": "x86",
      "full_name": "Divide Packed Single-Precision",
      "summary": "Divides four 32-bit floats.",
      "syntax": "DIVPS xmm, xmm/m128",
      "encoding": { "format": "SSE", "hex_opcode": "0F 5E" },
      "extension": "SSE"
    },
    {
      "mnemonic": "divpd",
      "architecture": "x86",
      "full_name": "Divide Packed Double-Precision",
      "summary": "Divides two 64-bit doubles.",
      "syntax": "DIVPD xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F 5E" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "sqrtps",
      "architecture": "x86",
      "full_name": "Square Root Packed Single-Precision",
      "summary": "Computes square root of four 32-bit floats.",
      "syntax": "SQRTPS xmm, xmm/m128",
      "encoding": { "format": "SSE", "hex_opcode": "0F 51" },
      "extension": "SSE"
    },
    {
      "mnemonic": "sqrtpd",
      "architecture": "x86",
      "full_name": "Square Root Packed Double-Precision",
      "summary": "Computes square root of two 64-bit doubles.",
      "syntax": "SQRTPD xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F 51" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "rcpps",
      "architecture": "x86",
      "full_name": "Reciprocal Packed Single-Precision",
      "summary": "Approximate reciprocal (1/x) of four 32-bit floats.",
      "syntax": "RCPPS xmm, xmm/m128",
      "encoding": { "format": "SSE", "hex_opcode": "0F 53" },
      "extension": "SSE"
    },
    {
      "mnemonic": "rsqrtps",
      "architecture": "x86",
      "full_name": "Reciprocal Square Root Packed Single-Precision",
      "summary": "Approximate reciprocal sqrt (1/sqrt(x)) of four 32-bit floats.",
      "syntax": "RSQRTPS xmm, xmm/m128",
      "encoding": { "format": "SSE", "hex_opcode": "0F 52" },
      "extension": "SSE"
    },
    {
      "mnemonic": "maxps",
      "architecture": "x86",
      "full_name": "Maximum Packed Single-Precision",
      "summary": "Returns maximum of packed floats.",
      "syntax": "MAXPS xmm, xmm/m128",
      "encoding": { "format": "SSE", "hex_opcode": "0F 5F" },
      "extension": "SSE"
    },
    {
      "mnemonic": "minps",
      "architecture": "x86",
      "full_name": "Minimum Packed Single-Precision",
      "summary": "Returns minimum of packed floats.",
      "syntax": "MINPS xmm, xmm/m128",
      "encoding": { "format": "SSE", "hex_opcode": "0F 5D" },
      "extension": "SSE"
    },
    {
      "mnemonic": "andps",
      "architecture": "x86",
      "full_name": "Bitwise Logical AND Packed Single-Precision",
      "summary": "Bitwise AND of 128 bits.",
      "syntax": "ANDPS xmm, xmm/m128",
      "encoding": { "format": "SSE", "hex_opcode": "0F 54" },
      "extension": "SSE"
    },
    {
      "mnemonic": "andpd",
      "architecture": "x86",
      "full_name": "Bitwise Logical AND Packed Double-Precision",
      "summary": "Bitwise AND of 128 bits.",
      "syntax": "ANDPD xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F 54" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "orps",
      "architecture": "x86",
      "full_name": "Bitwise Logical OR Packed Single-Precision",
      "summary": "Bitwise OR of 128 bits.",
      "syntax": "ORPS xmm, xmm/m128",
      "encoding": { "format": "SSE", "hex_opcode": "0F 56" },
      "extension": "SSE"
    },
    {
      "mnemonic": "xorps",
      "architecture": "x86",
      "full_name": "Bitwise Logical XOR Packed Single-Precision",
      "summary": "Bitwise XOR of 128 bits (Used to clear registers).",
      "syntax": "XORPS xmm, xmm/m128",
      "encoding": { "format": "SSE", "hex_opcode": "0F 57" },
      "extension": "SSE"
    },
    {
      "mnemonic": "paddb",
      "architecture": "x86",
      "full_name": "Packed Add Bytes",
      "summary": "Adds 16 bytes (Wraparound).",
      "syntax": "PADDB xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F FC" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "paddw",
      "architecture": "x86",
      "full_name": "Packed Add Words",
      "summary": "Adds 8 words (Wraparound).",
      "syntax": "PADDW xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F FD" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "paddd",
      "architecture": "x86",
      "full_name": "Packed Add Doublewords",
      "summary": "Adds 4 doublewords (Wraparound).",
      "syntax": "PADDD xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F FE" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "paddq",
      "architecture": "x86",
      "full_name": "Packed Add Quadwords",
      "summary": "Adds 2 quadwords (Wraparound).",
      "syntax": "PADDQ xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F D4" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "paddsb",
      "architecture": "x86",
      "full_name": "Packed Add Bytes Signed Saturate",
      "summary": "Adds 16 signed bytes with saturation.",
      "syntax": "PADDSB xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F EC" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "paddusb",
      "architecture": "x86",
      "full_name": "Packed Add Bytes Unsigned Saturate",
      "summary": "Adds 16 unsigned bytes with saturation.",
      "syntax": "PADDUSB xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F DC" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "psubb",
      "architecture": "x86",
      "full_name": "Packed Subtract Bytes",
      "summary": "Subtracts 16 bytes.",
      "syntax": "PSUBB xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F F8" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "psubw",
      "architecture": "x86",
      "full_name": "Packed Subtract Words",
      "summary": "Subtracts 8 words.",
      "syntax": "PSUBW xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F F9" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "psubd",
      "architecture": "x86",
      "full_name": "Packed Subtract Doublewords",
      "summary": "Subtracts 4 doublewords.",
      "syntax": "PSUBD xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F FA" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "pand",
      "architecture": "x86",
      "full_name": "Packed Logical AND",
      "summary": "Bitwise AND of 128-bit integers.",
      "syntax": "PAND xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F DB" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "por",
      "architecture": "x86",
      "full_name": "Packed Logical OR",
      "summary": "Bitwise OR of 128-bit integers.",
      "syntax": "POR xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F EB" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "pxor",
      "architecture": "x86",
      "full_name": "Packed Logical Exclusive OR",
      "summary": "Bitwise XOR of 128-bit integers.",
      "syntax": "PXOR xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F EF" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "psllw",
      "architecture": "x86",
      "full_name": "Packed Shift Left Logical Word",
      "summary": "Shifts words left.",
      "syntax": "PSLLW xmm, imm8",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F 71 /6" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "pslld",
      "architecture": "x86",
      "full_name": "Packed Shift Left Logical Doubleword",
      "summary": "Shifts doublewords left.",
      "syntax": "PSLLD xmm, imm8",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F 72 /6" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "psrlw",
      "architecture": "x86",
      "full_name": "Packed Shift Right Logical Word",
      "summary": "Shifts words right logical.",
      "syntax": "PSRLW xmm, imm8",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F 71 /2" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "psrld",
      "architecture": "x86",
      "full_name": "Packed Shift Right Logical Doubleword",
      "summary": "Shifts doublewords right logical.",
      "syntax": "PSRLD xmm, imm8",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F 72 /2" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "psraw",
      "architecture": "x86",
      "full_name": "Packed Shift Right Arithmetic Word",
      "summary": "Shifts words right arithmetic (sign bit).",
      "syntax": "PSRAW xmm, imm8",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F 71 /4" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "psrad",
      "architecture": "x86",
      "full_name": "Packed Shift Right Arithmetic Doubleword",
      "summary": "Shifts doublewords right arithmetic.",
      "syntax": "PSRAD xmm, imm8",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F 72 /4" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "pcmpeqb",
      "architecture": "x86",
      "full_name": "Packed Compare Equal Byte",
      "summary": "Compares bytes for equality (Result mask 0xFF or 0x00).",
      "syntax": "PCMPEQB xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F 74" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "pcmpeqw",
      "architecture": "x86",
      "full_name": "Packed Compare Equal Word",
      "summary": "Compares words for equality.",
      "syntax": "PCMPEQW xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F 75" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "pcmpeqd",
      "architecture": "x86",
      "full_name": "Packed Compare Equal Doubleword",
      "summary": "Compares doublewords for equality.",
      "syntax": "PCMPEQD xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F 76" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "shufps",
      "architecture": "x86",
      "full_name": "Shuffle Packed Single-Precision",
      "summary": "Shuffles 32-bit floats based on immediate mask.",
      "syntax": "SHUFPS xmm, xmm/m128, imm8",
      "encoding": { "format": "SSE", "hex_opcode": "0F C6" },
      "extension": "SSE"
    },
    {
      "mnemonic": "shufpd",
      "architecture": "x86",
      "full_name": "Shuffle Packed Double-Precision",
      "summary": "Shuffles 64-bit doubles based on immediate mask.",
      "syntax": "SHUFPD xmm, xmm/m128, imm8",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F C6" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "pshufd",
      "architecture": "x86",
      "full_name": "Packed Shuffle Doubleword",
      "summary": "Shuffles 32-bit integers.",
      "syntax": "PSHUFD xmm, xmm/m128, imm8",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F 70" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "cvtsi2ss",
      "architecture": "x86",
      "full_name": "Convert Doubleword Integer to Scalar Single-Precision",
      "summary": "Converts 32-bit int to float.",
      "syntax": "CVTSI2SS xmm, r/m32",
      "encoding": { "format": "SSE", "hex_opcode": "F3 0F 2A" },
      "extension": "SSE"
    },
    {
      "mnemonic": "cvtsi2sd",
      "architecture": "x86",
      "full_name": "Convert Doubleword Integer to Scalar Double-Precision",
      "summary": "Converts 32-bit int to double.",
      "syntax": "CVTSI2SD xmm, r/m32",
      "encoding": { "format": "SSE2", "hex_opcode": "F2 0F 2A" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "cvttss2si",
      "architecture": "x86",
      "full_name": "Convert with Truncation Scalar Single to Integer",
      "summary": "Converts float to 32-bit int (Truncate).",
      "syntax": "CVTTSS2SI r32, xmm/m32",
      "encoding": { "format": "SSE", "hex_opcode": "F3 0F 2C" },
      "extension": "SSE"
    },
    {
      "mnemonic": "cvttsd2si",
      "architecture": "x86",
      "full_name": "Convert with Truncation Scalar Double to Integer",
      "summary": "Converts double to 32-bit int (Truncate).",
      "syntax": "CVTTSD2SI r32, xmm/m64",
      "encoding": { "format": "SSE2", "hex_opcode": "F2 0F 2C" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "cvtss2sd",
      "architecture": "x86",
      "full_name": "Convert Scalar Single to Scalar Double",
      "summary": "Converts float to double.",
      "syntax": "CVTSS2SD xmm, xmm/m32",
      "encoding": { "format": "SSE2", "hex_opcode": "F3 0F 5A" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "cvtsd2ss",
      "architecture": "x86",
      "full_name": "Convert Scalar Double to Scalar Single",
      "summary": "Converts double to float.",
      "syntax": "CVTSD2SS xmm, xmm/m64",
      "encoding": { "format": "SSE2", "hex_opcode": "F2 0F 5A" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "ucomiss",
      "architecture": "x86",
      "full_name": "Unordered Compare Scalar Single-Precision",
      "summary": "Compares low float and sets EFLAGS.",
      "syntax": "UCOMISS xmm1, xmm2/m32",
      "encoding": { "format": "SSE", "hex_opcode": "0F 2E" },
      "extension": "SSE"
    },
    {
      "mnemonic": "ucomisd",
      "architecture": "x86",
      "full_name": "Unordered Compare Scalar Double-Precision",
      "summary": "Compares low double and sets EFLAGS.",
      "syntax": "UCOMISD xmm1, xmm2/m64",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F 2E" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "punpcklbw",
      "architecture": "x86",
      "full_name": "Unpack Low Data Bytes",
      "summary": "Interleaves low bytes from two sources.",
      "syntax": "PUNPCKLBW xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F 60" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "punpcklwd",
      "architecture": "x86",
      "full_name": "Unpack Low Data Words",
      "summary": "Interleaves low words.",
      "syntax": "PUNPCKLWD xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F 61" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "punpckldq",
      "architecture": "x86",
      "full_name": "Unpack Low Data Doublewords",
      "summary": "Interleaves low doublewords.",
      "syntax": "PUNPCKLDQ xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F 62" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "punpcklqdq",
      "architecture": "x86",
      "full_name": "Unpack Low Data Quadwords",
      "summary": "Interleaves low quadwords.",
      "syntax": "PUNPCKLQDQ xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F 6C" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "packsswb",
      "architecture": "x86",
      "full_name": "Pack with Signed Saturation Word to Byte",
      "summary": "Converts words to bytes with saturation.",
      "syntax": "PACKSSWB xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F 63" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "packssdw",
      "architecture": "x86",
      "full_name": "Pack with Signed Saturation Doubleword to Word",
      "summary": "Converts doublewords to words with saturation.",
      "syntax": "PACKSSDW xmm, xmm/m128",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F 6B" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "pmovmskb",
      "architecture": "x86",
      "full_name": "Move Byte Mask",
      "summary": "Creates a mask from the MSB of each byte in XMM.",
      "syntax": "PMOVMSKB r32, xmm",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F D7" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "maskmovdqu",
      "architecture": "x86",
      "full_name": "Store Selected Bytes of Double Quadword",
      "summary": "Non-temporal store of selected bytes (masked).",
      "syntax": "MASKMOVDQU xmm, xmm",
      "encoding": { "format": "SSE2", "hex_opcode": "66 0F F7" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "ldmxcsr",
      "architecture": "x86",
      "full_name": "Load MXCSR Register",
      "summary": "Loads the MXCSR control/status register from memory.",
      "syntax": "LDMXCSR m32",
      "encoding": { "format": "SSE", "hex_opcode": "0F AE /2" },
      "extension": "SSE"
    },
    {
      "mnemonic": "stmxcsr",
      "architecture": "x86",
      "full_name": "Store MXCSR Register",
      "summary": "Stores the MXCSR register to memory.",
      "syntax": "STMXCSR m32",
      "encoding": { "format": "SSE", "hex_opcode": "0F AE /3" },
      "extension": "SSE"
    },
    {
      "mnemonic": "prefetcht0",
      "architecture": "x86",
      "full_name": "Prefetch Data into all Cache Levels",
      "summary": "Prefetches data to L1 cache.",
      "syntax": "PREFETCHT0 m8",
      "encoding": { "format": "SSE", "hex_opcode": "0F 18 /1" },
      "extension": "SSE"
    },
    {
      "mnemonic": "prefetchnta",
      "architecture": "x86",
      "full_name": "Prefetch Data using Non-Temporal Access",
      "summary": "Prefetches data to non-temporal cache structure (minimize pollution).",
      "syntax": "PREFETCHNTA m8",
      "encoding": { "format": "SSE", "hex_opcode": "0F 18 /0" },
      "extension": "SSE"
    },
    {
      "mnemonic": "sfence",
      "architecture": "x86",
      "full_name": "Store Fence",
      "summary": "Serializes all store operations.",
      "syntax": "SFENCE",
      "encoding": { "format": "SSE", "hex_opcode": "0F AE F8" },
      "extension": "SSE"
    },
    {
      "mnemonic": "lfence",
      "architecture": "x86",
      "full_name": "Load Fence",
      "summary": "Serializes all load operations.",
      "syntax": "LFENCE",
      "encoding": { "format": "SSE2", "hex_opcode": "0F AE E8" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "mfence",
      "architecture": "x86",
      "full_name": "Memory Fence",
      "summary": "Serializes all load and store operations.",
      "syntax": "MFENCE",
      "encoding": { "format": "SSE2", "hex_opcode": "0F AE F0" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "clflush",
      "architecture": "x86",
      "full_name": "Flush Cache Line",
      "summary": "Flushes cache line containing address.",
      "syntax": "CLFLUSH m8",
      "encoding": { "format": "SSE2", "hex_opcode": "0F AE /7" },
      "extension": "SSE2"
    },
    {
      "mnemonic": "vfmadd132ps",
      "architecture": "x86",
      "full_name": "Fused Multiply-Add (132) Packed Single",
      "summary": "Computes (Dest * Src2) + Src1.",
      "syntax": "VFMADD132PS ymm1, ymm2, ymm3/m256",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... 98" },
      "extension": "FMA3"
    },
    {
      "mnemonic": "vfmadd213ps",
      "architecture": "x86",
      "full_name": "Fused Multiply-Add (213) Packed Single",
      "summary": "Computes (Src1 * Dest) + Src2.",
      "syntax": "VFMADD213PS ymm1, ymm2, ymm3/m256",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... A8" },
      "extension": "FMA3"
    },
    {
      "mnemonic": "vfmsub132ps",
      "architecture": "x86",
      "full_name": "Fused Multiply-Subtract (132) Packed Single",
      "summary": "Computes (Dest * Src2) - Src1.",
      "syntax": "VFMSUB132PS ymm1, ymm2, ymm3/m256",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... 9A" },
      "extension": "FMA3"
    },
    {
      "mnemonic": "vfnmadd132ps",
      "architecture": "x86",
      "full_name": "Fused Negative Multiply-Add (132) Packed Single",
      "summary": "Computes -(Dest * Src2) + Src1.",
      "syntax": "VFNMADD132PS ymm1, ymm2, ymm3/m256",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... 9C" },
      "extension": "FMA3"
    },
    {
      "mnemonic": "vpaddd",
      "architecture": "x86",
      "full_name": "Packed Add Doubleword (AVX2)",
      "summary": "Adds 8 integers (256-bit).",
      "syntax": "VPADDD ymm1, ymm2, ymm3/m256",
      "encoding": { "format": "VEX", "hex_opcode": "C5 ... FE" },
      "extension": "AVX2"
    },
    {
      "mnemonic": "vpaddb",
      "architecture": "x86",
      "full_name": "Packed Add Byte (AVX2)",
      "summary": "Adds 32 bytes (256-bit).",
      "syntax": "VPADDB ymm1, ymm2, ymm3/m256",
      "encoding": { "format": "VEX", "hex_opcode": "C5 ... FC" },
      "extension": "AVX2"
    },
    {
      "mnemonic": "vpsubd",
      "architecture": "x86",
      "full_name": "Packed Subtract Doubleword (AVX2)",
      "summary": "Subtracts 8 integers (256-bit).",
      "syntax": "VPSUBD ymm1, ymm2, ymm3/m256",
      "encoding": { "format": "VEX", "hex_opcode": "C5 ... FA" },
      "extension": "AVX2"
    },
    {
      "mnemonic": "vpmulld",
      "architecture": "x86",
      "full_name": "Packed Multiply Low Doubleword (AVX2)",
      "summary": "Multiplies 8 integers (256-bit).",
      "syntax": "VPMULLD ymm1, ymm2, ymm3/m256",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... 40" },
      "extension": "AVX2"
    },
    {
      "mnemonic": "vpshufb",
      "architecture": "x86",
      "full_name": "Packed Shuffle Bytes (AVX2)",
      "summary": "Shuffles 32 bytes based on indices.",
      "syntax": "VPSHUFB ymm1, ymm2, ymm3/m256",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... 00" },
      "extension": "AVX2"
    },
    {
      "mnemonic": "vperm2i128",
      "architecture": "x86",
      "full_name": "Permute 128-bit Integer Blocks",
      "summary": "Shuffles two 128-bit lanes between registers.",
      "syntax": "VPERM2I128 ymm1, ymm2, ymm3/m256, imm8",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... 46" },
      "extension": "AVX2"
    },
    {
      "mnemonic": "vpermd",
      "architecture": "x86",
      "full_name": "Permute Doublewords",
      "summary": "Full permutation of 8 integers using indices from a register.",
      "syntax": "VPERMD ymm1, ymm2, ymm3/m256",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... 36" },
      "extension": "AVX2"
    },
    {
      "mnemonic": "vpermps",
      "architecture": "x86",
      "full_name": "Permute Single-Precision Floating-Point",
      "summary": "Full permutation of 8 floats using indices.",
      "syntax": "VPERMPS ymm1, ymm2, ymm3/m256",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... 16" },
      "extension": "AVX2"
    },
    {
      "mnemonic": "vpbroadcastb",
      "architecture": "x86",
      "full_name": "Broadcast Byte",
      "summary": "Broadcasts a byte from memory/register to all elements of YMM.",
      "syntax": "VPBROADCASTB ymm1, xmm2/m8",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... 78" },
      "extension": "AVX2"
    },
    {
      "mnemonic": "vpbroadcastd",
      "architecture": "x86",
      "full_name": "Broadcast Doubleword",
      "summary": "Broadcasts an integer to all elements of YMM.",
      "syntax": "VPBROADCASTD ymm1, xmm2/m32",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... 58" },
      "extension": "AVX2"
    },
    {
      "mnemonic": "vgatherdps",
      "architecture": "x86",
      "full_name": "Gather Packed Single Precision",
      "summary": "Loads floats from non-contiguous memory using indices.",
      "syntax": "VGATHERDPS ymm1, [base+ymm_idx*scale], ymm_mask",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... 92" },
      "extension": "AVX2"
    },
    {
      "mnemonic": "vgatherdpd",
      "architecture": "x86",
      "full_name": "Gather Packed Double Precision",
      "summary": "Loads doubles from non-contiguous memory using indices.",
      "syntax": "VGATHERDPD ymm1, [base+xmm_idx*scale], ymm_mask",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... 92" },
      "extension": "AVX2"
    },
    {
      "mnemonic": "andn",
      "architecture": "x86",
      "full_name": "Logical AND NOT",
      "summary": "Calculates (NOT src1) AND src2. Non-destructive.",
      "syntax": "ANDN r32, r32, r/m32",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... F2" },
      "extension": "BMI1"
    },
    {
      "mnemonic": "bextr",
      "architecture": "x86",
      "full_name": "Bit Field Extract",
      "summary": "Extracts sequence of bits from source using index/length.",
      "syntax": "BEXTR r32, r/m32, r32",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... F7" },
      "extension": "BMI1"
    },
    {
      "mnemonic": "blsi",
      "architecture": "x86",
      "full_name": "Extract Lowest Set Isolated Bit",
      "summary": "Extracts the lowest set bit (x & -x).",
      "syntax": "BLSI r32, r/m32",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... F3 /3" },
      "extension": "BMI1"
    },
    {
      "mnemonic": "blsmsk",
      "architecture": "x86",
      "full_name": "Get Mask Up to Lowest Set Bit",
      "summary": "Creates mask up to lowest set bit (x ^ (x-1)).",
      "syntax": "BLSMSK r32, r/m32",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... F3 /2" },
      "extension": "BMI1"
    },
    {
      "mnemonic": "blsr",
      "architecture": "x86",
      "full_name": "Reset Lowest Set Bit",
      "summary": "Clears the lowest set bit (x & (x-1)).",
      "syntax": "BLSR r32, r/m32",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... F3 /1" },
      "extension": "BMI1"
    },
    {
      "mnemonic": "tzcnt",
      "architecture": "x86",
      "full_name": "Count Trailing Zeros",
      "summary": "Counts the number of trailing zeros.",
      "syntax": "TZCNT r32, r/m32",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 0F BC" },
      "extension": "BMI1"
    },
    {
      "mnemonic": "bzhi",
      "architecture": "x86",
      "full_name": "Zero High Bits Starting with Specified Bit Position",
      "summary": "Clears high bits starting at index.",
      "syntax": "BZHI r32, r/m32, r32",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... F5" },
      "extension": "BMI2"
    },
    {
      "mnemonic": "pext",
      "architecture": "x86",
      "full_name": "Parallel Bits Extract",
      "summary": "Extracts bits from source using mask and packs them to LSB.",
      "syntax": "PEXT r32, r32, r/m32",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... F5" },
      "extension": "BMI2"
    },
    {
      "mnemonic": "pdep",
      "architecture": "x86",
      "full_name": "Parallel Bits Deposit",
      "summary": "Scatters bits from LSB of source to positions marked in mask.",
      "syntax": "PDEP r32, r32, r/m32",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... F5" },
      "extension": "BMI2"
    },
    {
      "mnemonic": "mulx",
      "architecture": "x86",
      "full_name": "Unsigned Multiply Without Affecting Flags",
      "summary": "Unsigned multiply of RDX * Src. Result in Hi:Lo. No flags.",
      "syntax": "MULX r32, r32, r/m32",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... F6" },
      "extension": "BMI2"
    },
    {
      "mnemonic": "shlx",
      "architecture": "x86",
      "full_name": "Shift Logical Left Without Affecting Flags",
      "summary": "Logical left shift, count in register. No flags update.",
      "syntax": "SHLX r32, r/m32, r32",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... F7" },
      "extension": "BMI2"
    },
    {
      "mnemonic": "shrx",
      "architecture": "x86",
      "full_name": "Shift Logical Right Without Affecting Flags",
      "summary": "Logical right shift, count in register. No flags update.",
      "syntax": "SHRX r32, r/m32, r32",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... F7" },
      "extension": "BMI2"
    },
    {
      "mnemonic": "sarx",
      "architecture": "x86",
      "full_name": "Shift Arithmetic Right Without Affecting Flags",
      "summary": "Arithmetic right shift, count in register. No flags update.",
      "syntax": "SARX r32, r/m32, r32",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... F7" },
      "extension": "BMI2"
    },
    {
      "mnemonic": "rorx",
      "architecture": "x86",
      "full_name": "Rotate Right Logical Without Affecting Flags",
      "summary": "Rotate right with immediate. No flags update.",
      "syntax": "RORX r32, r/m32, imm8",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... F0" },
      "extension": "BMI2"
    },
    {
      "mnemonic": "rdrand",
      "architecture": "x86",
      "full_name": "Read Random Number",
      "summary": "Retrieves a hardware-generated random number.",
      "syntax": "RDRAND r32",
      "encoding": { "format": "Legacy", "hex_opcode": "0F C7 /6" },
      "extension": "RDRAND"
    },
    {
      "mnemonic": "rdseed",
      "architecture": "x86",
      "full_name": "Read Random Seed",
      "summary": "Retrieves a random seed from hardware entropy source.",
      "syntax": "RDSEED r32",
      "encoding": { "format": "Legacy", "hex_opcode": "0F C7 /7" },
      "extension": "RDSEED"
    },
    {
      "mnemonic": "xsave",
      "architecture": "x86",
      "full_name": "Save Processor Extended States",
      "summary": "Saves state components (AVX/SSE) to memory.",
      "syntax": "XSAVE m",
      "encoding": { "format": "Legacy", "hex_opcode": "0F AE /4" },
      "extension": "XSAVE"
    },
    {
      "mnemonic": "xrstor",
      "architecture": "x86",
      "full_name": "Restore Processor Extended States",
      "summary": "Restores state components from memory.",
      "syntax": "XRSTOR m",
      "encoding": { "format": "Legacy", "hex_opcode": "0F AE /5" },
      "extension": "XSAVE"
    },
    {
      "mnemonic": "xgetbv",
      "architecture": "x86",
      "full_name": "Get Value of Extended Control Register",
      "summary": "Reads an XCR specified by ECX into EDX:EAX.",
      "syntax": "XGETBV",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 01 D0" },
      "extension": "XSAVE"
    },
    {
      "mnemonic": "xsetbv",
      "architecture": "x86",
      "full_name": "Set Value of Extended Control Register",
      "summary": "Writes EDX:EAX to XCR specified by ECX (Privileged).",
      "syntax": "XSETBV",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 01 D1" },
      "extension": "XSAVE"
    },
    {
      "mnemonic": "invpcid",
      "architecture": "x86",
      "full_name": "Invalidate Process-Context Identifier",
      "summary": "Invalidates TLB entries based on PCID.",
      "syntax": "INVPCID r32, m128",
      "encoding": { "format": "Legacy", "hex_opcode": "66 0F 38 82" },
      "extension": "INVPCID"
    },
    {
      "mnemonic": "adcx",
      "architecture": "x86",
      "full_name": "Unsigned Integer Addition of Two Operands with Carry Flag",
      "summary": "Adds with Carry Flag (distinct from ADC, affects CF only).",
      "syntax": "ADCX r32, r/m32",
      "encoding": { "format": "Legacy", "hex_opcode": "66 0F 38 F6" },
      "extension": "ADX"
    },
    {
      "mnemonic": "adox",
      "architecture": "x86",
      "full_name": "Unsigned Integer Addition of Two Operands with Overflow Flag",
      "summary": "Adds with Overflow Flag (Parallel addition with ADCX).",
      "syntax": "ADOX r32, r/m32",
      "encoding": { "format": "Legacy", "hex_opcode": "F3 0F 38 F6" },
      "extension": "ADX"
    },
    {
      "mnemonic": "rdtscp",
      "architecture": "x86",
      "full_name": "Read Time-Stamp Counter and Processor ID",
      "summary": "Reads TSC and IA32_TSC_AUX into EDX:EAX and ECX.",
      "syntax": "RDTSCP",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 01 F9" },
      "extension": "Base"
    },
    {
      "mnemonic": "vinserti128",
      "architecture": "x86",
      "full_name": "Insert Integer 128-bit",
      "summary": "Inserts 128-bits of integer data into a YMM register.",
      "syntax": "VINSERTI128 ymm1, ymm2, xmm3/m128, imm8",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... 38" },
      "extension": "AVX2"
    },
    {
      "mnemonic": "vextracti128",
      "architecture": "x86",
      "full_name": "Extract Integer 128-bit",
      "summary": "Extracts 128-bits of integer data from YMM.",
      "syntax": "VEXTRACTI128 xmm1/m128, ymm2, imm8",
      "encoding": { "format": "VEX", "hex_opcode": "C4 ... 39" },
      "extension": "AVX2"
    },
    {
      "mnemonic": "clac",
      "architecture": "x86",
      "full_name": "Clear AC Flag in EFLAGS",
      "summary": "Clears Alignment Check flag (SMAP prevention).",
      "syntax": "CLAC",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 01 CA" },
      "extension": "SMAP"
    },
    {
      "mnemonic": "stac",
      "architecture": "x86",
      "full_name": "Set AC Flag in EFLAGS",
      "summary": "Sets Alignment Check flag (Allow user memory access).",
      "syntax": "STAC",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 01 CB" },
      "extension": "SMAP"
    },
    {
      "mnemonic": "gf2p8affineqb",
      "architecture": "x86",
      "full_name": "Galois Field Affine Transformation",
      "summary": "Computes affine transformation in GF(2^8).",
      "syntax": "GF2P8AFFINEQB xmm1, xmm2/m128, imm8",
      "encoding": { "format": "VEX", "hex_opcode": "66 0F 3A CE" },
      "extension": "GFNI"
    },
    {
      "mnemonic": "gf2p8mulb",
      "architecture": "x86",
      "full_name": "Galois Field Multiply Bytes",
      "summary": "Multiplies bytes in GF(2^8).",
      "syntax": "GF2P8MULB xmm1, xmm2/m128",
      "encoding": { "format": "VEX", "hex_opcode": "66 0F 38 CF" },
      "extension": "GFNI"
    },
    {
      "mnemonic": "sha1msg1",
      "architecture": "x86",
      "full_name": "SHA1 Message Schedule 1",
      "summary": "Performs intermediate calculation for SHA1 message schedule.",
      "syntax": "SHA1MSG1 xmm1, xmm2/m128",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 38 C9" },
      "extension": "SHA"
    },
    {
      "mnemonic": "sha1msg2",
      "architecture": "x86",
      "full_name": "SHA1 Message Schedule 2",
      "summary": "Performs final calculation for SHA1 message schedule.",
      "syntax": "SHA1MSG2 xmm1, xmm2/m128",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 38 CA" },
      "extension": "SHA"
    },
    {
      "mnemonic": "sha1nexte",
      "architecture": "x86",
      "full_name": "SHA1 State Variable E",
      "summary": "Calculates SHA1 state variable E.",
      "syntax": "SHA1NEXTE xmm1, xmm2/m128",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 38 C8" },
      "extension": "SHA"
    },
    {
      "mnemonic": "sha1rnds4",
      "architecture": "x86",
      "full_name": "SHA1 Rounds 4",
      "summary": "Performs 4 rounds of SHA1 operation.",
      "syntax": "SHA1RNDS4 xmm1, xmm2/m128, imm8",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 3A CC" },
      "extension": "SHA"
    },
    {
      "mnemonic": "sha256msg1",
      "architecture": "x86",
      "full_name": "SHA256 Message Schedule 1",
      "summary": "Performs intermediate calculation for SHA256 message schedule.",
      "syntax": "SHA256MSG1 xmm1, xmm2/m128",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 38 CC" },
      "extension": "SHA"
    },
    {
      "mnemonic": "sha256msg2",
      "architecture": "x86",
      "full_name": "SHA256 Message Schedule 2",
      "summary": "Performs final calculation for SHA256 message schedule.",
      "syntax": "SHA256MSG2 xmm1, xmm2/m128",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 38 CD" },
      "extension": "SHA"
    },
    {
      "mnemonic": "sha256rnds2",
      "architecture": "x86",
      "full_name": "SHA256 Rounds 2",
      "summary": "Performs 2 rounds of SHA256 operation.",
      "syntax": "SHA256RNDS2 xmm1, xmm2/m128, xmm0",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 38 CB" },
      "extension": "SHA"
    },
    {
      "mnemonic": "vmxon",
      "architecture": "x86",
      "full_name": "Enter VMX Operation",
      "summary": "Enters VMX root operation (Host Mode).",
      "syntax": "VMXON m64",
      "encoding": { "format": "VMX", "hex_opcode": "F3 0F C7 /6" },
      "extension": "VMX"
    },
    {
      "mnemonic": "vmcall",
      "architecture": "x86",
      "full_name": "Call to VM Monitor",
      "summary": "Guest VM calls the Hypervisor (VM Exit).",
      "syntax": "VMCALL",
      "encoding": { "format": "VMX", "hex_opcode": "0F 01 C1" },
      "extension": "VMX"
    },
    {
      "mnemonic": "vmclear",
      "architecture": "x86",
      "full_name": "Clear Virtual-Machine Control Structure",
      "summary": "Initializes a VMCS region in memory.",
      "syntax": "VMCLEAR m64",
      "encoding": { "format": "VMX", "hex_opcode": "66 0F C7 /6" },
      "extension": "VMX"
    },
    {
      "mnemonic": "vmlaunch",
      "architecture": "x86",
      "full_name": "Launch Virtual Machine",
      "summary": "Launches a VM managed by the current VMCS.",
      "syntax": "VMLAUNCH",
      "encoding": { "format": "VMX", "hex_opcode": "0F 01 C2" },
      "extension": "VMX"
    },
    {
      "mnemonic": "vmresume",
      "architecture": "x86",
      "full_name": "Resume Virtual Machine",
      "summary": "Resumes a VM from the current VMCS.",
      "syntax": "VMRESUME",
      "encoding": { "format": "VMX", "hex_opcode": "0F 01 C3" },
      "extension": "VMX"
    },
    {
      "mnemonic": "vmptrld",
      "architecture": "x86",
      "full_name": "Load Pointer to VMCS",
      "summary": "Loads the current VMCS pointer from memory.",
      "syntax": "VMPTRLD m64",
      "encoding": { "format": "VMX", "hex_opcode": "0F C7 /6" },
      "extension": "VMX"
    },
    {
      "mnemonic": "vmptrst",
      "architecture": "x86",
      "full_name": "Store Pointer to VMCS",
      "summary": "Stores the current VMCS pointer to memory.",
      "syntax": "VMPTRST m64",
      "encoding": { "format": "VMX", "hex_opcode": "0F C7 /7" },
      "extension": "VMX"
    },
    {
      "mnemonic": "vmread",
      "architecture": "x86",
      "full_name": "Read Field from VMCS",
      "summary": "Reads a field from the Virtual Machine Control Structure.",
      "syntax": "VMREAD r/m64, r64",
      "encoding": { "format": "VMX", "hex_opcode": "0F 78" },
      "extension": "VMX"
    },
    {
      "mnemonic": "vmwrite",
      "architecture": "x86",
      "full_name": "Write Field to VMCS",
      "summary": "Writes a field to the Virtual Machine Control Structure.",
      "syntax": "VMWRITE r64, r/m64",
      "encoding": { "format": "VMX", "hex_opcode": "0F 79" },
      "extension": "VMX"
    },
    {
      "mnemonic": "vmoff",
      "architecture": "x86",
      "full_name": "Leave VMX Operation",
      "summary": "Leaves VMX root operation.",
      "syntax": "VMOFF",
      "encoding": { "format": "VMX", "hex_opcode": "0F 01 C4" },
      "extension": "VMX"
    },
    {
      "mnemonic": "invept",
      "architecture": "x86",
      "full_name": "Invalidate Translations Derived from EPT",
      "summary": "Invalidates Extended Page Table entries.",
      "syntax": "INVEPT r64, m128",
      "encoding": { "format": "VMX", "hex_opcode": "66 0F 38 80" },
      "extension": "VMX (EPT)"
    },
    {
      "mnemonic": "invvpid",
      "architecture": "x86",
      "full_name": "Invalidate Translations Based on VPID",
      "summary": "Invalidates TLB entries based on Virtual Processor ID.",
      "syntax": "INVVPID r64, m128",
      "encoding": { "format": "VMX", "hex_opcode": "66 0F 38 81" },
      "extension": "VMX (VPID)"
    },
    {
      "mnemonic": "kmovw",
      "architecture": "x86",
      "full_name": "Move Word Mask Register",
      "summary": "Moves 16-bit mask to/from k-register.",
      "syntax": "KMOVW k1, k2/m16",
      "encoding": { "format": "EVEX", "hex_opcode": "0F 90" },
      "extension": "AVX-512"
    },
    {
      "mnemonic": "kmovq",
      "architecture": "x86",
      "full_name": "Move Quadword Mask Register",
      "summary": "Moves 64-bit mask to/from k-register.",
      "syntax": "KMOVQ k1, k2/m64",
      "encoding": { "format": "EVEX", "hex_opcode": "0F 90" },
      "extension": "AVX-512BW"
    },
    {
      "mnemonic": "kandw",
      "architecture": "x86",
      "full_name": "Bitwise Logical AND Masks Word",
      "summary": "Bitwise AND of 16-bit masks.",
      "syntax": "KANDW k1, k2, k3",
      "encoding": { "format": "EVEX", "hex_opcode": "0F 41" },
      "extension": "AVX-512"
    },
    {
      "mnemonic": "kandnw",
      "architecture": "x86",
      "full_name": "Bitwise Logical AND NOT Masks Word",
      "summary": "Bitwise AND NOT of 16-bit masks.",
      "syntax": "KANDNW k1, k2, k3",
      "encoding": { "format": "EVEX", "hex_opcode": "0F 42" },
      "extension": "AVX-512"
    },
    {
      "mnemonic": "korw",
      "architecture": "x86",
      "full_name": "Bitwise Logical OR Masks Word",
      "summary": "Bitwise OR of 16-bit masks.",
      "syntax": "KORW k1, k2, k3",
      "encoding": { "format": "EVEX", "hex_opcode": "0F 45" },
      "extension": "AVX-512"
    },
    {
      "mnemonic": "kxorw",
      "architecture": "x86",
      "full_name": "Bitwise Logical XOR Masks Word",
      "summary": "Bitwise XOR of 16-bit masks.",
      "syntax": "KXORW k1, k2, k3",
      "encoding": { "format": "EVEX", "hex_opcode": "0F 47" },
      "extension": "AVX-512"
    },
    {
      "mnemonic": "knotw",
      "architecture": "x86",
      "full_name": "Bitwise Logical NOT Masks Word",
      "summary": "Bitwise NOT of 16-bit mask.",
      "syntax": "KNOTW k1, k2",
      "encoding": { "format": "EVEX", "hex_opcode": "0F 44" },
      "extension": "AVX-512"
    },
    {
      "mnemonic": "kortestw",
      "architecture": "x86",
      "full_name": "OR Masks And Set Flags Word",
      "summary": "ORs two masks and sets EFLAGS (ZF, CF) based on result.",
      "syntax": "KORTESTW k1, k2",
      "encoding": { "format": "EVEX", "hex_opcode": "0F 98" },
      "extension": "AVX-512"
    },
    {
      "mnemonic": "vpternlogd",
      "architecture": "x86",
      "full_name": "Packed Doubleword Ternary Logic",
      "summary": "Performs one of 256 logical operations on 3 inputs.",
      "syntax": "VPTERNLOGD zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 3A 25" },
      "extension": "AVX-512F"
    },
    {
      "mnemonic": "vpternlogq",
      "architecture": "x86",
      "full_name": "Packed Quadword Ternary Logic",
      "summary": "Performs one of 256 logical operations on 3 quadwords.",
      "syntax": "VPTERNLOGQ zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 3A 25" },
      "extension": "AVX-512F"
    },
    {
      "mnemonic": "vcompresspd",
      "architecture": "x86",
      "full_name": "Store Sparse Packed Double-Precision Floating-Point Values",
      "summary": "Compresses active elements from ZMM to memory.",
      "syntax": "VCOMPRESSPD m512 {k1}, zmm1",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 38 8A" },
      "extension": "AVX-512F"
    },
    {
      "mnemonic": "vcompressps",
      "architecture": "x86",
      "full_name": "Store Sparse Packed Single-Precision Floating-Point Values",
      "summary": "Compresses active elements from ZMM to memory.",
      "syntax": "VCOMPRESSPS m512 {k1}, zmm1",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 38 8A" },
      "extension": "AVX-512F"
    },
    {
      "mnemonic": "vexpandpd",
      "architecture": "x86",
      "full_name": "Load Sparse Packed Double-Precision Floating-Point Values",
      "summary": "Expands data from memory into sparse locations in ZMM.",
      "syntax": "VEXPANDPD zmm1 {k1}, m512",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 38 88" },
      "extension": "AVX-512F"
    },
    {
      "mnemonic": "vexpandps",
      "architecture": "x86",
      "full_name": "Load Sparse Packed Single-Precision Floating-Point Values",
      "summary": "Expands data from memory into sparse locations in ZMM.",
      "syntax": "VEXPANDPS zmm1 {k1}, m512",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 38 88" },
      "extension": "AVX-512F"
    },
    {
      "mnemonic": "vpermi2d",
      "architecture": "x86",
      "full_name": "Permute Two-Source Doublewords",
      "summary": "Shuffles doublewords from two ZMM registers into destination.",
      "syntax": "VPERMI2D zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 38 76" },
      "extension": "AVX-512F"
    },
    {
      "mnemonic": "vpermt2d",
      "architecture": "x86",
      "full_name": "Permute Two-Source Doublewords (Overwrite)",
      "summary": "Shuffles 2 sources, overwriting the index register.",
      "syntax": "VPERMT2D zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 38 7F" },
      "extension": "AVX-512F"
    },
    {
      "mnemonic": "vshuff32x4",
      "architecture": "x86",
      "full_name": "Shuffle Packed Float32x4",
      "summary": "Shuffles 128-bit blocks of single-precision floats.",
      "syntax": "VSHUFF32X4 zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 3A 23" },
      "extension": "AVX-512F"
    },
    {
      "mnemonic": "vpmovdb",
      "architecture": "x86",
      "full_name": "Truncate Doubleword to Byte",
      "summary": "Down-converts 32-bit integers to 8-bit.",
      "syntax": "VPMOVDB xmm1/m128 {k1}, zmm2",
      "encoding": { "format": "EVEX", "hex_opcode": "F3 0F 38 31" },
      "extension": "AVX-512F"
    },
    {
      "mnemonic": "vpmovusdb",
      "architecture": "x86",
      "full_name": "Saturate Unsigned Doubleword to Byte",
      "summary": "Down-converts 32-bit to 8-bit with unsigned saturation.",
      "syntax": "VPMOVUSDB xmm1/m128 {k1}, zmm2",
      "encoding": { "format": "EVEX", "hex_opcode": "F3 0F 38 11" },
      "extension": "AVX-512F"
    },
    {
      "mnemonic": "vrndscalepd",
      "architecture": "x86",
      "full_name": "Round Packed Double-Precision Floating-Point with Scale",
      "summary": "Rounds doubles to integer values using imm8 control.",
      "syntax": "VRNDSCALEPD zmm1 {k1}, zmm2/m512, imm8",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 3A 09" },
      "extension": "AVX-512F"
    },
    {
      "mnemonic": "vfixupimmpd",
      "architecture": "x86",
      "full_name": "Fix Up Special Packed Float64 Values",
      "summary": "Fixes special cases (NaN, Inf) using a table.",
      "syntax": "VFIXUPIMMPD zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 3A 54" },
      "extension": "AVX-512F"
    },
    {
      "mnemonic": "vgetmantpd",
      "architecture": "x86",
      "full_name": "Get Mantissa Packed Double-Precision",
      "summary": "Extracts mantissas from doubles.",
      "syntax": "VGETMANTPD zmm1 {k1}, zmm2/m512, imm8",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 3A 26" },
      "extension": "AVX-512F"
    },
    {
      "mnemonic": "vgetexppd",
      "architecture": "x86",
      "full_name": "Get Exponent Packed Double-Precision",
      "summary": "Extracts exponents from doubles as float values.",
      "syntax": "VGETEXPPD zmm1 {k1}, zmm2/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 38 42" },
      "extension": "AVX-512F"
    },
    {
      "mnemonic": "vscalefpd",
      "architecture": "x86",
      "full_name": "Scale Packed Float64 Values with Float64 Exponents",
      "summary": "Scales doubles by exponents (x * 2^n).",
      "syntax": "VSCALEFPD zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 38 2C" },
      "extension": "AVX-512F"
    },
    {
      "mnemonic": "valignd",
      "architecture": "x86",
      "full_name": "Align Doubleword Vectors",
      "summary": "Extracts 512-bits from two concatenated ZMMs shifted by count.",
      "syntax": "VALIGND zmm1 {k1}, zmm2, zmm3/m512, imm8",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 3A 03" },
      "extension": "AVX-512F"
    },
    {
      "mnemonic": "vpconflictd",
      "architecture": "x86",
      "full_name": "Detect Conflicts Within a Vector of Packed Dword Values",
      "summary": "Detects duplicate values in a vector (Conflict Detection).",
      "syntax": "VPCONFLICTD zmm1 {k1}, zmm2/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 38 C4" },
      "extension": "AVX-512CD"
    },
    {
      "mnemonic": "vplzcntd",
      "architecture": "x86",
      "full_name": "Count Leading Zero Bits",
      "summary": "Counts leading zeros for each doubleword element.",
      "syntax": "VPLZCNTD zmm1 {k1}, zmm2/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 38 44" },
      "extension": "AVX-512CD"
    },
    {
      "mnemonic": "vcvtudq2ps",
      "architecture": "x86",
      "full_name": "Convert Packed Unsigned Doubleword Integers to Packed Single-Precision Floating-Point",
      "summary": "Converts unsigned int32 to float.",
      "syntax": "VCVTUDQ2PS zmm1 {k1}, zmm2/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "F2 0F 5B" },
      "extension": "AVX-512F"
    },
    {
      "mnemonic": "vprolvd",
      "architecture": "x86",
      "full_name": "Rotate Left Doubleword Variable",
      "summary": "Rotates doublewords left by amounts in second vector.",
      "syntax": "VPROLVD zmm1 {k1}, zmm2, zmm3/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 38 15" },
      "extension": "AVX-512F"
    },
    {
      "mnemonic": "vpopcntd",
      "architecture": "x86",
      "full_name": "Packed Population Count Doubleword",
      "summary": "Counts set bits in each doubleword element.",
      "syntax": "VPOPCNTD zmm1 {k1}, zmm2/m512",
      "encoding": { "format": "EVEX", "hex_opcode": "66 0F 38 55" },
      "extension": "AVX-512_VPOPCNTDQ"
    },
    {
      "mnemonic": "encls",
      "architecture": "x86",
      "full_name": "Execute Enclave Supervisor Leaf",
      "summary": "Executes an SGX supervisor function specified by EAX.",
      "syntax": "ENCLS",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 01 CF" },
      "extension": "SGX"
    },
    {
      "mnemonic": "enclu",
      "architecture": "x86",
      "full_name": "Execute Enclave User Leaf",
      "summary": "Executes an SGX user function specified by EAX.",
      "syntax": "ENCLU",
      "encoding": { "format": "Legacy", "hex_opcode": "0F 01 D7" },
      "extension": "SGX"
    }
  ]
}
