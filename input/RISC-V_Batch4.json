{
  "instructions": [
    {
      "mnemonic": "BLTU",
      "architecture": "RISC-V",
      "extension": "Base",
      "full_name": "Branch if Less Than Unsigned",
      "summary": "Take the branch if rs1 is less than rs2 (unsigned comparison).",
      "syntax": "BLTU rs1, rs2, offset",
      "encoding": {
        "format": "B-Type",
        "binary_pattern": "imm | rs2 | rs1 | 110 | imm | 1100011",
        "hex_opcode": "0x63"
      },
      "operands": [
        { "name": "rs1", "desc": "Source 1" },
        { "name": "rs2", "desc": "Source 2" },
        { "name": "offset", "desc": "Offset" }
      ],
      "pseudocode": "if (R[rs1] <u R[rs2]) PC += sext(offset);"
    },
    {
      "mnemonic": "BGEU",
      "architecture": "RISC-V",
      "extension": "Base",
      "full_name": "Branch if Greater or Equal Unsigned",
      "summary": "Take the branch if rs1 is greater than or equal to rs2 (unsigned comparison).",
      "syntax": "BGEU rs1, rs2, offset",
      "encoding": {
        "format": "B-Type",
        "binary_pattern": "imm | rs2 | rs1 | 111 | imm | 1100011",
        "hex_opcode": "0x63"
      },
      "operands": [
        { "name": "rs1", "desc": "Source 1" },
        { "name": "rs2", "desc": "Source 2" },
        { "name": "offset", "desc": "Offset" }
      ],
      "pseudocode": "if (R[rs1] >=u R[rs2]) PC += sext(offset);"
    },
    {
      "mnemonic": "FMV.X.D",
      "architecture": "RISC-V",
      "extension": "D (Double)",
      "full_name": "Move Double to Integer",
      "summary": "Moves the bit pattern of a 64-bit floating-point register to an integer register (RV64).",
      "syntax": "FMV.X.D rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "1110001 | 00000 | rs1 | 000 | rd | 1010011",
        "hex_opcode": "0x53"
      },
      "operands": [
        { "name": "rd", "desc": "Dest (Int64)" },
        { "name": "rs1", "desc": "Source (Double)" }
      ],
      "pseudocode": "R[rd] = F[rs1];"
    },
    {
      "mnemonic": "FMV.D.X",
      "architecture": "RISC-V",
      "extension": "D (Double)",
      "full_name": "Move Integer to Double",
      "summary": "Moves the bit pattern of a 64-bit integer register to a floating-point register (RV64).",
      "syntax": "FMV.D.X rd, rs1",
      "encoding": {
        "format": "I-Type (Float)",
        "binary_pattern": "1111001 | 00000 | rs1 | 000 | rd | 1010011",
        "hex_opcode": "0x53"
      },
      "operands": [
        { "name": "rd", "desc": "Dest (Double)" },
        { "name": "rs1", "desc": "Source (Int64)" }
      ],
      "pseudocode": "F[rd] = R[rs1];"
    },
    {
      "mnemonic": "FSGNJX.D",
      "architecture": "RISC-V",
      "extension": "D (Double)",
      "full_name": "Float Sign Injection XOR (Double)",
      "summary": "Injects the XOR of signs of rs1 and rs2 (Double Precision).",
      "syntax": "FSGNJX.D rd, rs1, rs2",
      "encoding": {
        "format": "R-Type",
        "binary_pattern": "0010001 | rs2 | rs1 | 010 | rd | 1010011",
        "hex_opcode": "0x53"
      },
      "operands": [
        { "name": "rd", "desc": "Dest" },
        { "name": "rs1", "desc": "Source 1" },
        { "name": "rs2", "desc": "Source 2" }
      ],
      "pseudocode": "F[rd] = {F[rs1][63] ^ F[rs2][63], F[rs1][62:0]};"
    },
    {
      "mnemonic": "C.NOP",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed No Operation",
      "summary": "Performs no operation (Compressed encoding).",
      "syntax": "C.NOP",
      "encoding": {
        "format": "CI",
        "binary_pattern": "000 | 0 | 00000 | 0 | 01",
        "hex_opcode": "01"
      },
      "operands": [],
      "pseudocode": "R[0] = R[0] + 0;"
    },
    {
      "mnemonic": "C.ADDIW",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Add Immediate Word",
      "summary": "Adds a signed immediate to a register (32-bit result sign-extended, RV64).",
      "syntax": "C.ADDIW rd, imm",
      "encoding": {
        "format": "CI",
        "binary_pattern": "001 | imm | rd | imm | 01",
        "hex_opcode": "01"
      },
      "operands": [
        { "name": "rd", "desc": "Dest/Src" },
        { "name": "imm", "desc": "Immediate" }
      ],
      "pseudocode": "R[rd] = sext((R[rd] + sext(imm))[31:0]);"
    },
    {
      "mnemonic": "C.ADDW",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Add Word",
      "summary": "Adds two registers (32-bit result sign-extended, RV64).",
      "syntax": "C.ADDW rd', rs2'",
      "encoding": {
        "format": "CA",
        "binary_pattern": "100111 | rd' | 10 | rs2' | 01",
        "hex_opcode": "01"
      },
      "operands": [
        { "name": "rd'", "desc": "Dest/Src1" },
        { "name": "rs2'", "desc": "Src2" }
      ],
      "pseudocode": "R[rd'] = sext((R[rd'] + R[rs2'])[31:0]);"
    },
    {
      "mnemonic": "C.SUBW",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Subtract Word",
      "summary": "Subtracts two registers (32-bit result sign-extended, RV64).",
      "syntax": "C.SUBW rd', rs2'",
      "encoding": {
        "format": "CA",
        "binary_pattern": "100111 | rd' | 00 | rs2' | 01",
        "hex_opcode": "01"
      },
      "operands": [
        { "name": "rd'", "desc": "Dest/Src1" },
        { "name": "rs2'", "desc": "Src2" }
      ],
      "pseudocode": "R[rd'] = sext((R[rd'] - R[rs2'])[31:0]);"
    },
    {
      "mnemonic": "C.LDSP",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Load Doubleword from Stack Pointer",
      "summary": "Loads a 64-bit value from the stack pointer (RV64).",
      "syntax": "C.LDSP rd, offset(x2)",
      "encoding": {
        "format": "CI",
        "binary_pattern": "011 | imm | rd | imm | 10",
        "hex_opcode": "02"
      },
      "operands": [
        { "name": "rd", "desc": "Dest" },
        { "name": "offset", "desc": "Offset" }
      ],
      "pseudocode": "R[rd] = M[R[2] + offset][63:0];"
    },
    {
      "mnemonic": "C.SDSP",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Store Doubleword to Stack Pointer",
      "summary": "Stores a 64-bit value to the stack pointer (RV64).",
      "syntax": "C.SDSP rs2, offset(x2)",
      "encoding": {
        "format": "CSS",
        "binary_pattern": "111 | imm | rs2 | 10",
        "hex_opcode": "02"
      },
      "operands": [
        { "name": "rs2", "desc": "Source" },
        { "name": "offset", "desc": "Offset" }
      ],
      "pseudocode": "M[R[2] + offset][63:0] = R[rs2];"
    },
    {
      "mnemonic": "C.FLWSP",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Float Load Word from Stack Pointer",
      "summary": "Loads a single-precision float from the stack pointer.",
      "syntax": "C.FLWSP rd, offset(x2)",
      "encoding": {
        "format": "CI",
        "binary_pattern": "011 | imm | rd | imm | 10",
        "hex_opcode": "02"
      },
      "operands": [
        { "name": "rd", "desc": "Dest" },
        { "name": "offset", "desc": "Offset" }
      ],
      "pseudocode": "F[rd] = M[R[2] + offset][31:0];"
    },
    {
      "mnemonic": "C.FSWSP",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Float Store Word to Stack Pointer",
      "summary": "Stores a single-precision float to the stack pointer.",
      "syntax": "C.FSWSP rs2, offset(x2)",
      "encoding": {
        "format": "CSS",
        "binary_pattern": "111 | imm | rs2 | 10",
        "hex_opcode": "02"
      },
      "operands": [
        { "name": "rs2", "desc": "Source" },
        { "name": "offset", "desc": "Offset" }
      ],
      "pseudocode": "M[R[2] + offset][31:0] = F[rs2];"
    },
    {
      "mnemonic": "C.FLDSP",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Float Load Double from Stack Pointer",
      "summary": "Loads a double-precision float from the stack pointer.",
      "syntax": "C.FLDSP rd, offset(x2)",
      "encoding": {
        "format": "CI",
        "binary_pattern": "001 | imm | rd | imm | 10",
        "hex_opcode": "02"
      },
      "operands": [
        { "name": "rd", "desc": "Dest" },
        { "name": "offset", "desc": "Offset" }
      ],
      "pseudocode": "F[rd] = M[R[2] + offset][63:0];"
    },
    {
      "mnemonic": "C.FSDSP",
      "architecture": "RISC-V",
      "extension": "C (Compressed)",
      "full_name": "Compressed Float Store Double to Stack Pointer",
      "summary": "Stores a double-precision float to the stack pointer.",
      "syntax": "C.FSDSP rs2, offset(x2)",
      "encoding": {
        "format": "CSS",
        "binary_pattern": "101 | imm | rs2 | 10",
        "hex_opcode": "02"
      },
      "operands": [
        { "name": "rs2", "desc": "Source" },
        { "name": "offset", "desc": "Offset" }
      ],
      "pseudocode": "M[R[2] + offset][63:0] = F[rs2];"
    },
    {
      "mnemonic": "VSUB.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Integer Subtract",
      "summary": "Subtracts elements of two vector registers.",
      "syntax": "VSUB.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "000010 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57"
      },
      "operands": [
        { "name": "vd", "desc": "Dest" },
        { "name": "vs2", "desc": "Src 2 (Subtrahend)" },
        { "name": "vs1", "desc": "Src 1 (Minuend)" }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs1[i] - vs2[i];"
    },
    {
      "mnemonic": "VRSUB.VX",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Integer Reverse Subtract Scalar",
      "summary": "Subtracts vector elements from a scalar value (scalar - vector).",
      "syntax": "VRSUB.VX vd, vs2, rs1, vm",
      "encoding": {
        "format": "OPIVX",
        "binary_pattern": "000011 | vm | vs2 | rs1 | 100 | vd | 1010111",
        "hex_opcode": "0x57"
      },
      "operands": [
        { "name": "vd", "desc": "Dest" },
        { "name": "vs2", "desc": "Vector Src" },
        { "name": "rs1", "desc": "Scalar Src" }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = rs1 - vs2[i];"
    },
    {
      "mnemonic": "VMIN.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Minimum (Signed)",
      "summary": "Computes the signed minimum of elements in two vectors.",
      "syntax": "VMIN.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "000101 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57"
      },
      "operands": [
        { "name": "vd", "desc": "Dest" },
        { "name": "vs2", "desc": "Src 2" },
        { "name": "vs1", "desc": "Src 1" }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = min(vs1[i], vs2[i]);"
    },
    {
      "mnemonic": "VMAX.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Maximum (Signed)",
      "summary": "Computes the signed maximum of elements in two vectors.",
      "syntax": "VMAX.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "000111 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57"
      },
      "operands": [
        { "name": "vd", "desc": "Dest" },
        { "name": "vs2", "desc": "Src 2" },
        { "name": "vs1", "desc": "Src 1" }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = max(vs1[i], vs2[i]);"
    },
    {
      "mnemonic": "VMINU.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Minimum (Unsigned)",
      "summary": "Computes the unsigned minimum of elements in two vectors.",
      "syntax": "VMINU.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "000100 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57"
      },
      "operands": [
        { "name": "vd", "desc": "Dest" },
        { "name": "vs2", "desc": "Src 2" },
        { "name": "vs1", "desc": "Src 1" }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = min_u(vs1[i], vs2[i]);"
    },
    {
      "mnemonic": "VMAXU.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Maximum (Unsigned)",
      "summary": "Computes the unsigned maximum of elements in two vectors.",
      "syntax": "VMAXU.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "000110 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57"
      },
      "operands": [
        { "name": "vd", "desc": "Dest" },
        { "name": "vs2", "desc": "Src 2" },
        { "name": "vs1", "desc": "Src 1" }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = max_u(vs1[i], vs2[i]);"
    },
    {
      "mnemonic": "VOR.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Bitwise OR",
      "summary": "Performs bitwise OR on elements of two vectors.",
      "syntax": "VOR.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "001010 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57"
      },
      "operands": [
        { "name": "vd", "desc": "Dest" },
        { "name": "vs2", "desc": "Src 2" },
        { "name": "vs1", "desc": "Src 1" }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs1[i] | vs2[i];"
    },
    {
      "mnemonic": "VXOR.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Bitwise XOR",
      "summary": "Performs bitwise XOR on elements of two vectors.",
      "syntax": "VXOR.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "001011 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57"
      },
      "operands": [
        { "name": "vd", "desc": "Dest" },
        { "name": "vs2", "desc": "Src 2" },
        { "name": "vs1", "desc": "Src 1" }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs1[i] ^ vs2[i];"
    },
    {
      "mnemonic": "VSLL.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Shift Left Logical",
      "summary": "Shifts elements of vector vs2 left by amounts in vs1.",
      "syntax": "VSLL.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "100101 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57"
      },
      "operands": [
        { "name": "vd", "desc": "Dest" },
        { "name": "vs2", "desc": "Source" },
        { "name": "vs1", "desc": "Shift Amount" }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs2[i] << (vs1[i] & Mask);"
    },
    {
      "mnemonic": "VSRL.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Shift Right Logical",
      "summary": "Shifts elements of vector vs2 right (logical) by amounts in vs1.",
      "syntax": "VSRL.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "101000 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57"
      },
      "operands": [
        { "name": "vd", "desc": "Dest" },
        { "name": "vs2", "desc": "Source" },
        { "name": "vs1", "desc": "Shift Amount" }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs2[i] >> (vs1[i] & Mask);"
    },
    {
      "mnemonic": "VSRA.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Shift Right Arithmetic",
      "summary": "Shifts elements of vector vs2 right (arithmetic) by amounts in vs1.",
      "syntax": "VSRA.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "101001 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57"
      },
      "operands": [
        { "name": "vd", "desc": "Dest" },
        { "name": "vs2", "desc": "Source" },
        { "name": "vs1", "desc": "Shift Amount" }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs2[i] >>s (vs1[i] & Mask);"
    },
    {
      "mnemonic": "VMSEQ.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Mask Set Equal",
      "summary": "Sets destination mask bit if elements are equal.",
      "syntax": "VMSEQ.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "011000 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57"
      },
      "operands": [
        { "name": "vd", "desc": "Dest Mask" },
        { "name": "vs2", "desc": "Src 2" },
        { "name": "vs1", "desc": "Src 1" }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = (vs2[i] == vs1[i]) ? 1 : 0;"
    },
    {
      "mnemonic": "VMSLT.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Mask Set Less Than (Signed)",
      "summary": "Sets destination mask bit if vs2 < vs1 (signed).",
      "syntax": "VMSLT.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "011011 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57"
      },
      "operands": [
        { "name": "vd", "desc": "Dest Mask" },
        { "name": "vs2", "desc": "Src 2" },
        { "name": "vs1", "desc": "Src 1" }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = (vs2[i] <s vs1[i]) ? 1 : 0;"
    },
    {
      "mnemonic": "VMSLTU.VV",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Mask Set Less Than (Unsigned)",
      "summary": "Sets destination mask bit if vs2 < vs1 (unsigned).",
      "syntax": "VMSLTU.VV vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPIVV",
        "binary_pattern": "011100 | vm | vs2 | vs1 | 000 | vd | 1010111",
        "hex_opcode": "0x57"
      },
      "operands": [
        { "name": "vd", "desc": "Dest Mask" },
        { "name": "vs2", "desc": "Src 2" },
        { "name": "vs1", "desc": "Src 1" }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = (vs2[i] <u vs1[i]) ? 1 : 0;"
    },
    {
      "mnemonic": "VREDSUM.VS",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Reduction Sum",
      "summary": "Reduces a vector to a scalar by summing all elements.",
      "syntax": "VREDSUM.VS vd, vs2, vs1, vm",
      "encoding": {
        "format": "OPMVV",
        "binary_pattern": "000000 | vm | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57"
      },
      "operands": [
        { "name": "vd", "desc": "Dest Scalar" },
        { "name": "vs2", "desc": "Source Vector" },
        { "name": "vs1", "desc": "Start Scalar" }
      ],
      "pseudocode": "vd[0] = vs1[0] + sum(vs2[*]);"
    },
    {
      "mnemonic": "VLSE32.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Load Strided Element (32-bit)",
      "summary": "Loads elements from memory with a fixed stride.",
      "syntax": "VLSE32.V vd, (rs1), rs2, vm",
      "encoding": {
        "format": "VL-Type",
        "binary_pattern": "000110 | mop | vm | rs1 | 110 | vd | 0000111",
        "hex_opcode": "0x07"
      },
      "operands": [
        { "name": "vd", "desc": "Vector Dest" },
        { "name": "rs1", "desc": "Base Address" },
        { "name": "rs2", "desc": "Stride" }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = M[rs1 + i * rs2];"
    },
    {
      "mnemonic": "VSSE32.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Store Strided Element (32-bit)",
      "summary": "Stores elements to memory with a fixed stride.",
      "syntax": "VSSE32.V vs3, (rs1), rs2, vm",
      "encoding": {
        "format": "VS-Type",
        "binary_pattern": "000110 | mop | vm | rs1 | 110 | vs3 | 0100111",
        "hex_opcode": "0x27"
      },
      "operands": [
        { "name": "vs3", "desc": "Vector Source" },
        { "name": "rs1", "desc": "Base Address" },
        { "name": "rs2", "desc": "Stride" }
      ],
      "pseudocode": "foreach(i < vl): M[rs1 + i * rs2] = vs3[i];"
    },
    {
      "mnemonic": "VLUXEI32.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Load Unordered Indexed (32-bit indices)",
      "summary": "Loads elements from memory using a vector of indices (Gather).",
      "syntax": "VLUXEI32.V vd, (rs1), vs2, vm",
      "encoding": {
        "format": "VL-Type",
        "binary_pattern": "000111 | mop | vm | rs1 | 110 | vd | 0000111",
        "hex_opcode": "0x07"
      },
      "operands": [
        { "name": "vd", "desc": "Vector Dest" },
        { "name": "rs1", "desc": "Base Address" },
        { "name": "vs2", "desc": "Vector Indices" }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = M[rs1 + vs2[i]];"
    },
    {
      "mnemonic": "VSUXEI32.V",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Store Unordered Indexed (32-bit indices)",
      "summary": "Stores elements to memory using a vector of indices (Scatter).",
      "syntax": "VSUXEI32.V vs3, (rs1), vs2, vm",
      "encoding": {
        "format": "VS-Type",
        "binary_pattern": "000111 | mop | vm | rs1 | 110 | vs3 | 0100111",
        "hex_opcode": "0x27"
      },
      "operands": [
        { "name": "vs3", "desc": "Vector Source" },
        { "name": "rs1", "desc": "Base Address" },
        { "name": "vs2", "desc": "Vector Indices" }
      ],
      "pseudocode": "foreach(i < vl): M[rs1 + vs2[i]] = vs3[i];"
    },
    {
      "mnemonic": "VSLIDEUP.VX",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Slide Up",
      "summary": "Moves elements up by a scalar amount (vd[i] = vs2[i - rs1]).",
      "syntax": "VSLIDEUP.VX vd, vs2, rs1, vm",
      "encoding": {
        "format": "OPIVX",
        "binary_pattern": "001110 | vm | vs2 | rs1 | 100 | vd | 1010111",
        "hex_opcode": "0x57"
      },
      "operands": [
        { "name": "vd", "desc": "Dest" },
        { "name": "vs2", "desc": "Source Vector" },
        { "name": "rs1", "desc": "Shift Amount" }
      ],
      "pseudocode": "foreach(i): if i < rs1: vd[i] = vd[i] (unchanged); else: vd[i] = vs2[i - rs1];"
    },
    {
      "mnemonic": "VSLIDEDOWN.VX",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Slide Down",
      "summary": "Moves elements down by a scalar amount (vd[i] = vs2[i + rs1]).",
      "syntax": "VSLIDEDOWN.VX vd, vs2, rs1, vm",
      "encoding": {
        "format": "OPIVX",
        "binary_pattern": "001111 | vm | vs2 | rs1 | 100 | vd | 1010111",
        "hex_opcode": "0x57"
      },
      "operands": [
        { "name": "vd", "desc": "Dest" },
        { "name": "vs2", "desc": "Source Vector" },
        { "name": "rs1", "desc": "Shift Amount" }
      ],
      "pseudocode": "foreach(i < vl): vd[i] = vs2[i + rs1];"
    },
    {
      "mnemonic": "VMNAND.MM",
      "architecture": "RISC-V",
      "extension": "V (Vector)",
      "full_name": "Vector Mask NAND",
      "summary": "Performs bitwise NAND on vector mask registers. Used to invert masks (NOT).",
      "syntax": "VMNAND.MM vd, vs2, vs1",
      "encoding": {
        "format": "OPMVV",
        "binary_pattern": "011101 | 1 | vs2 | vs1 | 010 | vd | 1010111",
        "hex_opcode": "0x57"
      },
      "operands": [
        { "name": "vd", "desc": "Dest Mask" },
        { "name": "vs2", "desc": "Src 2 Mask" },
        { "name": "vs1", "desc": "Src 1 Mask" }
      ],
      "pseudocode": "vd = ~(vs1 & vs2);"
    }
  ]
}
